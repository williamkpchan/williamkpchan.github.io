<base target="_blank"><html><head><title>ESP 32 page 3</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="https://williamkpchan.github.io/lazyload.min.js"></script>
<script src='https://williamkpchan.github.io/mainscript.js'></script>
<script src="https://williamkpchan.github.io/commonfunctions.js"></script>
<script>
var showTopicNumber = true;
var topicEnd = "<br>";
var bookid = "ESP 32 page 3"
var markerName = "h2"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:24px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%;-radius:3px;}
k {color: #205080;}
</style></head><body onkeypress="chkKey()"><center>

<div id="toc"></div></center>
<pre>
<h2>Connect ESP32 to Cloud MQTT Broker (TTGO T-Call ESP32 SIM800L)</h2>
This guide shows how to connect the TTGO T-Call ESP32 SIM800L board to the Internet using a SIM card data plan and publish/subscribe to a cloud MQTT broker without using Wi-Fi. The cloud MQTT Mosquitto broker will be installed on a Digital Ocean server. We'll also use Node-RED to visualize the readings and control the outputs from anywhere. The board will be programmed using Arduino IDE.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/Connect-ESP32-to-Cloud-MQTT-Broker-TTGO-T-Call-ESP32-SIM800L.jpg">
With this setup, you can monitor and control your ESP32 from anywhere in the world, and the ESP32 doesn't need to be connected to a wireless router because it connects to the internet using a SIM card data plan.
<h3>Introducing the TTGO T-Call ESP32 SIM800L</h3>
The TTGO T-Call is an ESP32 development board that combines a SIM800L GSM/GPRS module. <a href="https://makeradvisor.com/tools/ttgo-t-call-esp32-sim800/" target="_blank">You can get if for approximately $11</a>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/09/SIMCOM-SIM800L-ESP32.jpg">
Besides Wi-Fi and Bluetooth, you can communicate with this ESP32 board using SMS or phone calls and you can connect it to the internet using your SIM card data plan. This is great for IoT projects that don't have access to a nearby router.
<k>Important: </k> the SIM800L works on 2G networks, so it will only work in your country, if 2G networks are available. Check if you have 2G network in your country, otherwise it won't work. 
To use the capabilities of this board you need to have a nano SIM card with data plan and a <a href="https://makeradvisor.com/tools/usb-c-data-charging-cable/" target="_blank" aria-label="USB-C cable (opens in a new tab)">USB-C cable</a> to upload code to the board.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/09/USB-C.jpg">
The package includes some header pins, a battery connector, and an external antenna that you should connect to your board. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/09/TTGO-T-Call-ESP32-Package.jpg">
However, we had some issues with that antenna, so we decided to switch to another type of antenna and all the problems were solved. The following figure shows the new antenna.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/09/ESP32-SIM800-another-antenna.jpg">
<h3>Project Overview</h3>
The idea of this project is to connect your ESP32 to a Cloud MQTT broker to subscribe to an MQTT topic and publish sensor data to MQTT topics. The ESP32 doesn't need to have access to a router via Wi-Fi, because it connects to the internet using a SIM card data plan.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/Connect-ESP32-Cloud-MQTT-Broker-TTGO-T-Call-ESP32-SIM800L-Project-Overview.png">
<a href="https://randomnerdtutorials.com/esp32-sim800l-publish-data-to-cloud/">In a previous project</a>, we created our own server with a database to plot sensor readings in charts that you can access from anywhere in the world.
In this project, we'll publish sensor readings to a server via MQTT and we'll use Mosquitto broker. You can publish your sensor readings to any other cloud broker.
In summary, here's how the project works:
<ol>
The T-Call ESP32 SIM800L board is connected to the internet using a SIM card data plan. 
The T-Call ESP32 SIM800L board publishes the sensor readings via MQTT and the readings are displayed in Node-RED Dashboard.
Through Node-RED Dashboard, you can press buttons to send on and off commands to control the ESP32 GPIOs.
</ol>
We'll be using a <a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/">BME280 sensor</a>, but you can use any other sensor that best suits your needs. 
<h3>Cloud MQTT Broker</h3>
You can search for a free cloud MQTT broker, however we'll be using our own cloud MQTT broker. We recommend using <a href="https://randomnerdtutorials.com/cloud-mqtt-mosquitto-broker-access-anywhere-digital-ocean/">Digital Ocean with MQTT Mosquitto Broker</a>, because it can handle all the project requirements. We'll also use <a href="https://randomnerdtutorials.com/access-node-red-dashboard-anywhere-digital-ocean/">Node-RED software</a> to visualize the readings in gauges and publish MQTT messages to the ESP32.
<a href="https://randomnerdtutorials.com/cloud-mqtt-mosquitto-broker-access-anywhere-digital-ocean/">Run Your Cloud MQTT Mosquitto Broker (access from anywhere using Digital Ocean)</a>
<a href="https://randomnerdtutorials.com/access-node-red-dashboard-anywhere-digital-ocean/">Access Node-RED Dashboard from Anywhere (using Digital Ocean)</a>
<h3>Prerequisites</h3>
<h3>1. ESP32 add-on Arduino IDE</h3>
We'll program the ESP32 using Arduino IDE. So, you need to have the ESP32 add-on installed in your Arduino IDE. Follow the next tutorial, if you haven't already.
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<h3>2. Preparing your Cloud MQTT Broker</h3>
In this project we'll show you how to exchange data via MQTT using a cloud MQTT broker. 
We'll be using our own cloud MQTT broker. However, if you find a free MQTT broker with all your desired features it will also work
If you want to follow this exact project, you should follow the next two tutorials to prepare your own server and Node-RED software.
<a href="https://randomnerdtutorials.com/cloud-mqtt-mosquitto-broker-access-anywhere-digital-ocean/">Run Your Cloud MQTT Mosquitto Broker (access from anywhere using Digital Ocean)</a>
<a href="https://randomnerdtutorials.com/access-node-red-dashboard-anywhere-digital-ocean/">Access Node-RED Dashboard from Anywhere (using Digital Ocean)</a>
The ESP32 is publishing temperature readings every 30 seconds on the <k>esp/temperature</k> and <k>esp/humidity</k> topics. It's subscribed to these two topics <k>esp/output1</k> and <k>esp/output2</k> to update the state of the output LEDs.
Having Node-RED running, go to your server IP address followed by :1880.
<k>http://cloud-mqtt-broker-ip-address:1880</k>
Wire your nodes as shown below:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/ESP32-SIM800L-GPRS-GSM-Cloud-MQTT-Broker-Node-RED-Arduino.png">
Finally, deploy your flow (press the button on the upper right corner).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/06/11_deploy_button.png">
Alternatively, you can go to <k>Menu </k>> <k>Import </k>and copy the following to your <k>Clipboard</k> to create your Node-RED flow.
<k>[{"id":"a2c394d8.1544e8","type":"mqtt in","z":"537cca59.c4a014","name":"","topic":"esp/temperature","qos":"2","datatype":"auto","broker":"18f874c0.4a464b","x":140,"y":1020,"wires":[["6907217e.f39bf"]]},{"id":"b83c2ecf.8ab94","type":"mqtt in","z":"537cca59.c4a014","name":"","topic":"esp/humidity","qos":"2","datatype":"auto","broker":"18f874c0.4a464b","x":130,"y":1100,"wires":[["c92e354e.a27d48"]]},{"id":"ee844c66.3eda2","type":"mqtt out","z":"537cca59.c4a014","name":"","topic":"esp/output1","qos":"1","retain":"","broker":"18f874c0.4a464b","x":330,"y":1180,"wires":[]},{"id":"54540fba.e5877","type":"mqtt out","z":"537cca59.c4a014","name":"","topic":"esp/output2","qos":"1","retain":"","broker":"18f874c0.4a464b","x":330,"y":1260,"wires":[]},{"id":"56080a9a.c7bba4","type":"ui_switch","z":"537cca59.c4a014","name":"","label":"Output 1","tooltip":"","group":"1539f836.ed9378","order":0,"width":0,"height":0,"passthru":true,"decouple":"false","topic":"","style":"","onvalue":"true","onvalueType":"bool","onicon":"","oncolor":"","offvalue":"false","offvalueType":"bool","officon":"","offcolor":"","x":120,"y":1180,"wires":[["ee844c66.3eda2"]]},{"id":"417bd6d1.1d1468","type":"ui_switch","z":"537cca59.c4a014","name":"","label":"Output 2","tooltip":"","group":"1539f836.ed9378","order":0,"width":0,"height":0,"passthru":true,"decouple":"false","topic":"","style":"","onvalue":"true","onvalueType":"bool","onicon":"","oncolor":"","offvalue":"false","offvalueType":"bool","officon":"","offcolor":"","x":120,"y":1260,"wires":[["54540fba.e5877"]]},{"id":"6907217e.f39bf","type":"ui_gauge","z":"537cca59.c4a014","name":"","group":"1539f836.ed9378","order":2,"width":0,"height":0,"gtype":"gage","title":"Temperature","label":"Celsius Degrees","format":"{{value}}","min":"-10","max":"40","colors":["#00b500","#e6e600","#ca3838"],"seg1":"","seg2":"","x":350,"y":1020,"wires":[]},{"id":"c92e354e.a27d48","type":"ui_gauge","z":"537cca59.c4a014","name":"","group":"1539f836.ed9378","order":2,"width":0,"height":0,"gtype":"gage","title":"Humidity","label":"%","format":"{{value}}","min":"0","max":"100","colors":["#93dae6","#0074cc","#002561"],"seg1":"","seg2":"","x":340,"y":1100,"wires":[]},{"id":"18f874c0.4a464b","type":"mqtt-broker","z":"","name":"","broker":"localhost","port":"1883","clientid":"","usetls":false,"compatmode":false,"keepalive":"60","cleansession":true,"birthTopic":"","birthQos":"0","birthPayload":"","closeTopic":"","closeQos":"0","closePayload":"","willTopic":"","willQos":"0","willPayload":""},{"id":"1539f836.ed9378","type":"ui_group","z":"","name":"Dashboard","tab":"38becbd0.c13714","order":1,"disp":true,"width":"6","collapse":false},{"id":"38becbd0.c13714","type":"ui_tab","z":"","name":"Home","icon":"dashboard","disabled":false,"hidden":false}]
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_SIM800L_Cloud_MQTT_Broker_NodeRED.txt" target="_blank">View raw code</a>
<h3>3. SIM Card with data plan</h3>
To use the TTGO T-Call ESP32 SIM800L board, you need a nano SIM card with a data plan. We recommend using a SIM card with a prepaid or monthly plan, so that you know exactly how much you'll spend.
<h3>4. APN Details</h3>
To connect your SIM card to the internet, you need to have your phone plan provider APN details. You need the domain name, username and password.
In my case, I'm using vodafone Portugal. If you search for <k>GPRS APN settings</k> followed by your phone plan provider name, (in my case its: <k>GPRS APN vodafone Portugal</k>), you can usually find in a forum or in their website all the information that you need.
I've found <a aria-label="this website (opens in a new tab)" href="https://wiki.apnchanger.org/Main_Page" target="_blank">this website</a> that can be very useful to find all the information you need.
It might be a bit tricky to find the details if you don't use a well known provider. So, you might need to contact your provider directly.
<h3>5. Libraries</h3>
You need to install these libraries in your Arduino IDE to proceed with this project: <a aria-label="Adafruit_BME280 (opens in a new tab)" href="https://github.com/adafruit/Adafruit_BME280_Library" target="_blank">Adafruit_BME280</a>, <a aria-label="Adafruit_Sensor (opens in a new tab)" href="https://github.com/adafruit/Adafruit_Sensor" target="_blank">Adafruit_Sensor</a>, <a aria-label="TinyGSM (opens in a new tab)" href="https://github.com/vshymanskyy/TinyGSM" target="_blank">TinyGSM</a>, and <a href="https://github.com/knolleary/pubsubclient" target="_blank">PubSubClient</a>. Follow the next instructions to install these libraries.
<h4>Installing the Adafruit BME280 Library</h4>
Open your Arduino IDE and go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k>. The Library Manager should open.
Search for <k>adafruit bme280</k>  on the Search box and install the library.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/08/install-bme280.png">
<h4>Installing the Adafruit Sensor Library </h4>
To use the BME280 library, you also need to install the <a href="https://github.com/adafruit/Adafruit_Sensor" target="_blank">Adafruit_Sensor library</a>. Follow the next steps to install the library in your Arduino IDE:
Go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k> and type <k>Adafruit Unified Sensor</k> in the search box. Scroll all the way down to find the library and install it.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/04/adafruit_unified_sensor_library.png">
<h4>Installing the TinyGSM Library </h4>
In the Arduino IDE Library Manager search for <k>TinyGSM</k>. Select the TinyGSM library by Volodymyr Shymanskyy.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/Install-TinyGSM-Library-Arduino-IDE.png">
<h4>Installing the PubSubClient Library </h4>
Search for <k>PubSubClient</k> and scroll down. Select the PubSubClient library by Nick O'Leary.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/PubSubClient-library-install-Arduino-IDE.png">
After installing the libraries, restart your Arduino IDE. 
<h3>Parts Required</h3>
To build this project, you need the following parts:
<a href="https://makeradvisor.com/tools/ttgo-t-call-esp32-sim800/" target="_blank"><k>TTGO T-Call ESP32 SIM800L</k></a>
<a aria-label="USB-C cable<U+2028> (opens in a new tab)" href="https://makeradvisor.com/tools/usb-c-data-charging-cable/" target="_blank">USB-C cable</a>
<a aria-label="Antenna  (opens in a new tab)" href="https://rover.ebay.com/rover/1/711-53200-19255-0/1?ff3=2&toolid=10044&campid=5338179998&customid=MakerAdvisorT&lgeo=1&vectorid=229466&item=311649924872" target="_blank" rel="noreferrer noopener nofollow">Antenna </a>(optional)
<a href="https://makeradvisor.com/tools/bme280-sensor-module/" target="_blank">BME280 sensor module</a> (<a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/">Guide for BME280 with ESP32</a>)
<a href="https://makeradvisor.com/tools/3mm-5mm-leds-kit-storage-box/" target="_blank">2x LEDs</a>
<a href="https://makeradvisor.com/tools/resistors-kits/" target="_blank">2x 220 ohm resistors</a>
<a aria-label="Breadboard (opens in a new tab)" href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a>
<a aria-label="Jumper wires (opens in a new tab)" href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="lazy" fetchpriority="low"></a>
<h3>Schematic Diagram</h3>
Wire the BME280 sensor and two LEDs to the T-Call ESP32 SIM800L board as shown in the following schematic diagram.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/ESP32-SIM800L-2outputs-BME280-Cloud-MQTT-Broker-Wiring-schematic-diagram.jpg">
We're connecting the BME280's SDA pin to GPIO 18 and the SCL pin to GPIO 19.
<h3>Code</h3>
Copy the following code to your Arduino IDE but don't upload it yet. First, you need to make some modifications to make it work.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-cloud-mqtt-broker-sim800l/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
// Select your modem:
#define TINY_GSM_MODEM_SIM800 // Modem is SIM800L
// Set serial for debug console (to the Serial Monitor, default speed 115200)
#define SerialMon Serial
// Set serial for AT commands
#define SerialAT Serial1
// Define the serial console for debug prints, if needed
#define TINY_GSM_DEBUG SerialMon
// set GSM PIN, if any
#define GSM_PIN ""
// Your GPRS credentials, if any
const char apn[] = ""; // APN (example: internet.vodafone.pt) use https://wiki.apnchanger.org
const char gprsUser[] = "";
const char gprsPass[] = "";
// SIM card PIN (leave empty, if not defined)
const char simPIN[]   = ""; 
// MQTT details
const char* broker = "XXX.XXX.XXX.XXX";                    // Public IP address or domain name
const char* mqttUsername = "REPLACE_WITH_YOUR_MQTT_USER";  // MQTT username
const char* mqttPassword = "REPLACE_WITH_YOUR_MQTT_PASS";  // MQTT password
const char* topicOutput1 = "esp/output1";
const char* topicOutput2 = "esp/output2";
const char* topicTemperature = "esp/temperature";
const char* topicHumidity = "esp/humidity";
// Define the serial console for debug prints, if needed
//#define DUMP_AT_COMMANDS
#include &lt;Wire.h>
#include &lt;TinyGsmClient.h>
#ifdef DUMP_AT_COMMANDS
  #include &lt;StreamDebugger.h>
  StreamDebugger debugger(SerialAT, SerialMon);
  TinyGsm modem(debugger);
#else
  TinyGsm modem(SerialAT);
#endif
#include &lt;PubSubClient.h>
#include &lt;Adafruit_Sensor.h>
#include &lt;Adafruit_BME280.h>
TinyGsmClient client(modem);
PubSubClient mqtt(client);
// TTGO T-Call pins
#define MODEM_RST            5
#define MODEM_PWKEY          4
#define MODEM_POWER_ON       23
#define MODEM_TX             27
#define MODEM_RX             26
#define I2C_SDA              21
#define I2C_SCL              22
// BME280 pins
#define I2C_SDA_2            18
#define I2C_SCL_2            19
#define OUTPUT_1             2
#define OUTPUT_2             15
uint32_t lastReconnectAttempt = 0;
// I2C for SIM800 (to keep it running when powered from battery)
TwoWire I2CPower = TwoWire(0);
TwoWire I2CBME = TwoWire(1);
Adafruit_BME280 bme;
#define IP5306_ADDR          0x75
#define IP5306_REG_SYS_CTL0  0x00
float temperature = 0;
float humidity = 0;
long lastMsg = 0;
bool setPowerBoostKeepOn(int en){
  I2CPower.beginTransmission(IP5306_ADDR);
  I2CPower.write(IP5306_REG_SYS_CTL0);
  if (en) {
    I2CPower.write(0x37); // Set bit1: 1 enable 0 disable boost keep on
  } else {
    I2CPower.write(0x35); // 0x37 is default reg value
  }
  return I2CPower.endTransmission() == 0;
}
void mqttCallback(char* topic, byte* message, unsigned int len) {
  Serial.print("Message arrived on topic: ");
  Serial.print(topic);
  Serial.print(". Message: ");
  String messageTemp;
  
  for (int i = 0; i &lt; len; i++) {
    Serial.print((char)message[i]);
    messageTemp += (char)message[i];
  }
  Serial.println();
  // Feel free to add more if statements to control more GPIOs with MQTT
  // If a message is received on the topic esp/output1, you check if the message is either "true" or "false". 
  // Changes the output state according to the message
  if (String(topic) == "esp/output1") {
    Serial.print("Changing output to ");
    if(messageTemp == "true"){
      Serial.println("true");
      digitalWrite(OUTPUT_1, HIGH);
    }
    else if(messageTemp == "false"){
      Serial.println("false");
      digitalWrite(OUTPUT_1, LOW);
    }
  }
  else if (String(topic) == "esp/output2") {
    Serial.print("Changing output to ");
    if(messageTemp == "true"){
      Serial.println("true");
      digitalWrite(OUTPUT_2, HIGH);
    }
    else if(messageTemp == "false"){
      Serial.println("false");
      digitalWrite(OUTPUT_2, LOW);
    }
  }
}
boolean mqttConnect() {
  SerialMon.print("Connecting to ");
  SerialMon.print(broker);
  // Connect to MQTT Broker without username and password
  //boolean status = mqtt.connect("GsmClientN");
  // Or, if you want to authenticate MQTT:
  boolean status = mqtt.connect("GsmClientN", mqttUsername, mqttPassword);
  if (status == false) {
    SerialMon.println(" fail");
    ESP.restart();
    return false;
  }
  SerialMon.println(" success");
  mqtt.subscribe(topicOutput1);
  mqtt.subscribe(topicOutput2);
  return mqtt.connected();
}
void setup() {
  // Set console baud rate
  SerialMon.begin(115200);
  delay(10);
  
  // Start I2C communication
  I2CPower.begin(I2C_SDA, I2C_SCL, 400000);
  I2CBME.begin(I2C_SDA_2, I2C_SCL_2, 400000);
  
  // Keep power when running from battery
  bool isOk = setPowerBoostKeepOn(1);
  SerialMon.println(String("IP5306 KeepOn ") + (isOk ? "OK" : "FAIL"));
  // Set modem reset, enable, power pins
  pinMode(MODEM_PWKEY, OUTPUT);
  pinMode(MODEM_RST, OUTPUT);
  pinMode(MODEM_POWER_ON, OUTPUT);
  digitalWrite(MODEM_PWKEY, LOW);
  digitalWrite(MODEM_RST, HIGH);
  digitalWrite(MODEM_POWER_ON, HIGH);
  
  pinMode(OUTPUT_1, OUTPUT);
  pinMode(OUTPUT_2, OUTPUT);
  
  SerialMon.println("Wait...");
  // Set GSM module baud rate and UART pins
  SerialAT.begin(115200, SERIAL_8N1, MODEM_RX, MODEM_TX);
  delay(6000);
  // Restart takes quite some time
  // To skip it, call init() instead of restart()
  SerialMon.println("Initializing modem...");
  modem.restart();
  // modem.init();
  String modemInfo = modem.getModemInfo();
  SerialMon.print("Modem Info: ");
  SerialMon.println(modemInfo);
  // Unlock your SIM card with a PIN if needed
  if ( GSM_PIN && modem.getSimStatus() != 3 ) {
    modem.simUnlock(GSM_PIN);
  }
  // You might need to change the BME280 I2C address, in our case it's 0x76
  if (!bme.begin(0x76, &I2CBME)) {
    Serial.println("Could not find a valid BME280 sensor, check wiring!");
    while (1);
  }
  SerialMon.print("Connecting to APN: ");
  SerialMon.print(apn);
  if (!modem.gprsConnect(apn, gprsUser, gprsPass)) {
    SerialMon.println(" fail");
    ESP.restart();
  }
  else {
    SerialMon.println(" OK");
  }
  
  if (modem.isGprsConnected()) {
    SerialMon.println("GPRS connected");
  }
  // MQTT Broker setup
  mqtt.setServer(broker, 1883);
  mqtt.setCallback(mqttCallback);
}
void loop() {
  if (!mqtt.connected()) {
    SerialMon.println("=== MQTT NOT CONNECTED ===");
    // Reconnect every 10 seconds
    uint32_t t = millis();
    if (t - lastReconnectAttempt > 10000L) {
      lastReconnectAttempt = t;
      if (mqttConnect()) {
        lastReconnectAttempt = 0;
      }
    }
    delay(100);
    return;
  }
  long now = millis();
  if (now - lastMsg > 30000) {
    lastMsg = now;
    
    // Temperature in Celsius
    temperature = bme.readTemperature();   
    // Uncomment the next line to set temperature in Fahrenheit 
    // (and comment the previous temperature line)
    //temperature = 1.8 * bme.readTemperature() + 32; // Temperature in Fahrenheit
    
    // Convert the value to a char array
    char tempString[8];
    dtostrf(temperature, 1, 2, tempString);
    Serial.print("Temperature: ");
    Serial.println(tempString);
    mqtt.publish(topicTemperature, tempString);
    humidity = bme.readHumidity();
    
    // Convert the value to a char array
    char humString[8];
    dtostrf(humidity, 1, 2, humString);
    Serial.print("Humidity: ");
    Serial.println(humString);
    mqtt.publish(topicHumidity, humString);
  }
  mqtt.loop();
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_SIM800L_Cloud_MQTT_Broker.ino" target="_blank">View raw code</a>
Before uploading the code, you need to insert your APN details, SIM card PIN (if applicable) and your cloud MQTT server details.
<h3>How the Code Works</h3>
Insert your GPRS APN credentials in the following variables:
<k>const char apn[]      = ""; // APN (example: internet.vodafone.pt) use https://wiki.apnchanger.org
const char gprsUser[] = ""; // GPRS User
const char gprsPass[] = ""; // GPRS Password</k>
In our case, the APN is internet.vodafone.pt. Yours should be different. We explained previously how to get your APN details. 
Enter your SIM card PIN if applicable:
<k>const char simPIN[] = "";</k>
You also need to type the cloud MQTT server details in the following variables. It can be your own cloud MQTT domain or any other MQTT server that you want to use.
<k>const char* broker = "178.XXX.XXX.XXX";  // Public IP address or domain name
const char* mqttUsername = "REPLACE_WITH_YOUR_MQTT_USERNAME";
const char* mqttPassword = "REPLACE_WITH_YOUR_MQTT_PASSWORD";</k>
The ESP32 is subscribed to the esp/output1 and esp/output2 topics to update the outputs with the latest value:
<k>const char* topicOutput1 = "esp/output1";
const char* topicOutput2 = "esp/output2";</k>
The ESP32 publishes the temperature and humidity readings to these topics esp/temperature and esp/humidity every 30 seconds:
<k>const char* topicTemperature = "esp/temperature";
const char* topicHumidity = "esp/humidity";</k>
The code is heavily commented so that you understand the purpose of each line of code.
The following lines define the pins used by the SIM800L module:
<k>#define MODEM_RST       5
#define MODEM_PWKEY     4
#define MODEM_POWER_ON  23
#define MODEM_TX        27
#define MODEM_RX        26
#define I2C_SDA         21
#define I2C_SCL         22</k>
Define the BME280 I2C pins. In this example we're using GPIO 18 and GPIO 19.
<k>#define I2C_SDA_2  18
#define I2C_SCL_2  19</k>
Define a serial communication for the Serial Monitor and another to communicate with the SIM800L module:
<k>// Set serial for debug console (to Serial Monitor, default speed 115200)
#define SerialMon Serial
// Set serial for AT commands (to SIM800 module)
#define SerialAT Serial1</k>
Configure the TinyGSM library to work with the SIM800L module.
<k>#define TINY_GSM_MODEM_SIM800</k>
Include the following libraries to communicate with the SIM800L.
<k>#include &lt;Wire.h>
#include &lt;TinyGsmClient.h></k>
And the MQTT library and the BME280 sensor libraries:
<k>#include &lt;PubSubClient.h>
#include &lt;Adafruit_Sensor.h>
#include &lt;Adafruit_BME280.h></k>
Instantiate an I2C communication for the SIM800L (battery power management IC).
<k>TwoWire I2CPower = TwoWire(0);</k>
And another I2C communication for the BME280 sensor.
<k>TwoWire I2CBME = TwoWire(1);
Adafruit_BME280 bme;</k>
Initialize a TinyGsmClient for internet connection.
<k>TinyGsmClient client(modem);</k>
<h3>setup()</h3>
In the setup(), initialize the Serial Monitor at a baud rate of 115200:
<k>SerialMon.begin(115200);</k>
Start the I2C communication for the SIM800L module and for the BME280 sensor module:
<k>I2CPower.begin(I2C_SDA, I2C_SCL, 400000);
I2CBME.begin(I2C_SDA_2, I2C_SCL_2, 400000);</k>
Setup the SIM800L pins in a proper state to operate:
<k>pinMode(MODEM_PWKEY, OUTPUT);
pinMode(MODEM_RST, OUTPUT);
pinMode(MODEM_POWER_ON, OUTPUT);
digitalWrite(MODEM_PWKEY, LOW);
digitalWrite(MODEM_RST, HIGH);
digitalWrite(MODEM_POWER_ON, HIGH);</k>
Initialize a serial communication with the SIM800L module.
<k>SerialAT.begin(115200, SERIAL_8N1, MODEM_RX, MODEM_TX);</k>
Initialize the SIM800L module and unlock the SIM card PIN if needed.
<k>SerialMon.println("Initializing modem...");
modem.restart();
// Unlock your SIM card with a PIN if needed
if (strlen(simPIN) && modem.getSimStatus() != 3 ) {
  modem.simUnlock(simPIN);
}</k>
Initialize the BME280 sensor.
<k>if (!bme.begin(0x76, &I2CBME)) {
  Serial.println("Could not find a valid BME280 sensor, check wiring!");
  while (1);
}</k>
Finally, in the setup() is where we'll actually connect to the internet. The following lines connect the module to the internet:
<k>SerialMon.print("Connecting to APN: ");
SerialMon.print(apn);
if (!modem.gprsConnect(apn, gprsUser, gprsPass)) {
  SerialMon.println(" fail");
  ESP.restart();
}
else {
  SerialMon.println(" OK");
}</k>
<h3>mqttConnect()</h3>
The mqttConnect() function is responsible to connect your board to the MQTT broker using username and password. It also subscribes the ESP32 to the <k>esp/output1</k> and <k>esp/output2</k> MQTT topics.
<k>boolean mqttConnect() {
  SerialMon.print("Connecting to ");
  SerialMon.print(broker);
  // Connect to MQTT Broker without username and password
  //boolean status = mqtt.connect("GsmClientN");
  // Or, if you want to authenticate MQTT:
  boolean status = mqtt.connect("GsmClientN", mqttUsername, mqttPassword);
  if (status == false) {
    SerialMon.println(" fail");
    ESP.restart();
    return false;
  }
  SerialMon.println(" success");
  mqtt.subscribe(topicOutput1);
  mqtt.subscribe(topicOutput2);
  return mqtt.connected();
}</k>
<h3>loop()</h3>
In the loop(), there's a <a href="https://randomnerdtutorials.com/esp32-pir-motion-sensor-interrupts-timers/">timer</a> that publishes the temperature and humidity readings to your MQTT broker every 30 seconds.
<k>long now = millis();
if (now - lastMsg > 30000) {
  lastMsg = now;
    
  // Temperature in Celsius
  temperature = bme.readTemperature();   
  // Uncomment the next line to set temperature in Fahrenheit 
  // (and comment the previous temperature line)
  //temperature = 1.8 * bme.readTemperature() + 32; // Temperature in Fahrenheit
    
  // Convert the value to a char array
  char tempString[8];
  dtostrf(temperature, 1, 2, tempString);
  Serial.print("Temperature: ");
  Serial.println(tempString);
  mqtt.publish(topicTemperature, tempString);
  humidity = bme.readHumidity();
    
  // Convert the value to a char array
  char humString[8];
  dtostrf(humidity, 1, 2, humString);
  Serial.print("Humidity: ");
  Serial.println(humString);
  mqtt.publish(topicHumidity, humString);
}</k>
<h3>mqttCallback()</h3>
In the mqttCallback() function, the ESP32 receives the MQTT messages of the subscribed topics. Accordingly to the MQTT topic and message, it turns the outputs on or off:
<k>void mqttCallback(char* topic, byte* message, unsigned int len) {
  Serial.print("Message arrived on topic: ");
  Serial.print(topic);
  Serial.print(". Message: ");
  String messageTemp;
  for (int i = 0; i &lt; len; i++) {
    Serial.print((char)message[i]);
    messageTemp += (char)message[i];
  }
  Serial.println();
  // Feel free to add more if statements to control more GPIOs with MQTT
  // If a message is received on the topic esp/output1, you check if the message is either "true" or "false". 
  // Changes the output state according to the message
  if (String(topic) == "esp/output1") {
    Serial.print("Changing output to ");
    if(messageTemp == "true"){
      Serial.println("true");
      digitalWrite(OUTPUT_1, HIGH);
    }
    else if(messageTemp == "false"){
      Serial.println("false");
      digitalWrite(OUTPUT_1, LOW);
    }
  }
  else if (String(topic) == "esp/output2") {
    Serial.print("Changing output to ");
    if(messageTemp == "true"){
      Serial.println("true");
      digitalWrite(OUTPUT_2, HIGH);
    }
    else if(messageTemp == "false"){
      Serial.println("false");
      digitalWrite(OUTPUT_2, LOW);
    }
  }
}</k>
<h3>Upload the Code</h3>
After inserting all the necessary details, you can upload the code to your board.
To upload code to your board, go to <k>Tools </k>> <k>Board </k>and select <k>ESP32 Dev module</k>. Go to <k>Tools</k> > <k>Port</k> and select the COM port your board is connected to. Finally, press the upload button to upload the code to your board.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2016/12/arduino-ide-upload-button.png">
<k>Note: </k> at the moment, there isn't a board for the T-Call ESP32 SIM800L, but we've selected the <k>ESP32 Dev Module</k> and it's been working fine.
<h3>Demonstration</h3>
Open the Serial Monitor at baud rate of 115200 and press the board RST button. 
First, the module initializes and then it tries to connect to the internet. Please note that this can take some time (in some cases it took almost 1 minute to complete). 
After connecting to the internet, it will connect to your MQTT broker.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/ESP32-SIM800L-GPRS-GSM-Cloud-MQTT-Broker-Node-RED-Arduino-IDE-Serial-Monitor.png">
In this example, it publishes new sensor readings every 30 seconds, but for testing purposes you can use a shorter period of time.
Then, open a browser and type your server domain on the <k>/ui</k> URL. You should see the charts with the latest sensor readings and the toggle switches to control the outputs.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/ESP32-SIM800L-GPRS-GSM-Cloud-MQTT-Broker-Node-RED-Dashboard-Demonstration.png">
<h3>Troubleshooting</h3>
If at this point, you can't make your module connect to the internet, it can be caused by one of the following reasons:
The APN credentials might not be correct;
The antenna might not be working properly. In our case, we had to replace the antenna;
You might need to go outside to get a better signal coverage;
Or you might not be supplying enough current to the module. If you're connecting the module to your computer using a USB hub without external power supply, it might not provide enough current to operate.
<h3>Wrapping Up</h3>
We hope you liked this project. In our opinion, the <a aria-label="T-Call SIM800 ESP32 board (opens in a new tab)" href="https://makeradvisor.com/tools/ttgo-t-call-esp32-sim800/" target="_blank">T-Call SIM800 ESP32 board</a> can be very useful for IoT projects that don't have access to a nearby router via Wi-Fi. You can connect your board to the internet quite easily using a SIM card data plan.
You may also like the following projects:
<a href="https://makeradvisor.com/ttgo-t-call-esp32-with-sim800l-gsm-gprs/" target="_blank" aria-label=" (opens in a new tab)">$11 TTGO T-Call ESP32 with SIM800L GSM/GPRS (in-depth review)</a>
<a href="https://randomnerdtutorials.com/esp32-esp8266-mysql-database-php/">ESP32/ESP8266 Insert Data into MySQL Database using PHP and Arduino IDE</a>
<a href="https://randomnerdtutorials.com/esp32-esp8266-plot-chart-web-server/">ESP32/ESP8266 Plot Sensor Readings in Real Time Charts  Web Server</a>
<a href="https://randomnerdtutorials.com/esp32-web-server-with-bme280-mini-weather-station/">ESP32 Web Server with BME280  Advanced Weather Station</a>
<h2>ESP32 Web Server using Server-Sent Events (Update Sensor Readings Automatically)</h2>
This tutorial shows how to use Server-Sent Events (SSE) in an ESP32 Web Server programmed with Arduino IDE. SSE allows the browser to receive automatic updates from a server via HTTP connection. This is useful to send updated sensor readings to the browser, for example. Whenever a new reading is available, the ESP32 sends it to the client and the web page can be updated automatically without the need to make additional requests.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/ESP32-Web-Server-Server-Sent-Events-SSE-Update-Sensor-Readings-Automatically-Arduino.jpg">
As an example, we'll build a web server that displays sensor readings from a BME280 temperature, humidity and pressure sensor. To learn more about the BME280, read our guide:
<a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/">ESP32 with BME280 Sensor using Arduino IDE (Pressure, Temperature, Humidity)</a>
We also have a similar <a href="https://randomnerdtutorials.com/esp8266-nodemcu-web-server-sent-events-sse/">Server-Sent Events guide for the ESP8266</a>.
<h3>Introducing Server-Sent Events (SSE)</h3>
Server-Sent Events (SSE) allows the client to receive automatic updates from a server via HTTP connection.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/ESP32-ESP8266-Server-Sent-Events-How-it-Works.png">
The client initiates the SSE connection and the server uses the event source protocol to send updates to the client. The client will receive updates from the server, but it can't send any data to the server after the initial handshake.
This is useful to send updated sensor readings to the browser. Whenever a new reading is available, the ESP32 sends it to the client and the web page can be updated automatically without the need for further requests. Instead of sensor readings, you can send any data that might be useful for your project like GPIO states, notifications when motion is detected, etc.
<k>Important: </k> Server-Sent Events (SSE) are not supported on Internet Explorer.
<h3>Project Overview</h3>
Here's the web page we'll build for this project.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/BME28-Web-Server-with-Server-Sent-Events-Overview.png">
The ESP32 web server displays three cards with BME280 temperature, humidity and pressure readings;
The ESP32 gets new readings from the sensor every 30 seconds;
Whenever a new reading is available, the board (server) sends it to the client using server-sent events;
The client receives the data and updates the web page accordingly;
This allows the web page to be updated automatically whenever new readings are available.
<h3>How it Works?</h3>
The following diagram summarizes how Server-Sent Events work to update the web page.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/ESP32-BME280-Web-Server-Server-Sent-Events-How-it-Works.png">
<ol>
The client initiates the SSE connection and the server uses the event source protocol on the /events URL to send updates to the client;
The ESP32 gets new sensor readings;
It sends the readings as events with the following names to the client: temperature', humidity' and pressure';
The client has event listeners for the events sent by the server and receives the updated sensor readings on those events;
It updates the web page with the newest readings.
</ol>
<h3>Preparing Arduino IDE</h3>
We'll program the <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> board using Arduino IDE, so make sure you have it installed in your Arduino IDE.
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<h3>Installing Libraries  Async Web Server</h3>
To build the web server we'll use the <a href="https://github.com/me-no-dev/ESPAsyncWebServer" target="_blank">ESPAsyncWebServer </a>library. This library needs the <a href="https://github.com/me-no-dev/AsyncTCP" target="_blank">AsyncTCP </a>library to work properly. Click the links below to download the libraries.
<a href="https://github.com/me-no-dev/ESPAsyncWebServer/archive/master.zip" target="_blank">ESPAsyncWebServer</a> 
<a href="https://github.com/me-no-dev/AsyncTCP/archive/master.zip" target="_blank">AsyncTCP</a>
These libraries aren't available to install through the Arduino Library Manager, so you need to copy the library files to the Arduino Installation Libraries folder. Alternatively, in your Arduino IDE, you can go to <k>Sketch </k>> <k>Include Library</k> > <k>Add .zip Library</k> and select the libraries you've just downloaded.
<h3>Installing Libraries  BME280 Sensor</h3>
To get readings from the BME280 sensor module, we'll use the <a href="https://github.com/adafruit/Adafruit_BME280_Library" target="_blank">Adafruit_BME280 library</a>. You also need to install the <a href="https://github.com/adafruit/Adafruit_Sensor" target="_blank">Adafruit_Sensor library</a>. Follow the next steps to install the libraries in your Arduino IDE:
1. Open your Arduino IDE and go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k>. The Library Manager should open.
2. Search for <k>adafruit bme280</k>  on the Search box and install the library.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/08/install-bme280.png">
To use the BME280 library, you also need to install the <a href="https://github.com/adafruit/Adafruit_Sensor" target="_blank" aria-label="Adafruit Unified Sensor (opens in a new tab)">Adafruit Unified Sensor</a>. Follow the next steps to install the library in your Arduino IDE:
3. Search for <k>Adafruit Unified Sensor</k>in the search box. Scroll all the way down to find the library and install it.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/04/adafruit_unified_sensor_library.png">
After installing the libraries, restart your Arduino IDE.
To learn more about the BME280 sensor, read our guide: <a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/">ESP32 with BME280 Sensor using Arduino IDE (Pressure, Temperature, Humidity)</a>.
<h3>Building the Circuit</h3>
To exemplify how to use server-sent events with the ESP32, we'll send sensor readings from a BME280 sensor to the browser. So, you need to wire a BME280 sensor to your ESP32.
<h3>Parts Required</h3>
To complete this tutorial you need the following parts:
<a href="https://makeradvisor.com/tools/bme280-sensor-module/" target="_blank">BME280 sensor module</a>
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> (read <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">Best ESP32 development boards</a>)
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a>
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="lazy" fetchpriority="low"></a>
<h3>Schematic Diagram</h3>
We're going to use I2C communication with the BME280 sensor module. For that, wire the sensor to the default ESP32 SCL (GPIO 22) and SDA (GPIO 21) pins, as shown in the following schematic diagram.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/ESP32-BME280-Sensor-Temperature-Humidity-Pressure-Wiring-Diagram-Circuit_f.png">
Recommended reading: <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">ESP32 Pinout Reference: Which GPIO pins should you use?</a>
<h3>Code for ESP32 Web Server using Server-Sent Events (SSE)</h3>
Copy the following code to your Arduino IDE.
<k>/*********
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-web-server-sent-events-sse/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*********/
#include &lt;WiFi.h>
#include &lt;AsyncTCP.h>
#include &lt;ESPAsyncWebServer.h>
#include &lt;Adafruit_BME280.h>
#include &lt;Adafruit_Sensor.h>
// Replace with your network credentials
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
// Create AsyncWebServer object on port 80
AsyncWebServer server(80);
// Create an Event Source on /events
AsyncEventSource events("/events");
// Timer variables
unsigned long lastTime = 0;  
unsigned long timerDelay = 30000;
// Create a sensor object
Adafruit_BME280 bme;         // BME280 connect to ESP32 I2C (GPIO 21 = SDA, GPIO 22 = SCL)
float temperature;
float humidity;
float pressure;
// Init BME280
void initBME(){
    if (!bme.begin(0x76)) {
    Serial.println("Could not find a valid BME280 sensor, check wiring!");
    while (1);
  }
}
void getSensorReadings(){
  temperature = bme.readTemperature();
  // Convert temperature to Fahrenheit
  //temperature = 1.8 * bme.readTemperature() + 32;
  humidity = bme.readHumidity();
  pressure = bme.readPressure()/ 100.0F;
}
// Initialize WiFi
void initWiFi() {
    WiFi.mode(WIFI_STA);
    WiFi.begin(ssid, password);
    Serial.print("Connecting to WiFi ..");
    while (WiFi.status() != WL_CONNECTED) {
        Serial.print('.');
        delay(1000);
    }
    Serial.println(WiFi.localIP());
}
String processor(const String& var){
  getSensorReadings();
  //Serial.println(var);
  if(var == "TEMPERATURE"){
    return String(temperature);
  }
  else if(var == "HUMIDITY"){
    return String(humidity);
  }
  else if(var == "PRESSURE"){
    return String(pressure);
  }
  return String();
}
const char index_html[] PROGMEM = R"rawliteral(
&lt;!DOCTYPE HTML>&lt;html>
&lt;head>
  &lt;title>ESP Web Server&lt;/title>
  &lt;meta name="viewport" content="width=device-width, initial-scale=1">
  &lt;link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
  &lt;link rel="icon" href="data:,">
  &lt;style>
    html {font-family: Arial; display: inline-block; text-align: center;}
    p { font-size: 1.2rem;}
    body {  margin: 0;}
    .topnav { overflow: hidden; background-color: #50B8B4; color: white; font-size: 1rem; }
    .content { padding: 20px; }
    .card { background-color: white; box-shadow: 2px 2px 12px 1px rgba(140,140,140,.5); }
    .cards { max-width: 800px; margin: 0 auto; display: grid; grid-gap: 2rem; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); }
    .reading { font-size: 1.4rem; }
  &lt;/style>
&lt;/head>
&lt;body>
  &lt;div>
    &lt;h1>BME280 WEB SERVER (SSE)&lt;/h2>
  &lt;/div>
  &lt;div>
    &lt;div>
      &lt;div>
        &lt;p>&lt;i style="color:#059e8a;">&lt;/i> TEMPERATURE&lt;/p>&lt;p>&lt;span>&lt;span>%TEMPERATURE%&lt;/span> &deg;C&lt;/span>&lt;/p>
      &lt;/div>
      &lt;div>
        &lt;p>&lt;i style="color:#00add6;">&lt;/i> HUMIDITY&lt;/p>&lt;p>&lt;span>&lt;span>%HUMIDITY%&lt;/span> &percnt;&lt;/span>&lt;/p>
      &lt;/div>
      &lt;div>
        &lt;p>&lt;i style="color:#e1e437;">&lt;/i> PRESSURE&lt;/p>&lt;p>&lt;span>&lt;span>%PRESSURE%&lt;/span> hPa&lt;/span>&lt;/p>
      &lt;/div>
    &lt;/div>
  &lt;/div>
&lt;script>
if (!!window.EventSource) {
 var source = new EventSource('/events');
 
 source.addEventListener('open', function(e) {
  console.log("Events Connected");
 }, false);
 source.addEventListener('error', function(e) {
  if (e.target.readyState != EventSource.OPEN) {
    console.log("Events Disconnected");
  }
 }, false);
 
 source.addEventListener('message', function(e) {
  console.log("message", e.data);
 }, false);
 
 source.addEventListener('temperature', function(e) {
  console.log("temperature", e.data);
  document.getElementById("temp").innerHTML = e.data;
 }, false);
 
 source.addEventListener('humidity', function(e) {
  console.log("humidity", e.data);
  document.getElementById("hum").innerHTML = e.data;
 }, false);
 
 source.addEventListener('pressure', function(e) {
  console.log("pressure", e.data);
  document.getElementById("pres").innerHTML = e.data;
 }, false);
}
&lt;/script>
&lt;/body>
&lt;/html>)rawliteral";
void setup() {
  Serial.begin(115200);
  initWiFi();
  initBME();
  // Handle Web Server
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send_P(200, "text/html", index_html, processor);
  });
  // Handle Web Server Events
  events.onConnect([](AsyncEventSourceClient *client){
    if(client->lastId()){
      Serial.printf("Client reconnected! Last message ID that it got is: %u\n", client->lastId());
    }
    // send event with message "hello!", id current millis
    // and set reconnect delay to 1 second
    client->send("hello!", NULL, millis(), 10000);
  });
  server.addHandler(&events);
  server.begin();
}
void loop() {
  if ((millis() - lastTime) > timerDelay) {
    getSensorReadings();
    Serial.printf("Temperature = %.2f oC \n", temperature);
    Serial.printf("Humidity = %.2f \n", humidity);
    Serial.printf("Pressure = %.2f hPa \n", pressure);
    Serial.println();
    // Send Events to the Web Client with the Sensor Readings
    events.send("ping",NULL,millis());
    events.send(String(temperature).c_str(),"temperature",millis());
    events.send(String(humidity).c_str(),"humidity",millis());
    events.send(String(pressure).c_str(),"pressure",millis());
    
    lastTime = millis();
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Server_Sent_Events.ino" target="_blank">View raw code</a>
Insert your network credentials in the following variables and the code will work straight away.
<k>const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h3>How the Code Works</h3>
Continue reading to learn how the code works or skip to the Demonstration section.
<h3>Including Libraries</h3>
The Adafruit_Sensor and Adafruit_BME280 libraries are needed to interface with the BME280 sensor.
<k>#include &lt;Adafruit_BME280.h>
#include &lt;Adafruit_Sensor.h></k>
The WiFi, ESPAsyncWebServer and AsyncTCP libraries are used to create the web server.
<k>#include &lt;WiFi.h>
#include "ESPAsyncWebServer.h"</k>
<h3>Network Credentials</h3>
Insert your network credentials in the following variables, so that the ESP32 can connect to your local network using Wi-Fi.
<k>const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h3>AsyncWebServer and AsyncEventSource</h3>
Create an AsyncWebServer object on port 80.
<k>AsyncWebServer server(80);</k>
The following line creates a new event source on /events.
<k>AsyncEventSource events("/events");</k>
<h3>Declaring Variables</h3>
The lastTime and the timerDelay variables will be used to update sensor readings every X number of seconds. As an example, we'll get new sensor readings every 30 seconds (30000 milliseconds). You can change that delay time in the timerDelay variable.
<k>unsigned long lastTime = 0;
unsigned long timerDelay = 30000;</k>
Create an Adafruit_BME280 object called bme on the default ESP32 I2C pins.
<k>Adafruit_BME280 bme;</k>
The temperature, humidity and pressure float variables will be used to hold BME280 sensor readings.
<k>float temperature;
float humidity;
float pressure;</k>
<h3>Initialize BME280</h3>
The following function can be called to initialize the BME280 sensor.
<k>void initBME(){
  if (!bme.begin(0x76)) {
    Serial.println("Could not find a valid BME280 sensor, check wiring!");
    while (1);
  }
}</k>
<h3>Get BME280 Readings</h3>
The getSensorReading() function gets temperature, humidity and pressure readings from the BME280 sensor and saves them on the temperature, humidity and pressure variables.
<k>void getSensorReadings(){
  temperature = bme.readTemperature();
  // Convert temperature to Fahrenheit
  //temperature = 1.8 * bme.readTemperature() + 32;
  humidity = bme.readHumidity();
  pressure = bme.readPressure()/ 100.0F;
}</k>
<h3>Initialize Wi-Fi</h3>
The following function sets the ESP32 as a Wi-Fi station and connects to your router using the ssid and password defined earlier.
<k>void initWiFi() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  Serial.print("Connecting to WiFi ..");
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print('.');
    delay(1000);
  }
  Serial.println(WiFi.localIP());
}</k>
<h3>Processor</h3>
The processor() function replaces any placeholders on the HTML text used to build the web page with the current sensor readings before sending it to the browser.
<k>String processor(const String& var){
  getSensorReadings();
  //Serial.println(var);
  if(var == "TEMPERATURE"){
    return String(temperature);
  }
  else if(var == "HUMIDITY"){
    return String(humidity);
  }
  else if(var == "PRESSURE"){
    return String(pressure);
  }
}</k>
This allows us to display the current sensor readings on the web page when you access it for the first time. Otherwise, you would see a blank space until new readings were available (which can take some time depending on the delay time you've defined on the code).
<h3>Building the Web Page</h3>
The index_html variable contains all the HTML, CSS and JavaScript to build the web page. 
<k>Note: </k>for the simplicity of this tutorial, we're placing everything needed to build the web page on the index_html variable that we use on the Arduino sketch. Note that it may be more practical to have separated HTML, CSS and JavaScript files that then you upload to the ESP32 filesystem and reference them on the code.
Here's the content index_html variable:
<k>&lt;!DOCTYPE HTML>
&lt;html>
&lt;head>
  &lt;title>ESP Web Server&lt;/title>
  &lt;meta name="viewport" content="width=device-width, initial-scale=1">
  &lt;link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
  &lt;link rel="icon" href="data:,">
  &lt;style>
    html {
      font-family: Arial; 
      display: inline-block; 
      text-align: center;
    }
    p { 
      font-size: 1.2rem;
    }
    body {  
      margin: 0;
    }
    .topnav { 
      overflow: hidden; 
      background-color: #50B8B4; 
      color: white; 
      font-size: 1rem; 
    }
    .content { 
      padding: 20px; 
    }
    .card { 
      background-color: white; 
      box-shadow: 2px 2px 12px 1px rgba(140,140,140,.5); 
    }
    .cards { 
      max-width: 800px; 
      margin: 0 auto; 
      display: grid; 
      grid-gap: 2rem; 
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); }
    .reading { 
      font-size: 1.4rem;  
    }
  &lt;/style>
&lt;/head>
&lt;body>
  &lt;div>
    &lt;h1>BME280 WEB SERVER (SSE)&lt;/h2>
  &lt;/div>
  &lt;div>
    &lt;div>
      &lt;div>
        &lt;p>&lt;i style="color:#059e8a;">&lt;/i> TEMPERATURE&lt;/p>
        &lt;p>&lt;span>&lt;span>%TEMPERATURE%&lt;/span> &deg;C&lt;/span>&lt;/p>
      &lt;/div>
      &lt;div>
        &lt;p>&lt;i style="color:#00add6;">&lt;/i> HUMIDITY&lt;/p>
        &lt;p>&lt;span>&lt;span>%HUMIDITY%&lt;/span> &percnt;&lt;/span>&lt;/p>
      &lt;/div>
      &lt;div>
        &lt;p>&lt;i style="color:#e1e437;">&lt;/i> PRESSURE&lt;/p>&lt;p>&lt;span>&lt;span>%PRESSURE%&lt;/span> hPa&lt;/span>&lt;/p>
      &lt;/div>
    &lt;/div>
  &lt;/div>
&lt;script>
if (!!window.EventSource) {
  var source = new EventSource('/events');
  source.addEventListener('open', function(e) {
    console.log("Events Connected");
  }, false);
  source.addEventListener('error', function(e) {
    if (e.target.readyState != EventSource.OPEN) {
      console.log("Events Disconnected");
    }
  }, false);
  source.addEventListener('message', function(e) {
    console.log("message", e.data);
  }, false);
  source.addEventListener('temperature', function(e) {
    console.log("temperature", e.data);
    document.getElementById("temp").innerHTML = e.data;
  }, false);
  source.addEventListener('humidity', function(e) {
    console.log("humidity", e.data);
    document.getElementById("hum").innerHTML = e.data;
  }, false);
  source.addEventListener('pressure', function(e) {
    console.log("pressure", e.data);
    document.getElementById("pres").innerHTML = e.data;
  }, false);
}
&lt;/script>
&lt;/body>
&lt;/html>
</k>
We won't go into detail on how the HTML and CSS works. We'll just take a look at how to handle the events sent by the server.
<h3>CSS</h3>
Between the &lt;style> &lt;/style> tags we include the styles to style the web page using CSS. Feel free to change it to make the web page look as you wish. We won't explain how the CSS for this web page works because it is not relevant for this tutorial.
<k>&lt;style>
  html {
    font-family: Arial; 
    display: inline-block; 
    text-align: center;
  }
  p { 
    font-size: 1.2rem;
  }
  body {  
    margin: 0;
  }
  .topnav { 
    overflow: hidden; 
    background-color: #50B8B4; 
    color: white; 
    font-size: 1rem; 
  }
  .content { 
    padding: 20px; 
  }
  .card { 
    background-color: white; 
    box-shadow: 2px 2px 12px 1px rgba(140,140,140,.5); 
  }
  .cards { 
    max-width: 800px; 
    margin: 0 auto; 
    display: grid; 
    grid-gap: 2rem; 
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); }
  .reading { 
    font-size: 1.4rem;  
  }
&lt;/style></k>
<h3>HTML</h3>
Between the &lt;body> &lt;/body> tags we add the web page content that is visible to the user.
<k>&lt;body>
  &lt;div>
    &lt;h1>BME280 WEB SERVER (SSE)&lt;/h2>
  &lt;/div>
  &lt;div>
    &lt;div>
      &lt;div>
        &lt;p>&lt;i style="color:#059e8a;">&lt;/i> TEMPERATURE&lt;/p>
        &lt;p>&lt;span>&lt;span>%TEMPERATURE%&lt;/span> &deg;C&lt;/span>&lt;/p>
      &lt;/div>
      &lt;div>
        &lt;p>&lt;i style="color:#00add6;">&lt;/i> HUMIDITY&lt;/p>
        &lt;p>&lt;span>&lt;span>%HUMIDITY%&lt;/span> &percnt;&lt;/span>&lt;/p>
      &lt;/div>
      &lt;div>
        &lt;p>&lt;i style="color:#e1e437;">&lt;/i> PRESSURE&lt;/p>&lt;p>&lt;span>&lt;span>%PRESSURE%&lt;/span> hPa&lt;/span>&lt;/p>
      &lt;/div>
    &lt;/div>
  &lt;/div></k>
There's a heading 1 with the content BME280 WEB SERVER (SSE). That's the text that shows up on the top bar. Feel free to modify that text.
<k>&lt;h1>BME280 WEB SERVER (SSE)&lt;/h2></k>
Then, we display the sensor readings in separated div tags. Let's take a quick look at the paragraphs that displays the temperature:
<k>&lt;p>&lt;i style="color:#059e8a;">&lt;/i> TEMPERATURE&lt;/p>
&lt;p>&lt;span>&lt;span>%TEMPERATURE%&lt;/span> &deg;C&lt;/span>&lt;/p></k>
The first paragraph simply displays the TEMPERATURE text. We define the color and also an icon.
On the second paragraph, you can see that the %TEMPERATURE% placeholder is surrounded by &lt;span id=temp> &lt;/span> tags. The HTML id attribute is used to specify a unique id for an HTML element.
It is used to point to a specific style or it can be used by JavaScript to access and manipulate the element with that specific id. That's what we're going to do. For instance, when the client receives a new event with the latest temperature reading, it updates the HTML element with the id temp with the new reading.
A similar process is done to update the other readings.
<h3>JavaScript  EventSource</h3>
The JavaScript goes between the &lt;script> &lt;/script> tags. It is responsible for initializing an EventSource connection with the server and handle the events received from the server.
<k>&lt;script>
if (!!window.EventSource) {
  var source = new EventSource('/events');
  source.addEventListener('open', function(e) {
    console.log("Events Connected");
  }, false);
  source.addEventListener('error', function(e) {
    if (e.target.readyState != EventSource.OPEN) {
      console.log("Events Disconnected");
    }
  }, false);
  source.addEventListener('message', function(e) {
    console.log("message", e.data);
  }, false);
  source.addEventListener('temperature', function(e) {
    console.log("temperature", e.data);
    document.getElementById("temp").innerHTML = e.data;
  }, false);
  source.addEventListener('humidity', function(e) {
    console.log("humidity", e.data);
    document.getElementById("hum").innerHTML = e.data;
  }, false);
  source.addEventListener('pressure', function(e) {
    console.log("pressure", e.data);
    document.getElementById("pres").innerHTML = e.data;
  }, false);
}
&lt;/script></k>
Let's take a look at how this works.
<h4>Handle Events</h4>
Create a new EventSource object and specify the URL of the page sending the updates. In our case, it's /events.
<k>if (!!window.EventSource) {
  var source = new EventSource('/events');</k>
Once you've instantiated an event source, you can start listening for messages from the server with addEventListener().
These are the default event listeners, as shown here in the AsyncWebServer <a href="https://github.com/me-no-dev/ESPAsyncWebServer#setup-event-source-in-the-browser" target="_blank">documentation</a>.
<k>source.addEventListener('open', function(e) {
  console.log("Events Connected");
}, false);
source.addEventListener('error', function(e) {
  if (e.target.readyState != EventSource.OPEN) {
    console.log("Events Disconnected");
  }
}, false);
source.addEventListener('message', function(e) {
  console.log("message", e.data);
}, false);</k>
Then, add the event listener for temperature.
<k>source.addEventListener('temperature', function(e) {</k>
When a new temperature reading is available, the ESP32 sends an event (temperature) to the client. The following lines handle what happens when the browser receives that event.
<k>console.log("temperature", e.data);
document.getElementById("temp").innerHTML = e.data;</k>
Basically, print the new readings on the browser console, and put the received data into the element with the corresponding id (temp) on the web page.
A similar processor is done for humidity and pressure.
<k>source.addEventListener('humidity', function(e) {
  console.log("humidity", e.data);
  document.getElementById("hum").innerHTML = e.data;
}, false);
 
source.addEventListener('pressure', function(e) {
  console.log("pressure", e.data);
  document.getElementById("pres").innerHTML = e.data;
}, false);
 
source.addEventListener('gas', function(e) {
  console.log("gas", e.data);
  document.getElementById("gas").innerHTML = e.data;
}, false);</k>
<h3>setup()</h3>
In the setup(), initialize the Serial Monitor, initialize Wi-Fi and the BME280 sensor.
<k>Serial.begin(115200);
initWiFi();
initBME();</k>
<h4>Handle Requests</h4>
When you access the ESP32 IP address on the root / URL, send the text that is stored on the index_html variable to build the web page and pass the processor as argument, so that all placeholders are replaced with the latest sensor readings.
<k>server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
  request->send_P(200, "text/html", index_html, processor);
});</k>
<h4>Server Event Source</h4>
Set up the event source on the server.
<k>// Handle Web Server Events
events.onConnect([](AsyncEventSourceClient *client){
  if(client->lastId()){
    Serial.printf("Client reconnected! Last message ID that it got is: %u\n", client->lastId());
  }
  // send event with message "hello!", id current millis
  // and set reconnect delay to 1 second
  client->send("hello!", NULL, millis(), 10000);
});
server.addHandler(&events);</k>
Finally, start the server.
<k>server.begin();</k>
<h3>loop()</h3>
In the loop(), get new sensor readings:
<k>getSensorReadings();</k>
Print the new readings in the Serial Monitor.
<k>Serial.printf("Temperature = %.2f oC \n", temperature);
Serial.printf("Humidity = %.2f % \n", humidity);
Serial.printf("Pressure = %.2f hPa \n", pressure);
Serial.println();</k>
Finally, send events to the browser with the newest sensor readings to update the web page.
<k>// Send Events to the Web Server with the Sensor Readings
events.send("ping",NULL,millis());
events.send(String(temperature).c_str(),"temperature",millis());
events.send(String(humidity).c_str(),"humidity",millis());
events.send(String(pressure).c_str(),"pressure",millis());</k>
<h3>Demonstration</h3>
After inserting your network credentials on the ssid and password variables, you can upload the code to your board. Don't forget to check if you have the right board and COM port selected.
After uploading the code, open the Serial Monitor at a baud rate of 115200 and press the on-board EN/RST button. The ESP IP address should be printed.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/Server-Sent-Events-ESP32-Web-Server-Serial-Monitor-Sensor-Readings.png">
Open a browser on your local network and insert the ESP32 IP address. You should get access to the web page to monitor the sensor readings.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/BME28-Web-Server-with-Server-Sent-Events-Overview.png">
The readings are updated automatically every 30 seconds.
At the same time, you should get new sensor readings on the Serial Monitor as shown in the previous print screen. Additionally, you can check if the client is receiving the events. On your browser, open the console by pressing <k>Ctrl</k>+<k>Shift</k>+<k>J</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/Server-Sent-Events-Browser-Console-ESP2-Web-Server.png">
<h3>Wrapping Up</h3>
In this tutorial you've learned how to use Server-Sent Events with the ESP32. Server-Sent Events allow a web page (client) to get updates from a server. This can be used to automatically display new sensor readings on the web server page when they are available.
We have a similar tutorial but using the BME680 environmental sensor. You can check the tutorial on the following link:
<a href="https://randomnerdtutorials.com/esp32-bme680-web-server-arduino/">ESP32 Web Server with BME680  Weather Station (Arduino IDE)</a>
Instead of Server-Sent Events, you can also use the <a href="https://randomnerdtutorials.com/esp32-websocket-server-arduino/">WebSocket protocol</a> to keep the web page updated. Take a look at the following tutorial to learn how to set up a WebSocket server with the ESP32:
<a href="https://randomnerdtutorials.com/esp32-websocket-server-arduino/">ESP32 WebSocket Server: Control Outputs (Arduino IDE)</a>
<h2>ESP32 WebSocket Server: Control Outputs (Arduino IDE)</h2>
In this tutorial you'll learn how to build a web server with the ESP32 using WebSocket communication protocol. As an example, we'll show you how to build a web page to control the ESP32 outputs remotely. The output state is displayed on the web page and it updates automatically in all clients.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/ESP32-WebSocket-Server-Control-Outputs-Arduino-IDE.jpg">
The ESP32 will be programmed using Arduino IDE and the ESPAsyncWebServer. We also have a similar <a href="https://randomnerdtutorials.com/esp8266-nodemcu-websocket-server-arduino/">WebSocket guide for the ESP8266</a>.
If you've been following some of our <a href="https://randomnerdtutorials.com/esp32-async-web-server-espasyncwebserver-library/">previous web server projects like this one</a>, you may have noticed that if you have several tabs (in the same or on different devices) opened at the same time, the state doesn't update in all tabs automatically unless you refresh the web page. To solve this issue, we can use WebSocket protocol  all clients can be notified when a change occurs and update the web page accordingly.
This tutorial was based on a project created and documented by one of our readers (St<a8><a6>phane Calderoni). You can read his excellent <a href="https://m1cr0lab-esp32.github.io/remote-control-with-websocket/" target="_blank">tutorial here</a>.
<h3>Introducing WebSocket</h3>
A WebSocket is a persistent connection between a client and a server that allows bidirectional communication between both parties using a TCP connection. This means you can send data from the client to the server and from the server to the client at any given time. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/ESP3-ESP82662-WebSocket-Server-How-it-Works-f.png">
The client establishes a WebSocket connection with the server through a process known as <em>WebSocket handshake</em>. The handshake starts with an HTTP request/response, allowing servers to handle HTTP connections as well as WebSocket connections on the same port. Once the connection is established, the client and the server can send WebSocket data in full duplex mode.
Using the WebSockets protocol, the server (ESP32 board) can send information to the client or to all clients without being requested. This also allows us to send information to the web browser when a change occurs.
This change can be something that happened on the web page (you clicked a button) or something that happened on the ESP32 side like pressing a physical button on a circuit.
<h3>Project Overview</h3>
Here's the web page we'll build for this project.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/ESP32-WebSocket-Web-Server-Control-Outputs-Web-Page.png">
The ESP32 web server displays a web page with a button to toggle the state of GPIO 2;
For simplicity, we're controlling GPIO 2  the on-board LED. You can use this example to control any other GPIO;
The interface shows the current GPIO state. Whenever a change occurs on the GPIO state, the interface is updated instantaneously;
The GPIO state is updated automatically in all clients. This means that if you have several web browser tabs opened on the same device or on different devices, they are all updated at the same time.
<h3>How it Works?</h3>
The following image describes what happens when click on the Toggle button.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/ESP32-WebSocket-Web-Server-Update-All-Clients.png">
Here's what happens when you click on the Toggle button:
<ol>
Click on the Toggle button;
The client (your browser) sends data via WebSocket protocol with the toggle message;
The ESP32 (server) receives this message, so it knows it should toggle the LED state. If the LED was previously off, turn it on;
Then, it sends data with the new LED state to all clients also through WebSocket protocol;
The clients receive the message and update the led state on the web page accordingly. This allows us to update all clients almost instantaneously when a change happens.
</ol>
<h3>Preparing Arduino IDE</h3>
We'll program the <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> board using Arduino IDE, so make sure you have it installed in your Arduino IDE.
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<h3>Installing Libraries  Async Web Server</h3>
To build the web server we'll use the <a href="https://github.com/me-no-dev/ESPAsyncWebServer" target="_blank">ESPAsyncWebServer</a> library. This library needs the <a href="https://github.com/me-no-dev/AsyncTCP" target="_blank">AsyncTCP </a>library to work properly. Click the links below to download the libraries.
<a href="https://github.com/me-no-dev/ESPAsyncWebServer/archive/master.zip" target="_blank">ESPAsyncWebServer</a> 
<a href="https://github.com/me-no-dev/AsyncTCP/archive/master.zip" target="_blank">AsyncTCP</a>
These libraries aren't available to install through the Arduino Library Manager, so you need to copy the library files to the Arduino Installation Libraries folder. Alternatively, in your Arduino IDE, you can go to <k>Sketch </k>> <k>Include Library</k> > <k>Add .zip Library</k> and select the libraries you've just downloaded.
<h3>Code for ESP32 WebSocket Server</h3>
Copy the following code to your Arduino IDE.
<k>/*********
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-websocket-server-arduino/
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*********/
// Import required libraries
#include &lt;WiFi.h>
#include &lt;AsyncTCP.h>
#include &lt;ESPAsyncWebServer.h>
// Replace with your network credentials
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
bool ledState = 0;
const int ledPin = 2;
// Create AsyncWebServer object on port 80
AsyncWebServer server(80);
AsyncWebSocket ws("/ws");
const char index_html[] PROGMEM = R"rawliteral(
&lt;!DOCTYPE HTML>&lt;html>
&lt;head>
  &lt;title>ESP Web Server&lt;/title>
  &lt;meta name="viewport" content="width=device-width, initial-scale=1">
  &lt;link rel="icon" href="data:,">
  &lt;style>
  html {
    font-family: Arial, Helvetica, sans-serif;
    text-align: center;
  }
  h1 {
    font-size: 1.8rem;
    color: white;
  }
  h2{
    font-size: 1.5rem;
    font-weight: bold;
    color: #143642;
  }
  .topnav {
    overflow: hidden;
    background-color: #143642;
  }
  body {
    margin: 0;
  }
  .content {
    padding: 30px;
    max-width: 600px;
    margin: 0 auto;
  }
  .card {
    background-color: #F8F7F9;;
    box-shadow: 2px 2px 12px 1px rgba(140,140,140,.5);
    padding-top:10px;
    padding-bottom:20px;
  }
  .button {
    padding: 15px 50px;
    font-size: 24px;
    text-align: center;
    outline: none;
    color: #fff;
    background-color: #0f8b8d;
    border: none;
    border-radius: 5px;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-tap-highlight-color: rgba(0,0,0,0);
   }
   /*.button:hover {background-color: #0f8b8d}*/
   .button:active {
     background-color: #0f8b8d;
     box-shadow: 2 2px #CDCDCD;
     transform: translateY(2px);
   }
   .state {
     font-size: 1.5rem;
     color:#8c8c8c;
     font-weight: bold;
   }
  &lt;/style>
&lt;title>ESP Web Server&lt;/title>
&lt;meta name="viewport" content="width=device-width, initial-scale=1">
&lt;link rel="icon" href="data:,">
&lt;/head>
&lt;body>
  &lt;div>
    &lt;h1>ESP WebSocket Server&lt;/h2>
  &lt;/div>
  &lt;div>
    &lt;div>
      &lt;h2>Output - GPIO 2&lt;/h2>
      &lt;p>state: &lt;span>%STATE%&lt;/span>&lt;/p>
      &lt;p>&lt;button>Toggle&lt;/button>&lt;/p>
    &lt;/div>
  &lt;/div>
&lt;script>
  var gateway = `ws://${window.location.hostname}/ws`;
  var websocket;
  window.addEventListener('load', onLoad);
  function initWebSocket() {
    console.log('Trying to open a WebSocket connection...');
    websocket = new WebSocket(gateway);
    websocket.onopen    = onOpen;
    websocket.onclose   = onClose;
    websocket.onmessage = onMessage; // &lt;-- add this line
  }
  function onOpen(event) {
    console.log('Connection opened');
  }
  function onClose(event) {
    console.log('Connection closed');
    setTimeout(initWebSocket, 2000);
  }
  function onMessage(event) {
    var state;
    if (event.data == "1"){
      state = "ON";
    }
    else{
      state = "OFF";
    }
    document.getElementById('state').innerHTML = state;
  }
  function onLoad(event) {
    initWebSocket();
    initButton();
  }
  function initButton() {
    document.getElementById('button').addEventListener('click', toggle);
  }
  function toggle(){
    websocket.send('toggle');
  }
&lt;/script>
&lt;/body>
&lt;/html>
)rawliteral";
void notifyClients() {
  ws.textAll(String(ledState));
}
void handleWebSocketMessage(void *arg, uint8_t *data, size_t len) {
  AwsFrameInfo *info = (AwsFrameInfo*)arg;
  if (info->final && info->index == 0 && info->len == len && info->opcode == WS_TEXT) {
    data[len] = 0;
    if (strcmp((char*)data, "toggle") == 0) {
      ledState = !ledState;
      notifyClients();
    }
  }
}
void onEvent(AsyncWebSocket *server, AsyncWebSocketClient *client, AwsEventType type,
             void *arg, uint8_t *data, size_t len) {
  switch (type) {
    case WS_EVT_CONNECT:
      Serial.printf("WebSocket client #%u connected from %s\n", client->id(), client->remoteIP().toString().c_str());
      break;
    case WS_EVT_DISCONNECT:
      Serial.printf("WebSocket client #%u disconnected\n", client->id());
      break;
    case WS_EVT_DATA:
      handleWebSocketMessage(arg, data, len);
      break;
    case WS_EVT_PONG:
    case WS_EVT_ERROR:
      break;
  }
}
void initWebSocket() {
  ws.onEvent(onEvent);
  server.addHandler(&ws);
}
String processor(const String& var){
  Serial.println(var);
  if(var == "STATE"){
    if (ledState){
      return "ON";
    }
    else{
      return "OFF";
    }
  }
  return String();
}
void setup(){
  // Serial port for debugging purposes
  Serial.begin(115200);
  pinMode(ledPin, OUTPUT);
  digitalWrite(ledPin, LOW);
  
  // Connect to Wi-Fi
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi..");
  }
  // Print ESP Local IP Address
  Serial.println(WiFi.localIP());
  initWebSocket();
  // Route for root / web page
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send_P(200, "text/html", index_html, processor);
  });
  // Start server
  server.begin();
}
void loop() {
  ws.cleanupClients();
  digitalWrite(ledPin, ledState);
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_WebSocket_Server.ino" target="_blank">View raw code</a>
Insert your network credentials in the following variables and the code will work straight away.
<k>const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h3>How the Code Works</h3>
Continue reading to learn how the code works or skip to the Demonstration section.
<h3>Importing Libraries</h3>
Import the necessary libraries to build the web server.
<k>#include &lt;WiFi.h>
#include &lt;AsyncTCP.h>
#include &lt;ESPAsyncWebServer.h></k>
<h3>Network Credentials</h3>
Insert your network credentials in the following variables:
<k>const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h3>GPIO Output</h3>
Create a variable called ledState to hold the GPIO state and a variable called ledPin that refers to the GPIO you want to control. In this case, we'll control the on-board LED (that is connected to GPIO 2).
<k>bool ledState = 0;
const int ledPin = 2;</k>
<h3>AsyncWebServer and AsyncWebSocket</h3>
Create an AsyncWebServer object on port 80.
<k>AsyncWebServer server(80);</k>
The ESPAsyncWebServer library includes a WebSocket plugin that makes it easy to handle WebSocket connections. Create an AsyncWebSocket object called ws to handle the connections on the /ws path.
<k>AsyncWebSocket ws("/ws");</k>
<h3>Building the Web Page</h3>
The index_html variable contains the HTML, CSS and JavaScript needed to build and style the web page and handle client-server interactions using WebSocket protocol. 
<k>Note: </k> we're placing everything needed to build the web page on the index_html variable that we use on the Arduino sketch. Note that it may be more practical to have separated HTML, CSS and JavaScript files that then you upload to the ESP32 filesystem and reference them on the code.
Recommended reading: <a href="https://randomnerdtutorials.com/esp32-web-server-spiffs-spi-flash-file-system/">ESP32 Web Server using SPIFFS (SPI Flash File System)</a>
Here's the content of the index_html variable:
<k>&lt;!DOCTYPE HTML>
&lt;html>
&lt;head>
  &lt;title>ESP Web Server&lt;/title>
  &lt;meta name="viewport" content="width=device-width, initial-scale=1">
  &lt;link rel="icon" href="data:,">
  &lt;style>
  html {
    font-family: Arial, Helvetica, sans-serif;
    text-align: center;
  }
  h1 {
    font-size: 1.8rem;
    color: white;
  }
  h2{
    font-size: 1.5rem;
    font-weight: bold;
    color: #143642;
  }
  .topnav {
    overflow: hidden;
    background-color: #143642;
  }
  body {
    margin: 0;
  }
  .content {
    padding: 30px;
    max-width: 600px;
    margin: 0 auto;
  }
  .card {
    background-color: #F8F7F9;;
    box-shadow: 2px 2px 12px 1px rgba(140,140,140,.5);
    padding-top:10px;
    padding-bottom:20px;
  }
  .button {
    padding: 15px 50px;
    font-size: 24px;
    text-align: center;
    outline: none;
    color: #fff;
    background-color: #0f8b8d;
    border: none;
    border-radius: 5px;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-tap-highlight-color: rgba(0,0,0,0);
   }
   .button:active {
     background-color: #0f8b8d;
     box-shadow: 2 2px #CDCDCD;
     transform: translateY(2px);
   }
   .state {
     font-size: 1.5rem;
     color:#8c8c8c;
     font-weight: bold;
   }
  &lt;/style>
&lt;title>ESP Web Server&lt;/title>
&lt;meta name="viewport" content="width=device-width, initial-scale=1">
&lt;link rel="icon" href="data:,">
&lt;/head>
&lt;body>
  &lt;div>
    &lt;h1>ESP WebSocket Server&lt;/h2>
  &lt;/div>
  &lt;div>
    &lt;div>
      &lt;h2>Output - GPIO 2&lt;/h2>
      &lt;p>state: &lt;span>%STATE%&lt;/span>&lt;/p>
      &lt;p>&lt;button>Toggle&lt;/button>&lt;/p>
    &lt;/div>
  &lt;/div>
&lt;script>
  var gateway = `ws://${window.location.hostname}/ws`;
  var websocket;
  function initWebSocket() {
    console.log('Trying to open a WebSocket connection...');
    websocket = new WebSocket(gateway);
    websocket.onopen    = onOpen;
    websocket.onclose   = onClose;
    websocket.onmessage = onMessage; // &lt;-- add this line
  }
  function onOpen(event) {
    console.log('Connection opened');
  }
  function onClose(event) {
    console.log('Connection closed');
    setTimeout(initWebSocket, 2000);
  }
  function onMessage(event) {
    var state;
    if (event.data == "1"){
      state = "ON";
    }
    else{
      state = "OFF";
    }
    document.getElementById('state').innerHTML = state;
  }
  window.addEventListener('load', onLoad);
  function onLoad(event) {
    initWebSocket();
    initButton();
  }
  function initButton() {
    document.getElementById('button').addEventListener('click', toggle);
  }
  function toggle(){
    websocket.send('toggle');
  }
&lt;/script>
&lt;/body>
&lt;/html></k>
<h3>CSS</h3>
Between the &lt;style> &lt;/style> tags we include the styles to style the web page using CSS. Feel free to change it to make the web page look as you wish. We won't explain how the CSS for this web page works because it is not relevant for this WebSocket tutorial.
<k>&lt;style>
  html {
    font-family: Arial, Helvetica, sans-serif;
    text-align: center;
  }
  h1 {
    font-size: 1.8rem;
    color: white;
  }
  h2 {
    font-size: 1.5rem;
    font-weight: bold;
    color: #143642;
  }
  .topnav {
    overflow: hidden;
    background-color: #143642;
  }
  body {
    margin: 0;
  }
  .content {
    padding: 30px;
    max-width: 600px;
    margin: 0 auto;
  }
  .card {
    background-color: #F8F7F9;;
    box-shadow: 2px 2px 12px 1px rgba(140,140,140,.5);
    padding-top:10px;
    padding-bottom:20px;
  }
  .button {
    padding: 15px 50px;
    font-size: 24px;
    text-align: center;
    outline: none;
    color: #fff;
    background-color: #0f8b8d;
    border: none;
    border-radius: 5px;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-tap-highlight-color: rgba(0,0,0,0);
   }
   .button:active {
     background-color: #0f8b8d;
     box-shadow: 2 2px #CDCDCD;
     transform: translateY(2px);
   }
   .state {
     font-size: 1.5rem;
     color:#8c8c8c;
     font-weight: bold;
   }
 &lt;/style></k>
<h3>HTML</h3>
Between the &lt;body> &lt;/body> tags we add the web page content that is visible to the user.
<k>&lt;div>
  &lt;h1>ESP WebSocket Server&lt;/h2>
&lt;/div>
&lt;div>
  &lt;div>
    &lt;h2>Output - GPIO 2&lt;/h2>
    &lt;p>state: &lt;span>%STATE%&lt;/span>&lt;/p>
    &lt;p>&lt;button>Toggle&lt;/button>&lt;/p>
  &lt;/div>
&lt;/div></k>
There's a heading 1 with the text ESP WebSocket Server. Feel free to modify that text.
<k>&lt;h1>ESP WebSocket Server&lt;/h2></k>
Then, there's a heading 2 with the Output  GPIO 2 text.
<k>&lt;h2>Output - GPIO 2&lt;/h2></k>
After that, we have a paragraph that displays the current GPIO state.
<k>&lt;p>state: &lt;span>%STATE%&lt;/span>&lt;/p></k>
The %STATE% is a placeholder for the GPIO state. It will be replaced with the current value by the ESP32 at the time of sending the web page. The placeholders on the HTML text should go between % signs. This means that this %STATE% text is like a variable that will then be replaced with the actual value.
After sending the web page to the client, the state needs to change dynamically whenever there's a change in the GPIO state. We'll receive that information via WebSocket protocol. Then, JavaScript handles what to do with the information received to update the state accordingly. To be able to handle that text using JavaScript, the text must have an id that we can reference. In this case the id is  state ( &lt;span id=state>).
Finally, there's a paragraph with the button to toggle the GPIO state.
<k>&lt;p>&lt;button>Toggle&lt;/button>&lt;/p></k>
Note that we've given an id to the button (
id=button).
<h3>JavaScript  Handling WebSockets</h3>
The JavaScript goes between the &lt;script> &lt;/script> tags. It is responsible for initializing a WebSocket connection with the server as soon the web interface is fully loaded in the browser and handling data exchange through WebSockets.
<k>&lt;script>
  var gateway = `ws://${window.location.hostname}/ws`;
  var websocket;
  function initWebSocket() {
    console.log('Trying to open a WebSocket connection...');
    websocket = new WebSocket(gateway);
    websocket.onopen    = onOpen;
    websocket.onclose   = onClose;
    websocket.onmessage = onMessage; // &lt;-- add this line
  }
  function onOpen(event) {
    console.log('Connection opened');
  }
  function onClose(event) {
    console.log('Connection closed');
    setTimeout(initWebSocket, 2000);
  }
  function onMessage(event) {
    var state;
    if (event.data == "1"){
      state = "ON";
    }
    else{
      state = "OFF";
    }
    document.getElementById('state').innerHTML = state;
  }
  window.addEventListener('load', onLoad);
  function onLoad(event) {
    initWebSocket();
    initButton();
  }
  function initButton() {
    document.getElementById('button').addEventListener('click', toggle);
  }
  function toggle(){
    websocket.send('toggle');
  }
&lt;/script></k>
Let's take a look at how this works.
The gateway is the entry point to the WebSocket interface.
<k>var gateway = `ws://${window.location.hostname}/ws`;</k>
window.location.hostname gets the current page address (the web server IP address).
Create a new global variable called websocket.
<k>var websocket;</k>
Add an event listener that will call the onload function when the web page loads.
<k>window.addEventListener('load', onload);</k>
The onload() function calls the initWebSocket() function to initialize a WebSocket connection with the server and the initButton() function to add event listeners to the buttons.
<k>function onload(event) {
  initWebSocket();
  initButton();
}</k>
The initWebSocket() function initializes a WebSocket connection on the gateway defined earlier. We also assign several callback functions for when the WebSocket connection is opened, closed or when a message is received.
<k>function initWebSocket() {
  console.log('Trying to open a WebSocket connection');
  websocket = new WebSocket(gateway);
  websocket.onopen    = onOpen;
  websocket.onclose   = onClose;
  websocket.onmessage = onMessage;
}</k>
When the connection is opened, we simply print a message in the console and send a message saying hi. The ESP32 receives that message, so we know that the connection was initialized.
<k>function onOpen(event) {
  console.log('Connection opened');
  websocket.send('hi');
}</k>
If for some reason the web socket connection is closed, we call the initWebSocket() function again after 2000 milliseconds (2 seconds).
<k>function onClose(event) {
  console.log('Connection closed');
  setTimeout(initWebSocket, 2000);
} </k>
The setTimeout() method calls a function or evaluates an expression after a specified number of milliseconds.
Finally, we need to handle what happens  when we receive a new message. The server (your ESP board) will either send a 1 or a 0 message. Accordingly to the received message, we want to display an ON or a OFF message on the paragraph that displays the state. Remember that &lt;span> tag with id=state? We'll get that element and set its value to ON or OFF.
<k>function onMessage(event) {
  var state;
  if (event.data == "1"){
    state = "ON";
  }
  else{
    state = "OFF";
  }
  document.getElementById('state').innerHTML = state;
}</k>
The initButton() function gets the button by its id (button) and adds an event listener of type click'.
<k>function initButton() {
  document.getElementById('button').addEventListener('click', toggle);
}</k>
This means that when you click the button, the toggle function is called.
The toggle function sends a message using the WebSocket connection with the toggle' text.
<k>function toggle(){
  websocket.send('toggle');
}</k>
Then, the ESP32 should handle what happens when it receives this message  toggle the current GPIO state.
<h3>Handling WebSockets  Server</h3>
Previously, you've seen how to handle the WebSocket connection on the client side (browser). Now, let's take a look on how to handle it on the server side.
<h4>Notify All Clients</h4>
The notifyClients() function notifies all clients with a message containing whatever you pass as a argument. In this case, we'll want to notify all clients of the current LED state whenever there's a change.
<k>void notifyClients() {
  ws.textAll(String(ledState));
}</k>
The AsyncWebSocket class provides a textAll() method for sending the same message to all clients that are connected to the server at the same time.
<h4>Handle WebSocket Messages</h4>
The handleWebSocketMessage() function is a callback function that will run whenever we receive new data from the clients via WebSocket protocol.
<k>void handleWebSocketMessage(void *arg, uint8_t *data, size_t len) {
  AwsFrameInfo *info = (AwsFrameInfo*)arg;
  if (info->final && info->index == 0 && info->len == len && info->opcode == WS_TEXT) {
    data[len] = 0;
    if (strcmp((char*)data, "toggle") == 0) {
      ledState = !ledState;
      notifyClients();
    }
  }
}</k>
If we receive the toggle message, we toggle the value of the ledState variable. Additionally, we notify all clients by calling the notifyClients() function. This way, all clients are notified of the change and update the interface accordingly.
<k>if (strcmp((char*)data, "toggle") == 0) {
  ledState = !ledState;
  notifyClients();
}</k>
<h4>Configure the WebSocket server</h4>
Now we need to configure an event listener to handle the different asynchronous steps of the WebSocket protocol. This event handler can be implemented by defining the onEvent() as follows:
<k>void onEvent(AsyncWebSocket *server, AsyncWebSocketClient *client, AwsEventType type,
 void *arg, uint8_t *data, size_t len) {
  switch (type) {
    case WS_EVT_CONNECT:
      Serial.printf("WebSocket client #%u connected from %s\n", client->id(), client->remoteIP().toString().c_str());
      break;
    case WS_EVT_DISCONNECT:
      Serial.printf("WebSocket client #%u disconnected\n", client->id());
      break;
    case WS_EVT_DATA:
      handleWebSocketMessage(arg, data, len);
      break;
    case WS_EVT_PONG:
    case WS_EVT_ERROR:
      break;
  }
}</k>
The type argument represents the event that occurs. It can take the following values:
WS_EVT_CONNECT when a client has logged in;
WS_EVT_DISCONNECT when a client has logged out;
WS_EVT_DATA when a data packet is received from the client;
WS_EVT_PONG in response to a ping request;
WS_EVT_ERROR when an error is received from the client.
<h4>Initialize WebSocket</h4>
Finally, the initWebSocket() function initializes the WebSocket protocol.
<k>void initWebSocket() {
  ws.onEvent(onEvent);
  server.addHandler(&ws);
}</k>
<h3>processor()</h3>
The processor() function is responsible for searching for placeholders on the HTML text and replace them with whatever we want before sending the web page to the browser. In our case, we'll replace the %STATE% placeholder with ON if the ledState is 1. Otherwise, replace it with OFF.
<k>String processor(const String& var){
  Serial.println(var);
  if(var == "STATE"){
    if (ledState){
      return "ON";
    }
    else{
      return "OFF";
    }
  }
}</k>
<h3>setup()</h3>
In the setup(), initialize the Serial Monitor for debugging purposes.
<k>Serial.begin(115200);</k>
Set up the ledPin as an OUTPUT and set it to LOW when the program first starts.
<k>pinMode(ledPin, OUTPUT);
digitalWrite(ledPin, LOW);</k>
Initialize Wi-Fi and print the ESP32 IP address on the Serial Monitor.
<k>WiFi.begin(ssid, password);
while (WiFi.status() != WL_CONNECTED) {
  delay(1000);
  Serial.println("Connecting to WiFi..");
}
// Print ESP Local IP Address
Serial.println(WiFi.localIP());</k>
Initialize WebSocket protocol by calling the initWebSocket() function created previously.
<k>initWebSocket();</k>
<h3>Handle Requests</h3>
Serve the text saved on the index_html variable when you receive a request on the root <k>/</k> URL  you need to pass the processor function as an argument to replace the placeholders with the current GPIO state.
<k>server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
  request->send_P(200, "text/html", index_html, processor);
});</k>
Finally, start the server.
<k>server.begin();</k>
<h3>loop()</h3>
The LED will be physically controlled on the loop().
<k>void loop() {
  ws.cleanupClients();
  digitalWrite(ledPin, ledState);
}</k>
Note that we all call the cleanupClients() method. Here's why (explanation from the ESPAsyncWebServer library GitHub page):
Browsers sometimes do not correctly close the WebSocket connection, even when the close() function is called in JavaScript. This will eventually exhaust the web server's resources and will cause the server to crash. Periodically calling the cleanupClients() function from the main loop()limits the number of clients by closing the oldest client when the maximum number of clients has been exceeded. This can be called every cycle, however, if you wish to use less power, then calling as infrequently as once per second is sufficient.
<h3>Demonstration</h3>
After inserting your network credentials on the ssid and password variables, you can upload the code to your board. Don't forget to check if you have the right board and COM port selected.
After uploading the code, open the Serial Monitor at a baud rate of 115200 and press the on-board EN/RST button. The ESP IP address should be printed.
Open a browser on your local network and insert the ESP32 IP address. You should get access to the web page to control the output.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/ESP32-WebSocket-Web-Server-Control-Outputs-Web-Page.png">
Click on the button to toggle the LED. You can open several web browser tabs at the same time or access the web server from different devices and the LED state will be update automatically in all clients whenever there's a change.

<h3>Wrapping Up</h3>
In this tutorial you've learned how to set up a WebSocket server with the ESP32. The WebSocket protocol allows a full duplex communication between the client and the server. After initializing, the server and the client can exchange data at any given time. 
This is very useful because the server can send data to the client whenever something happens. For example, you can add a <a href="https://randomnerdtutorials.com/esp32-esp8266-web-server-physical-button/">physical button</a> to this setup that when pressed notifies all clients to update the web interface. 
In this example, we've shown you how to control one GPIO of the ESP32. You can use this method to control more GPIOs. You can also use the WebSocket protocol to send sensor readings or notifications at any given time.
We hope you've found this tutorial useful. We intend to create more tutorials and examples using the WebSocket protocol. So, stay tuned.
<h2>Getting Started with VS Code and PlatformIO IDE</h2>
Learn how to program the ESP32 and ESP8266 NodeMCU boards using VS Code (Microsoft Visual Studio Code) with PlatformIO IDE extension. We cover how to install the software on Windows, Mac OS X or Ubuntu operating systems.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/Getting-Started-Visual-Studio-VS-Code-PlatformIO-IDE-ESP32-ESP8266-NodeMCU-Windows-Mac-OS-X-Linux-Ubuntu.jpg">
The Arduino IDE works great for small applications. However, for advanced projects with more than 200 lines of code, multiple files, and other advanced features like auto completion and error checking, VS Code with the PlatformIO IDE extension is the best alternative.
In this tutorial, we'll cover the following topics:
Installing VS Code (Visual Studio Code):
A) Windows
B) Mac OS X
C) Linux Ubuntu
Installing PlatformIO IDE Extension on VS Code
Visual Studio Quick Interface Overview
PlatformIO IDE Overview
Uploading Code using PlatformIO IDE: ESP32/ESP8266
Changing the Serial Monitor Baud Rate  PlatformIO IDE
Installing Libraries on PlatformIO IDE
<h3>A) Installing VS Code on Windows (Visual Studio Code)</h3>
Go to <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a> and download the stable build for your operating system (Windows).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/1-Download-VS-Studio-Code.jpg">
Click on the installation wizard to start the installation and follow all the steps to complete the installation. Accept the agreement and press the <k>Next </k>button.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/2-Install-VS-Code.png">
Select the following options and click <k>Next</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/3-Install-VS-Code.png">
Press the <k>Install </k>button.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/4-Install-VS-Code.png">
Finally, click <k>Finish </k>to finish the installation.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/5-Install-VS-Code.png">
Open VS Code and you'll be greeted by a Welcome tab with the released notes of the newest version.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/VS-Code-Welcome-Screen.png">
That's it. Visual Studio Code was successfully installed.
<h3>Installing Python on Windows</h3>
To program the ESP32 and ESP8266 boards with PlatformIO IDE you need Python 3.5 or higher installed in your computer. We're using Python 3.8.5.
Go to <a href="https://python.org/download" target="_blank">python.org/download</a> and download Python 3.8.5 or a newest version.
Open the downloaded file to start the Python installation wizard.
The following window shows up.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/Install-Python-Add-to-path.png">
<k>IMPORTANT: Make sure you check the option Add Python 3.8 to PATH. </k>Then, you can click on the <k>Install Now</k> button.
When the installation is successful you'll get the following message.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/Python-Installation-successful.png">
You can click the <k>Close</k> button.
Now, go to this section to install PlatformIO IDE extension.
<hr>
<h3>B) Installing VS Code on Mac OS X (Visual Studio Code)</h3>
Go to <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a> and download the stable build for your operating system (Mac OS X).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/3-Getting-Started-VS-Code-PlatformIO-IDE-ESP32-ESP8266-download-Mac-OS-X.png">
After downloading the Visual Studio Code application file, you'll be prompted with the following message. Press the <k>Open</k> button.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/5-Getting-Started-VS-Code-PlatformIO-IDE-ESP32-ESP8266-save-file.png">
Or open your Downloads folder and open Visual Studio Code.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/4-Getting-Started-VS-Code-PlatformIO-IDE-ESP32-ESP8266-file-downloaded-Mac-OS-X.png">
After that, you'll be greeted by a Welcome tab with the released notes of the newest version.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/6-Getting-Started-VS-Code-PlatformIO-IDE-ESP32-ESP8266-installed.png">
That's it. Visual Studio Code was successfully installed.
<h3>Installing Python on Mac OS X</h3>
To program the ESP32 and ESP8266 boards with PlatformIO IDE you need Python 3.5 or higher installed in your computer. We're using Python 3.8.5.
To install Python I'll be using Homebrew. If you don't have the brew command available, type the next command:
<k>$ /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)"
</k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/1-Getting-Started-VS-Code-PlatformIO-IDE-ESP32-ESP8266-install-brew.png">
Then, run the  brew command to install Python 3.X:
<k>$ brew install python3</k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/2-Getting-Started-VS-Code-PlatformIO-IDE-ESP32-ESP8266-install-Python3.png">
Now, go to this section to install PlatformIO IDE extension.
<hr>
<h3>C) Installing VS Code on Linux Ubuntu (Visual Studio Code)</h3>
Go to <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a> and download the stable build for your operating system (Linux Ubuntu).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/3-Getting-Started-VS-Code-PlatformIO-IDE-ESP32-ESP8266-downloading-VS-Code-Linux-Ubuntu.png">
Save the installation file:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/4-Getting-Started-VS-Code-PlatformIO-IDE-ESP32-ESP8266-downloading-VS-Code-Linux-Ubuntu.png">
To install it, open a Terminal windows, navigate to your Downloads folder and run the following command to install VS Code.
<k>$ cd Downloads
~/Downloads $ sudo apt install ./code_1.49.1-1600299189_amd64.deb</k>
When the installation is finished, VS Code should be available in your applications menu.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/5-Getting-Started-VS-Code-PlatformIO-IDE-ESP32-ESP8266-run-VS-Code-Linux-Ubuntu.png">
Open VS Code and you'll be greeted by a Welcome tab with the released notes of the newest version.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/6-Getting-Started-VS-Code-PlatformIO-IDE-ESP32-ESP8266-downloading-VS-Code-Linux-Ubuntu-Testing.png">
That's it. Visual Studio Code was successfully installed.
<h3>Installing Python on Linux Ubuntu</h3>
To program the ESP32 and ESP8266 boards with PlatformIO IDE you need Python 3.5 or higher installed in your computer. We're using Python 3.8.
Open the Terminal window and check that you already have Python 3 installed.
<k>$ python3 --version
python 3.8.2
</k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/1-Getting-Started-VS-Code-PlatformIO-IDE-ESP32-ESP8266-Python3-installed.png">
As you can see in the preceding figure, Python 3.8.2 is already installed. 
If you don't have Python 3.8.X installed, run the next command to install it:
<k>$ sudo apt install python3</k>
Whether you already have Python installed or not, you need to run the following command to install Python utilities.
<k>$ sudo apt install python3-distutils</k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/2-Getting-Started-VS-Code-PlatformIO-IDE-ESP32-ESP8266-Python3-installed-distutils.png">
Now, go to this section to install PlatformIO IDE extension.
<hr>
<h3>Installing PlatformIO IDE Extension on VS Code</h3>
It is possible to program the <a href="https://randomnerdtutorials.com/projects-esp32/">ESP32</a> and <a href="https://randomnerdtutorials.com/projects-esp8266/">ESP8266</a> boards using VS Code with the PlatformIO IDE extension. Follow the next steps to install the PlatformIO IDE extension.
Open VS Code:
<ol>
Click on the <k>Extensions </k>icon or press <k>Ctrl</k>+<k>Shift</k>+<k>X</k> to open the <k>Extensions </k>tab
Search for <k>PlatformIO IDE</k>
Select the first option 
Finally, click the <k>Install</k> button (Note: the installation may take a few minutes)
</ol>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/Install-Platformio-Extension-VS-Code.png">
After installing, make sure that PlatformIO IDE extension is enabled as shown below.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/Platformioextension-enabled.png">
After that, the PlatformIO icon should show up on the left sidebar as well as an <k>Home</k> icon that redirects you to PlatformIO home.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/PlatformIO-extension-installed-successfully.png">
That's it, PlatformIO IDE extension was successfully added to VS Code.
If you don't see the <k>PIO </k>icon and the quick tools at the bottom, you may need to restart VS code for the changes to take effect.
Either way, we recommend restarting VS Code before proceeding.
<h3>VS Code Quick Interface Overview</h3>
Open VS Code. The following print screen shows the meaning of each icon on the left sidebar and its shortcuts:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/VS-Code-Interface-Overview.png">
File explorer
Search across files
Source code management (using gist)
Launch and debug your code
Manage extensions
Additionally, you can press <k>Ctrl</k>+<k>Shift</k>+<k>P</k> or go to <k>View </k>><k> Command Palette</k> to show all the available commands. If you're searching for a command and you don't know where it is or its shortcut, you just need to go to the Command Palette and search for it.
At the bottom, there's a blue bar with PlatformIO commands.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/PlatformIO-Quick-Tools-Icons.png">
Here's the what icon does from left to right:
PlatformIO Home
Build/Compile
Upload
Clean
Serial Monitor
New Terminal
If you hover your mouse over the icons, it will show what each icon does.
Alternatively, you can also click on the PIO icon to see all the PlatformIO tasks. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/PlatformIO-Tasks.png">
If the tasks don't show up on your IDE when you click the icon, you may need to click on the three dot icon at the top and enable PlatformIO tasks as shown below.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/Enable-PlatformIO-Tasks.png">
<h3>PlatformIO IDE Overview</h3>
For you to get an overview on how PlatformIO works on VS code, we'll show you how to create, save and upload a Blinking LED sketch to your ESP32 or ESP8266 board.
<h3>Create a New Project</h3>
On VS Code, click on the PlartfomIO <k>Home </k>icon. Click on <k>+ New Project</k> to start a new project.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/PlatformIO-Create-New-Project.png">
Give your project a name (for example <em>Blink_LED</em>) and select the board you're using. In our case, we're using the <k><a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">DOIT ESP32 DEVKIT V1</a></k>. The Framework should be <k>Arduino</k> to use the Arduino core. 
You can choose the default location to save your project or a custom location.
The default location is in this path <em>Documents </em>><em>PlatformIO</em> ><em>Projects</em>. For this test, you can use the default location. Finally, click Finish.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/PlatformIO-Create-New-Project-ESP32.png">
For this example, we'll be using the <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">DOIT ESP32 DEVKIT board</a>. If you are using an <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP8266 NodeMCU board</a> the process is very similar, you just need to select your ESP8266 board:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/PlatformIO-Create-New-Project-ESP8266.png">
The Blink_LED project should be accessible from the Explorer tab.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/PlatfomIO-project-created-folder-structure.png">
VS Code and PlatformIO have a folder structure that is different from the standard <em>.ino</em> project. If you click on the Explorer tab, you'll see all the files it created under your project folder. It may seem a lot of files to work with. But, don't worry, usually you'll just need to deal with one or two of those files.
<k>Warning: </k> you shouldn't delete, modify or move the folders and the <em>platformio.ini</em> file. Otherwise, you will no longer be able to compile your project using PlatformIO.
<h3>platformio.ini file</h3>
The <em>platformio.ini</em> file is the PlatformIO Configuration File for your project. It shows the platform, board, and framework for your project. You can also add other configurations like libraries to be included, upload options, changing the Serial Monitor baud rate and other configurations.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/PlatformIO-Config-init-file-ESP32.png">
<k>platform</k>: which corresponds to the SoC used by the board.
<k>board</k>: the development board you're using.
<k>framework</k>: the software environment that will run the project code.
With the ESP32 and ESP8266, if you want to use a baud rate of 115200 in your Serial Monitor, you just need to add the following line to your <em>platformio.ini</em> file.
<k>monitor_speed = 115200</k>
After that, make sure you save the changes made to the file by pressing <k>Ctrl</k>+<k>S</k>.
In this file, you can also include the identifier of libraries you'll use in your project using the lib_deps directive, as we'll see later.
<h3>src folder</h3>
The <em>src </em>folder is your working folder. Under the <em>src </em>folder, there's a<em> main.cpp</em> file. That's where you write your code. Click on that file. The structure of an Arduino program should open with the setup() and loop() functions.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/PlatformIO-scr-folder-main-file.png">
In PlatformIO, all your Arduino sketches should start with the #include &lt;Arduino.h>.
<h3>Uploading Code using PlatformIO IDE: ESP32/ESP8266</h3>
Copy the following code to your <em>main.cpp</em> file. 
<k>/*********
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/vs-code-platformio-ide-esp32-esp8266-arduino/
*********/
#include &lt;Arduino.h>
#define LED 2
void setup() {
  // put your setup code here, to run once:
  Serial.begin(115200);
  pinMode(LED, OUTPUT);
}
void loop() {
  // put your main code here, to run repeatedly:
  digitalWrite(LED, HIGH);
  Serial.println("LED is on");
  delay(1000);
  digitalWrite(LED, LOW);
  Serial.println("LED is off");
  delay(1000);
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_Blink_VS_Code.ino" target="_blank">View raw code</a>
This code blinks the on-board LED every second. It works with the ESP32 and ESP8266 boards (both have the on-board LED connected to GPIO 2). 
We recommend that you copy this code manually, so that you see the autocompletion and other interesting features of the IDE in action. Additionally, if you have a syntax error somewhere in your program, it will underline it in red even before compiling.
After that, press <k>Ctrl</k>+<k>S</k> or go to <k>File </k>> <k>Save </k>to save the file.
Now, you can click on the Upload icon to compile and upload the code. Alternatively, you can go to the PIO Project Tasks menu and select <k>Upload</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/Upload-Code-ESP32-PlatformIO-VS-Code.png">
If the code is successfully uploaded, you should get the following message.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/Upload-Code-ESP32-PlatformIO-VS-Code-Success.png">
After uploading the code, the ESP32 or ESP8266 should be blinking its on-board LED every second.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-board-Built_in-LED-turned-on-HIGH.jpg">
Now, click on the Serial Monitor icon and you should see it printing the current LED state.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/Platformio-VS-Code-Serial-Monitor-ESP32.png">
<k>Note: </k> if you don't see the Terminal window, go to the menu Terminal >  New Terminal.
<h3>Detect COM Port</h3>
PlatformIO will automatically detect the port your board is connected to. To check the connected devices you can go to the <k>PIO Home</k> and click the <k>Devices </k>icon.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/PlatformIO-VS-Code-Devices-COM-port.png">
<h3>Troubleshooting</h3>
If when trying to upload code you get the following error: F<em>ailed to connect to ESP32: Timed out waiting for packet header</em> it usually means that your board is not in flashing mode when you're uploading the code. 
When this happens you need to press the ESP32 on-board BOOT button when you start seeing a lot of dots in the debugging window.
If you don't want to have to press the BOOT button every time you upload new code, you can follow this guide: <a href="https://randomnerdtutorials.com/solved-failed-to-connect-to-esp32-timed-out-waiting-for-packet-header/">[SOLVED] Failed to connect to ESP32: Timed out waiting for packet header.</a>
<h3>Changing the Serial Monitor Baud Rate  PlatformIO IDE</h3>
The default baud rate used by PlatformIO is 9600. However, it is possible to set up a different value as mentioned previously. On the File Explorer, under your project folder, open the <em>platformio.ini</em> file and add the following line:
<k>monitor_speed = baud_rate</k>
For example:
<k>monitor_speed = 115200</k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/PlatformIO-change-serial-monitor-baud-rate.png">
After that, save that file.
<h3>Installing ESP32/ESP8266 Libraries on PlatformIO IDE</h3>
Follow the next procedure if you need to install libraries in PlatformIO IDE.
Click the <k>Home </k>icon to go to PlatformIO Home. Click on the <k>Libraries </k>icon on the left side bar.
Search for the library you want to install. For example <em>Adafruit_BME280</em>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/PlatformIO-VS-Code-Search-BME280-library.png">
Click on the library you want to include in your project. Then, click <k>Add to Project</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/PlatformIO-add-library-to-project.png">
Select the project were you want to use the library.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/PlatformIO-VS-Code-Add-Library-to-Project-Choose-Project.png">
This will add the library identifier using the lib_deps directive on the <em>platformio.ini</em> file. If you open your project's <em>platformio.ini</em> file, it should look as shown in the following image.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/PIO-Configuration-File-Add-Library.png">
Alternatively, on the library window, if you select the <k>Installation </k>tab and scroll a bit, you'll see the identifier for the library. You can choose any of those identifiers depending on the options you want to use. The library identifiers are highlighted in red.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/PlatformIO-Library-registry.png">
Then, go to the <em>platformio.ini</em> file of your project and paste the library identifier into that file, like this:
<k>lib_deps = adafruit/Adafruit BME280 Library@^2.1.0</k>
If you need multiple libraries, you can separate their name by a coma or put them on different lines. For example:
<k>lib_deps =
  arduino-libraries/Arduino_JSON @ 0.1.0
  adafruit/Adafruit BME280 Library @ ^2.1.0
  adafruit/Adafruit Unified Sensor @ ^1.1.4</k>
PlatformIO has a built-in powerful Library Manager, that allows you to specify custom dependencies per project in the Project Configuration File <em>platformio.ini</em> using  lib_deps. This will tell PlatformIO to automatically download the library and all its dependencies when you save the configuration file or when you compile your project.
<h3>Open a Project Folder</h3>
To open an existing project folder on PlatformIO, open VS Code, go to PlatformIO Home and click on <k>Open Project</k>. Navigate through the files and select your project folder.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/PlatformIO-open-project-folder.png">
PlatformIO will open all the files within the project folder.
<h3>VS Code Color Themes</h3>
VS Code lets you choose between different color themes. Go to the <k>Manage</k> icon and select <k>Color Theme</k>. You can then select from several different light and dark themes.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/VS-Code-Change-Color-Theme.png">
<h3>Shortcuts' List</h3>
For a complete list of VS Code shortcuts for Windows, Mac OS X or Linux, check the next link: 
<a href="https://code.visualstudio.com/docs/getstarted/keybindings#_keyboard-shortcuts-reference" target="_blank">VS Code Keyboard Shortcuts Reference</a>.
<h3>Wrapping Up</h3>
In this tutorial you've learned how to install and prepare Visual Studio Code to work with the ESP32 and ESP8266 boards. VS Code with the PlatformIO IDE extension is a great alternative to the classical Arduino IDE, especially when you're working on more advanced sketches for larger applications.
Here's some of the advantages of using VS Code with PlatformIO IDE over Arduino IDE: 
It detects the COM port your board is connected to automatically; 
VS Code IntelliSense: Auto-Complete. IntelliSense code completion tries to guess what you want to write, displaying the different possibilities and provides insight into the parameters that a function may expect;
Error Highlights: VS Code + PIO underlines errors in your code before compiling;
Multiple open tabs: you can have several code tabs open at once;
You can hide certain parts of the code;
Advanced code navigation;
And much more
If you're looking for a more advanced IDE to write your applications for the ESP32 and ESP8266 boards, VS Code with the PlatformIO IDE extension is a great option.
We hope you've found this tutorial useful. If you like ESP32 and ESP8266, check the following resources:
<a href="https://randomnerdtutorials.com/esp32-cam-projects-ebook/">Learn ESP32 with Arduino IDE (eBook + course)</a>
<a href="https://randomnerdtutorials.com/home-automation-using-esp8266/">Home Automation using ESP8266 (eBook)</a>
<a href="https://randomnerdtutorials.com/projects-esp32/">More ESP32 Projects and Tutorials</a>
<a href="https://randomnerdtutorials.com/projects-esp8266/">More ESP8266 Projects and Tutorials</a>
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/smart-home-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px-pupj8i6e7hlzpgwxe82jjd8skst9vmrjt9lpqb0v0g.jpg" title="Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px" alt="SMART HOME with Raspberry Pi ESP32 and ESP8266 Node-RED InfluxDB eBook" loading="lazy" width="117" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/smart-home-ebook/">SMART HOME with Raspberry Pi, ESP32, ESP8266 [eBook] </a></h4>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>Telegram Group: Control ESP32/ESP8266 Outputs (Arduino IDE)</h2>
This tutorial shows how to control your ESP32 or ESP8266 boards through a Telegram group. Using a Telegram group to control your boards may be useful if you want to have several people interacting with a bot on the same chat and you want all those people to get notifications from the bot.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/ESP_Telegram_output_Group.jpg">
We have other tutorials about Telegram that we recommend reading:
<a href="Telegram:%20Control%20ESP32/ESP8266%20Outputs%20(Arduino%20IDE)">Control ESP32/ESP8266 Outputs using Telegram (Arduino IDE)</a>
<a href="https://randomnerdtutorials.com/telegram-request-esp32-esp8266-nodemcu-sensor-readings/">Request ESP32/ESP8266 Sensor Readings using Telegram (Arduino IDE)</a>
<a href="https://randomnerdtutorials.com/telegram-esp32-motion-detection-arduino/">ESP32 Motion Detection with Notifications using Telegram (Arduino IDE)</a>
<a href="https://randomnerdtutorials.com/telegram-esp8266-nodemcu-motion-detection-arduino/">ESP8266 NodeMCU Motion Detection with Notifications (Arduino IDE)</a>
<h3>Project Overview</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/08/Control-ESP32-ESP8266-NodeMCU-with-Telegram-Group-Arduino-IDE.jpg">
In this tutorial you'll create a telegram bot to interact with the ESP32 or ESP8266 boards;
You'll create a group where you can add several people you want to have control and receive notifications from the bot;
The bot will be added to the group so that the members can interact with it;
As an example, we'll show you how to send commands to control outputs and how to send responses from the bot to the group.
<h3>Introducing Telegram</h3>
<a href="https://telegram.org/" target="_blank">Telegram</a> Messenger is a cloud-based instant messaging and voice over IP service. You can easily install it in your smartphone (Android and iPhone) or computer (PC, Mac and Linux). It is free and without any ads. Telegram allows you to create bots that you can interact with.
<em>Bots are third-party applications that run inside Telegram. Users can interact with bots by sending them messages, commands and inline requests. You control your bots using HTTPS requests to Telegram Bot API</em>.
The ESP32/ESP8266 will interact with the Telegram bot to receive and handle the messages, and send responses to the Telegram group. 
<h3>Install Telegram</h3>
Go to Google Play or App Store, download and install <k>Telegram</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Install-Telegram.png">
<h3>Creating a Telegram Bot</h3>
The following steps are easier to follow on your computer. Open a browser, go to the <a href="https://web.telegram.org/" target="_blank">Telegram Web App</a> and login into your account.
If you've followed previous projects and you already have a telegram bot, you can skip this section.
On the top left corner, search for <k>botfather</k> and click the BotFather as shown below.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/08/search-botfather-telegram-web-app.png">
A new window should open and you'll be prompted to click the <k>start</k> button. Type <k>/newbot</k> and follow the instructions to create your bot. Give it a name and username.
If your bot is successfully created, you'll receive a message with a link to access the bot and the <k>bot token</k>. Save the bot token because you'll need it so that the ESP32/ESP8266 can interact with the bot.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/08/Telegram-Web-App-Create-bot-botfather.png">
<h3>Creating a Telegram Group</h3>
The next step is creating the Telegram group. On the top left corner, click on <k>New group</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/08/Create-a-new-group-web-telegram-app.png">
Add members to your group and give it a name.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/08/Name-group-Telegram.png">
<h3>Add the Bot to the Group</h3>
Once the group is created, click on the group name to add your bot. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/08/Add-new-member-group-telegram.png">
Search for your bot name and add it to the group.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/Add-bot-to-telegram-group-f.png">
<h3>Get the Group ID</h3>
To interact with the Telegram group, the ESP32 needs to know the telegram group ID. In you Telegram account, open your group. The group ID should be on the URL as shown below.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/08/Telegram-Group-ID.png">
Save the group ID because you'll need it later.
<h3>Preparing Arduino IDE</h3>
We'll program the <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> and <a href="https://makeradvisor.com/tools/esp8266-esp-12e-nodemcu-wi-fi-development-board/" target="_blank">ESP8266</a> boards using Arduino IDE, so make sure you have them installed in your Arduino IDE.
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<a href="https://randomnerdtutorials.com/how-to-install-esp8266-board-arduino-ide/">Installing ESP8266 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<h3>Universal Telegram Bot Library</h3>
To interact with the Telegram bot, we'll use the <a href="https://github.com/witnessmenow/Universal-Arduino-Telegram-Bot" target="_blank">Universal Telegram Bot Library</a> created by Brian Lough that provides an easy interface for the Telegram Bot API.
Follow the next steps to install the latest release of the library.
<ol>
<a href="https://github.com/witnessmenow/Universal-Arduino-Telegram-Bot/archive/master.zip" target="_blank">Click here to download the Universal Arduino Telegram Bot library</a>.
Go to <k>Sketch </k>> <k>Include Library</k> > <k>Add.ZIP Library..</k>.
Add the library you've just downloaded.
</ol>
And that's it. The library is installed.
<k>Important: </k> don't install the library through the Arduino Library Manager because it might install a deprecated version.
For all the details about the library, take a look at the Universal Arduino Telegram Bot Library <a href="https://github.com/witnessmenow/Universal-Arduino-Telegram-Bot" target="_blank">GitHub</a> page.
<h3>ArduinoJson Library</h3>
You also have to install the <a href="https://github.com/bblanchon" target="_blank">ArduinoJson</a> library. Follow the next steps to install the library.
<ol>
Go to <k>Skech </k>> <k>Include Library</k> > <k>Manage Libraries</k>.
Search for ArduinoJson.
Install the library.
</ol>
We're using ArduinoJson library version 6.15.2.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Install-ArduinoJson-Library.png">
<h3>Parts Required</h3>
For this example you just need one ESP32 or an ESP8266 board.
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32 board</a> (read <a href="https://makeradvisor.com/esp32-development-boards-review-comparison/" target="_blank">Best ESP32 dev boards</a>)
Alternative  <a href="https://makeradvisor.com/tools/esp8266-esp-12e-nodemcu-wi-fi-development-board/" target="_blank">ESP8266 board</a> (read <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">Best ESP8266 dev boards</a>)
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="lazy" fetchpriority="low"></a>
<h3>Control ESP32/ESP8266 using Telegram Group  Sketch</h3>
The following code allows you to control your ESP32 or ESP8266 NodeMCU GPIOs by sending messages to a group where your Telegram Bot is a member.
To make this sketch work for you, you need to insert your network credentials (SSID and password), the Telegram Bot Token and your Telegram Group ID.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/telegram-group-esp32-esp8266/
  
  Project created using Brian Lough's Universal Telegram Bot Library: https://github.com/witnessmenow/Universal-Arduino-Telegram-Bot
*/
#ifdef ESP32
  #include &lt;WiFi.h>
#else
  #include &lt;ESP8266WiFi.h>
#endif
#include &lt;WiFiClientSecure.h>
#include &lt;UniversalTelegramBot.h>   // Universal Telegram Bot Library written by Brian Lough: https://github.com/witnessmenow/Universal-Arduino-Telegram-Bot
#include &lt;ArduinoJson.h>
// Replace with your network credentials
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
// Initialize Telegram BOT
#define BOTtoken "XXXXXXXXXX:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"  // your Bot Token (Get from Botfather)
// Use @myidbot to find out the chat ID of an individual or a group
// Also note that you need to click "start" on a bot before it can
// message you
#define CHAT_ID "-XXXXXXXXXX"
#ifdef ESP8266
  X509List cert(TELEGRAM_CERTIFICATE_ROOT);
#endif
WiFiClientSecure client;
UniversalTelegramBot bot(BOTtoken, client);
// Checks for new messages every 1 second.
int botRequestDelay = 1000;
unsigned long lastTimeBotRan;
const int ledPin = 2;
bool ledState = LOW;
// Handle what happens when you receive new messages
void handleNewMessages(int numNewMessages) {
  Serial.println("handleNewMessages");
  Serial.println(String(numNewMessages));
  for (int i=0; i&lt;numNewMessages; i++) {
    // Chat id of the requester
    String chat_id = String(bot.messages[i].chat_id);
    if (chat_id != CHAT_ID){
      bot.sendMessage(chat_id, "Unauthorized user", "");
      continue;
    }
    
    // Print the received message
    String text = bot.messages[i].text;
    Serial.println(text);
    String from_name = bot.messages[i].from_name;
    if (text == "/led_on") {
      bot.sendMessage(chat_id, "LED state set to ON", "");
      ledState = HIGH;
      digitalWrite(ledPin, ledState);
    }
    
    if (text == "/led_off") {
      bot.sendMessage(chat_id, "LED state set to OFF", "");
      ledState = LOW;
      digitalWrite(ledPin, ledState);
    }
    
    if (text == "/state") {
      if (digitalRead(ledPin)){
        bot.sendMessage(chat_id, "LED is ON", "");
      }
      else{
        bot.sendMessage(chat_id, "LED is OFF", "");
      }
    }
  }
}
void setup() {
  Serial.begin(115200);
  #ifdef ESP8266
    configTime(0, 0, "pool.ntp.org");      // get UTC time via NTP
    client.setTrustAnchors(&cert); // Add root certificate for api.telegram.org
  #endif
  pinMode(ledPin, OUTPUT);
  digitalWrite(ledPin, ledState);
  
  // Connect to Wi-Fi
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  #ifdef ESP32
    client.setCACert(TELEGRAM_CERTIFICATE_ROOT); // Add root certificate for api.telegram.org
  #endif
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi..");
  }
  // Print ESP32 Local IP Address
  Serial.println(WiFi.localIP());
  bot.sendMessage(CHAT_ID, "Bot Started", "");
}
void loop() {
  if (millis() > lastTimeBotRan + botRequestDelay) {
    int numNewMessages = bot.getUpdates(bot.last_message_received + 1);
    while(numNewMessages) {
      Serial.println("got response");
      handleNewMessages(numNewMessages);
      numNewMessages = bot.getUpdates(bot.last_message_received + 1);
    }
    lastTimeBotRan = millis();
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_Telegram/ESP_Telegram_Group.ino" target="_blank">View raw code</a>
The code is compatible with ESP32 and ESP8266 NodeMCU boards (it's based on the Universal Arduino Telegram Bot library <a href="https://github.com/witnessmenow/Universal-Arduino-Telegram-Bot/blob/master/examples/ESP8266/FlashLED/FlashLED.ino" target="_blank">example</a>). The code will load the right libraries accordingly to the selected board.
<h3>How the Code Works</h3>
Start by importing the required libraries.
<k>#ifdef ESP32
  #include &lt;WiFi.h>
#else
  #include &lt;ESP8266WiFi.h>
#endif
#include &lt;WiFiClientSecure.h>
#include &lt;UniversalTelegramBot.h>
#include &lt;ArduinoJson.h></k>
<h3>Network Credentials</h3>
Insert your network credentials in the following variables.
<k>const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h3>Telegram Bot Token</h3>
Insert your Telegram Bot token you've got from Botfather on the BOTtoken variable.
<k>#define BOTtoken "XXXXXXXXXX:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"  // your Bot Token (Get from Botfather)</k>
<h3>Telegram Group ID</h3>
Insert your Telegram group ID. It should start with a - signal.
<k>#define CHAT_ID "-XXXXXXXXXX"</k>
Create a new WiFi client with WiFiClientSecure.
<k>WiFiClientSecure client;</k>
Create a bot with the token and client defined earlier.
<k>UniversalTelegramBot bot(BOTtoken, client);</k>
The botRequestDelay and lastTimeBotRan are used to check for new Telegram messages every x number of seconds. In this case, the code will check for new messages every second (1000 milliseconds). You can change that delay time in the botRequestDelay variable. 
<k>int botRequestDelay = 1000;
unsigned long lastTimeBotRan;</k>
<h3>Define Output</h3>
Set the GPIO you want to control. In our case, we'll control GPIO 2 (built-in LED) and its state is LOW by default.
<k>const int ledPin = 2;
bool ledState = LOW;</k>
<k>Note: </k> if you're using an ESP8266, the built-in LED works with inverted logic. So, you should send a LOW signal to turn the LED on and a HIGH signal to turn it off.
<h3>handleNewMessages()</h3>
The handleNewMessages() function handles what happens when new messages arrive.
<k>void handleNewMessages(int numNewMessages) {
  Serial.println("handleNewMessages");
  Serial.println(String(numNewMessages));</k>
It checks the available messages:
<k>for (int i=0; i&lt;numNewMessages; i++) {</k>
Get the chat ID for that particular message and store it in the chat_id variable. The chat ID allows us to identify who sent the message. 
<k>String chat_id = String(bot.messages[i].chat_id);</k>
If the chat_id is different from your chat group ID (CHAT_ID), it means that someone (that is not in the group) has sent a message to your bot. If that's the case, ignore the message and wait for the next message.
<k>if (chat_id != CHAT_ID) {
  bot.sendMessage(chat_id, "Unauthorized user", "");
  continue;
}</k>
Otherwise, it means that the message was sent from someone in your group, so we'll save it in the text variable and check its content.
<k>String text = bot.messages[i].text;
Serial.println(text);</k>
The from_name variable saves the name of the sender.
<k>String from_name = bot.messages[i].from_name;</k>
If it receives the<k> /led_on</k> message, turn the LED on and send a message confirming we've received the message. Also, update the ledState variable with the new state.
<k>if (text == "/led_on") {
  bot.sendMessage(chat_id, "LED state set to ON", "");
  ledState = HIGH;
  digitalWrite(ledPin, ledState);
}</k>
Sending a message to the bot is very simply. You just need to use the sendMessage() method on the bot object and pass as arguments the recipient's chat ID, the message, and the parse mode.
<k>bool sendMessage(String chat_id, String text, String parse_mode = "")</k>
Do something similar for the <k>/led_off</k> message.
<k>if (text == "/led_off") {
  bot.sendMessage(chat_id, "LED state set to OFF", "");
  ledState = LOW;
  digitalWrite(ledPin, ledState);
}</k>
<k>Note: </k> if you're using an ESP8266, the built-in LED works with inverted logic. So, you should send a LOW signal to turn the LED on and a HIGH signal to turn it off.
Finally, if the received message is <k>/state,</k> check the current GPIO state and send a message accordingly.
<k>if (text == "/state") {
  if (digitalRead(ledPin)){
    bot.sendMessage(chat_id, "LED is ON", "");
  }
  else{
    bot.sendMessage(chat_id, "LED is OFF", "");
  }
}</k>
<h3>setup()</h3>
In the setup(), initialize the Serial Monitor.
<k>Serial.begin(115200);</k>
If you're using the ESP8266, you need to use the following line:
<k>#ifdef ESP8266
  client.setInsecure();
#endif</k>
In the library examples for the ESP8266 they say: <em>This is the simplest way of getting this working. If you are passing sensitive information, or controlling something important, please either use certStore or at least client.setFingerPrint</em>.
Set the LED as an output and set it to LOW when the ESP first starts:
<k>pinMode(ledPin, OUTPUT);
digitalWrite(ledPin, ledState);</k>
<h4>Init Wi-Fi</h4>
Initialize Wi-Fi and connect the ESP to your local network with the SSID and password defined earlier.
<k>WiFi.mode(WIFI_STA);
WiFi.begin(ssid, password);
while (WiFi.status() != WL_CONNECTED) {
  delay(1000);
  Serial.println("Connecting to WiFi..");
}</k>
<h3>loop()</h3>
In the loop(), check for new messages every second.
<k>void loop() {
  if (millis() > lastTimeBotRan + botRequestDelay)  {
    int numNewMessages = bot.getUpdates(bot.last_message_received + 1);
    while(numNewMessages) {
      Serial.println("got response");
      handleNewMessages(numNewMessages);
      numNewMessages = bot.getUpdates(bot.last_message_received + 1);
    }
    lastTimeBotRan = millis();
  }
}</k>
When a new message arrives, call the handleNewMessages() function.
<k>while(numNewMessages) {
  Serial.println("got response");
  handleNewMessages(numNewMessages);
  numNewMessages = bot.getUpdates(bot.last_message_received + 1);
}</k>
That's pretty much how the code works.
<h3>Demonstration</h3>
Upload the code to your ESP32 or ESP8266 board. Don't forget to go to <k>Tools </k>> <k>Board </k>and select the board you're using. Go to <k>Tools </k>> <k>Port </k>and select the COM port your board is connected to.
After uploading the code, press the ESP32/ESP8266 on-board EN/RST button so that it starts running the code. Then, you can open the Serial Monitor to check what's happening in the background.
Go to your Telegram account and open the group.
 Send the following commands and see the bot responding:
<k>/led_on</k> turns the LED on.
<k>/led_off</k> turns the LED off.
<k>/state</k> requests the current LED state.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/08/Control-ESP32-ESP8266-Telegram-Group.png">
The on-board LED should turn on and turn off accordingly (the ESP8266 on-board LED works in reverse, it's off when you send <k>/led_on</k> and on when you send<k> /led_off</k>).
When you add your telegram bot to a group, everyone in the group can interact with the bot and receive messages from the bot. For example, in this case we can both (Sara and Rui) control the bot and see the commands that the other is sending. Additionally, in a project with notifications, we'd both be notified on the group. 
You can add more people to the group, for example all family members.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-board-Built_in-LED-turned-on-HIGH.jpg">
On the Serial Monitor you should see that the ESP is receiving the messages.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Control-ESP32-ESP8266-Outputs-Telegram-1.png">
<h3>Wrapping Up</h3>
In this tutorial you've learned how to get and send messages to the ESP32 or ESP8266 using a Telegram group. Using a Telegram group to control your ESP32 might be advantageous over a single chat, if you want to have several people able to control and monitor the same board. 
We've shown you a simple example on how to control an output. The idea is to modify the project to add more commands to execute other tasks. For example, you can <a href="https://randomnerdtutorials.com/telegram-request-esp32-esp8266-nodemcu-sensor-readings/">request sensor readings</a> or <a href="https://randomnerdtutorials.com/telegram-esp32-motion-detection-arduino/">send a telegram message when motion is detected</a>.
The great thing about using Telegram to control your ESP boards, is that as long as you have an internet connection (and your boards too), you can control and monitor them from anywhere in the world.
We hope you've found this project interesting. 
Learn more about the ESP32 and ESP8266 with our resources:
<a href="https://randomnerdtutorials.com/learn-esp32-with-arduino-ide/">Learn ESP32 with Arduino IDE (eBook + Video Course)</a>
<a href="https://randomnerdtutorials.com/home-automation-using-esp8266/">Home Automation using ESP8266</a>
<a href="https://randomnerdtutorials.com/projects-esp32/">More ESP32 projects and tutorials</a>
<a href="https://randomnerdtutorials.com/projects-esp8266/">More ESP8266 projects and tutorials</a>
Thanks for reading.
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h-p2lw6wwnkk9ystvwe9iof8zx6yt4x7uma3cqfup534.jpg" title="Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h" alt="Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h" loading="lazy" width="129" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/">[eBook] Build Web Servers with ESP32 and ESP8266 (2nd Edition)</a></h4>
Build Web Server projects with the ESP32 and ESP8266 boards to control outputs and monitor sensors remotely. Learn HTML, CSS, JavaScript and client-server communication protocols <k><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Build Web Server projects with the ESP32 and ESP8266 boards to control outputs and monitor sensors remotely. Learn HTML, CSS, JavaScript and client-server communication protocols <k><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>Telegram: ESP32-CAM Take and Send Photo (Arduino IDE)</h2>
In this tutorial, you'll create a Telegram bot to interact with the ESP32-CAM to request a new photo. You can request a new photo using your Telegram account from anywhere. You just need to have access to the internet on your smartphone.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/08/ESP32-CAM-Telegram-Picture.jpg">
<k>Note: </k> this project is compatible with any ESP32 Camera Board with the OV2640 camera. You just need to make sure you use the right <a href="https://randomnerdtutorials.com/esp32-cam-ai-thinker-pinout/">pinout for the board</a> you're using.
<em>Updated 19 September 2023.</em>
<h3>Project Overview</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/08/ESP32-CAM-Take-Send-Photo-Telegram-Project-Overview.jpg">
Here's an overview of the project you'll build:
You'll create a Telegram bot for your ESP32-CAM;
You can start a conversation with the ESP32-CAM bot;
When you send the message <k>/photo</k> to the ESP32-CAM bot, the ESP32-CAM board receives the message, takes a new photo, and responds with that photo;
You can send the message <k>/flash</k> to toggle the ESP32-CAM's LED flash;
You can send the <k>/start</k> message to receive a welcome message with the commands to control the board;
The ESP32-CAM will only respond to messages coming from your Telegram account ID.
This is a simple project but shows how you can use Telegram in your IoT and Home Automation projects. The idea is to apply the concepts learned in your own projects.

<h2>ESP32 Web Server with Slider: Control LED Brightness (PWM)</h2>
This tutorial shows how to build an ESP32 web server with a slider to control the LED brightness. You'll learn how to add a slider to your web server projects, get its value and save it in a variable that the ESP32 can use. We'll use that value to control the duty cycle of a <a href="https://randomnerdtutorials.com/esp32-pwm-arduino-ide/">PWM signal</a> and change the brightness of an LED. Instead of an LED you can control a servo motor, for example.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/08/ESP32-Slider-Web-Server-Control-LED-Brightness-PWM.jpg">
Additionally, you can also modify the code in this tutorial to add slider to <a href="https://randomnerdtutorials.com/projects-esp32/">your projects</a> to set a threshold value or any other value that you need to use in your code.
<h3>Project Overview</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/08/ESP32-ESP8266-Slider-Web-Server-Control-LED-Brightness.png">
The ESP32 hosts a web server that displays a web page with a slider;
When you move the slider, you make an HTTP request to the ESP32 with the new slider value;
The HTTP request comes in the following format: GET/slider?value=SLIDERVALUE, in which SLIDERVALUE is a number between 0 and 255. You can modify your slider to include any other range;
From the HTTP request, the ESP32 gets the current value of the slider;
The ESP32 adjusts the PWM duty cycle accordingly to the slider value;
This can be useful to control the brightness of an LED (as we'll do in this example), a servo motor, setting up a threshold value or other applications.
<h3>Prerequisites</h3>
Before proceeding with this project, make sure you check the following prerequisites.
<h3>Arduino IDE</h3>
We'll program the ESP32 boards using Arduino IDE, so before proceeding with this tutorial, make sure you have the ESP32 board installed in your Arduino IDE.
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing ESP32 Board in Arduino IDE (Windows, Mac OS X, and Linux)</a>
<h3>Async Web Server Libraries</h3>
We'll build the web server using the following libraries:
<a href="https://github.com/me-no-dev/ESPAsyncWebServer" target="_blank">ESPAsyncWebServer</a> 
<a href="https://github.com/me-no-dev/AsyncTCP" target="_blank">AsyncTCP</a>
These libraries aren't available to install through the Arduino Library Manager, so you need to copy the library files to the Arduino Installation Libraries folder. Alternatively, in your Arduino IDE, you can go to <k>Sketch </k>> <k>Include Library</k> > <k>Add .zip Library</k> and select the libraries you've just downloaded.
<h3>Code</h3>
The following code controls the brightness of the ESP32 built-in LED using a slider on a web server. In other words, you can change the PWM duty cycle with a slider. This can be useful to control the LED brightness or control a servo motor, for example.
Copy the code to your Arduino IDE. Insert your network credentials and the code will work straight way.
<k>/*********
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-web-server-slider-pwm/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*********/
// Import required libraries
#include &lt;WiFi.h>
#include &lt;AsyncTCP.h>
#include &lt;ESPAsyncWebServer.h>
// Replace with your network credentials
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
const int output = 2;
String sliderValue = "0";
// setting PWM properties
const int freq = 5000;
const int ledChannel = 0;
const int resolution = 8;
const char* PARAM_INPUT = "value";
// Create AsyncWebServer object on port 80
AsyncWebServer server(80);
const char index_html[] PROGMEM = R"rawliteral(
&lt;!DOCTYPE HTML>&lt;html>
&lt;head>
  &lt;meta name="viewport" content="width=device-width, initial-scale=1">
  &lt;title>ESP Web Server&lt;/title>
  &lt;style>
    html {font-family: Arial; display: inline-block; text-align: center;}
    h2 {font-size: 2.3rem;}
    p {font-size: 1.9rem;}
    body {max-width: 400px; margin:0px auto; padding-bottom: 25px;}
    .slider { -webkit-appearance: none; margin: 14px; width: 360px; height: 25px; background: #FFD65C;
      outline: none; -webkit-transition: .2s; transition: opacity .2s;}
    .slider::-webkit-slider-thumb {-webkit-appearance: none; appearance: none; width: 35px; height: 35px; background: #003249; cursor: pointer;}
    .slider::-moz-range-thumb { width: 35px; height: 35px; background: #003249; cursor: pointer; } 
  &lt;/style>
&lt;/head>
&lt;body>
  &lt;h2>ESP Web Server&lt;/h2>
  &lt;p>&lt;span>%SLIDERVALUE%&lt;/span>&lt;/p>
  &lt;p>&lt;input type="range" onchange="updateSliderPWM(this)" min="0" max="255" value="%SLIDERVALUE%" step="1">&lt;/p>
&lt;script>
function updateSliderPWM(element) {
  var sliderValue = document.getElementById("pwmSlider").value;
  document.getElementById("textSliderValue").innerHTML = sliderValue;
  console.log(sliderValue);
  var xhr = new XMLHttpRequest();
  xhr.open("GET", "/slider?value="+sliderValue, true);
  xhr.send();
}
&lt;/script>
&lt;/body>
&lt;/html>
)rawliteral";
// Replaces placeholder with button section in your web page
String processor(const String& var){
  //Serial.println(var);
  if (var == "SLIDERVALUE"){
    return sliderValue;
  }
  return String();
}
void setup(){
  // Serial port for debugging purposes
  Serial.begin(115200);
  
  // configure LED PWM functionalitites
  ledcSetup(ledChannel, freq, resolution);
  
  // attach the channel to the GPIO to be controlled
  ledcAttachPin(output, ledChannel);
  
  ledcWrite(ledChannel, sliderValue.toInt());
  // Connect to Wi-Fi
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi..");
  }
  // Print ESP Local IP Address
  Serial.println(WiFi.localIP());
  // Route for root / web page
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send_P(200, "text/html", index_html, processor);
  });
  // Send a GET request to &lt;ESP_IP>/slider?value=&lt;inputMessage>
  server.on("/slider", HTTP_GET, [] (AsyncWebServerRequest *request) {
    String inputMessage;
    // GET input1 value on &lt;ESP_IP>/slider?value=&lt;inputMessage>
    if (request->hasParam(PARAM_INPUT)) {
      inputMessage = request->getParam(PARAM_INPUT)->value();
      sliderValue = inputMessage;
      ledcWrite(ledChannel, sliderValue.toInt());
    }
    else {
      inputMessage = "No message sent";
    }
    Serial.println(inputMessage);
    request->send(200, "text/plain", "OK");
  });
  
  // Start server
  server.begin();
}
  
void loop() {
  
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Slider_PWM.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
Continue reading to learn how the code works or skip to the next section.
<h3>Importing libraries</h3>
First, import the required libraries. The WiFi, ESPAsyncWebServer and the ESPAsyncTCP are needed to build the web server.
<k>#include &lt;WiFi.h>
#include &lt;AsyncTCP.h>
#include &lt;ESPAsyncWebServer.h></k>
<h3>Setting your network credentials</h3>
Insert your network credentials in the following variables, so that the ESP32 can connect to your local network.
<k>const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h3>Variables definition</h3>
We'll control the brightness of the ESP32 built-in LED. The built-in LED corresponds to GPIO 2. Save the GPIO we want to control on the output variable.
The sliderValue variable will hold the slider value. At start, it is set to zero.
<k>String sliderValue = "0";</k>
<h3>Set PWM Properties</h3>
The following lines define the PWM properties to control the LED. 
<k>// setting PWM properties
const int freq = 5000;
const int ledChannel = 0;
const int resolution = 8;</k>
We'll use 8-bit resolution, which means you can control the LED brightness using a value from 0 to 255.
To learn more about PWM properties with the ESP32, read our guide: <a href="https://randomnerdtutorials.com/esp32-pwm-arduino-ide/">ESP32 PWM with Arduino IDE (Analog Output)</a>.
<h3>Input Parameters</h3>
The PARAM_INPUT variable will be used to search for the slider value on the request received by the ESP32 when the slider is moved. (Remember: the ESP32 will receive a request like this GET/slider?value=SLIDERVALUE) 
<k>const char* PARAM_INPUT = "value";</k>
It will search for value on the URL and get the value assigned to it.
<h3>Building the Web Page</h3>
Let's now proceed to the web server page.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/08/ESP32-Slider-Web-Server-Page-Explained.png">
The web page for this project is pretty simple. It contains one heading, one paragraph and one input of type range.
Let's see how the web page is created.
All the HTML text with styles included is stored in the index_html variable. Now we'll go through the HTML text and see what each part does.
The following &lt;meta> tag makes your web page responsive in any browser.
<k>&lt;meta name="viewport" content="width=device-width, initial-scale=1"></k>
Between the &lt;title> &lt;/title> tags goes the title of our web server. The title is the text that shows up on the web browser tab.
<h4>Styles</h4>
Between the &lt;style>&lt;/style> tags, we add some CSS to style the web page.
<k>&lt;style>
  html {font-family: Arial; display: inline-block; text-align: center;}
  h2 {font-size: 2.3rem;}
  p {font-size: 1.9rem;}
  body {max-width: 400px; margin:0px auto; padding-bottom: 25px;}
  .slider { -webkit-appearance: none; margin: 14px; width: 360px; height: 25px; background: #FFD65C;
    outline: none; -webkit-transition: .2s; transition: opacity .2s;}
  .slider::-webkit-slider-thumb {-webkit-appearance: none; appearance: none; width: 35px; height: 35px; background: #003249; cursor: pointer;}
  .slider::-moz-range-thumb { width: 35px; height: 35px; background: #003249; cursor: pointer; }
&lt;/style></k>
Basically, we're setting the HTML page to display the text with Arial font in block without margin, and aligned at the center.
<k>html {font-family: Arial; display: inline-block; text-align: center;}</k>
The following lines set the font size for the heading (h2) and paragraph (p).
<k>h2 {font-size: 2.3rem;}
p {font-size: 1.9rem;}</k>
Set the HTML body properties.
<k>body {max-width: 400px; margin:0px auto; padding-bottom: 25px;}</k>
The following lines customize the slider:
<k>.slider { -webkit-appearance: none; margin: 14px; width: 360px; height: 25px; background: #FFD65C;
      outline: none; -webkit-transition: .2s; transition: opacity .2s;}
.slider::-webkit-slider-thumb {-webkit-appearance: none; appearance: none; width: 35px; height: 35px; background: #003249; cursor: pointer;}
.slider::-moz-range-thumb { width: 35px; height: 35px; background: #003249; cursor: pointer; } </k>
<h4>HTML Body</h4>
Inside the &lt;body>&lt;/body> tags is where we add the web page content.
The &lt;h2>&lt;/h2> tags add a heading to the web page. In this case, the ESP Web Server text, but you can add any other text.
<k>&lt;h2>ESP Web Server&lt;/h2></k>
The first paragraph will contain the current slider value. That particular HTML tag has the id textSliderValue assign to it, so that we can reference it later. 
<k>&lt;p>&lt;span>%SLIDERVALUE%&lt;/span>&lt;/p></k>
The %SLIDERVALUE% is a placeholder for the slider value. This will be replaced by the ESP32 by an actual value when it sends it to the browser. This is useful to show the current value when you access the browser for the first time.
<h3>Creating a Slider</h3>
To create a slider in HTML you use the &lt;input> tag. The &lt;input> tag specifies a field where the user can enter data.
There are a wide variety of input types. To define a slider, use the <k>type</k> attribute with the <k>range</k> value. In a slider, you also need to define the minimum and the maximum range using the <k>min</k> and <k>max</k> attributes (in this case, 0 and 255, respectively). 
<k>&lt;p>&lt;input type="range" onchange="updateSliderPWM(this)" min="0" max="255" value="%SLIDERVALUE%" step="1">&lt;/p></k>
You also need to define other attributes like:
the <k>step</k> attribute specifies the interval between valid numbers. In our case, it is set to 1;
the <k>class</k> to style the slider (class=slider);
the <k>id</k> to update the current position displayed on the web page;
 the <k>onchange</k> attribute to call a function (updateSliderPWM(this)) to send an HTTP request to the ESP32 when the slider moves. The this keyword refers to the current value of the slider.
<h3>Adding JavaScript to the HTML File</h3>
Next, you need to add some JavaScript code to your HTML file using the &lt;script> and &lt;/script> tags. You need to add the updateSliderPWM() function that will make a request to the ESP32 with the current slider value.
<k>&lt;script>
function updateSliderPWM(element) {
  var sliderValue = document.getElementById("pwmSlider").value;
  document.getElementById("textSliderValue").innerHTML = sliderValue;
  console.log(sliderValue);
  var xhr = new XMLHttpRequest();
  xhr.open("GET", "/slider?value="+sliderValue, true);
  xhr.send();
}
&lt;/script></k>
This next line gets the current slider value by its id and saves it in the sliderValue JavaScript variable. Previously, we've assigned the id of the slider to pwmSlider. So, we get it as follows:
<k>var sliderValue = document.getElementById("pwmSlider").value;</k>
After that, we set the slider label (whose id is textSliderValue) to the value saved on the sliderValue variable.
Finally, make an <a href="https://randomnerdtutorials.com/esp32-http-get-post-arduino/">HTTP GET request</a>.
<k>var xhr = new XMLHttpRequest();
xhr.open("GET", "/slider?value="+sliderValue, true);
xhr.send();</k>
For example, when the slider is at <k>0</k>, you make an HTTP GET request on the following URL:
<k>http://ESP-IP-ADDRESS/slider?value=0</k>
And when the slider value is 200, you'll have a request on the follow URL.
<k>http://ESP-IP-ADDRESS/slider?value=200</k>
This way, when the ESP32 receives the GET request, it can retrieve the value parameter in the URL and control the PWM signal accordingly as we'll se in the next sections
<h3>Processor</h3>
Now, we need to create the processor() function, that will replace the placeholders in our HTML text with the current slider value when you access it for the first time in a browser.
<k>// Replaces placeholder with button section in your web page
String processor(const String& var){
  //Serial.println(var);
  if (var == "SLIDERVALUE"){
    return sliderValue;
  }
  return String();
}</k>
When the web page is requested, we check if the HTML has any placeholders. If it finds the <k>%SLIDERVALUE%</k> placeholder, we return the value saved on the sliderValue variable.
<h3>setup()</h3>
In the setup(), initialize the Serial Monitor for debugging purposes.
<k>Serial.begin(115200);</k>
Configure the LED PWM properties defined earlier.
<k>ledcSetup(ledChannel, freq, resolution);</k>
Attach the channel to the GPIO you want to control.
<k>ledcAttachPin(output, ledChannel);</k>
Set the duty cycle of the PWM signal to the value saved on the sliderValue (when the ESP32 starts, it is set to 0).
<k>ledcWrite(ledChannel, sliderValue.toInt());</k>
Connect to your local network and print the ESP32 IP address.
<k>// Connect to Wi-Fi
WiFi.begin(ssid, password);
while (WiFi.status() != WL_CONNECTED) {
  delay(1000);
  Serial.println("Connecting to WiFi..");
}
// Print ESP Local IP Address
Serial.println(WiFi.localIP());</k>
<h3>Handle Requests</h3>
Finally, add the next lines of code to handle the web server.
<k>// Route for root / web page
server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
  request->send_P(200, "text/html", index_html, processor);
});
// Send a GET request to &lt;ESP_IP>/slider?value=&lt;inputMessage>
server.on("/slider", HTTP_GET, [] (AsyncWebServerRequest *request) {
  String inputMessage;
  // GET input1 value on &lt;ESP_IP>/slider?value=&lt;inputMessage>
  if (request->hasParam(PARAM_INPUT)) {
    inputMessage = request->getParam(PARAM_INPUT)->value();
    sliderValue = inputMessage;
    ledcWrite(ledChannel, sliderValue.toInt());
  }
  else {
    inputMessage = "No message sent";
  }
  Serial.println(inputMessage);
  request->send(200, "text/plain", "OK");
});</k>
When we make a request on the root URL, we send the HTML text that is stored on the index_html variable. We also need to pass the processorfunction, that will replace all the placeholders with the right values.
<k>// Route for root / web page
server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
  request->send_P(200, "text/html", index_html, processor);
});</k>
We need another handler that will save the current slider value and set he LED brightness accordingly.
<k>server.on("/slider", HTTP_GET, [] (AsyncWebServerRequest *request) {
  String inputMessage;
  // GET input1 value on &lt;ESP_IP>/slider?value=&lt;inputMessage>
  if (request->hasParam(PARAM_INPUT)) {
    inputMessage = request->getParam(PARAM_INPUT)->value();
    sliderValue = inputMessage;
    ledcWrite(ledChannel, sliderValue.toInt());
  }
  else {
    inputMessage = "No message sent";
  }
  Serial.println(inputMessage);
  request->send(200, "text/plain", "OK");
});</k>
Basically, we get the slider value on the following lines:
<k>if (request->hasParam(PARAM_INPUT)) {
  inputMessage = request->getParam(PARAM_INPUT)->value();
  sliderValue = inputMessage;</k>
Then, update the LED brightness (PWM duty cycle) using the ledcWrite() function that accepts as arguments the channel you want to control and the value.
<k>ledcWrite(ledChannel, sliderValue.toInt());</k>
Lastly, start the server.
<k>server.begin();</k>
Because this is an asynchronous web server, we don't need to write anything in the loop().
<k>void loop(){
}</k>
That's pretty much how the code works.
<h3>Upload the Code</h3>
Now, upload the code to your ESP32. Make sure you have the right board and COM port selected. 
After uploading, open the Serial Monitor at a baud rate of 115200. Press the ESP32 reset button. The ESP32 IP address should be printed in the serial monitor.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/08/ESP32-ESP8266-PWM-Web-Server-Arduino-IDE-Serial-Monitor-IP-Address.png">
<h3>Web Server Demonstration</h3>
Open a browser and type the ESP32 IP address. Your web server should display the slider and its current value.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/08/ESP32-ESP8266-PWM-web-server-demonstration.png">
Move the slider and see the ESP32 built-in LED increasing and decreasing its brightness.

<h3>Wrapping Up</h3>
With this tutorial you've learned how to add a slider to your web server projects and get and save its value on a variable that the ESP32 can use. As an example, we're controlling a PWM signal to control the brightness of an LED. Instead of an LED, you can control a servo motor, for example.
Additionally, the slider may also be used to set up a threshold or any other value that you need to be set up and then be used by the ESP32 to decide on something.
If you're using an ESP8266 board, <a href="https://randomnerdtutorials.com/esp8266-nodemcu-web-server-slider-pwm/">read ESP8266 NodeMCU Web Server with Slider Control LED Brightness (PWM)</a>.
We hope you've found this project useful. You may also like the following tutorials:
<a href="https://randomnerdtutorials.com/esp32-async-web-server-espasyncwebserver-library/">ESP32 Async Web Server  Control Outputs</a>
<a href="https://randomnerdtutorials.com/esp32-esp8266-web-server-timer-pulse/">ESP Web Server  Control Outputs with Timer</a>
<a href="https://randomnerdtutorials.com/esp32-dht11-dht22-temperature-humidity-web-server-arduino-ide/">ESP32 DHT11/DHT22 Web Server  Temperature and Humidity</a>
<h2>ESP32: ESP-NOW Web Server Sensor Dashboard (ESP-NOW + Wi-Fi)</h2>
In this project, you'll learn how to host an ESP32 web server and use ESP-NOW communication protocol at the same time. You can have several ESP32 boards sending sensor readings via ESP-NOW to one ESP32 receiver that displays all readings on a web server. The boards will be programmed using Arduino IDE.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ESP32-ESP-NOW-Web-Server-Sensor-Dashboard-ESP-NOW-Wi-Fi.jpg">

<k>Note: </k> we've updated this tutorial with a better method to use ESP-NOW and Wi-Fi simultaneously. The video doesn't use this current method. You can still watch the video to see how everything works, but we recommend that you take a look at the written article.
<h3>Using ESP-NOW and Wi-Fi Simultaneously</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/08/ESP-NOW-With-Wi-Fi-Web-Server-How-It-Works.png">There are a few things you need to take into account if you want to use Wi-Fi to host a web server and use ESP-NOW simultaneously to receive sensor readings from other boards:
The ESP32 sender boards must use the same Wi-Fi channel of the receiver board.
The Wi-Fi channel of the receiver board is automatically assigned by your Wi-Fi router.
The Wi-Fi mode of the receiver board must be access point and station (WIFI_AP_STA).
You can set up the same Wi-Fi channel manually, or you can add a simple spinet of code on the sender to set its Wi-Fi channel to the same of the receiver board.
<h3>Project Overview</h3>
The following diagram shows a high-level overview of the project we'll build.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ESP-NOW-Web-Server-REceiver-Two-Sender-Board-how-it-works.png">
There are two ESP32 sender boards that send <a href="https://makeradvisor.com/tools/dht22-temperature-humidity-sensor/" target="_blank">DHT22</a> temperature and humidity readings via ESP-NOW to one ESP32 receiver board (<a href="https://randomnerdtutorials.com/esp-now-many-to-one-esp32/">ESP-NOW many to one configuration</a>);
The ESP32 receiver board receives the packets and displays the readings on a web server;
The web server is updated automatically every time it receives a new reading using Server-Sent Events (SSE).
<h3>Prerequisites</h3>
Before proceeding with this project, make sure you check the following prerequisites.
<h3>Arduino IDE</h3>
We'll program the ESP32 boards using Arduino IDE, so before proceeding with this tutorial, make sure you have the ESP32 board installed in your Arduino IDE.
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing ESP32 Board in Arduino IDE (Windows, Mac OS X, and Linux)</a>
<h3>DHT Libraries</h3>
The ESP32 sender board will send temperature and humidity readings from a DHT22 sensor.
To read from the DHT sensor, we'll use the <a href="https://github.com/adafruit/DHT-sensor-library" target="_blank">DHT library from Adafruit</a>. To use this library you also need to install the <a href="https://github.com/adafruit/Adafruit_Sensor" target="_blank">Adafruit Unified Sensor library</a>. Follow the next steps to install those libraries.
1. Open your Arduino IDE and go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k>. The Library Manager should open.
2. Search for <k>DHT</k> on the Search box and install the DHT library from Adafruit.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/04/adafruit_dht_library.png">
3. After installing the DHT library from Adafruit, type <k>Adafruit Unified Sensor</k> in the search box. Scroll all the way down to find the library and install it.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/04/adafruit_unified_sensor_library.png">
After installing the libraries, restart your Arduino IDE.
To learn more about the DHT11 or DHT22 temperature sensor, read our guide: <a href="https://randomnerdtutorials.com/esp32-dht11-dht22-temperature-humidity-sensor-arduino-ide/">ESP32 with DHT11/DHT22 Temperature and Humidity Sensor using Arduino IDE</a>.
<h3>Async Web Server Libraries</h3>
To build the web server you need to install the following libraries:
<a href="https://github.com/me-no-dev/ESPAsyncWebServer" target="_blank">ESPAsyncWebServer</a> 
<a href="https://github.com/me-no-dev/AsyncTCP" target="_blank">AsyncTCP</a>
These libraries aren't available to install through the Arduino Library Manager, so you need to copy the library files to the Arduino Installation Libraries folder. Alternatively, in your Arduino IDE, you can go to <k>Sketch </k>> <k>Include Library</k> > <k>Add .zip Library</k> and select the libraries you've just downloaded.
<h3>Arduino_JSON Library</h3>
You need to install the Arduino_JSON library. You can install this library in the Arduino IDE Library Manager. Just go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k> and search for the library name as follows:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/Install-Arduino-JSON-library-Arduino-IDE.png">
<h3>Parts Required</h3>
To follow this tutorial, you need multiple ESP32 boards. We'll use three ESP32 boards. You also need:
3x <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> (read <a href="https://makeradvisor.com/esp32-development-boards-review-comparison/" target="_blank">Best ESP32 development boards</a>)
2x <a href="https://makeradvisor.com/tools/dht22-temperature-humidity-sensor/" target="_blank">DHT22 temperature and humidity sensor</a>  <a href="https://randomnerdtutorials.com/esp32-dht11-dht22-temperature-humidity-sensor-arduino-ide/">DHT guide for ESP32</a>
2x <a href="https://makeradvisor.com/tools/resistors-kits/" target="_blank">4.7k Ohm resistor</a>
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a>
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="lazy" fetchpriority="low"></a>
<h3>Getting the Receiver Board MAC Address</h3>
To send messages via ESP-NOW, you need to know the receiver board's <a href="https://randomnerdtutorials.com/get-change-esp32-esp8266-mac-address-arduino/">MAC address</a>. Each board has a unique MAC address (learn how to <a href="https://randomnerdtutorials.com/get-change-esp32-esp8266-mac-address-arduino/">Get and Change the ESP32 MAC Address</a>).
Upload the following code to your ESP32 receiver board to get its MAC address.
<k>// Complete Instructions to Get and Change ESP MAC Address: https://RandomNerdTutorials.com/get-change-esp32-esp8266-mac-address-arduino/
#ifdef ESP32
  #include &lt;WiFi.h>
#else
  #include &lt;ESP8266WiFi.h>
#endif
void setup(){
  Serial.begin(115200);
  Serial.println();
  Serial.print("ESP Board MAC Address:  ");
  Serial.println(WiFi.macAddress());
}
 
void loop(){
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_Get_MAC_Address.ino" target="_blank">View raw code</a>
After uploading the code, press the RST/EN button, and the MAC address should be displayed on the Serial Monitor. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-MAC-Address-Serial-Monitor.png">
<h3>ESP32 Receiver (ESP-NOW + Web Server)</h3>
The ESP32 receiver board receives the packets from the sender boards and hosts a web server to display the latest received readings.
Upload the following code to your receiver board  the code is prepared to receive readings from two different boards.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-esp-now-wi-fi-web-server/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;esp_now.h>
#include &lt;WiFi.h>
#include "ESPAsyncWebServer.h"
#include &lt;Arduino_JSON.h>
// Replace with your network credentials (STATION)
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
// Structure example to receive data
// Must match the sender structure
typedef struct struct_message {
  int id;
  float temp;
  float hum;
  unsigned int readingId;
} struct_message;
struct_message incomingReadings;
JSONVar board;
AsyncWebServer server(80);
AsyncEventSource events("/events");
// callback function that will be executed when data is received
void OnDataRecv(const uint8_t * mac_addr, const uint8_t *incomingData, int len) { 
  // Copies the sender mac address to a string
  char macStr[18];
  Serial.print("Packet received from: ");
  snprintf(macStr, sizeof(macStr), "%02x:%02x:%02x:%02x:%02x:%02x",
           mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5]);
  Serial.println(macStr);
  memcpy(&incomingReadings, incomingData, sizeof(incomingReadings));
  
  board["id"] = incomingReadings.id;
  board["temperature"] = incomingReadings.temp;
  board["humidity"] = incomingReadings.hum;
  board["readingId"] = String(incomingReadings.readingId);
  String jsonString = JSON.stringify(board);
  events.send(jsonString.c_str(), "new_readings", millis());
  
  Serial.printf("Board ID %u: %u bytes\n", incomingReadings.id, len);
  Serial.printf("t value: %4.2f \n", incomingReadings.temp);
  Serial.printf("h value: %4.2f \n", incomingReadings.hum);
  Serial.printf("readingID value: %d \n", incomingReadings.readingId);
  Serial.println();
}
const char index_html[] PROGMEM = R"rawliteral(
&lt;!DOCTYPE HTML>&lt;html>
&lt;head>
  &lt;title>ESP-NOW DASHBOARD&lt;/title>
  &lt;meta name="viewport" content="width=device-width, initial-scale=1">
  &lt;link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
  &lt;link rel="icon" href="data:,">
  &lt;style>
    html {font-family: Arial; display: inline-block; text-align: center;}
    p {  font-size: 1.2rem;}
    body {  margin: 0;}
    .topnav { overflow: hidden; background-color: #2f4468; color: white; font-size: 1.7rem; }
    .content { padding: 20px; }
    .card { background-color: white; box-shadow: 2px 2px 12px 1px rgba(140,140,140,.5); }
    .cards { max-width: 700px; margin: 0 auto; display: grid; grid-gap: 2rem; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); }
    .reading { font-size: 2.8rem; }
    .packet { color: #bebebe; }
    .card.temperature { color: #fd7e14; }
    .card.humidity { color: #1b78e2; }
  &lt;/style>
&lt;/head>
&lt;body>
  &lt;div>
    &lt;h3>ESP-NOW DASHBOARD&lt;/h3>
  &lt;/div>
  &lt;div>
    &lt;div>
      &lt;div>
        &lt;h4>&lt;i>&lt;/i> BOARD #1 - TEMPERATURE&lt;/h4>&lt;p>&lt;span>&lt;span>&lt;/span> &deg;C&lt;/span>&lt;/p>&lt;p>Reading ID: &lt;span>&lt;/span>&lt;/p>
      &lt;/div>
      &lt;div>
        &lt;h4>&lt;i>&lt;/i> BOARD #1 - HUMIDITY&lt;/h4>&lt;p>&lt;span>&lt;span>&lt;/span> &percnt;&lt;/span>&lt;/p>&lt;p>Reading ID: &lt;span>&lt;/span>&lt;/p>
      &lt;/div>
      &lt;div>
        &lt;h4>&lt;i>&lt;/i> BOARD #2 - TEMPERATURE&lt;/h4>&lt;p>&lt;span>&lt;span>&lt;/span> &deg;C&lt;/span>&lt;/p>&lt;p>Reading ID: &lt;span>&lt;/span>&lt;/p>
      &lt;/div>
      &lt;div>
        &lt;h4>&lt;i>&lt;/i> BOARD #2 - HUMIDITY&lt;/h4>&lt;p>&lt;span>&lt;span>&lt;/span> &percnt;&lt;/span>&lt;/p>&lt;p>Reading ID: &lt;span>&lt;/span>&lt;/p>
      &lt;/div>
    &lt;/div>
  &lt;/div>
&lt;script>
if (!!window.EventSource) {
 var source = new EventSource('/events');
 
 source.addEventListener('open', function(e) {
  console.log("Events Connected");
 }, false);
 source.addEventListener('error', function(e) {
  if (e.target.readyState != EventSource.OPEN) {
    console.log("Events Disconnected");
  }
 }, false);
 
 source.addEventListener('message', function(e) {
  console.log("message", e.data);
 }, false);
 
 source.addEventListener('new_readings', function(e) {
  console.log("new_readings", e.data);
  var obj = JSON.parse(e.data);
  document.getElementById("t"+obj.id).innerHTML = obj.temperature.toFixed(2);
  document.getElementById("h"+obj.id).innerHTML = obj.humidity.toFixed(2);
  document.getElementById("rt"+obj.id).innerHTML = obj.readingId;
  document.getElementById("rh"+obj.id).innerHTML = obj.readingId;
 }, false);
}
&lt;/script>
&lt;/body>
&lt;/html>)rawliteral";
void setup() {
  // Initialize Serial Monitor
  Serial.begin(115200);
  // Set the device as a Station and Soft Access Point simultaneously
  WiFi.mode(WIFI_AP_STA);
  
  // Set device as a Wi-Fi Station
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Setting as a Wi-Fi Station..");
  }
  Serial.print("Station IP Address: ");
  Serial.println(WiFi.localIP());
  Serial.print("Wi-Fi Channel: ");
  Serial.println(WiFi.channel());
  // Init ESP-NOW
  if (esp_now_init() != ESP_OK) {
    Serial.println("Error initializing ESP-NOW");
    return;
  }
  
  // Once ESPNow is successfully Init, we will register for recv CB to
  // get recv packer info
  esp_now_register_recv_cb(OnDataRecv);
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send_P(200, "text/html", index_html);
  });
   
  events.onConnect([](AsyncEventSourceClient *client){
    if(client->lastId()){
      Serial.printf("Client reconnected! Last message ID that it got is: %u\n", client->lastId());
    }
    // send event with message "hello!", id current millis
    // and set reconnect delay to 1 second
    client->send("hello!", NULL, millis(), 10000);
  });
  server.addHandler(&events);
  server.begin();
}
 
void loop() {
  static unsigned long lastEventTime = millis();
  static const unsigned long EVENT_INTERVAL_MS = 5000;
  if ((millis() - lastEventTime) > EVENT_INTERVAL_MS) {
    events.send("ping",NULL,millis());
    lastEventTime = millis();
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP_NOW_WiFi/ESP_NOW_Receiver_Web_Server.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
First, include the necessary libraries.
<k>#include &lt;esp_now.h>
#include &lt;WiFi.h>
#include "ESPAsyncWebServer.h"
#include &lt;Arduino_JSON.h></k>
The <a href="https://github.com/arduino-libraries/Arduino_JSON" target="_blank">Arduino_JSON library</a> is needed because we'll create a JSON variable with the data received from each board. This JSON variable will be used to send all the needed information to the web page as you'll see later in this project. 
Insert your network credentials on the following lines so that the ESP32 can connect to your local network.
<k>const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h4>Data Structure</h4>
Then, create a structure that contains the data we'll receive. We called this structure struct_message and it contains the board ID, temperature and humidity readings, and the reading ID.
<k>typedef struct struct_message {
    int id;
    float temp;
    float hum;
    int readingId;
} struct_message;</k>
Create a new variable of type struct_message that is called incomingReadings that will store the variables' values.
<k>struct_message incomingReadings;</k>
Create a JSON variable called board.
<k>JSONVar board;</k>
Create an Async Web Server on port 80.
<k>AsyncWebServer server(80);</k>
<h3>Create Event Source</h3>
To automatically display the information on the web server when a new reading arrives, we'll use Server-Sent Events (SSE).
The following line creates a new event source on /events.
<k>AsyncEventSource events("/events");</k>
Server-Sent Events allow a web page (client) to get updates from a server. We'll use this to automatically display new readings on the web server page when a new ESP-NOW packet arrives.
<k>Important: </k> Server-sent events are not supported on Internet Explorer.
<h3>OnDataRecv() function</h3>
The OnDataRecv() function will be executed when you receive a new ESP-NOW packet.
<k>void OnDataRecv(const uint8_t * mac_addr, const uint8_t *incomingData, int len) {</k>
Inside that function, print the sender's MAC address:
<k>// Copies the sender mac address to a string
char macStr[18];
Serial.print("Packet received from: ");
snprintf(macStr, sizeof(macStr), "%02x:%02x:%02x:%02x:%02x:%02x",
         mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5]);
Serial.println(macStr);</k>
Copy the information in the incomingData variable into the incomingReadings structure variable.
<k>memcpy(&incomingReadings, incomingData, sizeof(incomingReadings));</k>
Then, create a JSON String variable with the received information (jsonString variable):
<k>board["id"] = incomingReadings.id;
board["temperature"] = incomingReadings.temp;
board["humidity"] = incomingReadings.hum;
board["readingId"] = String(incomingReadings.readingId);
String jsonString = JSON.stringify(board);</k>
Here's an example of how the jsonString variable may look like after receiving the readings:
<k>board = {
  "id": "1",
  "temperature": "24.32",
  "humidity" = "65.85",
  "readingId" = "2"
}</k>
After gathering all the received data on the jsonString variable, send that information to the browser as an event (new_readings).
<k>events.send(jsonString.c_str(), "new_readings", millis());</k>
Later, we'll see how to handle these events on the client side. 
Finally, print the received information on the Arduino IDE Serial Monitor for debugging purposes:
<k>Serial.printf("Board ID %u: %u bytes\n", incomingReadings.id, len);
Serial.printf("t value: %4.2f \n", incomingReadings.temp);
Serial.printf("h value: %4.2f \n", incomingReadings.hum);
Serial.printf("readingID value: %d \n", incomingReadings.readingId);
Serial.println();</k>
<h3>Building the Web Page</h3>
The index_html variable contains all the HTML, CSS and JavaScript to build the web page. We won't go into details on how the HTML and CSS works. We'll just take a look at how to handle the events sent by the server.
<h4>Handle Events</h4>
Create a new EventSource object and specify the URL of the page sending the updates. In our case, it's /events.
<k>if (!!window.EventSource) {
 var source = new EventSource('/events');</k>
Once you've instantiated an event source, you can start listening for messages from the server with addEventListener().
These are the default event listeners, as shown here in the AsyncWebServer <a href="https://github.com/me-no-dev/ESPAsyncWebServer#setup-event-source-in-the-browser" target="_blank">documentation</a>.
<k>source.addEventListener('open', function(e) {
  console.log("Events Connected");
}, false);
source.addEventListener('error', function(e) {
 if (e.target.readyState != EventSource.OPEN) {
   console.log("Events Disconnected");
 }
}, false);
source.addEventListener('message', function(e) {
 console.log("message", e.data);
}, false);</k>
Then, add the event listener for new_readings.
<k>source.addEventListener('new_readings', function(e) {</k>
When the ESP32 receives a new packet, it sends a JSON string with the readings as an event (new_readings) to the client. The following lines handle what happens when the browser receives that event.
<k>console.log("new_readings", e.data);
var obj = JSON.parse(e.data);
document.getElementById("t"+obj.id).innerHTML = obj.temperature.toFixed(2);
document.getElementById("h"+obj.id).innerHTML = obj.humidity.toFixed(2);
document.getElementById("rt"+obj.id).innerHTML = obj.readingId;
document.getElementById("rh"+obj.id).innerHTML = obj.readingId;</k>
Basically, print the new readings on the browser console, and put the received data into the elements with the corresponding id on the web page.
<h3>setup()</h3>
In the setup(), set the ESP32 receiver as an access point and Wi-Fi station:
<k>WiFi.mode(WIFI_AP_STA);</k>
The following lines connect the ESP32 to your local network and print the IP address and the Wi-Fi channel:
<k>// Set device as a Wi-Fi Station
WiFi.begin(ssid, password);
while (WiFi.status() != WL_CONNECTED) {
  delay(1000);
  Serial.println("Setting as a Wi-Fi Station..");
}
Serial.print("Station IP Address: ");
Serial.println(WiFi.localIP());
Serial.print("Wi-Fi Channel: ");
Serial.println(WiFi.channel());</k>
Initialize ESP-NOW.
<k>if (esp_now_init() != ESP_OK) {
  Serial.println("Error initializing ESP-NOW");
  return;
}</k>
Register for the OnDataRecv callback function, so that it is executed when a new ESP-NOW packet arrives.
<k>esp_now_register_recv_cb(OnDataRecv);</k>
<h3>Handle Requests</h3>
When you access the ESP32 IP address on the root / URL, send the text that is stored on the index_html variable to build the web page.
<k>server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
  request->send_P(200, "text/html", index_html);
});</k>
<h3>Server Event Source</h3>
Set up the event source on the server.
<k>events.onConnect([](AsyncEventSourceClient *client){
  if(client->lastId()){
    Serial.printf("Client reconnected! Last message ID that it got is: %u\n", client->lastId());
  }
  // send event with message "hello!", id current millis
  // and set reconnect delay to 1 second
  client->send("hello!", NULL, millis(), 10000);
 );
  server.addHandler(&events);</k>
Finally, start the server.
<k>server.begin();</k>
<h3>loop()</h3>
In the loop(), send a ping every 5 seconds. This is used to check on the client side, if the server is still running.
<k>static unsigned long lastEventTime = millis();
static const unsigned long EVENT_INTERVAL_MS = 5000;
if ((millis() - lastEventTime) > EVENT_INTERVAL_MS) {
  events.send("ping",NULL,millis());
  lastEventTime = millis();
}</k>
The following diagram summarizes how the Server-sent Events work on this project and how it updates the values without refreshing the web page. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ESP-NOW-Web-Server-with-Server-Sent-Events.png">
After uploading the code to the receiver board, press the on-board EN/RST button. The ESP32 IP address should be printed on the Serial Monitor as well as the Wi-Fi channel.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/08/ESP-NOW-IP-Address-Wi-Fi-channel-Serial-Monitor.png">
<h3>ESP32 Sender Circuit</h3>
The ESP32 sender boards are connected to a <a href="https://makeradvisor.com/tools/dht22-temperature-humidity-sensor/" target="_blank">DHT22 temperature and humidity sensor</a>. The data pin is connected to GPIO 4. You can choose any other suitable GPIO (<a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">read ESP32 Pinout Guide</a>). Follow the next schematic diagram to wire the circuit.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/04/dht_esp32_bb.png">
<h3>ESP32 Sender Code (ESP-NOW)</h3>
Each sender board will send a structure via ESP-NOW that contains the board ID (so that you can identify which board sent the readings), the temperature, the humidity, and the reading ID. The reading ID is an int number to know how many messages were sent.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ESP-NOW-Send-Sensor-Readings-Structures-ESP32.png">
Upload the following code to each of your sender boards. Don't forget to increment the id number for each sender board and insert your SSID in the WIFI_SSID variable.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-esp-now-wi-fi-web-server/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;esp_now.h>
#include &lt;esp_wifi.h>
#include &lt;WiFi.h>
#include &lt;Adafruit_Sensor.h>
#include &lt;DHT.h>
// Set your Board ID (ESP32 Sender #1 = BOARD_ID 1, ESP32 Sender #2 = BOARD_ID 2, etc)
#define BOARD_ID 1
// Digital pin connected to the DHT sensor
#define DHTPIN 4  
// Uncomment the type of sensor in use:
//#define DHTTYPE    DHT11     // DHT 11
#define DHTTYPE    DHT22     // DHT 22 (AM2302)
//#define DHTTYPE    DHT21     // DHT 21 (AM2301)
DHT dht(DHTPIN, DHTTYPE);
//MAC Address of the receiver 
uint8_t broadcastAddress[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
//Structure example to send data
//Must match the receiver structure
typedef struct struct_message {
    int id;
    float temp;
    float hum;
    int readingId;
} struct_message;
//Create a struct_message called myData
struct_message myData;
unsigned long previousMillis = 0;   // Stores last time temperature was published
const long interval = 10000;        // Interval at which to publish sensor readings
unsigned int readingId = 0;
// Insert your SSID
constexpr char WIFI_SSID[] = "REPLACE_WITH_YOUR_SSID";
int32_t getWiFiChannel(const char *ssid) {
  if (int32_t n = WiFi.scanNetworks()) {
      for (uint8_t i=0; i&lt;n; i++) {
          if (!strcmp(ssid, WiFi.SSID(i).c_str())) {
              return WiFi.channel(i);
          }
      }
  }
  return 0;
}
float readDHTTemperature() {
  // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor)
  // Read temperature as Celsius (the default)
  float t = dht.readTemperature();
  // Read temperature as Fahrenheit (isFahrenheit = true)
  //float t = dht.readTemperature(true);
  // Check if any reads failed and exit early (to try again).
  if (isnan(t)) {    
    Serial.println("Failed to read from DHT sensor!");
    return 0;
  }
  else {
    Serial.println(t);
    return t;
  }
}
float readDHTHumidity() {
  // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor)
  float h = dht.readHumidity();
  if (isnan(h)) {
    Serial.println("Failed to read from DHT sensor!");
    return 0;
  }
  else {
    Serial.println(h);
    return h;
  }
}
// callback when data is sent
void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
  Serial.print("\r\nLast Packet Send Status:\t");
  Serial.println(status == ESP_NOW_SEND_SUCCESS ? "Delivery Success" : "Delivery Fail");
}
 
void setup() {
  //Init Serial Monitor
  Serial.begin(115200);
  dht.begin();
 
  // Set device as a Wi-Fi Station and set channel
  WiFi.mode(WIFI_STA);
  int32_t channel = getWiFiChannel(WIFI_SSID);
  WiFi.printDiag(Serial); // Uncomment to verify channel number before
  esp_wifi_set_promiscuous(true);
  esp_wifi_set_channel(channel, WIFI_SECOND_CHAN_NONE);
  esp_wifi_set_promiscuous(false);
  WiFi.printDiag(Serial); // Uncomment to verify channel change after
  //Init ESP-NOW
  if (esp_now_init() != ESP_OK) {
    Serial.println("Error initializing ESP-NOW");
    return;
  }
  // Once ESPNow is successfully Init, we will register for Send CB to
  // get the status of Trasnmitted packet
  esp_now_register_send_cb(OnDataSent);
  
  //Register peer
  esp_now_peer_info_t peerInfo;
  memcpy(peerInfo.peer_addr, broadcastAddress, 6);
  peerInfo.encrypt = false;
  
  //Add peer        
  if (esp_now_add_peer(&peerInfo) != ESP_OK){
    Serial.println("Failed to add peer");
    return;
  }
}
 
void loop() {
  unsigned long currentMillis = millis();
  if (currentMillis - previousMillis >= interval) {
    // Save the last time a new reading was published
    previousMillis = currentMillis;
    //Set values to send
    myData.id = BOARD_ID;
    myData.temp = readDHTTemperature();
    myData.hum = readDHTHumidity();
    myData.readingId = readingId++;
     
    //Send message via ESP-NOW
    esp_err_t result = esp_now_send(broadcastAddress, (uint8_t *) &myData, sizeof(myData));
    if (result == ESP_OK) {
      Serial.println("Sent with success");
    }
    else {
      Serial.println("Error sending the data");
    }
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP_NOW_WiFi/ESP_NOW_Sender.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
Start by importing the required libraries:
<k>#include &lt;esp_now.h>
#include &lt;esp_wifi.h>
#include &lt;WiFi.h>
#include &lt;Adafruit_Sensor.h>
#include &lt;DHT.h></k>
<h4>Set Board ID</h4>
Define the ESP32 sender board ID, for example set BOARD_ID 1 for ESP32 Sender #1, etc
<k>// Set your Board ID (ESP32 Sender #1 = BOARD_ID 1, ESP32 Sender #2 = BOARD_ID 2, etc)
#define BOARD_ID 1</k>
<h4>DHT Sensor</h4>
Define the pin the DHT sensor is connected to. In our example, it is connected to GPIO 4.
<k>#define DHTPIN 4</k>
Select the DHT sensor type you're using. We're using the DHT22.
<k>// Uncomment the type of sensor in use:
//#define DHTTYPE    DHT11     // DHT 11
#define DHTTYPE    DHT22     // DHT 22 (AM2302)
//#define DHTTYPE    DHT21     // DHT 21 (AM2301)</k>
Create a DHT object on the pin and type defined earlier.
<k>DHT dht(DHTPIN, DHTTYPE);</k>
<h4>Receiver's MAC Address</h4>
Insert the receiver's MAC address on the next line (for example):
<k>uint8_t broadcastAddress[] = {0x30, 0xAE, 0xA4, 0x15, 0xC7, 0xFC};</k>
<h4>Data Structure</h4>
Then, create a structure that contains the data we want to send. The struct_message contains the board ID, temperature reading, humidity reading, and the reading ID.
<k>typedef struct struct_message {
    int id;
    float temp;
    float hum;
    int readingId;
} struct_message;</k>
Create a new variable of type struct_message that is called myData that stores the variables' values.
<k>struct_message myData;</k>
<h4>Timer Interval</h4>
Create some auxiliary timer variables to publish the readings every 10 seconds. You can change the delay time on the interval variable.
<k>unsigned long previousMillis = 0;  // Stores last time temperature was published
const long interval = 10000;       // Interval at which to publish sensor readings</k>
Initialize the readingId variable  it keeps track of the number of readings sent.
<k>unsigned int readingId = 0;</k>
<h4>Changing Wi-Fi channel</h4>
Now, we'll get the receiver's Wi-Fi channel. This is useful because it allows us to automatically assign the same Wi-Fi channel to the sender board.
To do that, you must insert your SSID in the following line:
<k>constexpr char WIFI_SSID[] = "REPLACE_WITH_YOUR_SSID";</k>
Then, the getWiFiChannel() function scans for your network and gets its channel.
<k>int32_t getWiFiChannel(const char *ssid) {
  if (int32_t n = WiFi.scanNetworks()) {
    for (uint8_t i=0; i&lt;n; i++) {
      if (!strcmp(ssid, WiFi.SSID(i).c_str())) {
        return WiFi.channel(i);
      }
    }
  }
  return 0;
}</k>
<em>This snippet of code was proposed by Stephane (one of our readers). You can see his complete example <a href="https://github.com/m1cr0lab-esp32/esp-now-network-and-wifi-gateway" target="_blank">here</a>.</em>
<h4>Reading Temperature</h4>
The readDHTTemperature() function reads and returns the temperature from the DHT sensor. In case it is not able to get temperature readings, it returns 0.
<k>float readDHTTemperature() {
  // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor)
  // Read temperature as Celsius (the default)
  float t = dht.readTemperature();
  // Read temperature as Fahrenheit (isFahrenheit = true)
  //float t = dht.readTemperature(true);
  // Check if any reads failed and exit early (to try again).
  if (isnan(t)) {
    Serial.println("Failed to read from DHT sensor!");
    return 0;
  }
  else {
    Serial.println(t);
    return t;
  }
}</k>
<h4>Reading Humidity</h4>
The readDHTHumidity() function reads and returns the humidity from the DHT sensor. In case it is not able to get humidity readings, it returns 0.
<k>float readDHTHumidity() {
  // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor)
  float h = dht.readHumidity();
  if (isnan(h)) {
    Serial.println("Failed to read from DHT sensor!");
    return 0;
  }
  else {
    Serial.println(h);
    return h;
  }
}</k>
<k>Note: </k> to learn more about getting temperature and humidity from the DHT22 or DHT11 sensors, read: <a href="https://randomnerdtutorials.com/esp32-dht11-dht22-temperature-humidity-sensor-arduino-ide/">ESP32 with DHT11/DHT22 Temperature and Humidity Sensor using Arduino IDE</a>.
<h4>OnDataSent Callback Function</h4>
The OnDataSent() callback function will be executed when a message is sent. In this case, this function prints if the message was successfully delivered or not.
<k>void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
  Serial.print("\r\nLast Packet Send Status:\t");
  Serial.println(status == ESP_NOW_SEND_SUCCESS ? "Delivery Success" : "Delivery Fail");
}</k>
<h4>setup()</h4>
Initialize the Serial Monitor.
<k>Serial.begin(115200);</k>
Set the ESP32 as a Wi-Fi station.
<k>WiFi.mode(WIFI_STA);</k>
Set its channel to match the receiver's Wi-Fi channel:
<k>int32_t channel = getWiFiChannel(WIFI_SSID);
WiFi.printDiag(Serial); // Uncomment to verify channel number before
esp_wifi_set_promiscuous(true);
esp_wifi_set_channel(channel, WIFI_SECOND_CHAN_NONE);
esp_wifi_set_promiscuous(false);
WiFi.printDiag(Serial); // Uncomment to verify channel change after</k>
Initialize ESP-NOW.
<k>if (esp_now_init() != ESP_OK) {
  Serial.println("Error initializing ESP-NOW");
  return;
}</k>
After successfully initializing ESP-NOW, register the callback function that will be called when a message is sent. In this case, register for the OnDataSent() function created previously.
<k>esp_now_register_send_cb(OnDataSent);</k>
<h4>Add peer</h4>
To send data to another board (the receiver), you need to pair it as a peer. The following lines register and add the receiver as a peer.
<k>// Register peer
esp_now_peer_info_t peerInfo;
memcpy(peerInfo.peer_addr, broadcastAddress, 6);
peerInfo.encrypt = false;
// Add peer
if (esp_now_add_peer(&peerInfo) != ESP_OK){
  Serial.println("Failed to add peer");
  return;
}</k>
<h4>loop()</h4>
In the loop(), check if it is time to get and send new readings.
<k>unsigned long currentMillis = millis();
if (currentMillis - previousMillis >= interval) {
  // Save the last time a new reading was published
  previousMillis = currentMillis;</k>
<h4>Send ESP-NOW Message</h4>
Finally, send the message structure via ESP-NOW.
<k>// Send message via ESP-NOW
esp_err_t result = esp_now_send(broadcastAddress, (uint8_t *) &myData, sizeof(myData));
if (result == ESP_OK) {
  Serial.println("Sent with success");
}
else {
  Serial.println("Error sending the data");
}</k>
<k>Recommended reading:</k> <a href="https://randomnerdtutorials.com/esp-now-esp32-arduino-ide/" target="_blank">Getting Started with ESP-NOW (ESP32 with Arduino IDE)</a>
Upload the code to your sender boards. You should notice that the boards change their Wi-Fi channel to the channel of the receiver board. In our case, the boards changed their Wi-Fi channel number to 6.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/08/Change-Wi-Fi-Cahnnel-ESP-NOW-ESP32.png">
<h3>Demonstration</h3>
After uploading the code to all the boards and if everything is going as expected, the ESP32 receiver board should start receiving sensor readings from the other boards.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ESP32-ESP-NOW-Web-Server-Sensor-Dashboard-ESP-NOW-Wi-Fi-Demonstration-Sensor-Readings.jpg">
Open a browser on your local network and type the ESP32 IP address. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ESP-NOW-Receiver-Web-Server-ESP32.png">
It should load the temperature, humidity, and reading IDs for each board. Upon receiving a new packet, your web page updates automatically without refreshing the web page.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ESP32-ESP-NOW-Web-Server-Sensor-Modile-Responsive-Dashboard.png">
<h3>Wrapping Up</h3>
In this tutorial you've learned how to use ESP-NOW and Wi-Fi to set up a web server to receive ESP-NOW packets from multiple boards (many-to-one configuration).
Additionally, you also used Server-Sent Events to automatically update the web page every time a new packet is received without refreshing the web page.
We hope you like this project. Other projects/tutorials you may like:
<a href="https://randomnerdtutorials.com/esp-now-esp32-arduino-ide/">Getting Started with ESP-NOW (ESP32 with Arduino IDE)</a>
<a href="https://randomnerdtutorials.com/esp-now-one-to-many-esp32-esp8266/">ESP-NOW with ESP32: Send Data to Multiple Boards (one-to-many)</a>
<a href="https://randomnerdtutorials.com/esp-now-many-to-one-esp32/">ESP-NOW with ESP32: Receive Data from Multiple Boards (many-to-one)</a>
<a href="https://randomnerdtutorials.com/esp-now-two-way-communication-esp32/">ESP-NOW Two-Way Communication Between ESP32 Boards</a>
<a href="https://randomnerdtutorials.com/esp32-lora-sensor-web-server/">ESP32 LoRa Sensor Monitoring with Web Server (Long Range Communication)</a>
<h2>ESP32-CAM Take Photos, Control Outputs</h2>
In this project we'll create a PCB shield for the ESP32-CAM AI-Thinker board with a PIR motion sensor, a BME280 temperature, humidity and pressure sensor and some additional exposed pins. We'll create a Telegram bot for the ESP32-CAM that allows you to control your board from anywhere to request a photo, sensor readings or control the flash. Additionally, you'll receive a notification with a new photo whenever motion is detected. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/08/Control-ESP32-CAM-with-Telegram-Take-Photos-Control-Outputs-Request-Sensor-Readings-and-Motion-Notifications.jpg">
Alternatively, you can also follow this project by wiring the circuit on a breadboard.
<h3>Watch the Video Tutorial</h3>
This project is available in video format and in written format. You can watch the video below or you can scroll down for the written instructions.

<h3>Resources</h3>
You can find all the resources needed to build this project in the links below (or you can visit the <a href="https://github.com/RuiSantosdotme/ESP32-CAM-Shield-Telegram/" target="_blank">GitHub project</a>):
<a href="https://raw.githubusercontent.com/RuiSantosdotme/ESP32-CAM-Shield-Telegram/master/ESP32_CAM_Shield_PCB_Telegram/ESP32_CAM_Shield_PCB_Telegram.ino" target="_blank">ESP32-CAM Code (Arduino IDE)</a>
<a href="https://github.com/RuiSantosdotme/ESP32-CAM-Shield-Telegram/raw/master/Gerber_PCB_2020-07-07_10-25-47_2020-07-07_11-49-04.zip" target="_blank">Gerber files</a>
<a href="https://github.com/RuiSantosdotme/ESP32-CAM-Shield-Telegram/raw/master/Project_ESP32-CAM%20Shield%20PCB_%20Telegram%20Take%20Photos%2C%20Detect%20Motion%20and%20Sensor%20Readings_2020-07-27_16-27-04.zip" target="_blank">EasyEDA project to edit the PCB</a>
<k><a href="https://github.com/RuiSantosdotme/ESP32-CAM-Shield-Telegram/archive/master.zip" target="_blank">Click here to download all the files</a></k>
<h3>Project Overview</h3>
This project consists of three parts:
<ol>
Designing and Building the PCB shield
Creating the Telegram Bot
Programming the PCB shield using Arduino IDE
</ol>
<h3>ESP32-CAM PCB Shield Features</h3>
The PCB shield is designed to be stacked to the ESP32-CAM. For this reason, if you want to use our PCB, you need the same ESP32-CAM board. We're using the <a href="https://makeradvisor.com/tools/esp32-cam/" target="_blank">ESP32-CAM AI-Thinker Module</a>. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-CAM-AI-Thinker-Module-Shield-PCB-Parts-Components-Mounted.jpg">
We're also using a <a href="https://makeradvisor.com/tools/ov2640-probes-esp32-cam/" target="_blank">camera module with a longer ribbon</a>. So that when you mount the shield, the camera is on the same side of the PIR motion sensor.
Alternatively, you can also assemble the circuit on a breadboard.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-CAM-Project-Telegram-Test-Circuit-Diagram-Breadboard-Wiring.jpg">
The shield consists of:
<a href="https://makeradvisor.com/tools/bme280-sensor-module/" target="_blank">BME280 </a>temperature, humidity and pressure sensor (4 pins);
<a href="https://makeradvisor.com/tools/mini-hc-sr505-pir-motion-sensor/" target="_blank">Mini PIR motion sensor (AM312)</a>;
Exposed 5V and GND pins to power up the shield and ESP32-CAM;
Other exposed GPIOs if you want to add additional features.
<h3>ESP32-CAM PCB Shield Pin Assignment</h3>
This is the pin assignment for the BME280 and PIR motion sensor on the PCB shield:
PIR Motion Sensor: GPIO 13
BME280: GPIO 14 (SDA), GPIO 15 (SCL)
<h3>ESP32-CAM Telegram Bot</h3>
To control the ESP32-CAM shield, we'll create a Telegram bot, so that you can monitor your ESP32-CAM from anywhere (as long as you have internet access in your smartphone). You can use the following commands to interact with your bot:
<k>/start</k>: sends a welcome message with the valid commands to control the shield;
<k>/flash</k>: toggles the ESP32-CAM LED Flash;
<k>/photo</k>: takes a new photo and sends it to your Telegram account;
<k>/readings</k>: requests the latest BME280 sensor readings.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/08/Control-ESP32-CAM-Telegram-Take-Photos-Control-Outputs-Sensor-Readings-Motion-Notifications.jpg">
Additionally, you'll receive a notification with a photo whenever motion is detected. Finally, only you (or any other authorized user that you want) can control the ESP32-CAM using Telegram. 
<h3>Testing the Circuit on a Breadboard</h3>
Before designing and building the PCB shield, it's important to test the circuit on a breadboard. If you don't want to make a PCB, you can still follow this project by assembling the circuit on a breadboard.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-CAM-Project-Telegram-Test-Circuit-Diagram-Breadboard-Wiring.jpg">
<h3>Parts Required</h3>
To assemble the circuit on a breadboard you need the following parts:
<a href="https://makeradvisor.com/tools/esp32-cam/" target="_blank">ESP32-CAM AI-Thinker</a>
<a href="https://makeradvisor.com/tools/mini-hc-sr505-pir-motion-sensor/" target="_blank">Mini PIR motion sensor</a>
<a href="https://makeradvisor.com/tools/bme280-sensor-module/" target="_blank">BME280</a> (4 pins)
<a href="https://makeradvisor.com/tools/ftdi-programmer-board/" target="_blank">FTDI programmer</a> (to <a href="https://randomnerdtutorials.com/program-upload-code-esp32-cam/">upload code</a>)
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a>
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="lazy" fetchpriority="low"></a>
After gathering all the parts, assemble the circuit by following the next schematic diagram:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-CAM-BME280-PIR-Motion-Sensor-Wiring-Schematic-Diagram.jpg">
<h3>Designing the PCB</h3>
To design the circuit and PCB, we used <a href="https://easyeda.com/" target="_blank" rel="noreferrer noopener nofollow">EasyEDA</a> which is a browser based software to design PCBs. If you want to customize your PCB, you just need to upload the following files:
<a href="https://github.com/RuiSantosdotme/ESP32-CAM-Shield-Telegram/raw/master/Project_ESP32-CAM%20Shield%20PCB_%20Telegram%20Take%20Photos%2C%20Detect%20Motion%20and%20Sensor%20Readings_2020-07-27_16-27-04.zip" target="_blank">EasyEDA project files to edit the PCB</a>
Designing the circuit works like in any other circuit software tool, you place some components and you wire them together. Then, you assign each component to a footprint.
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-CAM-PCB-Shield-Circuit-Diagram-Telegram-Take-Photo-PIR-BME280.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-CAM-PCB-Shield-Circuit-Diagram-Telegram-Take-Photo-PIR-BME280.png"></a>
Having the parts assigned, place each component. When you're happy with the layout, make all the connections and route your PCB.
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-CAM-PCB-Shield-Telegram-Take-Photo-PIR-BME280.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-CAM-PCB-Shield-Telegram-Take-Photo-PIR-BME280.png"></a>
Save your project and export the Gerber files.
<k>Note: </k>you can grab the project files and edit them to customize the shield for your own needs.
<a href="https://github.com/RuiSantosdotme/ESP32-CAM-Shield-Telegram/raw/master/Gerber_PCB_2020-07-07_10-25-47_2020-07-07_11-49-04.zip" target="_blank"><k>Download Gerber .zip file</k></a>
<a href="https://github.com/RuiSantosdotme/ESP32-CAM-Shield-Telegram/raw/master/Project_ESP32-CAM%20Shield%20PCB_%20Telegram%20Take%20Photos%2C%20Detect%20Motion%20and%20Sensor%20Readings_2020-07-27_16-27-04.zip" target="_blank">EasyEDA project to edit the PCB</a>
<h3>Ordering the PCBs at PCBWay</h3>
This project is sponsored by PCBWay. <a href="https://randomnerdtutorials.com/pcbway" target="_blank">PCBWay</a> is a full feature Printed Circuit Board manufacturing service.
<a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/PCBWay-banner.jpg"></a>
Turn your DIY breadboard circuits into <a href="https://randomnerdtutorials.com/pcbway" target="_blank">professional PCBs</a>  get 10 boards for approximately $5 + shipping (which will vary depending on your country).
Once you have your Gerber files, you can order the PCB. Follow the next steps to download the file.
1. Download the Gerber files  <a href="https://github.com/RuiSantosdotme/ESP32-CAM-Shield-Telegram/raw/master/Gerber_PCB_2020-07-07_10-25-47_2020-07-07_11-49-04.zip" target="_blank">click here to download the .zip file</a>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/08/Gerber_Files_PCB.png">
2. Go to <a href="https://randomnerdtutorials.com/pcbway" target="_blank">PCBWay website</a> and open the PCB Instant Quote page. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/1-PCBWay-Order-PCB.png">
3. PCBWay can grab all the PCB details and automatically fill them for you. Use the Quick-order PCB (Autofill parameters).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/2-PCBWay-Order-PCB-autofill-parameters.png">
4. Press the + Add Gerber file button to upload the provided Gerber files.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/3-PCBWay-Order-PCB-gerbers-files.png">
And that's it. You can also use the OnlineGerberViewer to check if your PCB is looking as it should.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/08/PCBWay-Preview-PCB.png">
If you aren't in a hurry, you can use the China Post shipping method to lower your cost significantly. In our opinion, we think they overestimate the China Post shipping time.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/6-PCBWay-Order-PCB-china-post.png">
You can increase your PCB order quantity and change the solder mask color. I've ordered the Blue color.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/7-PCBWay-Order-PCB-final-step.png">
Once you're ready, you can order the PCBs by clicking Save to Cart and complete your order.
<h3>Unboxing</h3>
After approximately one week using the DHL shipping method, I received the PCBs at my office.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/PCBWay-Unboxing.jpg">
Everything comes well packed, and the PCBs are really high-quality. The letters on the silkscreen are really well-printed and easy to read. Additionally, the solder sticks easily to the pads.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-CAM-Shield-PCB-Unboxing.jpg">
Besides the PCBs, I also received some gifts (celebration of their 6th anniversary): a badge, some stickers, a t-shirt, a pen and some rulers.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-CAM-PCBWay-Unboxing-PCBs.jpg">
<h3>Soldering the Components</h3>
The next step is soldering the components to the PCB. You just need to solder female header pins. The PIR motion sensor and the BME280 will then connect to those pins.
Here's a list of all the components needed to build the PCB shield:
<a href="https://makeradvisor.com/tools/bme280-sensor-module/">1x BME280</a>
<a href="https://makeradvisor.com/tools/mini-hc-sr505-pir-motion-sensor/" target="_blank">1x Mini PIR motion sensor</a>
<a href="https://makeradvisor.com/female-pin-header-socket" target="_blank">Female pin header socket</a> (2.54 mm)
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-CAM-AI-Thinker-Module-Shield-PCB-Parts-Components-Required.jpg">
Here's the soldering tools I've used:
<a href="https://makeradvisor.com/ts80-soldering-iron-review/" target="_blank">TS80 mini portable soldering iron</a>
<a href="https://www.banggood.com/0_5mm-500g-Soldering-Wires-Welding-Iron-Rosin-Core-6040-Lead-Tin-Flux-2_0-Percent-p-1023387.html?p=MA240439985285201910" target="_blank">Solder 60/40 0.5mm diameter</a>
<a href="https://makeradvisor.com/soldering-mats-review/" target="_blank">Soldering mat</a>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/TS80-Soldering-Iron-Review-Best-Portable-Soldering-Iron.jpg">Read our review about the TS80 Soldering Iron: <a href="https://makeradvisor.com/ts80-soldering-iron-review/" target="_blank">TS80 Soldering Iron Review  Best Portable Soldering Iron</a>.
The soldering process is pretty simple as you just need to solder the headers pins. There are some exposed GPIOs in the middle of the shield. Solder pins to those GPIOs if you want to use them to connect any other peripherals.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-CAM-AI-Thinker-Module-Shield-PCB-Soldering-Parts-Components.jpg">
Here's how the ESP32-CAM PCB Shield looks like after assembling.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/08/ESP32-CAM-AI-Thinker-Module-Shield-PCB-Final-Demonstration.jpg">
<h3>Creating a Telegram Bot</h3>
The ESP32-CAM will interact with a Telegram bot to receive and handle the messages, and send responses to your Telegram account (sensor readings and photos). Follow the next steps to create a Telegram bot.
Go to Google Play or App Store, download and install <k>Telegram</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Install-Telegram.png">
Open Telegram and follow the next steps to create a Telegram Bot. First, search for <k>botfather</k> and click the BotFather as shown below. Or open this link <a href="http://t.me/botfather" target="_blank">t.me/botfather</a> in your smartphone.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Telegram-Botfather.png">
The following window should open and you'll be prompted to click the <k>start</k> button.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/start-bot-father-telegram.png">
Type <k>/newbot</k> and follow the instructions to create your bot. Give it a name and username.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Create-bot-Telegram-Botfather_f.png">
If your bot is successfully created, you'll receive a message with a link to access the bot and the <k>bot token</k>. Save the bot token because you'll need it so that the ESP32/ESP8266 can interact with the bot.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Bot-Token-Telegram-Bot-Father.png">
<h3>Get Your Telegram User ID</h3>
Anyone that knows your bot username can interact with it. To make sure that we ignore messages that are not from our Telegram account (or any authorized users), you can get your Telegram User ID. Then, when your telegram bot receives a message, the ESP can check whether the sender ID corresponds to your User ID and handle the message or ignore it.
In your Telegram account, search for IDBot or open this link <a href="http://t.me/myidbot" target="_blank">t.me/myidbot</a> in your smartphone.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Telegram-ID-Bot.png">
Start a conversation with that bot and type <k>/getid</k>. You will get a reply back with your user ID. Save that <k>user ID</k>, because you'll need it later in this tutorial.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Telegram-Get-Chat-ID.png">
<h3>Preparing Arduino IDE</h3>
We'll program the <a href="https://makeradvisor.com/tools/esp32-cam/" target="_blank">ESP32-CAM</a> using Arduino IDE, so make sure you have the ESP32 add-on installed in your Arduino IDE.
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<h3>Universal Telegram Bot Library</h3>
To interact with the Telegram bot, we'll use the <a href="https://github.com/witnessmenow/Universal-Arduino-Telegram-Bot" target="_blank">Universal Telegram Bot Library</a> created by Brian Lough that provides an easy interface for the Telegram Bot API.
Follow the next steps to install the latest release of the library.
<ol>
<a href="https://github.com/witnessmenow/Universal-Arduino-Telegram-Bot/archive/master.zip" target="_blank">Click here to download the Universal Arduino Telegram Bot library</a>.
Go to <k>Sketch </k>> <k>Include Library</k> > <k>Add .ZIP Library..</k>.
Add the library you've just downloaded.
</ol>
And that's it. The library is installed.
<k>Important: </k>don't install the library through the Arduino Library Manager because it might install a deprecated version.
For all the details about the library, take a look at the Universal Arduino Telegram Bot Library <a href="https://github.com/witnessmenow/Universal-Arduino-Telegram-Bot" target="_blank">GitHub</a> page.
<h3>ArduinoJson Library</h3>
You also have to install the <a href="https://github.com/bblanchon" target="_blank">ArduinoJson</a> library. Follow the next steps to install the library.
<ol>
Go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k>.
Search for ArduinoJson.
Install the library.
</ol>
We're using ArduinoJson library version 6.15.2.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Install-ArduinoJson-Library.png">
<h3>BME280 SparkFun Library</h3>
In most of our projects with the BME280 sensor, we use the Adafruit_BME280 library. However, it conflicts with some of the ESP32-CAM libraries. So, to avoid modifying the library files, we used the<a href="https://github.com/sparkfun/SparkFun_BME280_Arduino_Library" target="_blank"> <k>BME280 Sparkfun library</k></a> instead that works well with the ESP32-CAM. Follow the next steps to install the BME280 Sparkfun library.
<ol>
Go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k>.
Search for Sparkfun BME280.
Install the library.
</ol>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/Install-BME280-SparkFun-Library-Arduino-IDE.png">
<h3>Control ESP32-CAM with Telegram  Arduino Sketch</h3>
The following sketch allows you to control the ESP32-CAM using your Telegram account. You'll also receive a notification with a photo when motion is detected.
Copy the following code to your Arduino IDE. To make it work for you, you need to insert your network credentials (SSID and password), your Telegram Bot Token and your Telegram User ID.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-cam-shield-pcb-telegram/
  
  Project created using Brian Lough's Universal Telegram Bot Library: https://github.com/witnessmenow/Universal-Arduino-Telegram-Bot
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;WiFi.h>
#include &lt;WiFiClientSecure.h>
#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"
#include "esp_camera.h"
#include &lt;UniversalTelegramBot.h>
#include &lt;ArduinoJson.h>
#include &lt;Wire.h>
#include "SparkFunBME280.h"
// Replace with your network credentials
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
// Use @myidbot to find out the chat ID of an individual or a group
// Also note that you need to click "start" on a bot before it can
// message you
String chatId = "XXXXXXXXXX";
// Initialize Telegram BOT
String BOTtoken = "XXXXXXXXXX:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX";
bool sendPhoto = false;
WiFiClientSecure clientTCP;
UniversalTelegramBot bot(BOTtoken, clientTCP);
//CAMERA_MODEL_AI_THINKER
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22
#define FLASH_LED_PIN 4
bool flashState = LOW;
// Motion Sensor
bool motionDetected = false;
// Define I2C Pins for BME280
#define I2C_SDA 14
#define I2C_SCL 15
BME280 bme;
 
int botRequestDelay = 1000;   // mean time between scan messages
long lastTimeBotRan;     // last time messages' scan has been done
void handleNewMessages(int numNewMessages);
String sendPhotoTelegram();
// Get BME280 sensor readings and return them as a String variable
String getReadings(){
  float temperature, humidity;
  temperature = bme.readTempC();
  //temperature = bme.readTempF();
  humidity = bme.readFloatHumidity();
  String message = "Temperature: " + String(temperature) + " oC \n";
  message += "Humidity: " + String (humidity) + " % \n";
  return message;
}
// Indicates when motion is detected
static void IRAM_ATTR detectsMovement(void * arg){
  //Serial.println("MOTION DETECTED!!!");
  motionDetected = true;
}
void setup(){
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0); 
  Serial.begin(115200);
  
  pinMode(FLASH_LED_PIN, OUTPUT);
  digitalWrite(FLASH_LED_PIN, flashState);
  // Init BME280 sensor
  Wire.begin(I2C_SDA, I2C_SCL);
  bme.settings.commInterface = I2C_MODE;
  bme.settings.I2CAddress = 0x76;
  bme.settings.runMode = 3;
  bme.settings.tStandby = 0;
  bme.settings.filter = 0;
  bme.settings.tempOverSample = 1;
  bme.settings.pressOverSample = 1;
  bme.settings.humidOverSample = 1;
  bme.begin();
  
  WiFi.mode(WIFI_STA);
  Serial.println();
  Serial.print("Connecting to ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);
  clientTCP.setCACert(TELEGRAM_CERTIFICATE_ROOT); // Add root certificate for api.telegram.org
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print(".");
    delay(500);
  }
  Serial.println();
  Serial.print("ESP32-CAM IP Address: ");
  Serial.println(WiFi.localIP());
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM;
  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;
  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;
  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;
  config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk = XCLK_GPIO_NUM;
  config.pin_pclk = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM;
  config.pin_href = HREF_GPIO_NUM;
  config.pin_sscb_sda = SIOD_GPIO_NUM;
  config.pin_sscb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn = PWDN_GPIO_NUM;
  config.pin_reset = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG;
  //init with high specs to pre-allocate larger buffers
  if(psramFound()){
    config.frame_size = FRAMESIZE_UXGA;
    config.jpeg_quality = 10;  //0-63 lower number means higher quality
    config.fb_count = 2;
  } else {
    config.frame_size = FRAMESIZE_SVGA;
    config.jpeg_quality = 12;  //0-63 lower number means higher quality
    config.fb_count = 1;
  }
  
  // camera init
  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed with error 0x%x", err);
    delay(1000);
    ESP.restart();
  }
  // Drop down frame size for higher initial frame rate
  sensor_t * s = esp_camera_sensor_get();
  s->set_framesize(s, FRAMESIZE_CIF);  // UXGA|SXGA|XGA|SVGA|VGA|CIF|QVGA|HQVGA|QQVGA
  // PIR Motion Sensor mode INPUT_PULLUP
  //err = gpio_install_isr_service(0); 
  err = gpio_isr_handler_add(GPIO_NUM_13, &detectsMovement, (void *) 13);  
  if (err != ESP_OK){
    Serial.printf("handler add failed with error 0x%x \r\n", err); 
  }
  err = gpio_set_intr_type(GPIO_NUM_13, GPIO_INTR_POSEDGE);
  if (err != ESP_OK){
    Serial.printf("set intr type failed with error 0x%x \r\n", err);
  }
}
void loop(){
  if (sendPhoto){
    Serial.println("Preparing photo");
    sendPhotoTelegram(); 
    sendPhoto = false; 
  }
  if(motionDetected){
    bot.sendMessage(chatId, "Motion detected!!", "");
    Serial.println("Motion Detected");
    sendPhotoTelegram();
    motionDetected = false;
  }
  
  if (millis() > lastTimeBotRan + botRequestDelay){
    int numNewMessages = bot.getUpdates(bot.last_message_received + 1);
    while (numNewMessages){
      Serial.println("got response");
      handleNewMessages(numNewMessages);
      numNewMessages = bot.getUpdates(bot.last_message_received + 1);
    }
    lastTimeBotRan = millis();
  }
}
String sendPhotoTelegram(){
  const char* myDomain = "api.telegram.org";
  String getAll = "";
  String getBody = "";
  camera_fb_t * fb = NULL;
  fb = esp_camera_fb_get();  
  if(!fb) {
    Serial.println("Camera capture failed");
    delay(1000);
    ESP.restart();
    return "Camera capture failed";
  }  
  
  Serial.println("Connect to " + String(myDomain));
  if (clientTCP.connect(myDomain, 443)) {
    Serial.println("Connection successful");
    
    String head = "--RandomNerdTutorials\r\nContent-Disposition: form-data; name=\"chat_id\"; \r\n\r\n" + chatId + "\r\n--RandomNerdTutorials\r\nContent-Disposition: form-data; name=\"photo\"; filename=\"esp32-cam.jpg\"\r\nContent-Type: image/jpeg\r\n\r\n";
    String tail = "\r\n--RandomNerdTutorials--\r\n";
    uint16_t imageLen = fb->len;
    uint16_t extraLen = head.length() + tail.length();
    uint16_t totalLen = imageLen + extraLen;
  
    clientTCP.println("POST /bot"+BOTtoken+"/sendPhoto HTTP/1.1");
    clientTCP.println("Host: " + String(myDomain));
    clientTCP.println("Content-Length: " + String(totalLen));
    clientTCP.println("Content-Type: multipart/form-data; boundary=RandomNerdTutorials");
    clientTCP.println();
    clientTCP.print(head);
  
    uint8_t *fbBuf = fb->buf;
    size_t fbLen = fb->len;
    for (size_t n=0;n&lt;fbLen;n=n+1024) {
      if (n+1024&lt;fbLen) {
        clientTCP.write(fbBuf, 1024);
        fbBuf += 1024;
      }
      else if (fbLen%1024>0) {
        size_t remainder = fbLen%1024;
        clientTCP.write(fbBuf, remainder);
      }
    }  
    
    clientTCP.print(tail);
    
    esp_camera_fb_return(fb);
    
    int waitTime = 10000;   // timeout 10 seconds
    long startTimer = millis();
    boolean state = false;
    
    while ((startTimer + waitTime) > millis()){
      Serial.print(".");
      delay(100);      
      while (clientTCP.available()) {
        char c = clientTCP.read();
        if (state==true) getBody += String(c);        
        if (c == '\n') {
          if (getAll.length()==0) state=true; 
          getAll = "";
        } 
        else if (c != '\r')
          getAll += String(c);
        startTimer = millis();
      }
      if (getBody.length()>0) break;
    }
    clientTCP.stop();
    Serial.println(getBody);
  }
  else {
    getBody="Connected to api.telegram.org failed.";
    Serial.println("Connected to api.telegram.org failed.");
  }
  return getBody;
}
void handleNewMessages(int numNewMessages){
  Serial.print("Handle New Messages: ");
  Serial.println(numNewMessages);
  for (int i = 0; i &lt; numNewMessages; i++){
    // Chat id of the requester
    String chat_id = String(bot.messages[i].chat_id);
    if (chat_id != chatId){
      bot.sendMessage(chat_id, "Unauthorized user", "");
      continue;
    }
    
    // Print the received message
    String text = bot.messages[i].text;
    Serial.println(text);
    String fromName = bot.messages[i].from_name;
    if (text == "/flash") {
      flashState = !flashState;
      digitalWrite(FLASH_LED_PIN, flashState);
    }
    if (text == "/photo") {
      sendPhoto = true;
      Serial.println("New photo  request");
    }
    if (text == "/readings"){
      String readings = getReadings();
      bot.sendMessage(chatId, readings, "");
    }
    if (text == "/start"){
      String welcome = "Welcome to the ESP32-CAM Telegram bot.\n";
      welcome += "/photo : takes a new photo\n";
      welcome += "/flash : toggle flash LED\n";
      welcome += "/readings : request sensor readings\n\n";
      welcome += "You'll receive a photo whenever motion is detected.\n";
      bot.sendMessage(chatId, welcome, "Markdown");
    }
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/ESP32-CAM-Shield-Telegram/raw/master/ESP32_CAM_Shield_PCB_Telegram/ESP32_CAM_Shield_PCB_Telegram.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
Continue reading to learn how the code works, or skip to the next section.
<h3>Importing Libraries</h3>
Start by importing the required libraries.
<k>#include &lt;WiFi.h>
#include &lt;WiFiClientSecure.h>
#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"
#include "esp_camera.h"
#include &lt;UniversalTelegramBot.h>
#include &lt;ArduinoJson.h>
#include &lt;Wire.h>
#include "SparkFunBME280.h"</k>
<h3>Network Credentials</h3>
Insert your network credentials in the following variables.
<k>const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h3>Telegram User ID</h3>
Insert your Telegram chat ID on the chatId variable. The one you've got from the IDBot.
<k>String chatId = "XXXXXXXXXX";</k>
<h3>Telegram Bot Token</h3>
Insert your Telegram Bot token you've got from <k>Botfather</k> on the BOTtoken variable.
<k>String BOTtoken = "XXXXXXXXXX:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX";</k>
The sendPhoto Boolean variable indicates whether it is time to send a new photo to your telegram account. By default, it is set to false.
<k>bool sendPhoto = false;</k>
Create a new WiFi client with WiFiClientSecure.
<k>WiFiClientSecure clientTCP;</k>
Create a bot with the token and client defined earlier.
<k>UniversalTelegramBot bot(BOTtoken, clientTCP);</k>
<h3>Camera Pins</h3>
Define the pins used by the ESP32-CAM:
<k>//CAMERA_MODEL_AI_THINKER
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22</k>
This is the pin definition for the AI-Thinker board, if you're using another camera model, check the  pinout for your board: ESP32-CAM Camera Boards: <a href="https://randomnerdtutorials.com/esp32-cam-camera-pin-gpios/">Pin and GPIOs Assignment Guide</a>.
<h3>Flash LED</h3>
Create a variable to hold the flash LED pin (FLASH_LED_PIN). In the ESP32-CAM AI<U+2011>Thinker, the flash is connected to GPIO 4. By default, set it to LOW.
<k>#define FLASH_LED_PIN 4
bool flashState = LOW;</k>
<h3>Motion Sensor</h3>
The motionDetected variable indicates whether motion has been detected. It is set to false by default.
<k>bool motionDetected = false;</k>
<h3>BME280</h3>
Define the SDA and SCL pins to be used with the BME280. 
<k>#define I2C_SDA 14
#define I2C_SCL 15</k>
Create a BME280 instance called bme.
<k>BME280 bme;</k>
<h3>Request Delay</h3>
The botRequestDelay and lasTimeBotRan variables are used to check for new Telegram messages every x number of seconds. In this case, the code will check for new messages every second (1000 milliseconds). You can change that delay time in the botRequestDelay variable.
<k>int botRequestDelay = 1000;   // mean time between scan messages
long lastTimeBotRan;     // last time messages' scan has been done</k>
<h3>handleNewMessages()</h3>
The handleNewMessages() function handles what happens when new messages arrive.
<k>void handleNewMessages(int numNewMessages){
  Serial.print("Handle New Messages: ");
  Serial.println(numNewMessages);</k>
Get the chat ID for that particular message and store it in the chat_id variable. The chat ID identifies who sent the message.
<k>String chat_id = String(bot.messages[i].chat_id);</k>
If the chat_id is different from your chat ID (chatId), it means that someone (that is not you) has sent a message to your bot. If that's the case, ignore the message and wait for the next message.
<k>if (chat_id != chatId){
  bot.sendMessage(chat_id, "Unauthorized user", "");
  continue;
}</k>
Otherwise, it means that the message was sent from a valid user, so we'll save it in the text variable and check its content.
<k>String text = bot.messages[i].text;
Serial.println(text);</k>
The from_name variable saves the name of the sender.
<k>String fromName = bot.messages[i].from_name;</k>
If it receives the <k>/flash</k> message, invert the flashState variable and update the flash led state. If it was previously LOW, set it to HIGH. If it was previously HIGH, set it to LOW.
<k>if (text == "/flash") {
  flashState = !flashState;
  digitalWrite(FLASH_LED_PIN, flashState);
}</k>
If it receives the <k>/photo</k> message, set the sendPhoto variable to true. Then, in the loop(), we'll check the value of the sendPhoto variable and proceed accordingly.
<k>if (text == "/photo") {
  sendPhoto = true;
  Serial.println("New photo request");
}</k>
If it receives the <k>/readings</k> message, call the getReadings() function (we'll take a look at that function later on) and send the readings to the bot.
<k>if (text == "/readings"){
  String readings = getReadings();
  bot.sendMessage(chatId, readings, "");
}</k>
Sending a message to the bot is very simple. You just need to use the sendMessage() method on the bot object and pass as arguments the recipient's chat ID, the message, and the parse mode.
<k>bool sendMessage(String chat_id, String text, String parse_mode = "")</k>
Finally, if it receives the <k>/start</k> message, we'll send the valid commands to control the ESP. This is useful if you happen to forget what are the commands to control your board.
<k>if (text == "/start"){
  String welcome = "Welcome to the ESP32-CAM Telegram bot.\n";
  welcome += "/photo : takes a new photo\n";
  welcome += "/flash : toggle flash LED\n";
  welcome += "/readings : request sensor readings\n\n";
  welcome += "You'll receive a photo whenever motion is detected.\n";
  bot.sendMessage(chatId, welcome, "Markdown");
}</k>
<h3>sendPhotoTelegram()</h3>
The sendPhotoTelegram() function takes a photo with the ESP32-CAM.
<k>camera_fb_t * fb = NULL;
fb = esp_camera_fb_get();
if(!fb) {
  Serial.println("Camera capture failed");
  delay(1000);
  ESP.restart();
  return "Camera capture failed";
}</k>
Then, it makes an HTTP POST request to send the photo to your telegram bot.
<k>clientTCP.println("POST /bot"+BOTtoken+"/sendPhoto HTTP/1.1");
clientTCP.println("Host: " + String(myDomain));
clientTCP.println("Content-Length: " + String(totalLen));
clientTCP.println("Content-Type: multipart/form-data; boundary=RandomNerdTutorials");
clientTCP.println();
clientTCP.print(head);</k>
<h3>getReadings()</h3>
The getReadings() function requests temperature and humidity from the BME280 sensor.
<k>String getReadings(){
  float temperature, humidity;
  temperature = bme.readTempC();
  //temperature = bme.readTempF();
  humidity = bme.readFloatHumidity();</k>
The readings are concatenated in the message variable that is returned by the function.
<k>String message = "Temperature: " + String(temperature) + " oC \n";
message += "Humidity: " + String (humidity) + " % \n";
return message;</k>
<h3>detectsMovement()</h3>
The detectsMovement() is a callback function that is called when motion is detected. In this case, we set the motionDetected variable to true. Then, in the loop(), we'll handle what happens when there's motion (sends a photo).
<k>static void IRAM_ATTR detectsMovement(void * arg){
  //Serial.println("MOTION DETECTED!!!");
  motionDetected = true;
}</k>
<h3>setup()</h3>
In the setup(), initialize the Serial Monitor.
<k>Serial.begin(115200);</k>
Set the flash LED as an output and set it to its initial state.
<k>pinMode(FLASH_LED_PIN, OUTPUT);
digitalWrite(FLASH_LED_PIN, flashState);</k>
Initialize the BME280 sensor:
<k>// Init BME280 sensor
Wire.begin(I2C_SDA, I2C_SCL);
bme.settings.commInterface = I2C_MODE;
bme.settings.I2CAddress = 0x76;
bme.settings.runMode = 3;
bme.settings.tStandby = 0;
bme.settings.filter = 0;
bme.settings.tempOverSample = 1;
bme.settings.pressOverSample = 1;
bme.settings.humidOverSample = 1;
bme.begin();</k>
Connect your ESP32-CAM to your local network.
<k>WiFi.mode(WIFI_STA);
Serial.println();
Serial.print("Connecting to ");
Serial.println(ssid);
WiFi.begin(ssid, password);
while (WiFi.status() != WL_CONNECTED) {
  Serial.print(".");
  delay(500);
}
Serial.println();
Serial.print("ESP32-CAM IP Address: ");
Serial.println(WiFi.localIP());</k>
Configure and initialize the camera.
<k>camera_config_t config;
config.ledc_channel = LEDC_CHANNEL_0;
config.ledc_timer = LEDC_TIMER_0;
config.pin_d0 = Y2_GPIO_NUM;
config.pin_d1 = Y3_GPIO_NUM;
config.pin_d2 = Y4_GPIO_NUM;
config.pin_d3 = Y5_GPIO_NUM;
config.pin_d4 = Y6_GPIO_NUM;
config.pin_d5 = Y7_GPIO_NUM;
config.pin_d6 = Y8_GPIO_NUM;
config.pin_d7 = Y9_GPIO_NUM;
config.pin_xclk = XCLK_GPIO_NUM;
config.pin_pclk = PCLK_GPIO_NUM;
config.pin_vsync = VSYNC_GPIO_NUM;
config.pin_href = HREF_GPIO_NUM;
config.pin_sscb_sda = SIOD_GPIO_NUM;
config.pin_sscb_scl = SIOC_GPIO_NUM;
config.pin_pwdn = PWDN_GPIO_NUM;
config.pin_reset = RESET_GPIO_NUM;
config.xclk_freq_hz = 20000000;
config.pixel_format = PIXFORMAT_JPEG;
//init with high specs to pre-allocate larger buffers
if(psramFound()){
  config.frame_size = FRAMESIZE_UXGA;
  config.jpeg_quality = 10;  //0-63 lower number means higher quality
  config.fb_count = 2;
} else {
  config.frame_size = FRAMESIZE_SVGA;
  config.jpeg_quality = 12;  //0-63 lower number means higher quality
  config.fb_count = 1;
}
// camera init
esp_err_t err = esp_camera_init(&config);
if (err != ESP_OK) {
  Serial.printf("Camera init failed with error 0x%x", err);
  delay(1000);
  ESP.restart();
}
// Drop down frame size for higher initial frame rate
sensor_t * s = esp_camera_sensor_get();
s->set_framesize(s, FRAMESIZE_CIF);  // UXGA|SXGA|XGA|SVGA|VGA|CIF|QVGA|HQVGA|QQVGA</k>
Setup an interrupt on GPIO 13:
<k>err = gpio_isr_handler_add(GPIO_NUM_13, &detectsMovement, (void *) 13);
if (err != ESP_OK){
  Serial.printf("handler add failed with error 0x%x \r\n", err); 
}
err = gpio_set_intr_type(GPIO_NUM_13, GPIO_INTR_POSEDGE);
if (err != ESP_OK){
  Serial.printf("set intr type failed with error 0x%x \r\n", err);
}</k>
<h3>loop()</h3>
In the loop(), check the state of the sendPhoto variable. If it is true, call the sendPhotoTelegram() function to take and send a photo to your telegram account.
<k>if (sendPhoto){
  Serial.println("Preparing photo");
  sendPhotoTelegram(); 
  sendPhoto = false; 
}</k>
When it's done, set the sendPhoto variable to false.
<k>sendPhoto = false; </k>
When motion is detected, send a notification to your Telegram account and call the senPhototoTelegram() function. Then, set the motionDetected variable to false.
<k>if(motionDetected){
  bot.sendMessage(chatId, "Motion detected!!", "");
  Serial.println("Motion Detected");
  sendPhotoTelegram();
  motionDetected = false;
}</k>
Check for new Telegram messages every second.
<k>if (millis() > lastTimeBotRan + botRequestDelay){
  int numNewMessages = bot.getUpdates(bot.last_message_received + 1);
  while (numNewMessages){
    Serial.println("got response");
    handleNewMessages(numNewMessages);
    numNewMessages = bot.getUpdates(bot.last_message_received + 1);
  }
  lastTimeBotRan = millis();
}</k>
When a new message arrives, call the handleNewMessages() function.
<k>while (numNewMessages){
  Serial.println("got response");
  handleNewMessages(numNewMessages);
  numNewMessages = bot.getUpdates(bot.last_message_received + 1);
}</k>
That's pretty much how the code works.
<h3>Upload Code to the ESP32-CAM</h3>
After making the necessary changes, upload the code to your ESP32-CAM (before connecting the shield). Follow the next steps to upload code or follow this tutorial: <a href="https://randomnerdtutorials.com/program-upload-code-esp32-cam/">How to upload code to ESP32-CAM</a>.
<k>1)</k> Wire the ESP32-CAM to the FTDI programmer as shown in the following diagram.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-CAM-Upload-Code-FTDI-Programmer-Wiring.png">
<k>Note: </k> the order of the FTDI pins on the diagram may not match yours. Make sure you check the silkscreen label next to each pin.
<k>Important: </k> GPIO 0 needs to be connected to GND so that you're able to upload code.
<k>2)</k> Go to <k>Tools </k>> <k>Board </k>and select <k>AI-Thinker ESP32-CAM</k>. You must have the <a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">ESP32 add-on installed</a>. Otherwise, this board won't show up on the Boards menu.
<k>3)</k> Go to <k>Tools </k>> <k>Port </k>and select the COM port the ESP32-CAM is connected to.
<k>4) </k>Then, click the <k>Upload </k>button in your Arduino IDE.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/upload-button-arduino-ide.png">
<k>5)</k> When you start to see some dots on the debugging window, press the ESP32-CAM on-board RST button.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/dots-uploading-code.png">
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/ESP32-CAM-Press-Click-RESET-RST-button-on-board-restart.jpg">
After a few seconds, the code should be successfully uploaded to your board.
<k>6)</k> When you see the <k>Done uploading</k> message, remove GPIO 0 from GND.
Open the Serial Monitor, press the on-board RST button, and check that the ESP32-CAM is connecting to your network without any problems.
<h3>Demonstration</h3>
With the code uploaded to your ESP32-CAM, attach the PCB shield and all the components. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-CAM-Shield-PCB-Stack-to-AI-Thinker-Module.jpg">
Apply power using the 5V and GND pins on the shield.
Then, press the ESP32-CAM RST button, so that it starts running the code. 
Now, open your Telegram account and test your board. Send the following messages to your ESP32 Telegram bot to control your ESP32-CAM:
<k>/start</k>: sends a welcome message with the valid commands to control the shield;
<k>/flash</k>: toggles the ESP32-CAM LED Flash;
<k>/photo</k>: takes a new photo and sends it to your Telegram account;
<k>/readings</k>: requests the latest BME280 sensor readings.
Additionally, you'll receive a notification with a photo whenever motion is detected.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/08/Control-ESP32-CAM-Telegram-Take-Photos-Control-Outputs-Sensor-Readings-Motion.jpg">
If you try to interact with your bot from another account, you'll get the the <k>Unauthorized user</k> message.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Control-ESP32-ESP8266-Outputs-Telegram-Unauthorized-User.png">
<h3>Wrapping Up</h3>
In this tutorial we've created a PCB shield for the ESP32-CAM with a PIR motion sensor and BME280. This creates a more permanent circuit in a small footprint that you can put inside a small enclosure or <a href="https://makeradvisor.com/dummy-fake-dome-security-camera/" target="_blank">dummy camera</a>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/08/ESP32-CAM-AI-Thinker-Module-Shield-PCB-Final-Demonstration-Fake-dummy-surveillance-camera.jpg">
You also learned how to use your Telegram account to control your ESP32-CAM using a Telegram bot. This allows you to control and monitor your board from anywhere, as long as you have internet access in your smartphone.
You can also create your own code to do any other tasks with the shield.
We have other similar projects that include building and designing PCBs that you may like:
<a href="https://randomnerdtutorials.com/esp32-iot-shield-pcb-dashboard/">ESP32 IoT Shield PCB with Dashboard for Outputs and Sensors</a>
<a href="https://randomnerdtutorials.com/build-an-all-in-one-esp32-weather-station-shield/">Build an All-in-One ESP32 Weather Station Shield</a>
<a href="https://randomnerdtutorials.com/esp8266-multisensor-shield/">Build a Multisensor Shield for ESP8266</a>
<a href="https://randomnerdtutorials.com/power-saving-latching-circuit/">EXTREME POWER SAVING with Microcontroller External Wake Up: Latching Power PCB</a>
Learn more about the ESP32-CAM with our resources:
<k><a href="https://randomnerdtutorials.com/esp32-cam-projects-ebook/">Build ESP32-CAM Projects using Arduino IDE eBook</a></k>
<a href="https://randomnerdtutorials.com/projects-esp32-cam/">More ESP32-CAM Projects and Tutorials</a>
We're giving away 5 bare PCBs to someone that posts a comment below (comments might take up to 24 hours to be approved)! Simply post a comment in this blog post about what you would like to do with the PCB and you're entered for a chance to win one of these bare PCBs. We're currently confirm the winners and we will announce them during this weekend (August 22). So, stay tuned! <k>[Update] the giveaway ended and the winners are: Gerald Maurer, Jason Wilkins, Svein Utne, Domenico Carvetta, and Jo<U+00E3>o Paulo.</k>
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/smart-home-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px-pupj8i6e7hlzpgwxe82jjd8skst9vmrjt9lpqb0v0g.jpg" title="Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px" alt="SMART HOME with Raspberry Pi ESP32 and ESP8266 Node-RED InfluxDB eBook" loading="lazy" width="117" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/smart-home-ebook/">SMART HOME with Raspberry Pi, ESP32, ESP8266 [eBook] </a></h4>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>ESP32 Web Server with BME680  Weather Station (Arduino IDE)</a8></h2>
This tutorial shows how to build a web server weather station with the ESP32 to display sensor readings from the BME680 environmental sensor: gas (air quality), temperature, humidity and pressure. The readings are updated automatically on the web server using Server-Sent Events (SSE). The ESP32 will be programmed using Arduino IDE.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-BME680-Gas-sensor-humidity-barometric-pressure-ambient-temperature-gas-air-quality-Arduino-IDE-Web-Server.jpg">
To build the web server we'll use the ESP Async Web Server library that provides an easy way to build an asynchronous web server.
<h3>BME680 Environmental Sensor</h3>
The BME680 is an environmental sensor that combines gas, temperature, humidity and pressure sensors. The gas sensor can detect a broad range of gases like volatile organic compounds (VOC). For this reason, the BME680 can be used in indoor air quality control.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/BME680-Gas-sensor-humidity-barometric-pressure-ambient-temperature-gas-air-quality-front.jpg">
The BME680 contains a MOX (Metal-oxide) sensor that detects VOCs in the air. This sensor gives you a qualitative idea of the<k> sum of VOCs/contaminants</k> in the surrounding air. As a raw signal, the BME680 outputs resistance values. These values change due to variations in VOC concentrations:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/BME680-Gas-Sensor-Resistance-How-It-Works.jpg">
<k>Higher </k>concentration of VOCs <U+00BB> <k>Lower </k>resistance
<k>Lower </k>concentration of VOCs <U+00BB> <k>Higher </k>resistance
For more information about the BME680, read our getting started guide: <a href="http://ESP32:%20BME680%20Environmental%20Sensor%20using%20Arduino%20IDE%20(Gas,%20Pressure,%20Humidity,%20Temperature)" title="https://randomnerdtutorials.com/esp32-bme680-sensor-arduino/">ESP32: BME680 Environmental Sensor using Arduino IDE (Gas, Pressure, Humidity, Temperature)</a>.
<h3>Parts Required</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-Board-BME680-Gas-sensor-circuit-wiring-diagram-schematics.jpg">
To complete this tutorial you need the following parts:
<a href="https://makeradvisor.com/tools/bme680-gas-sensor-module/" target="_blank">BME680 sensor module</a>
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32 </a>(read <a href="https://makeradvisor.com/esp32-development-boards-review-comparison/" target="_blank">Best ESP32 development boards</a>)
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a>
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="lazy" fetchpriority="low"></a>
<h3>Schematic  ESP32 with BME680</h3>
The BME680 can communicate using I2C or SPI communication protocols. In this tutorial, we'll use I2C communication protocol.
Follow the next schematic diagram to wire the BME680 to the ESP32 using the default I2C pins.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32_BME680_Wiring_Diagram_I2C.png">
Recommended reading: <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">ESP32 Pinout Reference  Which GPIO pins should you use?</a>
<h3>Preparing Arduino IDE</h3>
We'll program the ESP32 board using Arduino IDE. So, make sure you have the ESP32 add-on installed. Follow the next tutorial:
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Install the ESP32 Board in Arduino IDE</a>
You also need to install the following libraries.
<a href="https://github.com/adafruit/Adafruit_BME680" target="_blank">Adafruit_BME680 library</a>
<a href="https://github.com/adafruit/Adafruit_Sensor" target="_blank">Adafruit_Sensor library</a>
<a href="https://github.com/me-no-dev/ESPAsyncWebServer" target="_blank">ESPAsyncWebServer</a>
<a href="https://github.com/me-no-dev/AsyncTCP" target="_blank">AsyncTCP</a>
Follow the next instructions to install them.
<h3>Installing the BME680 Library</h3>
To get readings from the BME680 sensor module we'll use the <a href="https://github.com/adafruit/Adafruit_BME680" target="_blank">Adafruit_BME680 library</a>. Follow the next steps to install the library in your Arduino IDE:
Open your Arduino IDE and go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k>. The Library Manager should open.
Search for <k>adafruit bme680</k>  on the Search box and install the library.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/Install-BM6280-Adafruit-Library-Arduino-IDE.png">
<h3>Installing the Adafruit_Sensor Library</h3>
To use the BME680 library, you also need to install the <a href="https://github.com/adafruit/Adafruit_Sensor" target="_blank">Adafruit_Sensor library</a>. Follow the next steps to install the library in your Arduino IDE:
Go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k> and type <k>Adafruit Unified Sensor</k> in the search box. Scroll all the way down to find the library and install it.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/04/adafruit_unified_sensor_library.png">
<h3>Installing the ESPAsyncWebServer library</h3>
The <a href="https://github.com/me-no-dev/ESPAsyncWebServer" target="_blank">ESPAsyncWebServer </a>library is not available to install in the Arduino IDE Library Manager. So, you need to install it manually.
Follow the next steps to install the ESPAsyncWebServer library:
<ol>
<a href="https://github.com/me-no-dev/ESPAsyncWebServer/archive/master.zip" target="_blank">Click here to download the ESPAsyncWebServer library</a>. You should have a .zip folder in your Downloads folder
Unzip the .zip folder and you should get <em>ESPAsyncWebServer-master</em> folder
Rename your folder from <del>ESPAsyncWebServer-master</del> to <em>ESPAsyncWebServer</em>
Move the <em>ESPAsyncWebServer </em>folder to your Arduino IDE installation libraries folder
</ol>
Alternatively, in your Arduino IDE, you can go to <k>Sketch </k>> <k>Include Library</k> > <k>Add .zip Library</k> and select the library you've just downloaded.
<h3>Installing the ESPAsync TCP Library</h3>
The ESPAsyncWebServer library requires the <a href="https://github.com/me-no-dev/ESPAsyncTCP" target="_blank">ESPAsyncTCP</a> library to work. Follow the next steps to install that library:
<ol>
<a href="https://github.com/me-no-dev/ESPAsyncTCP/archive/master.zip" target="_blank">Click here to download the ESPAsyncTCP library</a>. You should have a .zip folder in your Downloads folder
Unzip the .zip folder and you should get <em>ESPAsyncTCP-master</em> folder
Rename your folder from <del>ESPAsyncTCP-master</del> to <em>ESPAsyncTCP</em>
Move the <em>ESPAsyncTCP </em>folder to your Arduino IDE installation libraries folder
Finally, re-open your Arduino IDE
</ol>
Alternatively, in your Arduino IDE, you can go to <k>Sketch </k>> <k>Include Library</k> > <k>Add .zip Library</k> and select the library you've just downloaded.
<h3>ESP32 BME680 Web Server Code</h3>
Open your Arduino IDE and copy the following code. To make it work, you need to insert your network credentials: SSID and password.
<k>/*********
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-bme680-sensor-arduino/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*********/
#include &lt;Wire.h>
#include &lt;SPI.h>
#include &lt;Adafruit_Sensor.h>
#include "Adafruit_BME680.h"
#include &lt;WiFi.h>
#include "ESPAsyncWebServer.h"
// Replace with your network credentials
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
//Uncomment if using SPI
/*#define BME_SCK 18
#define BME_MISO 19
#define BME_MOSI 23
#define BME_CS 5*/
Adafruit_BME680 bme; // I2C
//Adafruit_BME680 bme(BME_CS); // hardware SPI
//Adafruit_BME680 bme(BME_CS, BME_MOSI, BME_MISO, BME_SCK);
float temperature;
float humidity;
float pressure;
float gasResistance;
AsyncWebServer server(80);
AsyncEventSource events("/events");
unsigned long lastTime = 0;  
unsigned long timerDelay = 30000;  // send readings timer
void getBME680Readings(){
  // Tell BME680 to begin measurement.
  unsigned long endTime = bme.beginReading();
  if (endTime == 0) {
    Serial.println(F("Failed to begin reading :("));
    return;
  }
  if (!bme.endReading()) {
    Serial.println(F("Failed to complete reading :("));
    return;
  }
  temperature = bme.temperature;
  pressure = bme.pressure / 100.0;
  humidity = bme.humidity;
  gasResistance = bme.gas_resistance / 1000.0;
}
String processor(const String& var){
  getBME680Readings();
  //Serial.println(var);
  if(var == "TEMPERATURE"){
    return String(temperature);
  }
  else if(var == "HUMIDITY"){
    return String(humidity);
  }
  else if(var == "PRESSURE"){
    return String(pressure);
  }
 else if(var == "GAS"){
    return String(gasResistance);
  }
}
const char index_html[] PROGMEM = R"rawliteral(
&lt;!DOCTYPE HTML>&lt;html>
&lt;head>
  &lt;title>BME680 Web Server&lt;/title>
  &lt;meta name="viewport" content="width=device-width, initial-scale=1">
  &lt;link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
  &lt;link rel="icon" href="data:,">
  &lt;style>
    html {font-family: Arial; display: inline-block; text-align: center;}
    p {  font-size: 1.2rem;}
    body {  margin: 0;}
    .topnav { overflow: hidden; background-color: #4B1D3F; color: white; font-size: 1.7rem; }
    .content { padding: 20px; }
    .card { background-color: white; box-shadow: 2px 2px 12px 1px rgba(140,140,140,.5); }
    .cards { max-width: 700px; margin: 0 auto; display: grid; grid-gap: 2rem; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); }
    .reading { font-size: 2.8rem; }
    .card.temperature { color: #0e7c7b; }
    .card.humidity { color: #17bebb; }
    .card.pressure { color: #3fca6b; }
    .card.gas { color: #d62246; }
  &lt;/style>
&lt;/head>
&lt;body>
  &lt;div>
    &lt;h3>BME680 WEB SERVER&lt;/h3>
  &lt;/div>
  &lt;div>
    &lt;div>
      &lt;div>
        &lt;h4>&lt;i>&lt;/i> TEMPERATURE&lt;/h4>&lt;p>&lt;span>&lt;span>%TEMPERATURE%&lt;/span> &deg;C&lt;/span>&lt;/p>
      &lt;/div>
      &lt;div>
        &lt;h4>&lt;i>&lt;/i> HUMIDITY&lt;/h4>&lt;p>&lt;span>&lt;span>%HUMIDITY%&lt;/span> &percnt;&lt;/span>&lt;/p>
      &lt;/div>
      &lt;div>
        &lt;h4>&lt;i>&lt;/i> PRESSURE&lt;/h4>&lt;p>&lt;span>&lt;span>%PRESSURE%&lt;/span> hPa&lt;/span>&lt;/p>
      &lt;/div>
      &lt;div>
        &lt;h4>&lt;i>&lt;/i> GAS&lt;/h4>&lt;p>&lt;span>&lt;span>%GAS%&lt;/span> K&ohm;&lt;/span>&lt;/p>
      &lt;/div>
    &lt;/div>
  &lt;/div>
&lt;script>
if (!!window.EventSource) {
 var source = new EventSource('/events');
 
 source.addEventListener('open', function(e) {
  console.log("Events Connected");
 }, false);
 source.addEventListener('error', function(e) {
  if (e.target.readyState != EventSource.OPEN) {
    console.log("Events Disconnected");
  }
 }, false);
 
 source.addEventListener('message', function(e) {
  console.log("message", e.data);
 }, false);
 
 source.addEventListener('temperature', function(e) {
  console.log("temperature", e.data);
  document.getElementById("temp").innerHTML = e.data;
 }, false);
 
 source.addEventListener('humidity', function(e) {
  console.log("humidity", e.data);
  document.getElementById("hum").innerHTML = e.data;
 }, false);
 
 source.addEventListener('pressure', function(e) {
  console.log("pressure", e.data);
  document.getElementById("pres").innerHTML = e.data;
 }, false);
 
 source.addEventListener('gas', function(e) {
  console.log("gas", e.data);
  document.getElementById("gas").innerHTML = e.data;
 }, false);
}
&lt;/script>
&lt;/body>
&lt;/html>)rawliteral";
void setup() {
  Serial.begin(115200);
  // Set the device as a Station and Soft Access Point simultaneously
  WiFi.mode(WIFI_AP_STA);
  
  // Set device as a Wi-Fi Station
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Setting as a Wi-Fi Station..");
  }
  Serial.print("Station IP Address: ");
  Serial.println(WiFi.localIP());
  Serial.println();
  // Init BME680 sensor
  if (!bme.begin()) {
    Serial.println(F("Could not find a valid BME680 sensor, check wiring!"));
    while (1);
  }
  // Set up oversampling and filter initialization
  bme.setTemperatureOversampling(BME680_OS_8X);
  bme.setHumidityOversampling(BME680_OS_2X);
  bme.setPressureOversampling(BME680_OS_4X);
  bme.setIIRFilterSize(BME680_FILTER_SIZE_3);
  bme.setGasHeater(320, 150); // 320*C for 150 ms
  // Handle Web Server
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send_P(200, "text/html", index_html, processor);
  });
  // Handle Web Server Events
  events.onConnect([](AsyncEventSourceClient *client){
    if(client->lastId()){
      Serial.printf("Client reconnected! Last message ID that it got is: %u\n", client->lastId());
    }
    // send event with message "hello!", id current millis
    // and set reconnect delay to 1 second
    client->send("hello!", NULL, millis(), 10000);
  });
  server.addHandler(&events);
  server.begin();
}
void loop() {
  if ((millis() - lastTime) > timerDelay) {
    getBME680Readings();
    Serial.printf("Temperature = %.2f oC \n", temperature);
    Serial.printf("Humidity = %.2f % \n", humidity);
    Serial.printf("Pressure = %.2f hPa \n", pressure);
    Serial.printf("Gas Resistance = %.2f KOhm \n", gasResistance);
    Serial.println();
    // Send Events to the Web Server with the Sensor Readings
    events.send("ping",NULL,millis());
    events.send(String(temperature).c_str(),"temperature",millis());
    events.send(String(humidity).c_str(),"humidity",millis());
    events.send(String(pressure).c_str(),"pressure",millis());
    events.send(String(gasResistance).c_str(),"gas",millis());
    
    lastTime = millis();
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_BME680_Web_Server.ino" target="_blank">View raw code</a>
Insert your network credentials in the following variables and the code will work straight away.
<k>const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h3>How the Code Works</h3>
Read this section to learn how the code works, or skip to the next section.
<h3>Including Libraries</h3>
Start by including the necessary libraries. The Wire library is needed for I2C communication protocol. We also include the SPI library if you want to use SPI communication instead. 
<k>#include &lt;Wire.h>
#include &lt;SPI.h></k>
The Adafruit_Sensor and Adafruit_BME680 libraries are needed to interface with the BME680 sensor.
<k>#include &lt;Adafruit_Sensor.h>
#include "Adafruit_BME680.h"</k>
The WiFi and ESPAsyncWebServer libraries are used to create the web server.
<k>#include &lt;WiFi.h>
#include "ESPAsyncWebServer.h"</k>
<h3>Network Credentials</h3>
Insert your network credentials in the following variables, so that the ESP32 can connect to your local network using Wi-Fi.
<k>const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h3>I2C Communication</h3>
Create an Adafruit_BME680 object called bme on the default ESP32 I2C pins.
<k>Adafruit_BME680 bme; // I2C</k>
If you want to use SPI communication instead, you need to define the ESP32 SPI pins on the following lines (to uncomment remove the /* and */):
<k>/*#define BME_SCK 18
#define BME_MISO 19
#define BME_MOSI 23
#define BME_CS 15*/</k>
And then, create an Adafruit_BME680 object using those pins (to uncomment remove the //).
<k>//Adafruit_BME680 bme(BME_CS, BME_MOSI, BME_MISO, BME_SCK);</k>
<h3>Declaring Variables</h3>
The temperature, humidity, pressure and gasResistance float variables will be used to hold BME680 sensor readings.
<k>float temperature;
float humidity;
float pressure;
float gasResistance;</k>
The lastTime and the timerDelay variables will be used to update sensor readings every X number of seconds. As an example, we'll get new sensor readings every 30 seconds (30000 milliseconds). You can change that delay time in the timerDelay variable.
<k>unsigned long lastTime = 0;
unsigned long timerDelay = 30000;</k>
Create an Async Web Server on port 80.
<k>AsyncWebServer server(80);</k>
<h3>Create Event Source</h3>
To automatically display the information on the web server when a new reading arrives, we'll use Server-Sent Events (SSE).
The following line creates a new event source on /events.
<k>AsyncEventSource events("/events");</k>
Server-Sent Events allow a web page (client) to get updates from a server. We'll use this to automatically display new readings on the web server page when new BME680 readings are available.
<k>Important: </k> Server-sent events are not supported on Internet Explorer.
<h3>Get BME680 Readings</h3>
The getBME680Reading() function gets gas, temperature, humidity and pressure readings from the BME680 sensor and saves them on the gasResistance, temperature, humidity and pressure variables.
<k>void getBME680Readings(){
  // Tell BME680 to begin measurement.
  unsigned long endTime = bme.beginReading();
  if (endTime == 0) {
    Serial.println(F("Failed to begin reading :("));
    return;
  }
  if (!bme.endReading()) {
    Serial.println(F("Failed to complete reading :("));
    return;
  }
  temperature = bme.temperature;
  pressure = bme.pressure / 100.0;
  humidity = bme.humidity;
  gasResistance = bme.gas_resistance / 1000.0;
}</k>
<h3>Processor</h3>
The processor() function replaces any placeholders on the HTML text used to build the web page with the current sensor readings.
<k>String processor(const String& var){
  getBME680Readings();
  //Serial.println(var);
  if(var == "TEMPERATURE"){
    return String(temperature);
  }
  else if(var == "HUMIDITY"){
    return String(humidity);
  }
  else if(var == "PRESSURE"){
    return String(pressure);
  }
 else if(var == "GAS"){
    return String(gasResistance);
  }
}</k>
This allows us to display the current sensor readings on the web page when you access it for the first time. Otherwise, you would see a blank space until new readings were available (which can take some time depending on the delay time you've defined on the code).
<h3>Building the Web Page</h3>
The index_html variable contains all the HTML, CSS and JavaScript to build the web page. We won't go into detail on how the HTML and CSS works. We'll just take a look at how to handle the events sent by the server.
Let's take a quick look at the line that displays the temperature:
<k>&lt;h4>&lt;i>&lt;/i> TEMPERATURE&lt;/h4>&lt;p>&lt;span>&lt;span>%TEMPERATURE%&lt;/span> &deg;C&lt;/span>&lt;/p></k>
You can see that the %TEMPERATURE% placeholder is surrounded by &lt;span id=temp>&lt;/span> tags. The HTML id attribute is used to specify a unique id for an HTML element.
It is used to point to a specific style or it can be used by JavaScript to access and manipulate the element with that specific id. That's what we're going to do. 
For instance, when the web server receives a new event with the latest temperature reading, we'll update the HTML element with the id temp with the new reading.
A similar process is done to update the other readings.
<h4>Handle Events</h4>
Create a new EventSource object and specify the URL of the page sending the updates. In our case, it's /events.
<k>if (!!window.EventSource) {
  var source = new EventSource('/events');</k>
Once you've instantiated an event source, you can start listening for messages from the server with addEventListener().
These are the default event listeners, as shown here in the AsyncWebServer <a href="https://github.com/me-no-dev/ESPAsyncWebServer#setup-event-source-in-the-browser" target="_blank">documentation</a>.
<k>source.addEventListener('open', function(e) {
  console.log("Events Connected");
}, false);
source.addEventListener('error', function(e) {
 if (e.target.readyState != EventSource.OPEN) {
   console.log("Events Disconnected");
 }
}, false);
source.addEventListener('message', function(e) {
 console.log("message", e.data);
}, false);</k>
Then, add the event listener for temperature.
<k>source.addEventListener('temperature', function(e) {</k>
When a new temperature reading is available, the ESP32 sends an event (temperature) to the client. The following lines handle what happens when the browser receives that event.
<k>console.log("temperature", e.data);
document.getElementById("temp").innerHTML = e.data;</k>
Basically, print the new readings on the browser console, and put the received data into the element with the corresponding id (temp) on the web page.
A similar processor is done for humidity, pressure and gas resistance.
<k>source.addEventListener('humidity', function(e) {
  console.log("humidity", e.data);
  document.getElementById("hum").innerHTML = e.data;
}, false);
 
source.addEventListener('pressure', function(e) {
  console.log("pressure", e.data);
  document.getElementById("pres").innerHTML = e.data;
}, false);
 
source.addEventListener('gas', function(e) {
  console.log("gas", e.data);
  document.getElementById("gas").innerHTML = e.data;
}, false);</k>
<h3>setup()</h3>
In the setup(), initialize the Serial Monitor.
<k>Serial.begin(115200);</k>
Connect the ESP32 to your local network and print the ESP32 IP address.
<k>// Set device as a Wi-Fi Station
WiFi.begin(ssid, password);
while (WiFi.status() != WL_CONNECTED) {
  delay(1000);
  Serial.println("Setting as a Wi-Fi Station..");
}
Serial.print("Station IP Address: ");
Serial.println(WiFi.localIP());
Serial.println();</k>
Initialize the BME680 sensor.
<k>// Init BME680 sensor
if (!bme.begin()) {
  Serial.println(F("Could not find a valid BME680 sensor, check wiring!"));
  while (1);
}
// Set up oversampling and filter initialization
bme.setTemperatureOversampling(BME680_OS_8X);
bme.setHumidityOversampling(BME680_OS_2X);
bme.setPressureOversampling(BME680_OS_4X);
bme.setIIRFilterSize(BME680_FILTER_SIZE_3);
bme.setGasHeater(320, 150); // 320*C for 150 ms</k>
<h4>Handle Requests</h4>
When you access the ESP32 IP address on the root / URL, send the text that is stored on the index_html variable to build the web page and pass the processor as argument, so that all placeholders are replaced with the latest sensor readings.
<k>server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
  request->send_P(200, "text/html", index_html, processor);
});</k>
<h4>Server Event Source</h4>
Set up the event source on the server.
<k>// Handle Web Server Events
events.onConnect([](AsyncEventSourceClient *client){
  if(client->lastId()){
    Serial.printf("Client reconnected! Last message ID that it got is: %u\n", client->lastId());
  }
  // send event with message "hello!", id current millis
  // and set reconnect delay to 1 second
  client->send("hello!", NULL, millis(), 10000);
});
server.addHandler(&events);</k>
Finally, start the server.
<k>server.begin();</k>
<h3>loop()</h3>
In the loop(), get new sensor readings:
<k>getBME680Readings();</k>
Print the new readings in the Serial Monitor.
<k>Serial.printf("Temperature = %.2f oC \n", temperature);
Serial.printf("Humidity = %.2f % \n", humidity);
Serial.printf("Pressure = %.2f hPa \n", pressure);
Serial.printf("Gas Resistance = %.2f KOhm \n", gasResistance);
Serial.println();</k>
Finally, send events to the browser with the newest sensor readings to update the web page.
<k>// Send Events to the Web Server with the Sensor Readings
events.send("ping",NULL,millis());
events.send(String(temperature).c_str(),"temperature",millis());
events.send(String(humidity).c_str(),"humidity",millis());
events.send(String(pressure).c_str(),"pressure",millis());
events.send(String(gasResistance).c_str(),"gas",millis());</k>
The following diagram summarizes how Server-Sent Events work to update the web page.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/Server-Sent-Events-BME680-Web-server-ESP32-Arduino-IDE.png">
<h3>Uploading the Code</h3>
Now, upload the code to your ESP32. Make sure you have the right board and COM port selected.
After uploading, open the Serial Monitor at a baud rate of 115200. Press the ESP32 on-board RST/EN button. The ESP32 IP address should be printed in the serial monitor.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-IP-Address-Serial-Monitor.png">
<h3>Demonstration</h3>
Open a browser in your local network and type the ESP32 IP address. You should get access to the ESP32 web server with the latest BME680 readings.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-BME680-Gas-sensor-Web-Server-Demonstration.jpg">
The readings are updated automatically using Server-Sent Events.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-ESP8266-NodeMCU-Web-Server-with-BME680-Gas-sensor.jpg">
<h3>Wrapping Up </h3>
In this tutorial you've learned how to build an asynchronous web server weather station with the ESP32 to display BME680 sensor readings  gas (air quality), temperature, humidity and pressure  and how to update the readings automatically on the web page using Server-Sent Events.
We have other web server tutorials that you may like:
<a href="https://randomnerdtutorials.com/esp32-dht11-dht22-temperature-humidity-web-server-arduino-ide/">ESP32 <k>DHT11/DHT22 Web Server</k>  Temperature and Humidity using Arduino IDE</a>
<a href="https://randomnerdtutorials.com/esp32-async-web-server-espasyncwebserver-library/">ESP32 Async <k>Web Server  Control Outputs </k>with Arduino IDE</a>
<a href="https://randomnerdtutorials.com/esp32-web-server-with-bme280-mini-weather-station/">ESP32 <k>Web Server with BME280</k>  Advanced Weather Station</a>
<a href="https://randomnerdtutorials.com/esp32-ds18b20-temperature-arduino-ide/">ESP32 <k>DS18B20</k> Temperature Sensor with Arduino IDE (Single, Multiple, <k>Web Server</k>)</a>
We hope you've found this project interesting. Learn more about the ESP32 with our resources:
<a href="https://randomnerdtutorials.com/learn-esp32-with-arduino-ide/">Learn ESP32 with Arduino IDE (eBook + Video Course)</a>
<a href="https://randomnerdtutorials.com/micropython-programming-with-esp32-and-esp8266/">MicroPython Programming with ESP32 and ESP8266</a>
<a href="https://randomnerdtutorials.com/projects-esp32/">More ESP32 Projects and Tutorials</a>
Thanks for reading.
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h-p2lw6wwnkk9ystvwe9iof8zx6yt4x7uma3cqfup534.jpg" title="Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h" alt="Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h" loading="lazy" width="129" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/">[eBook] Build Web Servers with ESP32 and ESP8266 (2nd Edition)</a></h4>
Build Web Server projects with the ESP32 and ESP8266 boards to control outputs and monitor sensors remotely. Learn HTML, CSS, JavaScript and client-server communication protocols <k><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Build Web Server projects with the ESP32 and ESP8266 boards to control outputs and monitor sensors remotely. Learn HTML, CSS, JavaScript and client-server communication protocols <k><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>ESP32: BME680 Environmental Sensor using Arduino IDE (Gas, Pressure, Humidity, Temperature)</h2>
The BME680 is an environmental digital sensor that measures gas, pressure, humidity and temperature. In this guide you'll learn how to use the BME680 sensor module with the ESP32 board using Arduino IDE. The sensor communicates with a microcontroller using I2C or SPI communication protocols.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP8266-NodeMCU-BME680-Gas-sensor-humidity-barometric-pressure-ambient-temperature-gas-air-quality-Arduino-IDE.jpg">
You'll learn how to wire the sensor to the ESP32 board, install the required libraries, use a simple sketch to display the sensor readings in the Serial Monitor and build a web server to monitor your sensor remotely.
<h3>Introducing BME680 Environmental Sensor Module</h3>
The BME680 is an environmental sensor that combines gas, pressure, humidity and temperature sensors. The gas sensor can detect a broad range of gases like volatile organic compounds (VOC). For this reason, the BME680 can be used in indoor air quality control.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/BME680-Gas-sensor-humidity-barometric-pressure-ambient-temperature-gas-air-quality-front.jpg">
<h3>BME680 Measurements</h3>
The BME680 is a 4-in-1 digital sensor that measures:
Temperature
Humidity
Barometric pressure
Gas: Volatile Organic Compounds (VOC) like ethanol and carbon monoxide
<h3>Gas Sensor</h3>
The BME680 contains a MOX (Metal-oxide) sensor that detects VOCs in the air. This sensor gives you a qualitative idea of the<k> sum of VOCs/contaminants</k> in the surrounding air  <k>it is not specific</k> for a specific gas molecule.
MOX sensors are composed of a metal-oxide surface, a sensing chip to measure changes in conductivity, and a heater. It detects VOCs by adsorption of oxygen molecules on its sensitive layer. The BME680 reacts to most VOCs polluting indoor air (except CO2). 
When the sensor comes into contact with the reducing gases, the oxygen molecules react and increase the conductivity across the surface. As a raw signal, the BME680 outputs resistance values. These values change due to variations in VOC concentrations:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/BME680-Gas-Sensor-Resistance-How-It-Works.jpg">
<k>Higher </k>concentration of VOCs <U+00BB> <k>Lower </k>resistance
<k>Lower </k>concentration of VOCs <U+00BB> <k>Higher </k>resistance
The reactions that occur on the sensor surface (thus, the resistance) are influenced by parameters other than VOC concentration like temperature and humidity.
<h3>Relevant Information Regarding Gas Sensor</h3>
The gas sensor gives you a qualitative idea of VOCs gasses in the surrounding air. So, you can get trends, compare your results and see if the air quality is increasing or decreasing. To get precise measurements, you need to calibrate the sensor against knows sources and build a calibration curve.
When you first get the sensor, it is recommended to run it for 48 hours after start collecting real data. After that, it is also recommend to run the sensor for 30 minutes before getting a gas reading.
<h3>BME680 Accuracy</h3>
Here's the accuracy of the temperature, humidity and pressure sensors of the BME680:
<table><tbody>
<tr>
<td><k>Sensor</k></td>
<td><k>Accuracy</k></td>
</tr>
<tr>
<td>Temperature</td>
<td>+/- 1.0oC</td>
</tr>
<tr>
<td>Humidity</td>
<td>+/- 3%</td>
</tr>
<tr>
<td>Pressure</td>
<td>+/- 1 hPa</td>
</tr>
</tbody></table><h3>BME680 Operation Range</h3>
The following table shows the operation range for the temperature, humidity and pressure sensors for the BME680.
<table><tbody>
<tr>
<td><k>Sensor</k></td>
<td>
<k>Operation </k>Range</td>
</tr>
<tr>
<td>Temperature</td>
<td>-40 to 85 oC</td>
</tr>
<tr>
<td>Humidity</td>
<td>0 to 100 %</td>
</tr>
<tr>
<td>Pressure</td>
<td>300 to 1100 hPa</td>
</tr>
</tbody></table><h3>BME680 Pinout</h3>
Here's the BME680 Pinout:
<table><tbody>
<tr>
<td><k>VCC</k></td>
<td>Powers the sensor</td>
</tr>
<tr>
<td><k>GND</k></td>
<td>Common GND</td>
</tr>
<tr>
<td><k>SCL</k></td>
<td>SCL pin for I2C communication
SCK pin for SPI communication</td>
</tr>
<tr>
<td><k>SDA</k></td>
<td>SDA pin for I2C communication
SDI (MOSI) pin for SPI communication</td>
</tr>
<tr>
<td><k>SDO</k></td>
<td>SDO (MISO) pin for SPI communication</td>
</tr>
<tr>
<td><k>CS</k></td>
<td>Chip select pin for SPI communication</td>
</tr>
</tbody></table><h3>BME680 Interface</h3>
The BME680 supports I2C and SPI Interfaces.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/BME680-Gas-sensor-humidity-barometric-pressure-ambient-temperature-gas-air-quality-back.jpg">
<h4>BME680 I2C</h4>
To use I2C communication protocol, use the following pins:
<table><tbody>
<tr>
<td><k>BME680</k></td>
<td><k>ESP32</k></td>
</tr>
<tr>
<td>SCL</td>
<td>
GPIO22 </td>
</tr>
<tr>
<td>SDA</td>
<td>
GPIO 21 </td>
</tr>
</tbody></table>GPIO 22 (SCL) and GPIO 21 (SDA) are the default <a href="https://randomnerdtutorials.com/esp32-i2c-communication-arduino-ide/">ESP32 I2C pins</a>. You can use other pins as long as you set them properly on code.
Recommended reading: <a href="https://randomnerdtutorials.com/esp32-i2c-communication-arduino-ide/">ESP32 I2C Communication: Set Pins, Multiple Bus Interfaces and Peripherals (Arduino IDE)</a>
<h4>BME680 SPI</h4>
To use SPI communication protocol, use the following pins:
<table><tbody>
<tr>
<td><k>BME680</k></td>
<td><k>ESP32</k></td>
</tr>
<tr>
<td>SCL (SCK SPI Clock)</td>
<td>
GPIO 18 </td>
</tr>
<tr>
<td>SDA (SDI MOSI)</td>
<td>
GPIO 23 </td>
</tr>
<tr>
<td>SDO (MISO)</td>
<td>
GPIO 19 </td>
</tr>
<tr>
<td>CS (Chip Select)</td>
<td>
GPIO 5 </td>
</tr>
</tbody></table>These are the default ESP32 SPI pins. You can use other pins as long as you set them properly in the code.
<h3>Parts Required</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-Board-BME680-Gas-sensor-circuit-wiring-diagram-schematics.jpg">
To complete this tutorial you need the following parts:
<a href="https://makeradvisor.com/tools/bme680-gas-sensor-module/" target="_blank">BME680 sensor module</a>
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32 </a>(read <a href="https://makeradvisor.com/esp32-development-boards-review-comparison/" target="_blank">Best ESP32 development boards</a>)
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a>
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="lazy" fetchpriority="low"></a>
<h3>Schematic  ESP32 with BME680</h3>
The BME680 can communicate using I2C or SPI communication protocols.
<k>ESP32 with BME680 using I2C</k>
Follow the next schematic diagram to wire the BME680 to the ESP32 using the default I2C pins.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32_BME680_Wiring_Diagram_I2C.png">
<k>ESP32 with BME680 using SPI</k>
Alternatively, you may want to use SPI communication protocol instead. In that case, follow the next schematic diagram to wire the BME680 to the ESP32 using the default SPI pins.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32_BME680_Wiring_Diagram_SPI.png">
Recommended reading: <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">ESP32 Pinout Reference: Which GPIO pins should you use?</a>
<h3>Preparing Arduino IDE</h3>
We'll program the ESP32 board using Arduino IDE. So, make sure you have the ESP32 add-on installed. Follow the next tutorial:
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Install the ESP32 Board in Arduino IDE</a>
You also need to install the Adafruit BME680 library and the Adafruit Unified Sensor library.
<h3>Installing the BME680 Library</h3>
To get readings from the BME680 sensor module we'll use the <a href="https://github.com/adafruit/Adafruit_BME680" target="_blank">Adafruit_BME680 library</a>. Follow the next steps to install the library in your Arduino IDE:
Open your Arduino IDE and go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k>. The Library Manager should open.
Search for <k>adafruit bme680</k>  on the Search box and install the library.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/Install-BM6280-Adafruit-Library-Arduino-IDE.png">
<h3>Installing the Adafruit_Sensor Library</h3>
To use the BME680 library, you also need to install the <a href="https://github.com/adafruit/Adafruit_Sensor" target="_blank">Adafruit_Sensor library</a>. Follow the next steps to install the library in your Arduino IDE:
Go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k> and type <k>Adafruit Unified Sensor</k> in the search box. Scroll all the way down to find the library and install it.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/04/adafruit_unified_sensor_library.png">
After installing the libraries, restart your Arduino IDE.
<h3>Code  Reading BME680 Gas, Pressure, Humidity and Temperature</h3>
To read gas, pressure, temperature, and humidity we'll use a sketch example from the library.
After installing the BME680 library, and the Adafruit_Sensor library, open the Arduino IDE and, go to <k>File</k> > <k>Examples</k> > <k>Adafruit BME680 Library</k> > <k>bme680async</k>.
<k>/***
  Read Our Complete Guide: https://RandomNerdTutorials.com/esp32-bme680-sensor-arduino/
  Designed specifically to work with the Adafruit BME680 Breakout ----> http://www.adafruit.com/products/3660 These sensors use I2C or SPI to communicate, 2 or 4 pins are required to interface. Adafruit invests time and resources providing this open source code, please support Adafruit and open-source hardware by purchasing products from Adafruit! Written by Limor Fried & Kevin Townsend for Adafruit Industries. BSD license, all text above must be included in any redistribution
***/
#include &lt;Wire.h>
#include &lt;SPI.h>
#include &lt;Adafruit_Sensor.h>
#include "Adafruit_BME680.h"
/*#define BME_SCK 18
#define BME_MISO 19
#define BME_MOSI 23
#define BME_CS 5*/
#define SEALEVELPRESSURE_HPA (1013.25)
Adafruit_BME680 bme; // I2C
//Adafruit_BME680 bme(BME_CS); // hardware SPI
//Adafruit_BME680 bme(BME_CS, BME_MOSI, BME_MISO, BME_SCK);
void setup() {
  Serial.begin(115200);
  while (!Serial);
  Serial.println(F("BME680 async test"));
  if (!bme.begin()) {
    Serial.println(F("Could not find a valid BME680 sensor, check wiring!"));
    while (1);
  }
  // Set up oversampling and filter initialization
  bme.setTemperatureOversampling(BME680_OS_8X);
  bme.setHumidityOversampling(BME680_OS_2X);
  bme.setPressureOversampling(BME680_OS_4X);
  bme.setIIRFilterSize(BME680_FILTER_SIZE_3);
  bme.setGasHeater(320, 150); // 320*C for 150 ms
}
void loop() {
  // Tell BME680 to begin measurement.
  unsigned long endTime = bme.beginReading();
  if (endTime == 0) {
    Serial.println(F("Failed to begin reading :("));
    return;
  }
  Serial.print(F("Reading started at "));
  Serial.print(millis());
  Serial.print(F(" and will finish at "));
  Serial.println(endTime);
  Serial.println(F("You can do other work during BME680 measurement."));
  delay(50); // This represents parallel work.
  // There's no need to delay() until millis() >= endTime: bme.endReading()
  // takes care of that. It's okay for parallel work to take longer than
  // BME680's measurement time.
  // Obtain measurement results from BME680. Note that this operation isn't
  // instantaneous even if milli() >= endTime due to I2C/SPI latency.
  if (!bme.endReading()) {
    Serial.println(F("Failed to complete reading :("));
    return;
  }
  Serial.print(F("Reading completed at "));
  Serial.println(millis());
  Serial.print(F("Temperature = "));
  Serial.print(bme.temperature);
  Serial.println(F(" *C"));
  Serial.print(F("Pressure = "));
  Serial.print(bme.pressure / 100.0);
  Serial.println(F(" hPa"));
  Serial.print(F("Humidity = "));
  Serial.print(bme.humidity);
  Serial.println(F(" %"));
  Serial.print(F("Gas = "));
  Serial.print(bme.gas_resistance / 1000.0);
  Serial.println(F(" KOhms"));
  Serial.print(F("Approx. Altitude = "));
  Serial.print(bme.readAltitude(SEALEVELPRESSURE_HPA));
  Serial.println(F(" m"));
  Serial.println();
  delay(2000);
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_BME680.ino" target="_blank">View raw code</a>
We've made a few changes to the sketch to make it fully compatible with the ESP32.
<h3>How the Code Works</h3>
Continue reading this section to learn how the code works, or skip to the Demonstration section.
<h3>Libraries</h3>
The code starts by including the needed libraries: the wire library to use I2C, the SPI library (if you want to use SPI instead of I2C), the Adafruit_Sensor and Adafruit_BME680 libraries to interface with the BME680 sensor.
<k>#include &lt;Wire.h>
#include &lt;SPI.h>
#include &lt;Adafruit_Sensor.h>
#include "Adafruit_BME680.h"</k>
<h3>SPI communication</h3>
We prefer to use I2C communication protocol with the sensor. However, the code is prepared if you want to use SPI. You just need to uncomment the following lines of code that define the SPI pins.
<k>/*#define BME_SCK 18
#define BME_MISO 19
#define BME_MOSI 23
#define BME_CS 15*/</k>
<h3>Sea level pressure</h3>
A variable called SEALEVELPRESSURE_HPA is created.
<k>#define SEALEVELPRESSURE_HPA (1013.25)</k>
This variable saves the pressure at the sea level in hectopascal (is equivalent to milibar). This variable is used to estimate the altitude for a given pressure by comparing it with the sea level pressure. This example uses the default value, but for accurate results, replace the value with the current sea level pressure at your location.
<h3>I2C</h3>
This example uses I2C communication protocol by default. The following line creates an Adafruit_BME680 object called bme on the default ESP32 I2C pins: GPIO 22 (SCL), GPIO 21 (SDA).
<k>Adafruit_BME680 bme; // I2C</k>
To use SPI, you need to comment this previous line and uncomment the following line.
<k>//Adafruit_BME680 bme(BME_CS, BME_MOSI, BME_MISO, BME_SCK); // software SPI</k>
<h3>setup()</h3>
In the setup() start a serial communication.
<k>Serial.begin(115200);</k>
<h4>Init BME680 Sensor</h4>
Initialize the BME680 sensor:
<k>if (!bme.begin()) {
  Serial.println(F("Could not find a valid BME680 sensor, check wiring!"));
  while (1);
}</k>
Set up the following parameters (oversampling, filter and gas heater) for the sensor.
<k>// Set up oversampling and filter initialization
bme.setTemperatureOversampling(BME680_OS_8X);
bme.setHumidityOversampling(BME680_OS_2X);
bme.setPressureOversampling(BME680_OS_4X);
bme.setIIRFilterSize(BME680_FILTER_SIZE_3);
bme.setGasHeater(320, 150); // 320*C for 150 ms</k>
To increase the resolution of the raw sensor data, it supports oversampling. We'll use the default oversampling parameters, but you can change them.
setTemperatureOversampling(): set temperature oversampling.
setHumidityOversampling(): set humidity oversampling.
setPressureOversampling(): set pressure oversampling.
These methods can accepts one of the following parameters:
BME680_OS_NONE: turn off reading;
BME680_OS_1X
BME680_OS_2X
BME680_OS_4X
BME680_OS_8X
BME680_OS_16X
The BME680 sensor integrates an internal IIR filter to reduce short-term changes in sensor output values caused by external disturbances. The setIIRFilterSize() method sets the IIR filter. It accepts the filter size as a parameter:
BME680_FILTER_SIZE_0 (no filtering)
BME680_FILTER_SIZE_1
BME680_FILTER_SIZE_3
BME680_FILTER_SIZE_7 
BME680_FILTER_SIZE_15 
BME680_FILTER_SIZE_31
BME680_FILTER_SIZE_63
BME680_FILTER_SIZE_127
The gas sensor integrates a heater. Set the heater profile using the setGasHeater() method that accepts as arguments:
the heater temperature (in degrees Centigrade) 
the time the heater should be on (in milliseconds)
We'll use the default settings: 320 oC for 150 ms.
<h3>loop()</h3>
In the loop(), we'll get measurements from the BME680 sensor.
First, tell the sensor to start an asynchronous reading with bme.beginReading(). This returns the time when the reading would be ready. 
<k>// Tell BME680 to begin measurement.
unsigned long endTime = bme.beginReading();
if (endTime == 0) {
  Serial.println(F("Failed to begin reading :("));
  return;
}
Serial.print(F("Reading started at "));
Serial.print(millis());
Serial.print(F(" and will finish at "));
Serial.println(endTime);</k>
Then, call the endReading() method to end an asynchronous reading. If the asynchronous reading is still in progress, block until it ends.
<k>if (!bme.endReading()) {
  Serial.println(F("Failed to complete reading :("));
  return;
}</k>
After this, we can get the readings as follows:
bme.temperature: returns temperature reading
bme.pressure: returns pressure reading
bme.humidity: returns humidity reading
bme.gas_resistance: returns gas resistance
<k>Serial.print(F("Temperature = "));
Serial.print(bme.temperature);
Serial.println(F(" *C"));
Serial.print(F("Pressure = "));
Serial.print(bme.pressure / 100.0);
Serial.println(F(" hPa"));
Serial.print(F("Humidity = "));
Serial.print(bme.humidity);
Serial.println(F(" %"));
Serial.print(F("Gas = "));
Serial.print(bme.gas_resistance / 1000.0);
Serial.println(F(" KOhms"));
Serial.print(F("Approx. Altitude = "));
Serial.print(bme.readAltitude(SEALEVELPRESSURE_HPA));
Serial.println(F(" m"));</k>
For more information about the library methods, take a look at the <a href="https://adafruit.github.io/Adafruit_BME680/html/class_adafruit___b_m_e680.html#aaae0839c68035001f491661cb2d012fc" target="_blank">Adafruit_BME</a><a href="https://adafruit.github.io/Adafruit_BME680/html/class_adafruit___b_m_e680.html#aaae0839c68035001f491661cb2d012fc" target="_blank">6</a><a href="https://adafruit.github.io/Adafruit_BME680/html/class_adafruit___b_m_e680.html#aaae0839c68035001f491661cb2d012fc" target="_blank">80 Class Reference</a>.
<h3>Demonstration</h3>
Upload the code to your ESP32 board. Go to <k>Tools </k>> <k>Board </k>and select the ESP32 board you're using. Go to <k>Tools </k>> <k>Port </k>and select the port your board is connected to. Then, click the upload button.
Open the Serial Monitor at a baud rate of 115200, press the on-board RST button. The sensor measurements will be displayed.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/BME680-Arduino-IDE-Example-Display-Readings-Serial-Monitor.png">
<h3>Code  ESP32 Web Server with BME680</h3>
In this section, we provide an example of web server that you can build with the ESP32 to display BME680 readings.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-BME680-Gas-sensor-Web-Server-Demonstration.jpg">
<h3>Installing Libraries  Async Web Server</h3>
To build the web server you need to install the following libraries. Click the links below to download the libraries.
<a href="https://github.com/me-no-dev/ESPAsyncWebServer/archive/master.zip" target="_blank">ESPAsyncWebServer</a> 
<a href="https://github.com/me-no-dev/AsyncTCP/archive/master.zip" target="_blank">AsyncTCP</a>
These libraries aren't available to install through the Arduino Library Manager, so you need to copy the library files to the Arduino Installation Libraries folder. Alternatively, in your Arduino IDE, you can go to <k>Sketch </k>> <k>Include Library</k> > <k>Add .zip Library</k> and select the libraries you've just downloaded.
<h3>Code</h3>
Then, upload the following code to your board (type your SSID and password).
<k>/*********
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-bme680-sensor-arduino/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*********/
#include &lt;Wire.h>
#include &lt;SPI.h>
#include &lt;Adafruit_Sensor.h>
#include "Adafruit_BME680.h"
#include &lt;WiFi.h>
#include "ESPAsyncWebServer.h"
// Replace with your network credentials
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
//Uncomment if using SPI
/*#define BME_SCK 18
#define BME_MISO 19
#define BME_MOSI 23
#define BME_CS 5*/
Adafruit_BME680 bme; // I2C
//Adafruit_BME680 bme(BME_CS); // hardware SPI
//Adafruit_BME680 bme(BME_CS, BME_MOSI, BME_MISO, BME_SCK);
float temperature;
float humidity;
float pressure;
float gasResistance;
AsyncWebServer server(80);
AsyncEventSource events("/events");
unsigned long lastTime = 0;  
unsigned long timerDelay = 30000;  // send readings timer
void getBME680Readings(){
  // Tell BME680 to begin measurement.
  unsigned long endTime = bme.beginReading();
  if (endTime == 0) {
    Serial.println(F("Failed to begin reading :("));
    return;
  }
  if (!bme.endReading()) {
    Serial.println(F("Failed to complete reading :("));
    return;
  }
  temperature = bme.temperature;
  pressure = bme.pressure / 100.0;
  humidity = bme.humidity;
  gasResistance = bme.gas_resistance / 1000.0;
}
String processor(const String& var){
  getBME680Readings();
  //Serial.println(var);
  if(var == "TEMPERATURE"){
    return String(temperature);
  }
  else if(var == "HUMIDITY"){
    return String(humidity);
  }
  else if(var == "PRESSURE"){
    return String(pressure);
  }
 else if(var == "GAS"){
    return String(gasResistance);
  }
}
const char index_html[] PROGMEM = R"rawliteral(
&lt;!DOCTYPE HTML>&lt;html>
&lt;head>
  &lt;title>BME680 Web Server&lt;/title>
  &lt;meta name="viewport" content="width=device-width, initial-scale=1">
  &lt;link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
  &lt;link rel="icon" href="data:,">
  &lt;style>
    html {font-family: Arial; display: inline-block; text-align: center;}
    p {  font-size: 1.2rem;}
    body {  margin: 0;}
    .topnav { overflow: hidden; background-color: #4B1D3F; color: white; font-size: 1.7rem; }
    .content { padding: 20px; }
    .card { background-color: white; box-shadow: 2px 2px 12px 1px rgba(140,140,140,.5); }
    .cards { max-width: 700px; margin: 0 auto; display: grid; grid-gap: 2rem; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); }
    .reading { font-size: 2.8rem; }
    .card.temperature { color: #0e7c7b; }
    .card.humidity { color: #17bebb; }
    .card.pressure { color: #3fca6b; }
    .card.gas { color: #d62246; }
  &lt;/style>
&lt;/head>
&lt;body>
  &lt;div>
    &lt;h3>BME680 WEB SERVER&lt;/h3>
  &lt;/div>
  &lt;div>
    &lt;div>
      &lt;div>
        &lt;h4>&lt;i>&lt;/i> TEMPERATURE&lt;/h4>&lt;p>&lt;span>&lt;span>%TEMPERATURE%&lt;/span> &deg;C&lt;/span>&lt;/p>
      &lt;/div>
      &lt;div>
        &lt;h4>&lt;i>&lt;/i> HUMIDITY&lt;/h4>&lt;p>&lt;span>&lt;span>%HUMIDITY%&lt;/span> &percnt;&lt;/span>&lt;/p>
      &lt;/div>
      &lt;div>
        &lt;h4>&lt;i>&lt;/i> PRESSURE&lt;/h4>&lt;p>&lt;span>&lt;span>%PRESSURE%&lt;/span> hPa&lt;/span>&lt;/p>
      &lt;/div>
      &lt;div>
        &lt;h4>&lt;i>&lt;/i> GAS&lt;/h4>&lt;p>&lt;span>&lt;span>%GAS%&lt;/span> K&ohm;&lt;/span>&lt;/p>
      &lt;/div>
    &lt;/div>
  &lt;/div>
&lt;script>
if (!!window.EventSource) {
 var source = new EventSource('/events');
 
 source.addEventListener('open', function(e) {
  console.log("Events Connected");
 }, false);
 source.addEventListener('error', function(e) {
  if (e.target.readyState != EventSource.OPEN) {
    console.log("Events Disconnected");
  }
 }, false);
 
 source.addEventListener('message', function(e) {
  console.log("message", e.data);
 }, false);
 
 source.addEventListener('temperature', function(e) {
  console.log("temperature", e.data);
  document.getElementById("temp").innerHTML = e.data;
 }, false);
 
 source.addEventListener('humidity', function(e) {
  console.log("humidity", e.data);
  document.getElementById("hum").innerHTML = e.data;
 }, false);
 
 source.addEventListener('pressure', function(e) {
  console.log("pressure", e.data);
  document.getElementById("pres").innerHTML = e.data;
 }, false);
 
 source.addEventListener('gas', function(e) {
  console.log("gas", e.data);
  document.getElementById("gas").innerHTML = e.data;
 }, false);
}
&lt;/script>
&lt;/body>
&lt;/html>)rawliteral";
void setup() {
  Serial.begin(115200);
  // Set the device as a Station and Soft Access Point simultaneously
  WiFi.mode(WIFI_AP_STA);
  
  // Set device as a Wi-Fi Station
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Setting as a Wi-Fi Station..");
  }
  Serial.print("Station IP Address: ");
  Serial.println(WiFi.localIP());
  Serial.println();
  // Init BME680 sensor
  if (!bme.begin()) {
    Serial.println(F("Could not find a valid BME680 sensor, check wiring!"));
    while (1);
  }
  // Set up oversampling and filter initialization
  bme.setTemperatureOversampling(BME680_OS_8X);
  bme.setHumidityOversampling(BME680_OS_2X);
  bme.setPressureOversampling(BME680_OS_4X);
  bme.setIIRFilterSize(BME680_FILTER_SIZE_3);
  bme.setGasHeater(320, 150); // 320*C for 150 ms
  // Handle Web Server
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send_P(200, "text/html", index_html, processor);
  });
  // Handle Web Server Events
  events.onConnect([](AsyncEventSourceClient *client){
    if(client->lastId()){
      Serial.printf("Client reconnected! Last message ID that it got is: %u\n", client->lastId());
    }
    // send event with message "hello!", id current millis
    // and set reconnect delay to 1 second
    client->send("hello!", NULL, millis(), 10000);
  });
  server.addHandler(&events);
  server.begin();
}
void loop() {
  if ((millis() - lastTime) > timerDelay) {
    getBME680Readings();
    Serial.printf("Temperature = %.2f oC \n", temperature);
    Serial.printf("Humidity = %.2f % \n", humidity);
    Serial.printf("Pressure = %.2f hPa \n", pressure);
    Serial.printf("Gas Resistance = %.2f KOhm \n", gasResistance);
    Serial.println();
    // Send Events to the Web Server with the Sensor Readings
    events.send("ping",NULL,millis());
    events.send(String(temperature).c_str(),"temperature",millis());
    events.send(String(humidity).c_str(),"humidity",millis());
    events.send(String(pressure).c_str(),"pressure",millis());
    events.send(String(gasResistance).c_str(),"gas",millis());
    
    lastTime = millis();
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_BME680_Web_Server.ino" target="_blank">View raw code</a>
<h3>Demonstration</h3>
After uploading, open the Serial Monitor at a baud rate of 115200 to get the ESP32 IP address.
Open a browser and type the IP address. You should get access to the web server with the latest sensor readings. You can access the web server on your computer, tablet or smartphone in your local network.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-ESP8266-NodeMCU-Web-Server-with-BME680-Gas-sensor.jpg">
The readings are updated automatically on the web server using Server-Sent Events. 
We won't explain how the web server works in this tutorial. We wrote <a href="https://randomnerdtutorials.com/esp32-bme680-web-server-arduino/">this guide dedicated to the BME680 web server with the ESP32</a> board.
<h3>Wrapping Up </h3>
The BME680 sensor module is a 4-in-1 digital sensor that combines gas, pressure, temperature and humidity sensors. The BME680 contains a MOX sensor that senses the presence of most VOC gases. This sensor gives you a qualitative idea of the<k> </k>sum of VOCs/contaminants in the surrounding air. For this reason, the BME680 can be used to monitor indoor air quality.
If you're using an ESP8266, read <a href="https://randomnerdtutorials.com/esp8266-nodemcu-bme680-sensor-arduino/">ESP8266 NodeMCU: BME680 Environmental Sensor using Arduino IDE (Gas, Pressure, Humidity, Temperature)</a>.
We hope you've found this getting started guide useful. We have guides for other popular sensors:
<a href="https://randomnerdtutorials.com/esp32-dht11-dht22-temperature-humidity-sensor-arduino-ide/">ESP32 with <k>DHT11/DHT22 Temperature and Humidity Sensor</k> using Arduino IDE</a>
<a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/">ESP32 with <k>BME280</k> using Arduino IDE (<k>Pressure, Temperature, Humidity</k>)</a>
<a href="https://randomnerdtutorials.com/esp32-ds18b20-temperature-arduino-ide/">ESP32<k> DS18B20 Temperature Sensor</k> with Arduino IDE (Single, Multiple, Web Server)</a>
<a href="https://randomnerdtutorials.com/esp32-with-bmp180-barometric-sensor/">ESP32 with <k>BMP180 Barometric Sensor</k> (Temperature and Pressure)</a>
<h2>Telegram: ESP32 Motion Detection with Notifications (Arduino IDE)</h2>
This tutorial shows how to send notifications to your Telegram account when the ESP32 detects motion. As long as you have access to the internet in your smartphone, you'll be notified no matter where you are. The ESP board will be programmed using Arduino IDE.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-PIR-Motion-Sensor-Telegram-Send-Message-Notification-Arduino.jpg">
<h3>Project Overview</h3>
This tutorial shows how to get notifications in your Telegram account when the ESP32 detects motion. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-PIR-Motion-Sensor-Send-Message-Notificatio-Telegram.png">
Here's an overview on how the project works:
You'll create a Telegram bot for your ESP32.
The ESP32 is connected to a PIR motion sensor.
When the sensor detects motion, the ESP32 sends a warning message to your telegram account.
You'll be notified in your telegram account whenever motion is detected.
This is a simple project, but shows how you can use Telegram in your IoT and Home Automation projects. The idea is to apply the concepts learned in your own projects.
<h3>Introducing Telegram</h3>
<a href="https://telegram.org/" target="_blank">Telegram</a> Messenger is a cloud-based instant messaging and voice over IP service. You can easily install it in your smartphone (Android and iPhone) or computer (PC, Mac and Linux). It is free and without any ads. Telegram allows you to create bots that you can interact with.
<em>Bots are third-party applications that run inside Telegram. Users can interact with bots by sending them messages, commands and inline requests. You control your bots using HTTPS requests to Telegram Bot API</em>.
The ESP32 will interact with the Telegram bot to send messages to your telegram account. Whenever motion is detected, you'll receive a notification in your smartphone (as long as you have access to the internet).
<h3>Creating a Telegram Bot</h3>
Go to Google Play or App Store, download and install <k>Telegram</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Install-Telegram.png">
Open Telegram and follow the next steps to create a Telegram Bot. First, search for <k>botfather</k> and click the BotFather as shown below. Or open this link <a href="http://t.me/botfather" target="_blank">t.me/botfather</a> in your smartphone.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Telegram-Botfather.png">
The following window should open and you'll be prompted to click the <k>start</k> button.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/start-bot-father-telegram.png">
Type <k>/newbot</k> and follow the instructions to create your bot. Give it a name and username.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Create-bot-Telegram-Botfather_f.png">
If your bot is successfully created, you'll receive a message with a link to access the bot and the <k>bot token</k>. Save the bot token because you'll need it so that the ESP32 can interact with the bot.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Bot-Token-Telegram-Bot-Father.png">
<h3>Get Your Telegram User ID</h3>
Anyone that knows your bot username can interact with it. To make sure that we ignore messages that are not from our Telegram account (or any authorized users), you can get your Telegram User ID. Then, when your telegram bot receives a message, the ESP can check whether the sender ID corresponds to your User ID and handle the message or ignore it.
In your Telegram account, search for IDBot or open this link <a href="http://t.me/myidbot" target="_blank">t.me/myidbot</a> in your smartphone.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Telegram-ID-Bot.png">
Start a conversation with that bot and type <k>/getid</k>. You will get a reply back with your user ID. Save that <k>user ID</k>, because you'll need it later in this tutorial.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Telegram-Get-Chat-ID.png">
<h3>Preparing Arduino IDE</h3>
We'll program the <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> board using Arduino IDE, so make sure you have them installed in your Arduino IDE.
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<h3>Universal Telegram Bot Library</h3>
To interact with the Telegram bot, we'll use the <a href="https://github.com/witnessmenow/Universal-Arduino-Telegram-Bot" target="_blank">Universal Telegram Bot Library</a> created by Brian Lough that provides an easy interface for the Telegram Bot API.
Follow the next steps to install the latest release of the library.
<ol>
<a href="https://github.com/witnessmenow/Universal-Arduino-Telegram-Bot/archive/master.zip" target="_blank">Click here to download the Universal Arduino Telegram Bot library</a>.
Go to <k>Sketch </k>> <k>Include Library</k> > <k>Add.ZIP Library..</k>.
Add the library you've just downloaded.
</ol>
<k>Important: </k> don't install the library through the Arduino Library Manager because it might install a deprecated version.
For all the details about the library, take a look at the Universal Arduino Telegram Bot Library <a href="https://github.com/witnessmenow/Universal-Arduino-Telegram-Bot" target="_blank">GitHub</a> page.
<h3>ArduinoJson Library</h3>
You also have to install the <a href="https://github.com/bblanchon/ArduinoJson" target="_blank">ArduinoJson</a> library. Follow the next steps to install the library.
<ol>
Go to <k>Skech </k>> <k>Include Library</k> > <k>Manage Libraries</k>.
Search for ArduinoJson.
Install the library.
</ol>
We're using ArduinoJson library version 6.5.12.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Install-ArduinoJson-Library.png">
<h3>Parts Required</h3>
For this project, you need the following parts:
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32 board</a> (read <a href="https://makeradvisor.com/esp32-development-boards-review-comparison/" target="_blank">Best ESP32 dev boards</a>)
<a href="https://makeradvisor.com/tools/mini-hc-sr505-pir-motion-sensor/" target="_blank"></a><a href="https://makeradvisor.com/tools/mini-hc-sr505-pir-motion-sensor/" target="_blank">Mini PIR motion sensor (AM312)</a> or <a href="https://makeradvisor.com/tools/pir-motion-sensor-hc-sr501/" target="_blank">PIR motion sensor (HC-SR501)</a>
<a style="font-size: inherit; background-color: initial;" href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a>
<h3>Schematic Diagram</h3>
For this project you need to wire a PIR motion sensor to your ESP32 board. Follow the next schematic diagram.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-PIR-Motion-Sensor-Wiring-Diagram.png">
In this example, we're wiring the PIR motion sensor data pin to GPIO 27. You can use any other suitable GPIO. Read <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">ESP32 GPIO Guide</a>.
<h3>Telegram Motion Detection with Notifications  ESP32 Sketch</h3>
The following code uses your Telegram bot to send a warning message to your telegram account whenever motion is detected. To make this sketch work for you, you need to insert your network credentials (SSID and password), the Telegram Bot token and your Telegram user ID.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/telegram-esp32-motion-detection-arduino/
  
  Project created using Brian Lough's Universal Telegram Bot Library: https://github.com/witnessmenow/Universal-Arduino-Telegram-Bot
*/
#include &lt;WiFi.h>
#include &lt;WiFiClientSecure.h>
#include &lt;UniversalTelegramBot.h>
#include &lt;ArduinoJson.h>
// Replace with your network credentials
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
// Initialize Telegram BOT
#define BOTtoken "XXXXXXXXXX:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"  // your Bot Token (Get from Botfather)
// Use @myidbot to find out the chat ID of an individual or a group
// Also note that you need to click "start" on a bot before it can
// message you
#define CHAT_ID "XXXXXXXXXX"
WiFiClientSecure client;
UniversalTelegramBot bot(BOTtoken, client);
const int motionSensor = 27; // PIR Motion Sensor
bool motionDetected = false;
// Indicates when motion is detected
void IRAM_ATTR detectsMovement() {
  //Serial.println("MOTION DETECTED!!!");
  motionDetected = true;
}
void setup() {
  Serial.begin(115200);
  // PIR Motion Sensor mode INPUT_PULLUP
  pinMode(motionSensor, INPUT_PULLUP);
  // Set motionSensor pin as interrupt, assign interrupt function and set RISING mode
  attachInterrupt(digitalPinToInterrupt(motionSensor), detectsMovement, RISING);
  // Attempt to connect to Wifi network:
  Serial.print("Connecting Wifi: ");
  Serial.println(ssid);
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  client.setCACert(TELEGRAM_CERTIFICATE_ROOT); // Add root certificate for api.telegram.org
  
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print(".");
    delay(500);
  }
  Serial.println("");
  Serial.println("WiFi connected");
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
  bot.sendMessage(CHAT_ID, "Bot started up", "");
}
void loop() {
  if(motionDetected){
    bot.sendMessage(CHAT_ID, "Motion detected!!", "");
    Serial.println("Motion Detected");
    motionDetected = false;
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_Telegram/ESP32_Telegram_Motion.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
This sections explain how the code works. Continue reading or skip to the Demonstration section. 
Start by importing the required libraries.
<k>#include &lt;WiFi.h>
#include &lt;WiFiClientSecure.h>
#include &lt;UniversalTelegramBot.h>
#include &lt;ArduinoJson.h></k>
<h3>Network Credentials</h3>
Insert your network credentials in the following variables.
<k>const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h3>Telegram Bot Token</h3>
Insert your Telegram Bot token you've got from Botfather on the BOTtoken variable.
<k>#define BOTtoken "XXXXXXXXXX:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"  // your Bot Token (Get from Botfather)</k>
<h3>Telegram User ID</h3>
Insert your chat ID. The one you've got from the IDBot.
<k>#define CHAT_ID "XXXXXXXXXX"</k>
Create a new WiFi client with WiFiClientSecure.
<k>WiFiClientSecure client;</k>
Create a bot with the token and client defined earlier.
<k>UniversalTelegramBot bot(BOTtoken, client);</k>
<h3>Motion Sensor</h3>
Define the GPIO that the motion sensor is connected to.
<k>const int motionSensor = 27; // PIR Motion Sensor</k>
The motionDetected boolean variable is used to indicate whether motion was detected or not. It is set to false by default.
<k>bool motionDetected = false;</k>
<h3>detectsMovement()</h3>
The detectsmovement() function is a callback function that will be executed when motion is detected. In this case, it simply changes the state of the motionDetected variable to true.
<k>void IRAM_ATTR detectsMovement() {
  //Serial.println("MOTION DETECTED!!!");
  motionDetected = true;
}</k>
<h3>setup()</h3>
In the setup(), initialize the Serial Monitor.
<k>Serial.begin(115200);</k>
<h4>PIR Motion Sensor Interrupt</h4>
Set the PIR motion sensor as an interrupt and set the detectsMovement() as the callback function (when motion is detected, that function will be executed):
<k>// PIR Motion Sensor mode INPUT_PULLUP
pinMode(motionSensor, INPUT_PULLUP);
// Set motionSensor pin as interrupt, assign interrupt function and set RISING mode
attachInterrupt(digitalPinToInterrupt(motionSensor), detectsMovement, RISING);</k>
<k>Note: </k> Recommended reading: <a href="https://randomnerdtutorials.com/esp32-pir-motion-sensor-interrupts-timers/">ESP32 with PIR Motion Sensor using Interrupts and Timers</a>
<h4>Init Wi-Fi</h4>
Initialize Wi-Fi and connect the ESP32 to your local network with the SSID and password defined earlier.
<k>WiFi.mode(WIFI_STA);
WiFi.begin(ssid, password);
while (WiFi.status() != WL_CONNECTED) {
  delay(1000);
  Serial.println("Connecting to WiFi..");
}</k>
Finally, send a message to indicate that the Bot has started up:
<k>bot.sendMessage(CHAT_ID, "Bot started up", "");</k>
<h3>loop()</h3>
In the loop(), check the state of the motionDetected variable. 
<k>void loop() {
  if(motionDetected){</k>
If it's true, it means that motion was detected. So, send a message to your Telegram account indicating that motion was detected. 
<k>bot.sendMessage(CHAT_ID, "Motion detected!!", "");</k>
Sending a message to the bot is very simply. You just need to use the sendMessage() method on the bot object and pass as arguments the recipient's chat ID, the message, and the parse mode.
<k>bool sendMessage(String chat_id, String text, String parse_mode = "")</k>
Finally, after sending the message, set the motionDetected variable to false, so it can detect motion again. 
<k>motionDetected = false;</k>
That's pretty much how the code works.
<h3>Demonstration</h3>
<k>Important: </k> go to your Telegram account and search for your bot. You need to click <k>start</k> on a bot before it can message you.
Upload the code to your ESP32 board. Don't forget to go to <k>Tools </k>> <k>Board </k>and select the board you're using. Go to <k>Tools </k>> <k>Port </k>and select the COM port your board is connected to.
After uploading the code, press the ESP32 on-board EN/RST button so that it starts running the code. Then, you can open the Serial Monitor to check what's happening in the background.
When your board first boots, it will send a message to your Telegram account: Bot started up. Then, move your hand in front of the PIR motion sensor and check that you've received the motion detected notification.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Motion-Detected-Telegram-Notification.png">
At the same time, this is what you should get on the Serial Monitor.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-Telegram-Motion-Detected-Serial-Monitor-Demonstration.png">
<h3>Wrapping Up</h3>
In this tutorial you've learned how to create a Telegram Bot to interact with the ESP32 board. When motion is detected, a message is sent.
With this bot, you can also use your Telegram account to send messages to the ESP32 to <a href="https://randomnerdtutorials.com/telegram-control-esp32-esp8266-nodemcu-outputs/">control its outputs</a> or <a href="https://randomnerdtutorials.com/telegram-request-esp32-esp8266-nodemcu-sensor-readings/">request sensor readings</a>, for example.
The great thing about using Telegram to control your ESP boards, is that as long as you have an internet connection (and your boards too), you can control and monitor them from anywhere in the world.
More projects with Telegram:
<a href="https://randomnerdtutorials.com/telegram-control-esp32-esp8266-nodemcu-outputs/">Control Outputs</a>
<a href="https://randomnerdtutorials.com/telegram-request-esp32-esp8266-nodemcu-sensor-readings/">Request Sensor Readings</a>
<a href="https://randomnerdtutorials.com/telegram-esp8266-nodemcu-motion-detection-arduino/">ESP8266 Motion Detection</a>
We hope you've found this project interesting. Learn more about the ESP32 with our resources:
<a href="https://randomnerdtutorials.com/learn-esp32-with-arduino-ide/">Learn ESP32 with Arduino IDE (eBook + Video Course)</a>
<a style="font-size: inherit; background-color: initial;" href="https://randomnerdtutorials.com/projects-esp32/">More ESP32 Projects and Tutorials</a>
Thanks for reading.
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/smart-home-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px-pupj8i6e7hlzpgwxe82jjd8skst9vmrjt9lpqb0v0g.jpg" title="Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px" alt="SMART HOME with Raspberry Pi ESP32 and ESP8266 Node-RED InfluxDB eBook" loading="lazy" width="117" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/smart-home-ebook/">SMART HOME with Raspberry Pi, ESP32, ESP8266 [eBook] </a></h4>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>Telegram: Control ESP32/ESP8266 Outputs (Arduino IDE)</h2>
This guide shows how to control the ESP32 or ESP8266 NodeMCU GPIOs from anywhere in the world using Telegram. As an example, we'll control an LED, but you can control any other output. You just need to send a message to your Telegram Bot to set your outputs HIGH or LOW. The ESP boards will be programmed using Arduino IDE.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-ESP8266-NodeMCU-Control-Outputs-LED-Telegram-Arduino.jpg">
<h3>Project Overview</h3>
In this tutorial we'll build a simple project that allows you to control ESP32 or ESP8266 NodeMCU GPIOs using Telegram. You can also <a href="https://randomnerdtutorials.com/esp32-relay-module-ac-web-server/">control a relay module</a>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-ESP8266-NodeMCU-Telegram-Control-Outputs-Overview.png">
You'll create a Telegram bot for your ESP32/ESP8266 board;
You can start a conversation with the bot;
When you send the message <k>/led_on</k> to the bot, the ESP board receives the message and turns GPIO 2 on;
Similarly, when you send the message <k>/led_off</k>, it turns GPIO 2 off;
Additionally, you can also send the message <k>/state</k> to request the current GPIO state. When the ESP receives that message, the bot responds with the current GPIO state;
You can send the <k>/start</k> message to receive a welcome message with the commands to control the board. 
This is a simple project, but shows how you can use Telegram in your IoT and Home Automation projects. The idea is to apply the concepts learned in your own projects.
<h3>Introducing Telegram</h3>
<a href="https://telegram.org/" target="_blank">Telegram</a> Messenger is a cloud-based instant messaging and voice over IP service. You can easily install it in your smartphone (Android and iPhone) or computer (PC, Mac and Linux). It is free and without any ads. Telegram allows you to create bots that you can interact with.
<em>Bots are third-party applications that run inside Telegram. Users can interact with bots by sending them messages, commands and inline requests. You control your bots using HTTPS requests to Telegram Bot API</em>.
The ESP32/ESP8266 will interact with the Telegram bot to receive and handle the messages, and send responses. In this tutorial you'll learn how to use Telegram to send messages to your bot to control the ESP outputs from anywhere (you just need Telegram and access to the internet).
<h3>Creating a Telegram Bot</h3>
Go to Google Play or App Store, download and install <k>Telegram</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Install-Telegram.png">
Open Telegram and follow the next steps to create a Telegram Bot. First, search for <k>botfather</k> and click the BotFather as shown below. Or open this link <a href="http://t.me/botfather" target="_blank">t.me/botfather</a> in your smartphone.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Telegram-Botfather.png">
The following window should open and you'll be prompted to click the <k>start</k> button.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/start-bot-father-telegram.png">
Type <k>/newbot</k> and follow the instructions to create your bot. Give it a name and username.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Create-bot-Telegram-Botfather_f.png">
If your bot is successfully created, you'll receive a message with a link to access the bot and the <k>bot token</k>. Save the bot token because you'll need it so that the ESP32/ESP8266 can interact with the bot.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Bot-Token-Telegram-Bot-Father.png">
<h3>Get Your Telegram User ID</h3>
Anyone that knows your bot username can interact with it. To make sure that we ignore messages that are not from our Telegram account (or any authorized users), you can get your Telegram User ID. Then, when your telegram bot receives a message, the ESP can check whether the sender ID corresponds to your User ID and handle the message or ignore it.
In your Telegram account, search for IDBot or open this link <a href="http://t.me/myidbot" target="_blank" title="Telegram: ESP32-CAM Take and Send Photo (Arduino IDE)">t.me/myidbot</a> in your smartphone.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Telegram-ID-Bot.png">
Start a conversation with that bot and type <k>/getid</k>. You will get a reply back with your user ID. Save that <k>user ID</k>, because you'll need it later in this tutorial.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Telegram-Get-Chat-ID.png">
<h3>Preparing Arduino IDE</h3>
We'll program the <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> and <a href="https://makeradvisor.com/tools/esp8266-esp-12e-nodemcu-wi-fi-development-board/" target="_blank">ESP8266</a> boards using Arduino IDE, so make sure you have them installed in your Arduino IDE.
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<a href="https://randomnerdtutorials.com/how-to-install-esp8266-board-arduino-ide/">Installing ESP8266 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<h3>Universal Telegram Bot Library</h3>
To interact with the Telegram bot, we'll use the <a href="https://github.com/witnessmenow/Universal-Arduino-Telegram-Bot" target="_blank">Universal Telegram Bot Library</a> created by Brian Lough that provides an easy interface for the Telegram Bot API.
Follow the next steps to install the latest release of the library.
<ol>
<a href="https://github.com/witnessmenow/Universal-Arduino-Telegram-Bot/archive/master.zip" target="_blank">Click here to download the Universal Arduino Telegram Bot library</a>.
Go to <k>Sketch </k>> <k>Include Library</k> > <k>Add.ZIP Library..</k>.
Add the library you've just downloaded.
</ol>
And that's it. The library is installed.
<k>Important: </k> don't install the library through the Arduino Library Manager because it might install a deprecated version.
For all the details about the library, take a look at the Universal Arduino Telegram Bot Library <a href="https://github.com/witnessmenow/Universal-Arduino-Telegram-Bot" target="_blank">GitHub</a> page.
<h3>ArduinoJson Library</h3>
You also have to install the <a href="https://github.com/bblanchon" target="_blank">ArduinoJson</a> library. Follow the next steps to install the library.
<ol>
Go to <k>Skech </k>> <k>Include Library</k> > <k>Manage Libraries</k>.
Search for ArduinoJson.
Install the library.
</ol>
We're using ArduinoJson library version 6.15.2.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Install-ArduinoJson-Library.png">
<h3>Parts Required</h3>
For this example we'll control the ESP on-board LEDs:
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32 board</a> (read <a href="https://makeradvisor.com/esp32-development-boards-review-comparison/" target="_blank">Best ESP32 dev boards</a>)
Alternative  <a href="https://makeradvisor.com/tools/esp8266-esp-12e-nodemcu-wi-fi-development-board/" target="_blank">ESP8266</a> board (read <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">Best ESP8266 dev boards</a>)
<h3>Control Outputs using Telegram  ESP32/ESP8266 Sketch</h3>
The following code allows you to control your ESP32 or ESP8266 NodeMCU GPIOs by sending messages to a Telegram Bot. To make it work for you, you need to insert your network credentials (SSID and password), the Telegram Bot Token and your Telegram User ID.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/telegram-control-esp32-esp8266-nodemcu-outputs/
  
  Project created using Brian Lough's Universal Telegram Bot Library: https://github.com/witnessmenow/Universal-Arduino-Telegram-Bot
  Example based on the Universal Arduino Telegram Bot Library: https://github.com/witnessmenow/Universal-Arduino-Telegram-Bot/blob/master/examples/ESP8266/FlashLED/FlashLED.ino
*/
#ifdef ESP32
  #include &lt;WiFi.h>
#else
  #include &lt;ESP8266WiFi.h>
#endif
#include &lt;WiFiClientSecure.h>
#include &lt;UniversalTelegramBot.h>   // Universal Telegram Bot Library written by Brian Lough: https://github.com/witnessmenow/Universal-Arduino-Telegram-Bot
#include &lt;ArduinoJson.h>
// Replace with your network credentials
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
// Initialize Telegram BOT
#define BOTtoken "XXXXXXXXXX:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"  // your Bot Token (Get from Botfather)
// Use @myidbot to find out the chat ID of an individual or a group
// Also note that you need to click "start" on a bot before it can
// message you
#define CHAT_ID "XXXXXXXXXX"
#ifdef ESP8266
  X509List cert(TELEGRAM_CERTIFICATE_ROOT);
#endif
WiFiClientSecure client;
UniversalTelegramBot bot(BOTtoken, client);
// Checks for new messages every 1 second.
int botRequestDelay = 1000;
unsigned long lastTimeBotRan;
const int ledPin = 2;
bool ledState = LOW;
// Handle what happens when you receive new messages
void handleNewMessages(int numNewMessages) {
  Serial.println("handleNewMessages");
  Serial.println(String(numNewMessages));
  for (int i=0; i&lt;numNewMessages; i++) {
    // Chat id of the requester
    String chat_id = String(bot.messages[i].chat_id);
    if (chat_id != CHAT_ID){
      bot.sendMessage(chat_id, "Unauthorized user", "");
      continue;
    }
    
    // Print the received message
    String text = bot.messages[i].text;
    Serial.println(text);
    String from_name = bot.messages[i].from_name;
    if (text == "/start") {
      String welcome = "Welcome, " + from_name + ".\n";
      welcome += "Use the following commands to control your outputs.\n\n";
      welcome += "/led_on to turn GPIO ON \n";
      welcome += "/led_off to turn GPIO OFF \n";
      welcome += "/state to request current GPIO state \n";
      bot.sendMessage(chat_id, welcome, "");
    }
    if (text == "/led_on") {
      bot.sendMessage(chat_id, "LED state set to ON", "");
      ledState = HIGH;
      digitalWrite(ledPin, ledState);
    }
    
    if (text == "/led_off") {
      bot.sendMessage(chat_id, "LED state set to OFF", "");
      ledState = LOW;
      digitalWrite(ledPin, ledState);
    }
    
    if (text == "/state") {
      if (digitalRead(ledPin)){
        bot.sendMessage(chat_id, "LED is ON", "");
      }
      else{
        bot.sendMessage(chat_id, "LED is OFF", "");
      }
    }
  }
}
void setup() {
  Serial.begin(115200);
  #ifdef ESP8266
    configTime(0, 0, "pool.ntp.org");      // get UTC time via NTP
    client.setTrustAnchors(&cert); // Add root certificate for api.telegram.org
  #endif
  pinMode(ledPin, OUTPUT);
  digitalWrite(ledPin, ledState);
  
  // Connect to Wi-Fi
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  #ifdef ESP32
    client.setCACert(TELEGRAM_CERTIFICATE_ROOT); // Add root certificate for api.telegram.org
  #endif
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi..");
  }
  // Print ESP32 Local IP Address
  Serial.println(WiFi.localIP());
}
void loop() {
  if (millis() > lastTimeBotRan + botRequestDelay)  {
    int numNewMessages = bot.getUpdates(bot.last_message_received + 1);
    while(numNewMessages) {
      Serial.println("got response");
      handleNewMessages(numNewMessages);
      numNewMessages = bot.getUpdates(bot.last_message_received + 1);
    }
    lastTimeBotRan = millis();
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_Telegram/ESP_Telegram_Control_Outputs.ino" target="_blank">View raw code</a>
The code is compatible with ESP32 and ESP8266 NodeMCU boards (it's based on the Universal Arduino Telegram Bot library <a href="https://github.com/witnessmenow/Universal-Arduino-Telegram-Bot/blob/master/examples/ESP8266/FlashLED/FlashLED.ino" target="_blank">example</a>). The code will load the right libraries accordingly to the selected board.
<h3>How the Code Works</h3>
This sections explain how the code works. Continue reading or skip to the Demonstration section.
Start by importing the required libraries.
<k>#ifdef ESP32
  #include &lt;WiFi.h>
#else
  #include &lt;ESP8266WiFi.h>
#endif
#include &lt;WiFiClientSecure.h>
#include &lt;UniversalTelegramBot.h>
#include &lt;ArduinoJson.h></k>
<h3>Network Credentials</h3>
Insert your network credentials in the following variables.
<k>const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h3>Define Output</h3>
Set the GPIO you want to control. In our case, we'll control GPIO 2 (built-in LED) and its state is LOW by default.
<k>const int ledPin = 2;
bool ledState = LOW;</k>
<k>Note: </k> if you're using an ESP8266, the built-in LED works with inverted logic. So, you should send a LOW signal to turn the LED on and a HIGH signal to turn it off.
<h3>Telegram Bot Token</h3>
Insert your Telegram Bot token you've got from Botfather on the BOTtoken variable.
<k>#define BOTtoken "XXXXXXXXXX:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"  // your Bot Token (Get from Botfather)</k>
<h3>Telegram User ID</h3>
Insert your chat ID. The one you've got from the IDBot.
<k>#define CHAT_ID "XXXXXXXXXX"</k>
Create a new WiFi client with WiFiClientSecure.
<k>WiFiClientSecure client;</k>
Create a bot with the token and client defined earlier.
<k>UniversalTelegramBot bot(BOTtoken, client);</k>
The botRequestDelay and lastTimeBotRan are used to check for new Telegram messages every x number of seconds. In this case, the code will check for new messages every second (1000 milliseconds). You can change that delay time in the botRequestDelay variable. 
<k>int botRequestDelay = 1000;
unsigned long lastTimeBotRan;</k>
<h3>handleNewMessages()</h3>
The handleNewMessages() function handles what happens when new messages arrive.
<k>void handleNewMessages(int numNewMessages) {
  Serial.println("handleNewMessages");
  Serial.println(String(numNewMessages));</k>
It checks the available messages:
<k>for (int i=0; i&lt;numNewMessages; i++) {</k>
Get the chat ID for that particular message and store it in the chat_id variable. The chat ID allows us to identify who sent the message. 
<k>String chat_id = String(bot.messages[i].chat_id);</k>
If the chat_id is different from your chat ID (CHAT_ID), it means that someone (that is not you) has sent a message to your bot. If that's the case, ignore the message and wait for the next message.
<k>if (chat_id != CHAT_ID) {
  bot.sendMessage(chat_id, "Unauthorized user", "");
  continue;
}</k>
Otherwise, it means that the message was sent from a valid user, so we'll save it in the text variable and check its content.
<k>String text = bot.messages[i].text;
Serial.println(text);</k>
The from_name variable saves the name of the sender.
<k>String from_name = bot.messages[i].from_name;</k>
If it receives the <k>/start</k> message, we'll send the valid commands to control the ESP32/ESP8266. This is useful if you happen to forget what are the commands to control your board.
<k>if (text == "/start") {
  String welcome = "Welcome, " + from_name + ".\n";
  welcome += "Use the following commands to control your outputs.\n\n";
  welcome += "/led_on to turn GPIO ON \n";
  welcome += "/led_off to turn GPIO OFF \n";
  welcome += "/state to request current GPIO state \n";
  bot.sendMessage(chat_id, welcome, "");
}</k>
Sending a message to the bot is very simply. You just need to use the sendMessage() method on the bot object and pass as arguments the recipient's chat ID, the message, and the parse mode.
<k>bool sendMessage(String chat_id, String text, String parse_mode = "")</k>
In our particular example, we'll send the message to the ID stored on the chat_id variable (that corresponds to the person who've sent the message) and send the message saved on the welcome variable. 
<k>bot.sendMessage(chat_id, welcome, "");</k>
If it receives the<k> /led_on</k> message, turn the LED on and send a message confirming we've received the message. Also, update the ledState variable with the new state.
<k>if (text == "/led_on") {
  bot.sendMessage(chat_id, "LED state set to ON", "");
  ledState = HIGH;
  digitalWrite(ledPin, ledState);
}</k>
Do something similar for the <k>/led_off</k> message.
<k>if (text == "/led_off") {
  bot.sendMessage(chat_id, "LED state set to OFF", "");
  ledState = LOW;
  digitalWrite(ledPin, ledState);
}</k>
<k>Note: </k> if you're using an ESP8266, the built-in LED works with inverted logic. So, you should send a LOW signal to turn the LED on and a HIGH signal to turn it off.
Finally, if the received message is <k>/state,</k> check the current GPIO state and send a message accordingly.
<k>if (text == "/state") {
  if (digitalRead(ledPin)){
    bot.sendMessage(chat_id, "LED is ON", "");
  }
  else{
    bot.sendMessage(chat_id, "LED is OFF", "");
  }
}</k>
<h3>setup()</h3>
In the setup(), initialize the Serial Monitor.
<k>Serial.begin(115200);</k>
If you're using the ESP8266, you need to use the following line:
<k>#ifdef ESP8266
  client.setInsecure();
#endif</k>
In the library examples for the ESP8266 they say: <em>This is the simplest way of getting this working. If you are passing sensitive information, or controlling something important, please either use certStore or at least client.setFingerPrint</em>.
We have a tutorial showing how to make HTTPS requests with the ESP8266: <a href="https://randomnerdtutorials.com/esp8266-nodemcu-https-requests/">ESP8266 NodeMCU HTTPS Requests (Arduino IDE)</a>.
Set the LED as an output and set it to LOW when the ESP first starts:
<k>pinMode(ledPin, OUTPUT);
digitalWrite(ledPin, ledState);</k>
<h4>Init Wi-Fi</h4>
Initialize Wi-Fi and connect the ESP to your local network with the SSID and password defined earlier.
<k>WiFi.mode(WIFI_STA);
WiFi.begin(ssid, password);
while (WiFi.status() != WL_CONNECTED) {
  delay(1000);
  Serial.println("Connecting to WiFi..");
}</k>
<h3>loop()</h3>
In the loop(), check for new messages every second.
<k>void loop() {
  if (millis() > lastTimeBotRan + botRequestDelay)  {
    int numNewMessages = bot.getUpdates(bot.last_message_received + 1);
    while(numNewMessages) {
      Serial.println("got response");
      handleNewMessages(numNewMessages);
      numNewMessages = bot.getUpdates(bot.last_message_received + 1);
    }
    lastTimeBotRan = millis();
  }
}</k>
When a new message arrives, call the handleNewMessages function.
<k>while(numNewMessages) {
  Serial.println("got response");
  handleNewMessages(numNewMessages);
  numNewMessages = bot.getUpdates(bot.last_message_received + 1);
}</k>
That's pretty much how the code works.
<h3>Demonstration</h3>
Upload the code to your ESP32 or ESP8266 board. Don't forget to go to <k>Tools </k>> <k>Board </k>and select the board you're using. Go to <k>Tools </k>> <k>Port </k>and select the COM port your board is connected to.
After uploading the code, press the ESP32/ESP8266 on-board EN/RST button so that it starts running the code. Then, you can open the Serial Monitor to check what's happening in the background.
Go to your Telegram account and open a conversation with your bot. Send the following commands and see the bot responding:
<k>/start</k> shows the welcome message with the valid commands.
<k>/led_on</k> turns the LED on.
<k>/led_off</k> turns the LED off.
<k>/state</k> requests the current LED state.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Control-ESP32-ESP8266-Outputs-Telegram.png">
The on-board LED should turn on and turn off accordingly (the ESP8266 on-board LED works in reverse, it's off when you send <k>/led_on</k> and on when you send<k> /led_off</k>).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-board-Built_in-LED-turned-on-HIGH.jpg">
At the same time, on the Serial Monitor you should see that the ESP is receiving the messages.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Control-ESP32-ESP8266-Outputs-Telegram-1.png">
If you try to interact with your bot from another account, you'll get the the <k>Unauthorized user</k> message.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Control-ESP32-ESP8266-Outputs-Telegram-Unauthorized-User.png">
<h3>Wrapping Up</h3>
In this tutorial you've learned how to create a Telegram Bot to interact with the ESP32 or ESP8266. With this bot, you can use your Telegram account to send messages to the ESP and control its outputs. The ESP can also interact with the bot to send responses.
We've shown you a simple example on how to control an output. The idea is to modify the project to add more commands to execute other tasks. For example, you can <a href="https://randomnerdtutorials.com/telegram-request-esp32-esp8266-nodemcu-sensor-readings/">request sensor readings</a> or send a message when motion is detected.
The great thing about using Telegram to control your ESP boards, is that as long as you have an internet connection (and your boards too), you can control and monitor them from anywhere in the world.
We hope you've found this project interesting. Learn more about the ESP32 and ESP8266 with our resources:
<a href="https://randomnerdtutorials.com/learn-esp32-with-arduino-ide/">Learn ESP32 with Arduino IDE (eBook + Video Course)</a>
<a href="https://randomnerdtutorials.com/home-automation-using-esp8266/">Home Automation using ESP8266</a>
<a href="https://randomnerdtutorials.com/projects-esp32/">More ESP32 projects and tutorials</a>
<a href="https://randomnerdtutorials.com/projects-esp8266/">More ESP8266 projects and tutorials</a>
Thanks for reading.
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/smart-home-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px-pupj8i6e7hlzpgwxe82jjd8skst9vmrjt9lpqb0v0g.jpg" title="Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px" alt="SMART HOME with Raspberry Pi ESP32 and ESP8266 Node-RED InfluxDB eBook" loading="lazy" width="117" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/smart-home-ebook/">SMART HOME with Raspberry Pi, ESP32, ESP8266 [eBook] </a></h4>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>Telegram: Request ESP32/ESP8266 Sensor Readings (Arduino IDE)</h2>
This guide shows how to request ESP32 or ESP8266 NodeMCU sensor readings using Telegram. As an example, we'll request temperature and humidity readings from a BME280 sensor. You just need to send a message to your Telegram Bot to monitor your sensors or inputs from anywhere in the world. The ESP boards will be programmed using Arduino IDE.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-ESP8266-NodeMCU-Send-Publish-Sensor-Readings-BME280-Telegram-Arduino.jpg">
<h3>Project Overview</h3>
In this tutorial we'll build a simple project that requests ESP32 or ESP8266 NodeMCU temperature and humidity readings using the Telegram app. We'll use a BME280 sensor, but you can use any <a href="https://randomnerdtutorials.com/dht11-vs-dht22-vs-lm35-vs-ds18b20-vs-bme280-vs-bmp180/">other sensor</a>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-ESP8266-NodeMCU-Telegram-Request-Sensor-Readings-Project-Overview.png">
You'll create a Telegram bot for your ESP32 or ESP8266 NodeMCU board;
You can start a conversation with the bot;
When you send the message <k>/readings</k> to the bot, the ESP board receives the message and responds with the current temperature and humidity readings;
You can send the <k>/start</k> message to receive a welcome message with the commands to control the board. 
This is a simple project, but shows how you can use Telegram in your IoT and Home Automation projects. The idea is to apply the concepts learned in your own projects.
<h3>Introducing Telegram App</h3>
<a href="https://telegram.org/" target="_blank">Telegram</a> Messenger is a cloud-based instant messaging and voice over IP service. You can easily install it in your smartphone (Android and iPhone) or computer (PC, Mac and Linux). It is free and without any ads. Telegram allows you to create bots that you can interact with.
<em>Bots are third-party applications that run inside Telegram. Users can interact with bots by sending them messages, commands and inline requests. You control your bots using HTTPS requests to Telegram Bot API</em>.
The ESP32/ESP8266 will interact with the Telegram bot to receive and handle the messages, and send responses. In this tutorial you'll learn how to use Telegram to send messages to your bot to request sensor readings from anywhere (you just need Telegram and access to the internet).
<h3>Creating a Telegram Bot</h3>
Go to Google Play or App Store, download and install <k>Telegram</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Install-Telegram.png">
Open Telegram and follow the next steps to create a Telegram Bot. First, search for <k>botfather</k> and click the BotFather as shown below. Or open this link <a href="http://t.me/botfather" target="_blank">t.me/botfather</a> in your smartphone.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Telegram-Botfather.png">
The following window should open and you'll be prompted to click the <k>start</k> button.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/start-bot-father-telegram.png">
Type <k>/newbot</k> and follow the instructions to create your bot. Give it a name and username.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Create-bot-Telegram-Botfather_f.png">
If your bot is successfully created, you'll receive a message with a link to access the bot and the <k>bot token</k>. Save the bot token because you'll need it so that the ESP32/ESP8266 can interact with the bot. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Bot-Token-Telegram-Bot-Father.png">
<h3>Get Your Telegram User ID</h3>
Anyone that knows your bot username can interact with it. To make sure that we ignore messages that are not from our Telegram account (or any authorized users), you can get your Telegram User ID. Then, when your telegram bot receives a message, the ESP can check whether the sender ID corresponds to your User ID and handle the message or ignore it. 
In your Telegram account, search for IDBot or open this link <a href="http://t.me/myidbot" target="_blank">t.me/myidbot</a> in your smartphone.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Telegram-ID-Bot.png">
Start a conversation with that bot and type <k>/getid</k>. You will get a reply back with your user ID. Save that <k>user ID</k>, because you'll need it later in this tutorial.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Telegram-Get-Chat-ID.png">
<h3>Preparing Arduino IDE</h3>
We'll program the <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> and <a href="https://makeradvisor.com/tools/esp8266-esp-12e-nodemcu-wi-fi-development-board/" target="_blank">ESP8266</a> boards using Arduino IDE, so make sure you have them installed in your Arduino IDE.
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<a href="https://randomnerdtutorials.com/how-to-install-esp8266-board-arduino-ide/">Installing ESP8266 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<h3>Universal Telegram Bot Library</h3>
To interact with the Telegram bot, we'll use the <a href="https://github.com/witnessmenow/Universal-Arduino-Telegram-Bot" target="_blank">Universal Telegram Bot Library</a> created by Brian Lough that provides an easy interface for the Telegram Bot API.
Follow the next steps to install the latest release of the library.
<ol>
<a href="https://github.com/witnessmenow/Universal-Arduino-Telegram-Bot/archive/master.zip" target="_blank">Click here to download the Universal Arduino Telegram Bot library</a>.
Go to <k>Sketch </k>> <k>Include Library</k> > <k>Add.ZIP Library..</k>.
Add the library you've just downloaded.
</ol>
<k>Important: </k> don't install the library through the Arduino Library Manager because it might install a deprecated version.
For all the details about the library, take a look at the Universal Arduino Telegram Bot Library <a href="https://github.com/witnessmenow/Universal-Arduino-Telegram-Bot" target="_blank">GitHub</a> page.
<h3>ArduinoJson Library</h3>
You also have to install the <a href="https://github.com/bblanchon/ArduinoJson" target="_blank">ArduinoJson</a> library. Follow the next steps to install the library.
<ol>
Go to <k>Skech </k>> <k>Include Library</k> > <k>Manage Libraries</k>.
Search for ArduinoJson.
Install the library.
</ol>
We're using ArduinoJson library version 6.15.2.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Install-ArduinoJson-Library.png">
<h3>BME280 Sensor Libraries</h3>
To get readings from the BME280 sensor module, we'll use the <a href="https://github.com/adafruit/Adafruit_BME280_Library" target="_blank">Adafruit_BME280 library</a>. You also need to install the <a href="https://github.com/adafruit/Adafruit_Sensor" target="_blank">Adafruit_Sensor library</a>. Follow the next steps to install the libraries in your Arduino IDE:
1. Open your Arduino IDE and go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k>. The Library Manager should open.
2. Search for <k>adafruit bme280</k>  on the Search box and install the library.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/08/install-bme280.png">
To use the BME280 library, you also need to install the <a href="https://github.com/adafruit/Adafruit_Sensor" target="_blank">Adafruit Unified Sensor</a>. Follow the next steps to install the library in your Arduino IDE:
3. Search for <k>Adafruit Unified Sensor</k>in the search box. Scroll all the way down to find the library and install it.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/04/adafruit_unified_sensor_library.png">
After installing the libraries, restart your Arduino IDE.
<h3>Parts Required</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/07/ESP32-BME280-circuit.jpg">
For this example we'll get sensor readings from the BME280 sensor. Here's a list of parts you need to build the circuit for this project:
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32 board</a> (read <a href="https://makeradvisor.com/esp32-development-boards-review-comparison/" target="_blank">Best ESP32 dev boards</a>)
Alternative  <a href="https://makeradvisor.com/tools/esp8266-esp-12e-nodemcu-wi-fi-development-board/" target="_blank">ESP8266</a> board (read <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">Best ESP8266 dev boards</a>)
<a href="https://makeradvisor.com/tools/bme280-sensor-module/" target="_blank">BME280 sensor</a>
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a>
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="lazy" fetchpriority="low"></a>
<h3>Schematic Diagram</h3>
The BME280 sensor module we're using communicates via <a href="https://randomnerdtutorials.com/esp32-i2c-communication-arduino-ide/">I2C communication protocol</a>, so you need to connect it to the ESP32 or ESP8266 I2C pins.
<h4>BME280 wiring to ESP32</h4>
The default <a href="https://randomnerdtutorials.com/esp32-i2c-communication-arduino-ide/">ESP32 I2C pins</a> are:
<k>GPIO 22</k>: <k>SCL</k> (SCK)
<k>GPIO 21</k>: <k>SDA</k> (SDI)
So, assemble your circuit as shown in the next schematic diagram (<a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/">Guide for ESP32 with BME280</a> and <a href="https://randomnerdtutorials.com/esp32-web-server-with-bme280-mini-weather-station/">ESP32 BME280 Web Server</a>).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-BME280-Sensor-Temperature-Humidity-Pressure-Wiring-Diagram-Circuit.png">
<k>Recommended reading:</k> <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">ESP32 Pinout Reference Guide</a>
<h4>BME280 wiring to ESP8266 NodeMCU</h4>
The default ESP8266 I2C pins are:
<k>GPIO 5 </k>(D1): <k>SCL</k> (SCK)
<k>GPIO 4 </k>(D2): <k>SDA</k> (SDI)
Assemble your circuit as in the next schematic diagram if you're using an ESP8266 board (<a href="https://randomnerdtutorials.com/esp8266-bme280-arduino-ide/">Guide for ESP8266 NodeMCU with BME280</a>).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP8266-NodeMCU-BME280-Sensor-Temperature-Humidity-Pressure-Wiring-Diagram-Circuit.png">
<k>Recommended reading:</k> <a href="https://randomnerdtutorials.com/esp8266-pinout-reference-gpios/">ESP8266 Pinout Reference Guide</a>
<h3>Telegram Request Sensor Readings  Code</h3>
The following code allows you to request BME280 sensor readings from your ESP32 or ESP8266 board by sending a message to a Telegram Bot. To make it work for you, you need to insert your network credentials (SSID and password), the Telegram Bot Token and your Telegram User ID.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/telegram-request-esp32-esp8266-nodemcu-sensor-readings/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
  Project created using Brian Lough's Universal Telegram Bot Library: https://github.com/witnessmenow/Universal-Arduino-Telegram-Bot
*/
#ifdef ESP32
  #include &lt;WiFi.h>
#else
  #include &lt;ESP8266WiFi.h>
#endif
#include &lt;WiFiClientSecure.h>
#include &lt;UniversalTelegramBot.h> // Universal Telegram Bot Library written by Brian Lough: https://github.com/witnessmenow/Universal-Arduino-Telegram-Bot
#include &lt;ArduinoJson.h>
#include &lt;Adafruit_BME280.h>
#include &lt;Adafruit_Sensor.h>
// Replace with your network credentials
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
// Use @myidbot to find out the chat ID of an individual or a group
// Also note that you need to click "start" on a bot before it can
// message you
#define CHAT_ID "XXXXXXXXXX"
// Initialize Telegram BOT
#define BOTtoken "XXXXXXXXXX:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"  // your Bot Token (Get from Botfather)
#ifdef ESP8266
  X509List cert(TELEGRAM_CERTIFICATE_ROOT);
#endif
WiFiClientSecure client;
UniversalTelegramBot bot(BOTtoken, client);
//Checks for new messages every 1 second.
int botRequestDelay = 1000;
unsigned long lastTimeBotRan;
// BME280 connect to ESP32 I2C (GPIO 21 = SDA, GPIO 22 = SCL)
// BME280 connect to ESP8266 I2C (GPIO 4 = SDA, GPIO 5 = SCL)
Adafruit_BME280 bme;         
// Get BME280 sensor readings and return them as a String variable
String getReadings(){
  float temperature, humidity;
  temperature = bme.readTemperature();
  humidity = bme.readHumidity();
  String message = "Temperature: " + String(temperature) + " oC \n";
  message += "Humidity: " + String (humidity) + " % \n";
  return message;
}
//Handle what happens when you receive new messages
void handleNewMessages(int numNewMessages) {
  Serial.println("handleNewMessages");
  Serial.println(String(numNewMessages));
  for (int i=0; i&lt;numNewMessages; i++) {
    // Chat id of the requester
    String chat_id = String(bot.messages[i].chat_id);
    if (chat_id != CHAT_ID){
      bot.sendMessage(chat_id, "Unauthorized user", "");
      continue;
    }
    
    // Print the received message
    String text = bot.messages[i].text;
    Serial.println(text);
    String from_name = bot.messages[i].from_name;
    if (text == "/start") {
      String welcome = "Welcome, " + from_name + ".\n";
      welcome += "Use the following command to get current readings.\n\n";
      welcome += "/readings \n";
      bot.sendMessage(chat_id, welcome, "");
    }
    if (text == "/readings") {
      String readings = getReadings();
      bot.sendMessage(chat_id, readings, "");
    }  
  }
}
void setup() {
  Serial.begin(115200);
  #ifdef ESP8266
    configTime(0, 0, "pool.ntp.org");      // get UTC time via NTP
    client.setTrustAnchors(&cert); // Add root certificate for api.telegram.org
  #endif
  
  // Init BME280 sensor
  if (!bme.begin(0x76)) {
    Serial.println("Could not find a valid BME280 sensor, check wiring!");
    while (1);
  }
  
  // Connect to Wi-Fi
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  #ifdef ESP32
    client.setCACert(TELEGRAM_CERTIFICATE_ROOT); // Add root certificate for api.telegram.org
  #endif
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi..");
  }
  // Print ESP32 Local IP Address
  Serial.println(WiFi.localIP());
}
void loop() {
  if (millis() > lastTimeBotRan + botRequestDelay)  {
    int numNewMessages = bot.getUpdates(bot.last_message_received + 1);
    while(numNewMessages) {
      Serial.println("got response");
      handleNewMessages(numNewMessages);
      numNewMessages = bot.getUpdates(bot.last_message_received + 1);
    }
    lastTimeBotRan = millis();
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_Telegram/ESP_Telegram_Request_Readings.ino" target="_blank">View raw code</a>
The code is compatible with ESP32 and ESP8266 NodeMCU boards. The code will load the right libraries accordingly to the selected board.
<h3>How the Code Works</h3>
This section explain how the code works. Continue reading or skip to the Demonstration section.
Start by importing the required libraries.
<k>#ifdef ESP32
  #include &lt;WiFi.h>
#else
  #include &lt;ESP8266WiFi.h>
#endif
#include &lt;WiFiClientSecure.h>
#include &lt;UniversalTelegramBot.h>
#include &lt;ArduinoJson.h>
#include &lt;Adafruit_BME280.h>
#include &lt;Adafruit_Sensor.h></k>
<h3>Network Credentials</h3>
Insert your network credentials in the following variables.
<k>const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h3>Telegram User ID</h3>
Insert your user ID. The one you've got from the IDBot.
<k>#define CHAT_ID "XXXXXXXXXX"</k>
<h3>Telegram Bot Token</h3>
Insert your Telegram Bot token you've got from Botfather on the BOTtoken variable.
<k>#define BOTtoken "XXXXXXXXXX:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"  // your Bot Token (Get from Botfather)</k>
Create a new WiFi client with WiFiClientSecure.
<k>WiFiClientSecure client;</k>
Create a bot with the token and client defined earlier.
<k>UniversalTelegramBot bot(BOTtoken, client);</k>
The botRequestDelay and lastTimeBotRan are used to check for new Telegram messages every x number of seconds. In this case, the code will check for new messages every second (1000 milliseconds). You can change that delay time in the botRequestDelay variable. 
<k>int botRequestDelay = 1000;
unsigned long lastTimeBotRan;</k>
<h3>BME280 Object</h3>
Create an Adafruit_BME280 called bme. This creates an I2C object on the default ESP I2C pins.
<k>Adafruit_BME280 bme; </k>
<h3>getReadings()</h3>
The getReadings() function requests temperature and humidity from the BME280 sensor and returns the results as a string variable that we can send to the Telegram bot.
<k>String getReadings(){
  float temperature, humidity;
  temperature = bme.readTemperature();
  humidity = bme.readHumidity();
  String message = "Temperature: " + String(temperature) + " oC \n";
  message += "Humidity: " + String (humidity) + " % \n";
  return message;
}</k>
To learn more about interfacing the BME280 sensor with the ESP32 and ESP8266, read:
<a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/">ESP32 with BME280 Sensor using Arduino IDE (Pressure, Temperature, Humidity)</a>
<a href="https://randomnerdtutorials.com/esp8266-bme280-arduino-ide/">ESP8266 with BME280 using Arduino IDE (Pressure, Temperature, Humidity)</a>
<h3>handleNewMessages()</h3>
The handleNewMessages() function handles what happens when new messages arrive.
<k>void handleNewMessages(int numNewMessages) {
  Serial.println("handleNewMessages");
  Serial.println(String(numNewMessages));</k>
It checks the available messages:
<k>for (int i=0; i&lt;numNewMessages; i++) {</k>
Get the chat ID for that particular message and store it in the chat_id variable. The chat ID identifies who sent the message. 
<k>String chat_id = String(bot.messages[i].chat_id);</k>
If the chat_id is different from your chat ID (CHAT_ID), it means that someone (that is not you) has sent a message to your bot. If that's the case, ignore the message and wait for the next message.
<k>if (chat_id != CHAT_ID){
  bot.sendMessage(chat_id, "Unauthorized user", "");
  continue;
}</k>
Otherwise, it means the message was sent from a valid user. So, we'll save it in the text variable and check its content.
<k>String text = bot.messages[i].text;
Serial.println(text);</k>
The from_name variable saves the name of the sender.
<k>String from_name = bot.messages[i].from_name;</k>
If it receives the <k>/start</k> message, we'll send the valid commands to control the ESP32/ESP8266. This is useful if you happen to forget what are the commands to control your board.
<k>if (text == "/start") {
  String welcome = "Welcome, " + from_name + ".\n";
  welcome += "Use the following command to get current readings.\n\n";
  welcome += "/readings \n";
  bot.sendMessage(chat_id, welcome, "");
}</k>
Sending a message to the bot is very simply. You just need to use the sendMessage() method on the bot object and pass as arguments the recipient's chat ID, the message, and the parse mode.
<k>bool sendMessage(String chat_id, String text, String parse_mode = "")</k>
In our example, we'll send the message to the ID stored on the chat_id variable (that corresponds to the person who've sent the message) and send the message saved on the welcome variable. 
<k>bot.sendMessage(chat_id, welcome, "");</k>
If it receives the<k> /readings</k> message, get the current sensor readings by calling the getReadings() function. Then, simply send the message.
<k>if (text == "/readings") {
  String readings = getReadings();
  bot.sendMessage(chat_id, readings, "");
}</k>
<h3>setup()</h3>
In the setup(), initialize the Serial Monitor.
<k>Serial.begin(115200);</k>
If you're using the ESP8266, you need to use the following line:
<k>#ifdef ESP8266
  client.setInsecure();
#endif</k>
In the Universal Telegram Bot Library library examples for the ESP8266, it says: <em>This is the simplest way of getting this working. If you are passing sensitive information, or controlling something important, please either use certStore or at least client.setFingerPrint</em>.
<h4>Init BME280</h4>
Initialize the BME280 sensor.
<k>if (!bme.begin(0x76)) {
  Serial.println("Could not find a valid BME280 sensor, check wiring!");
  while (1);
}</k>
<h4>Init Wi-Fi</h4>
Initialize Wi-Fi and connect the ESP to your local network with the SSID and password defined earlier.
<k>WiFi.mode(WIFI_STA);
WiFi.begin(ssid, password);
while (WiFi.status() != WL_CONNECTED) {
  delay(1000);
  Serial.println("Connecting to WiFi..");
}</k>
<h3>loop()</h3>
In the loop(), check for new messages every second.
<k>void loop() {
  if (millis() > lastTimeBotRan + botRequestDelay)  {
    int numNewMessages = bot.getUpdates(bot.last_message_received + 1);
    while(numNewMessages) {
      Serial.println("got response");
      handleNewMessages(numNewMessages);
      numNewMessages = bot.getUpdates(bot.last_message_received + 1);
    }
    lastTimeBotRan = millis();
  }
}</k>
When a new message arrives, call the handleNewMessages function.
<k>while(numNewMessages) {
  Serial.println("got response");
  handleNewMessages(numNewMessages);
  numNewMessages = bot.getUpdates(bot.last_message_received + 1);
}</k>
That's pretty much how the code works.
<h3>Demonstration</h3>
Upload the code to your ESP board, open the <k>Tools</k> menu > <k>Board </k>and select the board you're using. Go to <k>Tools </k>> <k>Port </k>and select the COM port your board is connected to.
After uploading the code, press the ESP on-board EN/RST button so that it starts running the code. Then, open the Serial Monitor to check what's happening in the background.
Go to your Telegram account and open a conversation with your bot. Send the following commands and see the bot responding:
<k>/start</k> shows the welcome message with the valid commands.
<k>/readings</k> returns the current temperature and humidity readings from the BME280 sensor.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Request-ESP32-ESP8266-Sensor-Readings-Telegram_f.png">
At the same time, on the Serial Monitor, you should see that the ESP32 or ESP8266 is receiving the messages.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-ESP8266-Telegram-Request-Sensor-Readings-Serial-Monitor.png">
If you try to interact with your bot from another account, you'll get the the <k>Unauthorized user</k> message.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Control-ESP32-ESP8266-Outputs-Telegram-Unauthorized-User.png">
<h3>Wrapping Up</h3>
In this tutorial you've learned how to create a Telegram Bot to interact with the ESP32 or ESP8266 NodeMCU boards. With this bot, you can use your Telegram account to monitor sensors and control outputs.
We've shown you a simple example on how to request sensor readings from a BME280 sensor. The idea is to modify the project to add more commands to execute other tasks. For example, you can <a href="https://randomnerdtutorials.com/telegram-control-esp32-esp8266-nodemcu-outputs/">send a Telegram message to control outputs</a> or send a message to your account when motion is detected.
The great thing about using Telegram to control your ESP boards, is that as long as you have an internet connection (and your boards too), you can control and monitor them from anywhere in the world.
We hope you've found this project interesting. Learn more about the ESP32 and ESP8266 with our resources:
<a href="https://randomnerdtutorials.com/learn-esp32-with-arduino-ide/">Learn ESP32 with Arduino IDE (eBook + Video Course)</a>
<a href="https://randomnerdtutorials.com/home-automation-using-esp8266/">Home Automation using ESP8266</a>
<a href="https://randomnerdtutorials.com/projects-esp32/">More ESP32 projects and tutorials</a>
<a href="https://randomnerdtutorials.com/projects-esp8266/">More ESP8266 projects and tutorials</a>
Thanks for reading.
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h-p2lw6wwnkk9ystvwe9iof8zx6yt4x7uma3cqfup534.jpg" title="Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h" alt="Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h" loading="lazy" width="129" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/">[eBook] Build Web Servers with ESP32 and ESP8266 (2nd Edition)</a></h4>
Build Web Server projects with the ESP32 and ESP8266 boards to control outputs and monitor sensors remotely. Learn HTML, CSS, JavaScript and client-server communication protocols <k><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Build Web Server projects with the ESP32 and ESP8266 boards to control outputs and monitor sensors remotely. Learn HTML, CSS, JavaScript and client-server communication protocols <k><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>Error Downloading URLs on Windows PC</h2>
If you're having trouble compiling code for your ESP32 or ESP8266 boards using Arduino IDE due to an error downloading the boards' URLs, you can follow this guide to help you fix the Arduino IDE installation on a Windows PC.
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing ESP32 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<a href="https://randomnerdtutorials.com/how-to-install-esp8266-board-arduino-ide/">Installing ESP8266 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Solved-fix-Arduino-IDE-installation-esp32-esp8266-nodemcu-board-addon-error-downloading-urls.jpg">
If you see a similar error in your Arduino IDE or any error related to downloading URLs, cleaning your Arduino IDE installation folder usually solves this issue.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Solved-Arduino-IDE-Installation-Error-downloading-ESP32-ESP8266-NodeMCU-thumb-Copy.png">
If your Arduino IDE doesn't launch (you click the Arduino icon and nothing happens) this trick might also solve the issue.
<h3>Fixing Arduino IDE Installation</h3>
1. In your Windows PC, open the <k>File Explorer</k>, select <k>View</k> menu and enable <k>Hidden items</k>:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Arduino-IDE-ESP32-ESP8266-NodeMCU-Board-Add-on-fix-install-1.png">
2. Go to your <k>Windows device</k> (for example C:), open <k>Users </k>and find the hidden <k>AppData</k> folder:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Arduino-IDE-ESP32-ESP8266-NodeMCU-Board-Add-on-fix-install-2.png">
3. Select the <k>AppData</k> folder and open <k>Local</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Arduino-IDE-ESP32-ESP8266-NodeMCU-Board-Add-on-fix-install-3.png">
4. Open the <k>Arduino15</k> folder, then I recommend deleting all files in this folder.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Arduino-IDE-ESP32-ESP8266-NodeMCU-Board-Add-on-fix-install-4.png">
5. That's it! Now, you just need to re-install the ESP32 and ESP8266 board add-ons.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/Arduino-IDE-ESP32-ESP8266-NodeMCU-Board-Add-on-fix-install-5.png">
<h3>Installing ESP32 and ESP8266 Board Add-on in Arduino IDE</h3>
Finally, you need to re-install the ESP board add-ons, you can either continue reading this guide or open one of the next links for more detailed instructions:
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing ESP32 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<a href="https://randomnerdtutorials.com/how-to-install-esp8266-board-arduino-ide/">Installing ESP8266 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
1. In your Arduino IDE, go to <k>File</k> > <k>Preferences</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2016/12/arduino-ide-open-preferences.png">
2. Enter the following URLs into the A<k>dditional Board Manager URLs</k> field as shown in the figure below.
<k>https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json, http://arduino.esp8266.com/stable/package_esp8266com_index.json</k>
Then, click the <k>OK</k> button:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/ESP32-URL-Arduino-IDE.png">
3. Open the Boards Manager. Go to <k>Tools </k>> <k>Board </k>> <k>Boards Manager</k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/06/boardsManager.png">
4. Search for <k>ESP32</k> and press the install button for the <k>ESP32 by Espressif Systems</k>:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/06/installing.png">
5. Search for <k>ESP8266</k> and press install button for the <k>ESP8266 by ESP8266 Community</k>:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/07/Install-ESP8266-Board-add-on-in-Arduino-IDE-search-ESP8266.png?w=828&quality=100&strip=all&ssl=1" alt="Install ESP8266 Board add-on in Arduino IDE search ESP8266" data-recalc-dims="1" loading="lazy" fetchpriority="low">
<h3>Testing the ESP32 and ESP8266 Board Add-on Installed in Arduino IDE</h3>
Plug the ESP32 or ESP8266 board to your computer. With your Arduino IDE open, follow these steps:
1. Select your Board in <k>Tools</k> > <k>Board</k> menu (in my case it's the <k>DOIT ESP32 DEVKIT V1</k>)
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2016/12/windows-select-board.png">
2. Select the Port (if you don't see the COM Port in your Arduino IDE, you need to install the <a href="https://www.silabs.com/products/development-tools/software/usb-to-uart-bridge-vcp-drivers" target="_blank">CP210x USB to UART Bridge VCP Drivers</a>):
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/08/com-port-selected.jpg">
3. Open the following example (or any other example) under <k>File</k> > <k>Examples</k> > <k>WiFi (ESP32)</k> > <k>WiFiScan</k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2016/12/windows-open-wifi-scan-example.png">
4. A new sketch opens in your Arduino IDE:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2016/12/windows-wifi-scan-example-open.png">
5. Press the <k>Upload</k> button in the Arduino IDE. Wait a few seconds while the code compiles and uploads to your board.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2016/12/arduino-ide-upload-button.png">
6. If everything went as expected, you should see a <k>Done uploading.</k> message.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2016/12/windows-arduino-ide-done-uploading.png">
If you get the Timed out waiting for packet header error, follow this guide: <a href="https://randomnerdtutorials.com/solved-failed-to-connect-to-esp32-timed-out-waiting-for-packet-header/">[SOLVED] Failed to connect to ESP32: Timed out waiting for packet header</a>.
7. Open the Arduino IDE Serial Monitor at a baud rate of 115200:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2016/12/mac-open-arduino-ide-serial-monitor.png">
8. Press the ESP on-board <k>Enable</k> button and you should see the networks available near your ESP32:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2016/12/windows-arduino-ide-serial-monitor.png">
<h3>Wrapping Up</h3>
We hope this guide fixed your Arduino IDE installation. Now, you're ready to start building your IoT projects with the ESP32 and ESP8266 boards!
For more ESP32 troubleshooting tips, try our <a href="https://randomnerdtutorials.com/esp32-troubleshooting-guide/">ESP32 Troubleshooting Guide</a>.
You might also like reading:
<a href="https://randomnerdtutorials.com/projects-esp32/">ESP32 Free Projects and Tutorials</a>
<a href="https://randomnerdtutorials.com/projects-esp8266/">ESP8266 Free Projects and Tutorials</a>
<a href="https://randomnerdtutorials.com/home-automation-using-esp8266/" target="_blank"><k>Home Automation using ESP8266</k></a>
<a href="https://randomnerdtutorials.com/learn-esp32-with-arduino-ide/"><k>Learn ESP32 with Arduino IDE</k></a>
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/smart-home-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px-pupj8i6e7hlzpgwxe82jjd8skst9vmrjt9lpqb0v0g.jpg" title="Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px" alt="SMART HOME with Raspberry Pi ESP32 and ESP8266 Node-RED InfluxDB eBook" loading="lazy" width="117" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/smart-home-ebook/">SMART HOME with Raspberry Pi, ESP32, ESP8266 [eBook] </a></h4>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>ESP32 IoT Shield PCB with Dashboard for Outputs and Sensors</h2>
In this project we'll show you how to build an IoT shield PCB for the ESP32 and a web server dashboard to control it. The shield is equipped with a BME280 sensor (temperature, humidity and pressure), an LDR (light dependent resistor), a PIR motion sensor, a status LED, a pushbutton and a terminal socket to connect a relay module or any other output. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-IoT-Shield-PCB-Dashboard-for-Outputs-and-Sensors-Arduino-IDE.jpg">
Alternatively, you can also follow this project by wiring the circuit on a breadboard.
<h3>Watch the Video Tutorial</h3>
This project is available in video format and in written format. You can watch the video below or you can scroll down for the written instructions.

<h3>Resources</h3>
You can find all the resources needed to build this project in the links below (or you can visit the GitHub project):
<a href="https://raw.githubusercontent.com/RuiSantosdotme/ESP32-IoT-Shield-PCB/master/ESP32_IoT_Shield_Dashboard/ESP32_IoT_Shield_Dashboard.ino" target="_blank">ESP32 Web Server Code (Arduino IDE)</a>
<a href="https://randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-IoT-Shield-PCB-Circuit-Breadboard.jpg" target="_blank">Schematic diagram</a>
<a href="https://github.com/RuiSantosdotme/ESP32-IoT-Shield-PCB/raw/master/Gerber_PCB_ESP32_IoT_Shield_2020-06-10_10-55-31.zip" target="_blank">Gerber files</a>
<a href="https://github.com/RuiSantosdotme/ESP32-IoT-Shield-PCB/raw/master/Project_ESP32%20IoT%20Shield_2020-06-10_09-57-16.zip" target="_blank">EasyEDA project to edit the PCB</a>
<k><a href="https://github.com/RuiSantosdotme/ESP32-IoT-Shield-PCB/archive/master.zip" target="_blank">Click here to download all the files</a></k>
<h3>Project Overview</h3>
This project consists of two parts: 
<ol>
Designing and Building the IoT shield 
Programming the IoT shield using Arduino IDE
</ol>
<h3>IoT Shield Features</h3>
The IoT sensor shield is designed to be stacked to the ESP32. For this reason, if you want to use our PCB, you need the same ESP32 board. We're using the <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32 DEVKIT DOIT V1</a> board (the model with <k>36 GPIOs</k>).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-IoT-Sensor-Shield-PCB-and-ESP32-board.jpg">
If you have another ESP32 model, you can still follow this project by assembling the circuit on a breadboard or modifying the PCB layout and wiring to match your ESP32 board.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-IoT-Shield-Breadboard-Circuit.jpg">
The shield consists of:
BME280 temperature, humidity and pressure sensor;
LDR (light dependent resistor);
PIR motion sensor;
Status on-board LED;
Pushbutton;
3-pin socket that gives you access to GND, 5V and a GPIO where you can connect any output (like a relay module for example).
<h3>ESP32 IoT Shield Pin Assignment</h3>
The following table describes the pin assignment for each component of the IoT shield:
<table><tbody>
<tr>
<td><k>Component</k></td>
<td><k>ESP32 Pin Assignment</k></td>
</tr>
<tr>
<td>BME280</td>
<td>GPIO 21 (SDA), GPIO 22 (SCL)</td>
</tr>
<tr>
<td>PIR Motion Sensor</td>
<td>GPIO 27</td>
</tr>
<tr>
<td>Light Dependent Resistor (LDR)</td>
<td>GPIO 33</td>
</tr>
<tr>
<td>Pushbutton</td>
<td>GPIO 18</td>
</tr>
<tr>
<td>LED</td>
<td>GPIO 19</td>
</tr>
<tr>
<td>Additional Output</td>
<td>GPIO 32</td>
</tr>
</tbody></table>If you want to assign and use different pins, read our <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">ESP32 Pinout Reference Guide</a>.
<h3>Web Server (IoT Dashboard) Features</h3>
To control the shield, we'll build a web server. However, you can program the sensor shield as you wish with any other web server or to integrate it with a home automation platform.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-IoT-Dashboard-Web-Server.jpg">
Here's the web server features to control the IoT shield:
To access the web server, you need to login with username and password (read: <a href="https://randomnerdtutorials.com/esp32-esp8266-web-server-http-authentication/">ESP32 Web Server HTTP Authentication: Username and Password Protected</a>).
After authenticating with the right credentials, you can access the web server. There's an icon at the top of the web page that you can click to logout. Then, you'll need to login again.
There are two toggle switches: one to control the output socket and another for the on-board status LED.
The status LED can also be controlled using the physical on-shield pushbutton. The state of the LED automatically updates on the web page (like in this tutorial: <a href="https://randomnerdtutorials.com/esp32-esp8266-web-server-physical-button/">Control Outputs with Web Server and a Physical Button Simultaneously</a>). The toggle switch for the status LED can be useful to activate or deactivate something on the ESP32 and the LED gives you a visual feedback of what's going on.
The temperature, humidity and luminosity are displayed on the web server and are automatically updated using server-sent events (SSE).
Finally, there's a card that indicates if motion was detected. After receiving the Motion Detected notification, you can click on the card to clear the warning.
These are the main features of the ESP32 IoT dashboard we're going to build. This combines many of the subjects approached in previous tutorials.
This is just an example on how you can control your shield. The idea is to modify the code to add your own features to the project.
<h3>Testing the Circuit on a Breadboard</h3>
Before designing and building the PCB shield, it's important to test the circuit on a breadboard. If you don't want to make a PCB, you can still follow this project by assembling the circuit on a breadboard.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-IoT-Shield-Breadboard-Circuit.jpg">
<h3>Parts Required</h3>
To assemble the circuit on a breadboard you need the following parts:
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">DOIT ESP32 DEVKIT V1 Board</a> (<k>version with 36 GPIOs</k>)  read <a href="https://makeradvisor.com/esp32-development-boards-review-comparison/" target="_blank">Best ESP32 Development Boards</a>
<a href="https://makeradvisor.com/tools/3mm-5mm-leds-kit-storage-box/" target="_blank">2x 5mm LED</a>
<a href="https://makeradvisor.com/tools/resistors-kits/" target="_blank">2x 330 Ohm resistor</a>
<a href="https://makeradvisor.com/tools/bme280-sensor-module/">1x BME280</a> (4 pins)
<a href="https://makeradvisor.com/tools/mini-hc-sr505-pir-motion-sensor/" target="_blank">1x mini PIR motion sensor</a>
<a href="https://makeradvisor.com/tools/photoresistor-light-dependent-resistor-ldr/" target="_blank">1x light dependent resistor</a>
<a href="https://makeradvisor.com/tools/resistors-kits/" target="_blank">2x 10k Ohm resistor</a>
<a href="https://makeradvisor.com/tools/pushbuttons-kit/" target="_blank">1x pushbutton</a>
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a>
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="lazy" fetchpriority="low"></a>
After gathering all the parts, assemble the circuit by following the next schematic diagram:
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-IoT-Shield-PCB-Circuit-Breadboard.jpg?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-IoT-Shield-PCB-Circuit-Breadboard.jpg"></a>
<h3>Designing the PCB</h3>
To design the circuit and PCB, we used <a rel="noreferrer noopener nofollow" href="https://easyeda.com/" target="_blank">EasyEDA</a> which is a browser based software to design PCBs. If you want to customize your PCB, you just need to upload the following files:
<a href="https://github.com/RuiSantosdotme/ESP32-IoT-Shield-PCB/raw/master/Project_ESP32%20IoT%20Shield_2020-06-10_09-57-16.zip" target="_blank">EasyEDA project files to edit the PCB</a>
Designing the circuit works like in any other circuit software tool, you place some components and you wire them together. Then, you assign each component to a footprint.
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-IoT-Shield-PCB-Schematic-Circuit-Diagram.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-IoT-Shield-PCB-Schematic-Circuit-Diagram.png"></a>
Having the parts assigned, place each component. When you're happy with the layout, make all the connections and route your PCB.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-IoT-Shield-PCB-Schematic.png">
Save your project and export the Gerber files.
<k>Note: </k> you can grab the project files and edit them to customize the shield for your own needs.
<a href="https://github.com/RuiSantosdotme/ESP32-IoT-Shield-PCB/raw/master/Gerber_PCB_ESP32_IoT_Shield_2020-06-10_10-55-31.zip" target="_blank"><k>Download Gerber .zip file</k></a>
<a href="https://github.com/RuiSantosdotme/ESP32-IoT-Shield-PCB/raw/master/Project_ESP32%20IoT%20Shield_2020-06-10_09-57-16.zip" target="_blank">EasyEDA project to edit the PCB</a>
<h3>Ordering the PCBs at PCBWay</h3>
This project is sponsored by PCBWay. <a href="https://randomnerdtutorials.com/pcbway" target="_blank">PCBWay</a> is a full feature Printed Circuit Board manufacturing service. 
<a href="https://makeradvisor.com/pcbway" target="_blank" rel="noopener noreferrer"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/PCBWay-banner.jpg"></a>
Turn your DIY breadboard circuits into <a href="https://randomnerdtutorials.com/pcbway" target="_blank">professional PCBs</a>  get 10 boards for approximately $5 + shipping (which will vary depending on your country).
Once you have your Gerber files, you can order the PCB. Follow the next steps to download the file.
1. Download the Gerber files  <a href="https://github.com/RuiSantosdotme/ESP32-IoT-Shield-PCB/raw/master/Gerber_PCB_ESP32_IoT_Shield_2020-06-10_10-55-31.zip" target="_blank">click here to download the .zip file</a>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/4-PCBWay-Order-PCB-import-zip-folder.png">
2. Go to <a href="https://randomnerdtutorials.com/pcbway" target="_blank">PCBWay website</a> and open the PCB Instant Quote page. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/1-PCBWay-Order-PCB.png">
3. PCBWay can grab all the PCB details and automatically fill them for you. Use the Quick-order PCB (Autofill parameters).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/2-PCBWay-Order-PCB-autofill-parameters.png">
4. Press the + Add Gerber file button to upload the provided Gerber files.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/3-PCBWay-Order-PCB-gerbers-files.png">
And that's it. You can also use the OnlineGerberViewer to check if your PCB is looking as it should.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/5-PCBWay-Order-PCB-Gerber-files-preview.png">
If you aren't in a hurry, you can use the China Post shipping method to lower your cost significantly. In our opinion, we think they overestimate the China Post shipping time.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/6-PCBWay-Order-PCB-china-post.png">
You can increase your PCB order quantity and change the solder mask color. I've ordered the Blue color.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/7-PCBWay-Order-PCB-final-step.png">
Once you're ready, you can order the PCBs by clicking Save to Cart and complete your order.
<h3>Unboxing</h3>
After approximately one week using the DHL shipping method, I received the PCBs at my office. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/PCBWay-Unboxing.jpg">
Everything comes well packed, and the PCBs are really high-quality. The letters on the silkscreen are really well-printed and easy to read. Additionally, the solder sticks easily to the pads.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/PCBWay-Unboxing-PCBs-bare-boards.jpg">
Besides the PCBs, I also received some stickers, a ruler and a pen. Overall, we're really satisfied with the PCBWay service.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/PCBWay-Unboxing-PCBs.jpg">
<h3>Soldering the Components</h3>
The next step is soldering the components to the PCB. I've used an SMD LED and SMD resistors. These can be a bit difficult to solder, but they save a lot of space on the PCB. 
Here's a list of all the components needed to build the PCB shield:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-IoT-Shield-PCB-assembled-components-parts-required.jpg">
<a href="https://makeradvisor.com/smd-leds/" target="_blank">1x SMD LED</a> (1206)
<a href="https://makeradvisor.com/smd-resistors" target="_blank">1x 330 Ohm SMD resistors</a> (1206)
<a href="https://makeradvisor.com/smd-resistors" target="_blank">2x 10k Ohm SMD resistor</a> (1206)
1x Pushbutton (0.55 mm)
<a href="https://makeradvisor.com/tools/bme280-sensor-module/">1x BME280</a>
<a href="https://makeradvisor.com/tools/mini-hc-sr505-pir-motion-sensor/" target="_blank">1x Mini PIR motion sensor</a>
<a href="https://makeradvisor.com/tools/photoresistor-light-dependent-resistor-ldr/" target="_blank">1x Light dependent resistor</a>
<a href="https://shrsl.com/roqk" target="_blank">1x Screw terminal blocks</a>
<a href="https://makeradvisor.com/female-pin-header-socket" target="_blank">Female pin header socket</a> (2.54 mm)
Here's the soldering tools I've used:
<a href="https://makeradvisor.com/ts80-soldering-iron-review/" target="_blank">TS80 mini portable soldering iron</a>
<a href="https://www.banggood.com/0_5mm-500g-Soldering-Wires-Welding-Iron-Rosin-Core-6040-Lead-Tin-Flux-2_0-Percent-p-1023387.html?p=MA240439985285201910" target="_blank">Solder 60/40 0.5mm diameter</a>
<a href="https://makeradvisor.com/soldering-mats-review/" target="_blank">Soldering mat</a>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/TS80-Soldering-Iron-Review-Best-Portable-Soldering-Iron.jpg">
Read our review about the TS80 Soldering Iron: <a href="https://makeradvisor.com/ts80-soldering-iron-review/" target="_blank">TS80 Soldering Iron Review  Best Portable Soldering Iron</a>.
Start by soldering the SMD components. Then, solder the header pins. And finally, solder the other components or use header pins if you don't want to connect the components permanently.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-IoT-Sensor-Shild-Soldering-Solder-parts-components.jpg">
Here's how the ESP32 IoT Shield looks like after assembling all the parts. It should connect perfectly to the ESP32 DEVKIT DOIT V1 board.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-IoT-Shield-PCB-assembled.jpg">
<hr>
<h3>Programming the ESP32 IoT Shield</h3>
The code for this project runs a web server that allows you to monitor and control the IoT shield. The features of the web server were covered previously.
We'll program the ESP32 board using Arduino IDE. So make sure you have the ESP32 board add-on installed.
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing ESP32 Board in Arduino IDE (Windows, Mac OS X, and Linux)</a>
<h3>Installing Libraries</h3>
Before uploading the code, make sure you have the following libraries installed:
<a href="https://github.com/adafruit/Adafruit_BME280_Library" target="_blank">Adafruit_BME280 library</a>
<a href="https://github.com/adafruit/Adafruit_Sensor" target="_blank">Adafruit_Sensor library</a>
<a href="https://github.com/me-no-dev/ESPAsyncWebServer" target="_blank">ESPAsyncWebServer</a>
<a href="https://github.com/me-no-dev/AsyncTCP" target="_blank">AsyncTCP</a>
Follow the next steps to install the libraries:
Open your Arduino IDE and go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k>. The Library Manager should open.
Search for <k>adafruit bme280</k>  on the Search box and install the library.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/08/install-bme280.png">To use the BME280 library, you also need to install the Adafruit_Sensor library. Follow the next steps to install the library in your Arduino IDE:
Go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k> and type <k>Adafruit Unified Sensor</k> in the search box. Scroll all the way down to find the library and install it.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/04/adafruit_unified_sensor_library.png">To install the ESPAsyncWebServer and the AsyncTCP libraries, click on the following links to download the .zip folder:
<a href="https://github.com/me-no-dev/ESPAsyncWebServer/archive/master.zip" target="_blank">ESPAsyncWebServer </a>
<a href="https://github.com/me-no-dev/AsyncTCP/archive/master.zip" target="_blank">AsyncTCP</a>
These libraries aren't available to install through the Arduino Library Manager, so you need to copy the library files to the Arduino Installation Libraries folder. Alternatively, in your Arduino IDE, you can go to <k>Sketch </k>> <k>Include Library</k> > <k>Add .zip Library</k> and select the libraries you've just downloaded.
<h3>Code  ESP32 IoT Shied Web Server Dashboard</h3>
Copy the following code to the Arduino IDE.
<k>/*********
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-iot-shield-pcb-dashboard/
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*********/
// Import required libraries
#include "WiFi.h"
#include "ESPAsyncWebServer.h"
#include &lt;Adafruit_BME280.h>
#include &lt;Adafruit_Sensor.h>
// Replace with your network credentials
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
// Web Server HTTP Authentication credentials
const char* http_username = "admin";
const char* http_password = "admin";
Adafruit_BME280 bme;         // BME280 connect to ESP32 I2C (GPIO 21 = SDA, GPIO 22 = SCL)
const int buttonPin = 18;    // Pushbutton
const int ledPin = 19;       // Status LED
const int output = 32;       // Output socket
const int ldr = 33;          // LDR (Light Dependent Resistor)
const int motionSensor = 27; // PIR Motion Sensor
int ledState = LOW;           // current state of the output pin
int buttonState;              // current reading from the input pin
int lastButtonState = LOW;    // previous reading from the input pin
bool motionDetected = false;  // flag variable to send motion alert message
bool clearMotionAlert = true; // clear last motion alert message from web page
unsigned long lastDebounceTime = 0;  // the last time the output pin was toggled
unsigned long debounceDelay = 50;    // the debounce time; increase if the output flickers
// Create AsyncWebServer object on port 80
AsyncWebServer server(80);
AsyncEventSource events("/events");
const char* PARAM_INPUT_1 = "state";
// Checks if motion was detected
void IRAM_ATTR detectsMovement() {
  //Serial.println("MOTION DETECTED!!!");
  motionDetected = true;
  clearMotionAlert = false;
}
// Main HTML web page in root url /
const char index_html[] PROGMEM = R"rawliteral(
&lt;!DOCTYPE HTML>&lt;html>
&lt;head>
  &lt;title>ESP IOT DASHBOARD&lt;/title>
  &lt;meta name="viewport" content="width=device-width, initial-scale=1">
  &lt;link rel="icon" href="data:,">
  &lt;link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
  &lt;style>
    html {font-family: Arial; display: inline-block; text-align: center;}
    h3 {font-size: 1.8rem; color: white;}
    h4 { font-size: 1.2rem;}
    p { font-size: 1.4rem;}
    body {  margin: 0;}
    .switch {position: relative; display: inline-block; width: 120px; height: 68px; margin-bottom: 20px;}
    .switch input {display: none;}
    .slider {position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; border-radius: 68px;   opacity: 0.8;   cursor: pointer;}
    .slider:before {position: absolute; content: ""; height: 52px; width: 52px; left: 8px; bottom: 8px; background-color: #fff; -webkit-transition: .4s; transition: .4s; border-radius: 68px}
    input:checked+.slider {background-color: #1b78e2}
    input:checked+.slider:before {-webkit-transform: translateX(52px); -ms-transform: translateX(52px); transform: translateX(52px)}
    .topnav { overflow: hidden; background-color: #1b78e2;}
    .content { padding: 20px;}
    .card { background-color: white; box-shadow: 2px 2px 12px 1px rgba(140,140,140,.5);}
    .cards { max-width: 700px; margin: 0 auto; display: grid; grid-gap: 2rem; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));}
    .slider2 { -webkit-appearance: none; margin: 14px;  height: 20px; background: #ccc; outline: none; opacity: 0.8; -webkit-transition: .2s; transition: opacity .2s; margin-bottom: 40px; }
    .slider:hover, .slider2:hover { opacity: 1; }
    .slider2::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 40px; height: 40px; background: #008B74; cursor: pointer; }
    .slider2::-moz-range-thumb { width: 40px; height: 40px; background: #008B74; cursor: pointer;}
    .reading { font-size: 2.6rem;}
    .card-switch {color: #50a2ff; }
    .card-light{ color: #008B74;}
    .card-bme{ color: #572dfb;}
    .card-motion{ color: #3b3b3b; cursor: pointer;}
    .icon-pointer{ cursor: pointer;}
  &lt;/style>
&lt;/head>
&lt;body>
  &lt;div>
    &lt;h3>ESP IOT DASHBOARD &lt;span style="text-align:right;">&nbsp;&nbsp; &lt;i onclick="logoutButton()">&lt;/i>&lt;/span>&lt;/h3>
  &lt;/div>
  &lt;div>
    &lt;div>
      %BUTTONPLACEHOLDER%
      &lt;div>
        &lt;h4>&lt;i>&lt;/i> TEMPERATURE&lt;/h4>&lt;div>&lt;p>&lt;span>&lt;/span>&deg;C&lt;/p>&lt;/div>
      &lt;/div>
      &lt;div>
        &lt;h4>&lt;i>&lt;/i> HUMIDITY&lt;/h4>&lt;div>&lt;p>&lt;span>&lt;/span>&percnt;&lt;/p>&lt;/div>
      &lt;/div>
      &lt;div>
        &lt;h4>&lt;i>&lt;/i> LIGHT&lt;/h4>&lt;div>&lt;p>&lt;span>&lt;/span>&lt;/p>&lt;/div>
      &lt;/div>
      &lt;div onClick="clearMotionAlert()">
        &lt;h4>&lt;i>&lt;/i> MOTION SENSOR&lt;/h4>&lt;div>&lt;p>&lt;span>%MOTIONMESSAGE%&lt;/span>&lt;/p>&lt;/div>
      &lt;/div>
  &lt;/div>
&lt;script>
function logoutButton() {
  var xhr = new XMLHttpRequest();
  xhr.open("GET", "/logout", true);
  xhr.send();
  setTimeout(function(){ window.open("/logged-out","_self"); }, 1000);
}
function controlOutput(element) {
  var xhr = new XMLHttpRequest();
  if(element.checked){ xhr.open("GET", "/output?state=1", true); }
  else { xhr.open("GET", "/output?state=0", true); }
  xhr.send();
}
function toggleLed(element) {
  var xhr = new XMLHttpRequest();
  xhr.open("GET", "/toggle", true);
  xhr.send();
}
function clearMotionAlert() {
  var xhr = new XMLHttpRequest();
  xhr.open("GET", "/clear-motion", true);
  xhr.send();
  setTimeout(function(){
    document.getElementById("motion").innerHTML = "No motion";
    document.getElementById("motion").style.color = "#3b3b3b";
  }, 1000);
}
if (!!window.EventSource) {
 var source = new EventSource('/events');
 source.addEventListener('open', function(e) {
  console.log("Events Connected");
 }, false);
 source.addEventListener('error', function(e) {
  if (e.target.readyState != EventSource.OPEN) {
    console.log("Events Disconnected");
  }
 }, false);
 source.addEventListener('message', function(e) {
  console.log("message", e.data);
 }, false);
 source.addEventListener('led_state', function(e) {
  console.log("led_state", e.data);
  var inputChecked;
  if( e.data == 1){ inputChecked = true; }
  else { inputChecked = false; }
  document.getElementById("led").checked = inputChecked;
 }, false);
 source.addEventListener('motion', function(e) {
  console.log("motion", e.data);
  document.getElementById("motion").innerHTML = e.data;
  document.getElementById("motion").style.color = "#b30000";
 }, false); 
 source.addEventListener('temperature', function(e) {
  console.log("temperature", e.data);
  document.getElementById("temp").innerHTML = e.data;
 }, false);
 source.addEventListener('humidity', function(e) {
  console.log("humidity", e.data);
  document.getElementById("humi").innerHTML = e.data;
 }, false);
 source.addEventListener('light', function(e) {
  console.log("light", e.data);
  document.getElementById("light").innerHTML = e.data;
 }, false);
}&lt;/script>
&lt;/body>
&lt;/html>)rawliteral";
String outputState(int gpio){
  if(digitalRead(gpio)){
    return "checked";
  }
  else {
    return "";
  }
}
String processor(const String& var){
  //Serial.println(var);
  if(var == "BUTTONPLACEHOLDER"){
    String buttons;
    String outputStateValue = outputState(32);
    buttons+="&lt;div class=\"card card-switch\">&lt;h4>&lt;i class=\"fas fa-lightbulb\">&lt;/i> OUTPUT&lt;/h4>&lt;label class=\"switch\">&lt;input type=\"checkbox\" onchange=\"controlOutput(this)\" id=\"output\" " + outputStateValue + ">&lt;span class=\"slider\">&lt;/span>&lt;/label>&lt;/div>";
    outputStateValue = outputState(19);
    buttons+="&lt;div class=\"card card-switch\">&lt;h4>&lt;i class=\"fas fa-lightbulb\">&lt;/i> STATUS LED&lt;/h4>&lt;label class=\"switch\">&lt;input type=\"checkbox\" onchange=\"toggleLed(this)\" id=\"led\" " + outputStateValue + ">&lt;span class=\"slider\">&lt;/span>&lt;/label>&lt;/div>";
    return buttons;
  }
  else if(var == "MOTIONMESSAGE"){
    if(!clearMotionAlert) {
      return String("&lt;span style=\"color:#b30000;\">MOTION DETECTED!&lt;/span>");
    }
    else {
      return String("No motion");
    }
  }
  return String();
}
// Logged out web page
const char logout_html[] PROGMEM = R"rawliteral(
&lt;!DOCTYPE HTML>&lt;html>
&lt;head>
  &lt;meta name="viewport" content="width=device-width, initial-scale=1">
&lt;/head>
&lt;body>
  &lt;p>Logged out or &lt;a href="/">return to homepage&lt;/a>.&lt;/p>
  &lt;p>&lt;strong>Note:&lt;/strong> close all web browser tabs to complete the logout process.&lt;/p>
&lt;/body>
&lt;/html>
)rawliteral";
void setup(){
  // Serial port for debugging purposes
  Serial.begin(115200);
    
  if (!bme.begin(0x76)) {
    Serial.println("Could not find a valid BME280 sensor, check wiring!");
    while (1);
  }
  
  // initialize the pushbutton pin as an input
  pinMode(buttonPin, INPUT);
  // initialize the LED pin as an output
  pinMode(ledPin, OUTPUT);
  // initialize the LED pin as an output
  pinMode(output, OUTPUT);
  // PIR Motion Sensor mode INPUT_PULLUP
  pinMode(motionSensor, INPUT_PULLUP);
  // Set motionSensor pin as interrupt, assign interrupt function and set RISING mode
  attachInterrupt(digitalPinToInterrupt(motionSensor), detectsMovement, RISING);
  
  // Connect to Wi-Fi
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi..");
  }
  // Print ESP32 Local IP Address
  Serial.println(WiFi.localIP());
  // Route for root / web page
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
   if(!request->authenticate(http_username, http_password))
      return request->requestAuthentication();
    request->send_P(200, "text/html", index_html, processor);
  });
  server.on("/logged-out", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send_P(200, "text/html", logout_html, processor);
  });
  server.on("/logout", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send(401);
  });
  // Send a GET request to control output socket &lt;ESP_IP>/output?state=&lt;inputMessage>
  server.on("/output", HTTP_GET, [] (AsyncWebServerRequest *request) {
    if(!request->authenticate(http_username, http_password))
      return request->requestAuthentication();
    String inputMessage;
    // GET gpio and state value
    if (request->hasParam(PARAM_INPUT_1)) {
      inputMessage = request->getParam(PARAM_INPUT_1)->value();
      digitalWrite(output, inputMessage.toInt());
      request->send(200, "text/plain", "OK");
    }
    request->send(200, "text/plain", "Failed");
  });
  // Send a GET request to control on board status LED &lt;ESP_IP>/toggle
  server.on("/toggle", HTTP_GET, [] (AsyncWebServerRequest *request) {
    if(!request->authenticate(http_username, http_password))
      return request->requestAuthentication();
    ledState = !ledState;
    digitalWrite(ledPin, ledState);
    request->send(200, "text/plain", "OK");
  });
  // Send a GET request to clear the "Motion Detected" message &lt;ESP_IP>/clear-motion
  server.on("/clear-motion", HTTP_GET, [] (AsyncWebServerRequest *request) {
    if(!request->authenticate(http_username, http_password))
      return request->requestAuthentication();
    clearMotionAlert = true;
    request->send(200, "text/plain", "OK");
  });
  events.onConnect([](AsyncEventSourceClient *client){
    if(client->lastId()){
      Serial.printf("Client reconnected! Last message ID that it got is: %u\n", client->lastId());
    }
    // send event with message "hello!", id current millis and set reconnect delay to 1 second
    client->send("hello!",NULL,millis(),1000);
  });
  server.addHandler(&events);
  
  // Start server
  server.begin();
}
 
void loop(){
  static unsigned long lastEventTime = millis();
  static const unsigned long EVENT_INTERVAL_MS = 10000;
  // read the state of the switch into a local variable
  int reading = digitalRead(buttonPin);
  // If the switch changed
  if (reading != lastButtonState) {
    // reset the debouncing timer
    lastDebounceTime = millis();
  }
  if ((millis() - lastDebounceTime) > debounceDelay) {
    // if the button state has changed:
    if (reading != buttonState) {
      buttonState = reading;
      // only toggle the LED if the new button state is HIGH
      if (buttonState == HIGH) {
        ledState = !ledState;
        digitalWrite(ledPin, ledState);
        events.send(String(digitalRead(ledPin)).c_str(),"led_state",millis());
      }
    }
  }
  if ((millis() - lastEventTime) > EVENT_INTERVAL_MS) {
    events.send("ping",NULL,millis());
    events.send(String(bme.readTemperature()).c_str(),"temperature",millis());
    events.send(String(bme.readHumidity()).c_str(),"humidity",millis());
    events.send(String(analogRead(ldr)).c_str(),"light",millis());
    lastEventTime = millis();
  }
  
  if(motionDetected & !clearMotionAlert){
    events.send(String("MOTION DETECTED!").c_str(),"motion",millis());
    motionDetected = false;
  }
  
  // save the reading. Next time through the loop, it'll be the lastButtonState:
  lastButtonState = reading;
}
</k>
<a href="https://github.com/RuiSantosdotme/ESP32-IoT-Shield-PCB/raw/master/ESP32_IoT_Shield_Dashboard/ESP32_IoT_Shield_Dashboard.ino" target="_blank">View raw code</a>
This code is quite long to explain, so you can simply replace the following two variables with your network credentials and the code will work straight away.
<k>const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
If you want to learn how this code works, continue reading. Otherwise, you can skip to the Demonstration section.
<h3>How the Code Works</h3>
Read this section if you want to learn how the code works, or skip to the next section.
The following lines import the required libraries:
<k>#include "WiFi.h"
#include "ESPAsyncWebServer.h"
#include &lt;Adafruit_BME280.h>
#include &lt;Adafruit_Sensor.h></k>
Insert your network credentials in the following lines so that the ESP32 can connect to your network.
<k>// Replace with your network credentials
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
The next lines define the username and password to access the web server. By default the username is <k>admin</k> and the password is<k> admin</k>. You can change them on the following lines:
<k>// Web Server HTTP Authentication credentials
const char* http_username = "admin";
const char* http_password = "admin";</k>
Create an Adafruit_BME280 object called bme. This creates an I2C connection to the BME280 on GPIO 21 and GPIO 22.
<k>Adafruit_BME280 bme;  // BME280 connect to ESP32 I2C (GPIO 21 = SDA, GPIO 22 = SCL)</k>
Then, define the GPIOs the components of the shield are connected to.
<k>const int buttonPin = 18;    // Pushbutton
const int ledPin = 19;       // Status LED
const int output = 32;       // Output socket
const int ldr = 33;          // LDR (Light Dependent Resistor)
const int motionSensor = 27; // PIR Motion Sensor</k>
Create the following variables to old states. The comments explain what each variable means.
<k>int ledState = LOW;           // current state of the output pin
int buttonState;              // current reading from the input pin
int lastButtonState = LOW;    // previous reading from the input pin
bool motionDetected = false;  // flag variable to send motion alert message
bool clearMotionAlert = true; // clear last motion alert message from web page</k>
The lastDebounceTime and the debounceDelay variables are used to debounce the button. This prevents false positive button presses.
<k>unsigned long lastDebounceTime = 0; // the last time the output pin was toggled
unsigned long debounceDelay = 50;   // the debounce time; increase if the output flickers</k>
Create an AsyncWebServer object on port 80.
<k>AsyncWebServer server(80);</k>
To automatically display the information on the web server when new readings are available, we'll use Server-Sent Events (SSE).
The following line creates a new event source on /events. Server-Sent Events allow a web page (client) to get updates from a server.
<k>AsyncEventSource events("/events");</k>
The PARAM_INPUT_1 variable will be used to check whether a certain URL request contains the parameter state.
<k>const char* PARAM_INPUT_1 = "state";</k>
<h3>Interrupt Callback Function</h3>
The detectsMovement() callback function will be called when the PIR motion sensor senses motion (an interrupt is triggered). The function changes the state of the motionDetected variable to true so that we know that motion was detected and set the clearMotionAlert variable to false because we want the Motion Detected message to be displayed on the web server.
<k>void IRAM_ATTR detectsMovement() {
  //Serial.println("MOTION DETECTED!!!");
  motionDetected = true;
  clearMotionAlert = false;
}</k>
<h3>Building the Web Page</h3>
The index_html variable contains all the HTML, CSS and JavaScript to build the web page. We won't go into details on how the HTML and CSS works. We'll just take a look at how to handle the events sent by the server.
<h4>Handle Events</h4>
Create a new EventSource object and specify the URL of the page sending the updates. In our case, it's /events.
<k>if (!!window.EventSource) {
 var source = new EventSource('/events');</k>
Once you've instantiated an event source, you can start listening for messages from the server with addEventListener().
These are the default event listeners, as shown here in the AsyncWebServer <a href="https://github.com/me-no-dev/ESPAsyncWebServer#setup-event-source-in-the-browser" target="_blank">documentation</a>.
<k>source.addEventListener('open', function(e) {
  console.log("Events Connected");
}, false);
source.addEventListener('error', function(e) {
 if (e.target.readyState != EventSource.OPEN) {
   console.log("Events Disconnected");
 }
}, false);
source.addEventListener('message', function(e) {
 console.log("message", e.data);
}, false);</k>
Then, add the other event listeners. 
When you change the status LED state, the ESP32 sends an event (led_state) with that information so that the dashboard updates automatically.
<k>source.addEventListener('led_state', function(e) {
  console.log("led_state", e.data);
  var inputChecked;
  if( e.data == 1){ inputChecked = true; }
  else { inputChecked = false; }
  document.getElementById("led").checked = inputChecked;
}, false);</k>
When the browser receives this event, it changes the state of the toggle switch element.
The motion event is sent when motion is detected. When this happens, it changes the content of the message and changes its color.
<k>source.addEventListener('motion', function(e) {
  console.log("motion", e.data);
  document.getElementById("motion").innerHTML = e.data;
  document.getElementById("motion").style.color = "#b30000";
}, false); </k>
The temperature, humidity and light events are sent to the browser when new readings are available. 
<k>source.addEventListener('temperature', function(e) {
  console.log("temperature", e.data);
  document.getElementById("temp").innerHTML = e.data;
}, false);
source.addEventListener('humidity', function(e) {
  console.log("humidity", e.data);
  document.getElementById("humi").innerHTML = e.data;
}, false);
source.addEventListener('light', function(e) {
  console.log("light", e.data);
  document.getElementById("light").innerHTML = e.data;
}, false);</k>
When that happens, we put the received data into the elements with the corresponding id.
<h3>outputState() function</h3>
The outputState() function is used to check the current output state of a GPIO. It returns checked if the GPIO is on or an empty string if it isn't. The returned string will be used to build the web page with the current outputs states. This way, every time you access the web server you see the current states.
<k>String outputState(int gpio){
  if(digitalRead(gpio)){
    return "checked";
  }
  else {
    return "";
  }
}</k>
<h3>processor()</h3>
The processor() function replaces the placeholders on the HTML text with whatever string we want. We use the processor() function so that when you access the web server page for the first time in a new browser tab, it shows the current GPIO states, and motion sensor state.
The BUTTONPLACEHODER is replaced with the HTML text to build the button with the right states.
<k>if(var == "BUTTONPLACEHOLDER"){
  String buttons;
  String outputStateValue = outputState(32);
  buttons+="&lt;div class=\"card card-switch\">&lt;h4>&lt;i class=\"fas fa-lightbulb\">&lt;/i> OUTPUT&lt;/h4>&lt;label class=\"switch\">&lt;input type=\"checkbox\" onchange=\"controlOutput(this)\" id=\"output\" " + outputStateValue + ">&lt;span class=\"slider\">&lt;/span>&lt;/label>&lt;/div>";
  outputStateValue = outputState(19);
  buttons+="&lt;div class=\"card card-switch\">&lt;h4>&lt;i class=\"fas fa-lightbulb\">&lt;/i> STATUS LED&lt;/h4>&lt;label class=\"switch\">&lt;input type=\"checkbox\" onchange=\"toggleLed(this)\" id=\"led\" " + outputStateValue + ">&lt;span class=\"slider\">&lt;/span>&lt;/label>&lt;/div>";
  return buttons;
}</k>
The MOTIONMESSAGE placeholder is replaced with the MOTION DETECTED message or No motion message, depending on the current motion state.
<k>else if(var == "MOTIONMESSAGE"){
  if(!clearMotionAlert) {
    return String("&lt;span style=\"color:#b30000;\">MOTION DETECTED!&lt;/span>");
  }
  else {
    return String("No motion");
  }
}
return String();</k>
<h3>Logout Page</h3>
The logout_html variable contains the HTML text to build the logout page. You are redirected to the logout page when you click on the web page logout button.
<k>const char logout_html[] PROGMEM = R"rawliteral(
&lt;!DOCTYPE HTML>&lt;html>
&lt;head>
  &lt;meta name="viewport" content="width=device-width, initial-scale=1">
&lt;/head>
&lt;body>
  &lt;p>Logged out or &lt;a href="/">return to homepage&lt;/a>.&lt;/p>
  &lt;p>&lt;strong>Note:&lt;/strong> close all web browser tabs to complete the logout process.&lt;/p>
&lt;/body>
&lt;/html>
)rawliteral";</k>
In the logout page, there's a link that allows you to go back to the login page (root <k>/ </k>URL).
<k>&lt;p>Logged out or &lt;a href="/">return to homepage&lt;/a>.&lt;/p></k>
<h3>setup()</h3>
In the setup(), initialize the serial monitor.
<k>Serial.begin(115200);</k>
Initialize the BME280 sensor.
<k>if (!bme.begin(0x76)) {
  Serial.println("Could not find a valid BME280 sensor, check wiring!");
  while (1);
}</k>
Set the button as an input, the status led and the additional output as outputs and the PIR motion sensor as an interrupt.
<k>// initialize the pushbutton pin as an input
pinMode(buttonPin, INPUT);
// initialize the LED pin as an output
pinMode(ledPin, OUTPUT);
// initialize the LED pin as an output
pinMode(output, OUTPUT);
// PIR Motion Sensor mode INPUT_PULLUP
pinMode(motionSensor, INPUT_PULLUP);
// Set motionSensor pin as interrupt, assign interrupt function and set RISING mode
attachInterrupt(digitalPinToInterrupt(motionSensor), detectsMovement, RISING);</k>
Connect to wi-fi and print the ESP32 IP address.
<k>// Connect to Wi-Fi
WiFi.begin(ssid, password);
while (WiFi.status() != WL_CONNECTED) {
  delay(1000);
  Serial.println("Connecting to WiFi..");
}
// Print ESP32 Local IP Address
Serial.println(WiFi.localIP());</k>
<h3>Handle Requests</h3>
We need to handle what happens when the ESP32 receives a request on a certain URL.
<h4>Handle Requests with Authentication</h4>
Every time you make a request to the ESP32 to access the web server, it will check whether you've already entered the correct username and password to authenticate.
Basically, to add authentication to your web server, you just need to add the following lines after each request:
<k>if(!request->authenticate(http_username, http_password))
  return request->requestAuthentication();</k>
These lines continuously pop up the authentication window until you insert the right credentials.
You need to do this for all requests. This way, you ensure that you'll only get responses if you are logged in.
For example, when you try to access the root URL (ESP IP address), you add the previous two lines before sending the page. If you enter the wrong credentials, the browser will keep asking for them.
<k>Recommended reading:</k> <a href="https://randomnerdtutorials.com/esp32-esp8266-web-server-http-authentication/">ESP32/ESP8266 Web Server HTTP Authentication (Username and Password Protected)</a>
If you access the root / URL and insert the right credentials, send the main web page (saved on the index_html) variable.
<k>server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
 if(!request->authenticate(http_username, http_password))
    return request->requestAuthentication();
  request->send_P(200, "text/html", index_html, processor);
});</k>
<h4>Handle Logout</h4>
When you click the logout button, the ESP receives a request on the <k><em>/logout</em></k> URL. When that happens send the response code 401.
<k>server.on("/logout", HTTP_GET, [](AsyncWebServerRequest *request){
  request->send(401);
});</k>
The response code 401 is an unauthorized error HTTP response status code indicating that the request sent by the client could not be authenticated. So, it will have the same effect as a logout  it will ask for the username and password and won't let you access the web server again until you login.
When you click the web server logout button, after one second, the ESP receives another request on the <em><k>/logged-out</k></em> URL. When that happens, send the HTML text to build the logout page (logout_html variable).
<k>server.on("/logged-out", HTTP_GET, [](AsyncWebServerRequest *request){
  request->send_P(200, "text/html", logout_html, processor);
});</k>
<h4>Handle Output</h4>
When you click the button to control the output, the ESP receives a request like this <em>/output?state=&lt;inputMessage></em>. The inputMessage can be either 0 or 1 (off or on).
The following lines checker whether the request on the <em>/output</em> URL contains the parameter state. If it does, save the value of the state into the inputMessage variable. Then, control the output GPIO with the value of that message digitalWrite(output, inputMessage.toInt());
<k>// Send a GET request to control output socket &lt;ESP_IP>/output?state=&lt;inputMessage>
server.on("/output", HTTP_GET, [] (AsyncWebServerRequest *request) {
  if(!request->authenticate(http_username, http_password))
    return request->requestAuthentication();
  String inputMessage;
  // GET gpio and state value
  if (request->hasParam(PARAM_INPUT_1)) {
    inputMessage = request->getParam(PARAM_INPUT_1)->value();
    digitalWrite(output, inputMessage.toInt());
    request->send(200, "text/plain", "OK");
  }
  request->send(200, "text/plain", "Failed");
});</k>
<h4>Handle Status LED</h4>
When you control the status LED, invert the button state.
<k>// Send a GET request to control on board status LED &lt;ESP_IP>/toggle
server.on("/toggle", HTTP_GET, [] (AsyncWebServerRequest *request) {
  if(!request->authenticate(http_username, http_password))
    return request->requestAuthentication();
  ledState = !ledState;
  digitalWrite(ledPin, ledState);
  request->send(200, "text/plain", "OK");
});</k>
<h4>Handle Motion</h4>
When you click the motion sensor card after motion being detected, you make a request on the <em>/clear-motion</em> URL. When that happens, set the clearMotion variable to true.
<k>server.on("/clear-motion", HTTP_GET, [] (AsyncWebServerRequest *request) {
  if(!request->authenticate(http_username, http_password))
    return request->requestAuthentication();
  clearMotionAlert = true;
  request->send(200, "text/plain", "OK");
});</k>
<h3>Server Event Source</h3>
Set up the event source on the server.
<k>events.onConnect([](AsyncEventSourceClient *client){
  if(client->lastId()){
    Serial.printf("Client reconnected! Last message ID that it got is: %u\n", client->lastId());
  }
  // send event with message "hello!", id current millis and set reconnect delay to 1 second
  client->send("hello!",NULL,millis(),1000);
});
server.addHandler(&events);</k>
Finally, start the web server.
<k>server.begin();</k>
<h3>loop()</h3>
In the loop(), check the pushbutton state. If the button state has changed its state, change the output LED state accordingly, and send an event to the browser to change the output state on the web page.
<k>int reading = digitalRead(buttonPin);
// If the switch changed
if (reading != lastButtonState) {
  // reset the debouncing timer
  lastDebounceTime = millis();
}
if ((millis() - lastDebounceTime) > debounceDelay) {
  // if the button state has changed:
  if (reading != buttonState) {
    buttonState = reading;
    // only toggle the LED if the new button state is HIGH
    if (buttonState == HIGH) {
      ledState = !ledState;
      digitalWrite(ledPin, ledState);
      events.send(String(digitalRead(ledPin)).c_str(),"led_state",millis());
    }
  }
}</k>
Send sensor readings to the browser using server-sent events, every 10 seconds. You can change that period of time in the EVENT_INTERVAL_MS variable.
<k>if ((millis() - lastEventTime) > EVENT_INTERVAL_MS) {
  events.send("ping",NULL,millis());
  events.send(String(bme.readTemperature()).c_str(),"temperature",millis());
  events.send(String(bme.readHumidity()).c_str(),"humidity",millis());
  events.send(String(analogRead(ldr)).c_str(),"light",millis());
  lastEventTime = millis();
}</k>
When motion is detected and if we haven't cleared the notification, send the MOTION DETECTED message in the event.
<k>if(motionDetected & !clearMotionAlert){
  events.send(String("MOTION DETECTED!").c_str(),"motion",millis());
  motionDetected = false;
}</k>
<h3>Upload the Code</h3>
To upload code, go to <k>Tools</k>> <k>Board </k>and select <k>DOIT ESP32 DEVKIT V1</k>. Go to <k>Tools </k>> <k>Port </k>and select the COM port the ESP32 is connected to. Then, click the upload button:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/upload-button-arduino-ide.png">
<h3>Testing the Multisensor Shield</h3>
Open the Serial Monitor at a baud rate of 112500. Press the ESP32 RST button to print the ESP IP address.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-IP-Address-Serial-Monitor.jpg">
Open your browser and type the ESP32 IP address. The following page should load. Insert the username and password to access the web server. By default the username is admin and the password is admin. You can change that on the code.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-IOT-dashboard-web-server-login.png">
After inserting the right credentials, you have access to the dashboard functionalities. There are two toggle switches: one to control the status LED and another to control the additional output.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-Io-T-Dashboard-Web-Server-Control-Outputs.jpg">
You can control the status LED using the toggle switch and also the shield physical button. The state is automatically updated on the web page. There's another toggle button to control an additional output like a relay module.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-IoT-Shield-Breadboard-Circuit-Demonstration.jpg">
<k>Recommended reading:</k> <a href="https://randomnerdtutorials.com/esp32-relay-module-ac-web-server/">ESP32 Relay Module  Control AC Appliances (Web Server)</a>
The web server shows the latest sensor readings. The readings are updated every 10 seconds automatically using server-sent events. This means that when the ESP32 grabs new readings, it sends an event to the client (your browser). When this event happens, it updates the fields with new readings.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-Io-T-Dashboard-Web-Server-sensor-readings.png">
Finally, there's a card indicating if motion was detected or not. When motion is detected, it shows the Motion Detected message. This message is also updated automatically using server-sent events. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-Io-T-Dashboard-Web-Server-Motion.png">
Once, you've seen this notification, you can click the motion card. It will clear the warning message and show No motion instead.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-Io-T-Dashboard-Web-Server-No-Motion.png">
<h3>Wrapping Up</h3>
We hope you've found this project useful and you're able to build it yourself. You can program the IoT Shield with other code suitable for your needs. For example, you can control the output based on the current temperature value or <a href="https://randomnerdtutorials.com/esp32-esp8266-thermostat-web-server/">add a threshold field</a>. You can also edit the gerber files and add other features to the ESP32 IoT Shield.
We have other similar projects that include building and designing PCBs that you may like:
<a href="https://randomnerdtutorials.com/build-an-all-in-one-esp32-weather-station-shield/">Build an All-in-One ESP32 Weather Station Shield</a>
<a href="https://randomnerdtutorials.com/esp8266-multisensor-shield/">Build a Multisensor Shield for ESP8266</a>
<a href="https://randomnerdtutorials.com/power-saving-latching-circuit/">EXTREME POWER SAVING with Microcontroller External Wake Up: Latching Power PCB</a>
<h2>ESP32 Async Web Server  Control Outputs with Arduino IDE (ESPAsyncWebServer library)</a8></h2>
In this tutorial you'll learn how to build an asynchronous web server with the ESP32 board to control its outputs. The board will be programmed using Arduino IDE, and we'll use the ESPAsyncWebServer library.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ESP32-ESP8266-AsyncWebServer-Web-Server-Arduino-IDE.jpg">
<k>You might also like:</k> <a href="https://randomnerdtutorials.com/esp8266-nodemcu-async-web-server-espasyncwebserver-library/">ESP8266 NodeMCU Async Web Server  Control Outputs with Arduino IDE (ESPAsyncWebServer library)</a>
<h3>Asynchronous Web Server</h3>
To build the web server we'll use the <a href="https://github.com/me-no-dev/ESPAsyncWebServer" target="_blank">ESPAsyncWebServer library</a> that provides an easy way to build an asynchronous web server. Building an asynchronous web server has several advantages as mentioned in the library GitHub page, such as:
Handle more than one connection at the same time;
When you send the response, you are immediately ready to handle other connections while the server is taking care of sending the response in the background;
Simple template processing engine to handle templates;
And much more.
Take a look at the <a href="https://github.com/me-no-dev/ESPAsyncWebServer" target="_blank">library documentation</a> on its GitHub page.
<h3>Parts Required</h3>
In this tutorial we'll control three outputs. As an example, we'll control LEDs. So, you need the following parts:
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> (read <a href="https://makeradvisor.com/esp32-development-boards-review-comparison/" target="_blank">Best ESP32 Development Board</a>)
3x <a href="https://makeradvisor.com/tools/3mm-5mm-leds-kit-storage-box/" target="_blank">LEDs</a>
3x <a href="https://makeradvisor.com/tools/resistors-kits/" target="_blank">220 Ohm Resistor</a>
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a>
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="eager" fetchpriority="high" decoding="async"></a>
<h3>Schematic</h3>
Before proceeding to the code, wire 3 LEDs to the ESP32. We're connecting the LEDs to GPIOs 2, 4 and 33, but you can use any other GPIOs (read <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">ESP32 GPIO Reference Guide</a>).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ESP32-Control-Three-LEDs.png">
<h3>Installing Libraries  ESP Async Web Server</h3>
To build the web server you need to install the following libraries. Click the links below to download the libraries.
<a href="https://github.com/me-no-dev/ESPAsyncWebServer/archive/master.zip" target="_blank">ESPAsyncWebServer</a> 
<a href="https://github.com/me-no-dev/AsyncTCP/archive/master.zip" target="_blank">AsyncTCP</a>
These libraries aren't available to install through the Arduino Library Manager, so you need to copy the library files to the Arduino Installation Libraries folder. Alternatively, in your Arduino IDE, you can go to <k>Sketch </k>> <k>Include Library</k> > <k>Add .zip Library</k> and select the libraries you've just downloaded.
<h3>Project Overview</h3>
To better understand the code, let's see how the web server works.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ESP32-Asybc-Web-Server-Control-Outputs.png">
The web server contains one heading ESP Web Server and three buttons (toggle switches) to control three outputs. Each slider button has a label indicating the GPIO output pin. You can easily remove/add more outputs.
When the slider is red, it means the output is on (its state is HIGH). If you toggle the slider, it turns off the output (change the state to LOW).
When the slider is gray, it means the output is off (its state is LOW). If you toggle the slider, it turns on the output (change the state to HIGH).
<h3>How it Works?</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ESP32-Async-Web-Server-Project-Overview-How-toggle-Buttons-Work.png">
Let's see what happens when you toggle the buttons. We'll see the example for GPIO 2. It works similarly for the other buttons.
<k>1.</k> In the first scenario, you toggle the button to turn GPIO 2 on. When that happens, the browser makes an HTTP GET request on the /update?output=<k>2</k>&state=<k>1</k> URL. Based on that URL, the ESP changes the state of GPIO 2 to 1 (<k>HIGH</k>) and turns the LED on.
<k>2.</k> In the second example,  you toggle the button to turn GPIO 2 off. When that happens, the browser makes an HTTP GET request on the /update?output=<k>2</k>&state=<k>0</k> URL. Based on that URL, we change the state of GPIO 2 to 0 (<k>LOW</k>) and turn the LED off.
<h3>Code for ESP Async Web Server</h3>
Copy the following code to your Arduino IDE.
<k>/*********
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-async-web-server-espasyncwebserver-library/
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*********/
// Import required libraries
#include &lt;WiFi.h>
#include &lt;AsyncTCP.h>
#include &lt;ESPAsyncWebServer.h>
// Replace with your network credentials
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
const char* PARAM_INPUT_1 = "output";
const char* PARAM_INPUT_2 = "state";
// Create AsyncWebServer object on port 80
AsyncWebServer server(80);
const char index_html[] PROGMEM = R"rawliteral(
&lt;!DOCTYPE HTML>&lt;html>
&lt;head>
  &lt;title>ESP Web Server&lt;/title>
  &lt;meta name="viewport" content="width=device-width, initial-scale=1">
  &lt;link rel="icon" href="data:,">
  &lt;style>
    html {font-family: Arial; display: inline-block; text-align: center;}
    h2 {font-size: 3.0rem;}
    p {font-size: 3.0rem;}
    body {max-width: 600px; margin:0px auto; padding-bottom: 25px;}
    .switch {position: relative; display: inline-block; width: 120px; height: 68px} 
    .switch input {display: none}
    .slider {position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; border-radius: 6px}
    .slider:before {position: absolute; content: ""; height: 52px; width: 52px; left: 8px; bottom: 8px; background-color: #fff; -webkit-transition: .4s; transition: .4s; border-radius: 3px}
    input:checked+.slider {background-color: #b30000}
    input:checked+.slider:before {-webkit-transform: translateX(52px); -ms-transform: translateX(52px); transform: translateX(52px)}
  &lt;/style>
&lt;/head>
&lt;body>
  &lt;h2>ESP Web Server&lt;/h2>
  %BUTTONPLACEHOLDER%
&lt;script>function toggleCheckbox(element) {
  var xhr = new XMLHttpRequest();
  if(element.checked){ xhr.open("GET", "/update?output="+element.id+"&state=1", true); }
  else { xhr.open("GET", "/update?output="+element.id+"&state=0", true); }
  xhr.send();
}
&lt;/script>
&lt;/body>
&lt;/html>
)rawliteral";
// Replaces placeholder with button section in your web page
String processor(const String& var){
  //Serial.println(var);
  if(var == "BUTTONPLACEHOLDER"){
    String buttons = "";
    buttons += "&lt;h4>Output - GPIO 2&lt;/h4>&lt;label class=\"switch\">&lt;input type=\"checkbox\" onchange=\"toggleCheckbox(this)\" id=\"2\" " + outputState(2) + ">&lt;span class=\"slider\">&lt;/span>&lt;/label>";
    buttons += "&lt;h4>Output - GPIO 4&lt;/h4>&lt;label class=\"switch\">&lt;input type=\"checkbox\" onchange=\"toggleCheckbox(this)\" id=\"4\" " + outputState(4) + ">&lt;span class=\"slider\">&lt;/span>&lt;/label>";
    buttons += "&lt;h4>Output - GPIO 33&lt;/h4>&lt;label class=\"switch\">&lt;input type=\"checkbox\" onchange=\"toggleCheckbox(this)\" id=\"33\" " + outputState(33) + ">&lt;span class=\"slider\">&lt;/span>&lt;/label>";
    return buttons;
  }
  return String();
}
String outputState(int output){
  if(digitalRead(output)){
    return "checked";
  }
  else {
    return "";
  }
}
void setup(){
  // Serial port for debugging purposes
  Serial.begin(115200);
  pinMode(2, OUTPUT);
  digitalWrite(2, LOW);
  pinMode(4, OUTPUT);
  digitalWrite(4, LOW);
  pinMode(33, OUTPUT);
  digitalWrite(33, LOW);
  
  // Connect to Wi-Fi
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi..");
  }
  // Print ESP Local IP Address
  Serial.println(WiFi.localIP());
  // Route for root / web page
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send_P(200, "text/html", index_html, processor);
  });
  // Send a GET request to &lt;ESP_IP>/update?output=&lt;inputMessage1>&state=&lt;inputMessage2>
  server.on("/update", HTTP_GET, [] (AsyncWebServerRequest *request) {
    String inputMessage1;
    String inputMessage2;
    // GET input1 value on &lt;ESP_IP>/update?output=&lt;inputMessage1>&state=&lt;inputMessage2>
    if (request->hasParam(PARAM_INPUT_1) && request->hasParam(PARAM_INPUT_2)) {
      inputMessage1 = request->getParam(PARAM_INPUT_1)->value();
      inputMessage2 = request->getParam(PARAM_INPUT_2)->value();
      digitalWrite(inputMessage1.toInt(), inputMessage2.toInt());
    }
    else {
      inputMessage1 = "No message sent";
      inputMessage2 = "No message sent";
    }
    Serial.print("GPIO: ");
    Serial.print(inputMessage1);
    Serial.print(" - Set to: ");
    Serial.println(inputMessage2);
    request->send(200, "text/plain", "OK");
  });
  // Start server
  server.begin();
}
void loop() {
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESPAsyncWebServer_library_example.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
In this section we'll explain how the code works. Keep reading if you want to learn more or jump to the Demonstration section to see the final result.
<h3>Importing libraries</h3>
First, import the required libraries. You need to include the WiFi, ESPAsyncWebserver and the AsyncTCP libraries.
<k>#include &lt;WiFi.h>
#include &lt;AsyncTCP.h>
#include &lt;ESPAsyncWebServer.h></k>
<h3>Setting your network credentials</h3>
Insert your network credentials in the following variables, so that the ESP32 can connect to your local network.
<k>const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h3>Input Parameters</h3>
To check the parameters passed on the URL (GPIO number and its state), we create two variables, one for the output and other for the state. 
<k>const char* PARAM_INPUT_1 = "output";
const char* PARAM_INPUT_2 = "state";</k>
Remember that the ESP32 receives requests like this: /update?<k>output</k>=2&<k>state</k>=0
<h3>AsyncWebServer object</h3>
Create an AsyncWebServer object on port 80.
<k>AsyncWebServer server(80);</k>
<h3>Building the Web Page</h3>
All the HTML text with styles and JavaScript is stored in the index_html variable. Now we'll go through the HTML text and see what each part does.
The title goes inside the &lt;title> and &lt;/tile> tags. The title is exactly what it sounds like: the title of your document, which shows up in your web browser's title bar. In this case, it is ESP Web Server.
<k>&lt;title>ESP Web Server&lt;/title></k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ESP32-Web-Server-Title.png">
The following &lt;meta> tag makes your web page responsive in any browser (laptop, tablet or smartphone).
<k>&lt;meta name="viewport" content="width=device-width, initial-scale=1"></k>
The next line prevents requests on the favicon. In this case, we don't have a favicon. The favicon is the website icon that shows next to the title in the web browser tab. If we don't add the following line, the ESP32 will receive a request for the favicon every time we access the web server.
<k>&lt;link rel="icon" href="data:,"></k>
Between the &lt;style>&lt;/style> tags, we add some CSS to style the web page. We won't go into detail on how this CSS styling works.
<k>&lt;style>
    html {font-family: Arial; display: inline-block; text-align: center;}
    h2 {font-size: 3.0rem;}
    p {font-size: 3.0rem;}
    body {max-width: 600px; margin:0px auto; padding-bottom: 25px;}
    .switch {position: relative; display: inline-block; width: 120px; height: 68px} 
    .switch input {display: none}
    .slider {position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; border-radius: 6px}
    .slider:before {position: absolute; content: ""; height: 52px; width: 52px; left: 8px; bottom: 8px; background-color: #fff; -webkit-transition: .4s; transition: .4s; border-radius: 3px}
    input:checked+.slider {background-color: #b30000}
    input:checked+.slider:before {-webkit-transform: translateX(52px); -ms-transform: translateX(52px); transform: translateX(52px)}
&lt;/style></k>
<h4>HTML Body</h4>
Inside the &lt;body>&lt;/body> tags is where we add the web page content.
The &lt;h2>&lt;/h2> tags add a heading to the web page. In this case, the ESP Web Server text, but you can add any other text.
<k>&lt;h2>ESP Web Server&lt;/h2></k>
After the heading, we have the buttons. The way the buttons show up on the web page (red: if the GPIO is on; or gray: if the GPIO is off) varies depending on the current GPIO state. 
When you access the web server page, you want it to show the right current GPIO states. So, instead of adding the HTML text to build the buttons, we'll add a placeholder %BUTTONPLACEHOLDER%. This palceholder will then be replaced with the actual HTML text to build the buttons with the right states, when the web page is loaded.
<k>%BUTTONPLACEHOLDER%</k>
<h3>JavaScript</h3>
Then, there's some JavaScript that is responsible to make an <a href="https://randomnerdtutorials.com/esp32-http-get-open-weather-map-thingspeak-arduino/">HTTP GET request</a> when you toggle the buttons as we've explained previously.
<k>&lt;script>function toggleCheckbox(element) {
  var xhr = new XMLHttpRequest();
  if(element.checked){ xhr.open("GET", "/update?output="+element.id+"&state=1", true); }
  else { xhr.open("GET", "/update?output="+element.id+"&state=0", true); }
  xhr.send();
}
&lt;/script></k>
Here's the line that makes the request:
<k>if(element.checked){ xhr.open("GET", "/update?output="+element.id+"&state=1", true); }</k>
element.id returns the id of an HTML element. The id of each button will be the GPIO controlled as we'll see in the next section:
GPIO 2 button <U+00BB> element.id = 2
GPIO 4 button <U+00BB> element.id = 4
GPIO 33 button <U+00BB> element.id = 33
<h3>Processor</h3>
Now, we need to create the processor() function, that replaces the placeholders in the HTML text with what we define. 
When the web page is requested, check if the HTML has any placeholders. If it finds the %BUTTONPLACEHOLDER% placeholder, it returns the HTML text to create the buttons.
<k>String processor(const String& var){
  //Serial.println(var);
  if(var == "BUTTONPLACEHOLDER"){
    String buttons = "";
    buttons += "&lt;h4>Output - GPIO 2&lt;/h4>&lt;label class=\"switch\">&lt;input type=\"checkbox\" onchange=\"toggleCheckbox(this)\" id=\"2\" " + outputState(2) + ">&lt;span class=\"slider\">&lt;/span>&lt;/label>";
    buttons += "&lt;h4>Output - GPIO 4&lt;/h4>&lt;label class=\"switch\">&lt;input type=\"checkbox\" onchange=\"toggleCheckbox(this)\" id=\"4\" " + outputState(4) + ">&lt;span class=\"slider\">&lt;/span>&lt;/label>";
    buttons += "&lt;h4>Output - GPIO 33&lt;/h4>&lt;label class=\"switch\">&lt;input type=\"checkbox\" onchange=\"toggleCheckbox(this)\" id=\"33\" " + outputState(33) + ">&lt;span class=\"slider\">&lt;/span>&lt;/label>";
    return buttons;
  }
  return String();
}</k>
You can easily delete or add more lines to create more buttons.
Let's take a look at how the buttons are created. We create a String variable called buttons that contains the HTML text to build the buttons. We concatenate the HTML text with the current output state so that the toggle button is either gray or red. The current output state is returned by the outputState(&lt;GPIO>) function (it accepts as argument the GPIO number). See below:
<k>buttons += "&lt;h4>Output - GPIO 2&lt;/h4>&lt;label class=\"switch\">&lt;input type=\"checkbox\" onchange=\"toggleCheckbox(this)\" id=\"2\" " + outputState(2) + ">&lt;span class=\"slider\">&lt;/span>&lt;/label>";</k>
The \ is used so that we can pass  inside the String.
The outputState() function returns either checked if the GPIO is on or and empty field  if the GPIO is off.
<k>String outputState(int output){
  if(digitalRead(output)){
    return "checked";
  }
  else {
    return "";
  }
}</k>
So, the HTML text for GPIO 2 when it is on, would be:
<k>&lt;h4>Output - GPIO 2&lt;/h4>
&lt;label>
&lt;input type="checkbox" onchange="toggleCheckbox(this)" checked>&lt;span>&lt;/span>
&lt;/label></k>
Let's break this down into smaller sections to understand how it works.
In HTML, a toggle switch is an input type. The &lt;input> tag specifies an input field where the user can enter data. The toggle switch is an input field of type checkbox. There are many other input field types.
<k>&lt;input type="checkbox"></k>
The checkbox can be checked or not. When it is check, you have something as follows:
<k>&lt;input type="checkbox" checked></k>
The onchange is an event attribute that occurs when we change the value of the element (the checkbox). Whenever you check or uncheck the toggle switch, it calls the toggleCheckbox() JavaScript function for that specific element id (this).
The id specifies a unique id for that HTML element. The id allows us to manipulate the element using JavaScript or CSS.
<k>&lt;input type="checkbox" onchange="toggleCheckbox(this)" checked></k>
<h3>setup()</h3>
In the setup() initialize the Serial Monitor for debugging purposes.
<k>Serial.begin(115200);</k>
Set the GPIOs you want to control as outputs using the pinMode() function and set them to LOW when the ESP32 first starts. If you've added more GPIOs, do the same procedure.
<k>pinMode(2, OUTPUT);
digitalWrite(2, LOW);
pinMode(4, OUTPUT);
digitalWrite(4, LOW);
pinMode(33, OUTPUT);
digitalWrite(33, LOW);</k>
Connect to your local network and print the ESP32 IP address.
<k>WiFi.begin(ssid, password);
while (WiFi.status() != WL_CONNECTED) {
  delay(1000);
  Serial.println("Connecting to WiFi..");
}
// Print ESP Local IP Address
Serial.println(WiFi.localIP());</k>
In the setup(), you need to handle what happens when the ESP32 receives requests. As we've seen previously, you receive a request of this type:
<k>&lt;ESP_IP>/update?output=&lt;inputMessage1>&state=&lt;inputMessage2></k>
So, we check if the request contains the PARAM_INPUT1 variable value (output) and the PARAM_INPUT2(state) and save the corresponding values on the input1Message and input2Message variables.
<k>if (request->hasParam(PARAM_INPUT_1) && request->hasParam(PARAM_INPUT_2)) {
  inputMessage1 = request->getParam(PARAM_INPUT_1)->value();
  inputMessage2 = request->getParam(PARAM_INPUT_2)->value();</k>
Then, we control the corresponding GPIO with the corresponding state (the inputMessage1 variable saves the GPIO number and the inputMessage2 saves the state  0 or 1)
<k>digitalWrite(inputMessage1.toInt(), inputMessage2.toInt());</k>
Here's the complete code to handle the HTTP GET <k>/update</k> request:
<k>server.on("/update", HTTP_GET, [] (AsyncWebServerRequest *request) {
  String inputMessage1;
  String inputMessage2;
  // GET input1 value on &lt;ESP_IP>/update?output=&lt;inputMessage1>&state=&lt;inputMessage2>
  if (request->hasParam(PARAM_INPUT_1) && request->hasParam(PARAM_INPUT_2)) {
    inputMessage1 = request->getParam(PARAM_INPUT_1)->value();
    inputMessage2 = request->getParam(PARAM_INPUT_2)->value();
    digitalWrite(inputMessage1.toInt(), inputMessage2.toInt());
  }
  else {
    inputMessage1 = "No message sent";
    inputMessage2 = "No message sent";
  }
  Serial.print("GPIO: ");
  Serial.print(inputMessage1);
  Serial.print(" - Set to: ");
  Serial.println(inputMessage2);
  request->send(200, "text/plain", "OK");
});</k>
Finally, start the server:
<k>server.begin();</k>
<h3>Demonstration</h3>
After uploading the code to your ESP32, open the Serial Monitor at a baud rate of 115200. Press the on-board RST/EN button. You should get its IP address.
Open a browser and type the ESP IP address. You'll get access to a similar web page.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ESP32-ESP8266-Async-Web-Server-Web-Browser-Switch-Buttons-Serial-Monitor.png">
Press the toggle buttons to control the ESP32 GPIOs. At the same time, you should get the following messages in the Serial Monitor to help you debug your code.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ESP32-ESP8266-Async-Web-Server-Arduino-IDE-Serial-Monitor.png">
You can also access the web server from a browser in your smartphone. Whenever you open the web server, it shows the current GPIO states. Red indicates the GPIO is on, and gray that the GPIO is off.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ESP32-ESP8266-Async-Web-Server-Web-Browser-Switch-Buttons-Serial-Monitor-Mobile-Responsive.png">
<h3>Wrapping Up</h3>
In this tutorial you've learned how to create an asynchronous web server with the ESP32 to control its outputs using toggle switches. Whenever you open the web page, it shows the updated GPIO states.
We have other web server examples using the ESPAsyncWebServer library that you may like:
<a href="https://randomnerdtutorials.com/esp32-dht11-dht22-temperature-humidity-web-server-arduino-ide/">ESP32 Web Server: DHT11 or DHT22 Temperature and Humidity</a>
<a href="https://randomnerdtutorials.com/esp32-esp8266-web-server-outputs-momentary-switch/">ESP32 Web Server: Control Outputs with Momentary Switch</a>
<a href="https://randomnerdtutorials.com/esp32-esp8266-web-server-timer-pulse/">ESP32 Web Server: Control Outputs with Timer</a>
<a href="https://randomnerdtutorials.com/esp32-esp8266-web-server-physical-button/">ESP32 Web Server: Control Outputs with a Physical Button</a>
<h2>ESP32 HTTP POST with Arduino IDE (ThingSpeak and IFTTT.com)</h2>
In this guide, you'll learn how to make HTTP POST requests using the ESP32 board with Arduino IDE. We'll demonstrate how to post JSON data or URL encoded values to two web APIs (ThingSpeak and IFTTT.com).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ESP32-HTTP-POST-with-Arduino-IDE-IFTTT-ThingSpeak.jpg">
<k>Recommended:</k> <a href="https://randomnerdtutorials.com/esp32-http-get-open-weather-map-thingspeak-arduino/">ESP32 HTTP GET with Arduino IDE (OpenWeatherMap.org and ThingSpeak)</a>
<h3>HTTP POST Request Method</h3>
The Hypertext Transfer Protocol (HTTP) works as a request-response protocol between a client and server. Here's an example:
The ESP32 (client) submits an HTTP request to a Server (for example: ThingSpeak or IFTTT.com);
The server returns a response to the ESP32 (client);
Finally, the response contains status information about the request and may also contain the requested content.
<h3>HTTP POST</h3>
<k>POST </k>is used to send data to a server to create/update a resource. For example, publish sensor readings to a server.
The data sent to the server with POST is stored in the request body of the HTTP request:
<k>POST /update HTTP/1.1
Host: example.com
api_key=api&field1=value1
Content-Type: application/x-www-form-urlencoded</k>
In the body request, you can also send a JSON object:
<k>POST /update HTTP/1.1
Host: example.com
{api_key: "api", field1: value1}
Content-Type: application/json</k>
<em>(With HTTP POST, data is not visible in the URL request. However, if it's not encrypted, it's still visible in the request body.)</em>
<h3>Prerequisites</h3>
Before proceeding with this tutorial, make sure you complete the following prerequisites.
<h3>Arduino IDE</h3>
We'll program the <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32 </a>using Arduino IDE, so make sure you have the ESP32 add-on installed.
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<h3>Other Web Services or APIs</h3>
In this guide, you'll learn how to setup your <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32 board</a> to perform HTTP requests to ThingSpeak and IFTTT.com. If you prefer to learn with a local solution you can use <a href="https://randomnerdtutorials.com/esp32-http-get-post-arduino/">HTTP with Node-RED</a>. All examples presented in this guide also work with other APIs.
In summary, to make this guide compatible with any service, you need to search for the service API documentation. Then, you need the server name (URL or IP address), and parameters to send in the request (URL path or request body). Finally, modify our examples to integrate with any API you want to use.
<h3>1. ESP32 HTTP POST Data (ThingSpeak)</h3>
In this example, the ESP32 makes an HTTP POST request to send a new value to ThingSpeak.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/HTTP-POST-Thingspeak-ESP32.png">
<h3>Using ThingSpeak API</h3>
ThingSpeak has a free API that allows you to store and retrieve data using HTTP. In this tutorial, you'll use the ThingSpeak API to publish and visualize data in charts from anywhere. As an example, we'll publish random values, but in a real application you would use <a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/">real sensor readings</a>.
To use ThingSpeak API, you need an API key. Follow the next steps:
<ol>
Go to <a href="https://thingspeak.com/" target="_blank">ThingSpeak.com</a> and create a free account.
Then, open the <a href="https://thingspeak.com/channels" target="_blank">Channels</a> tab.
Create a <k>New Channel</k>.
</ol>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ESP32-ESP8266-NodeMCU-ThingSpeak-New-Channel.png">
<ol start="4">Open your newly created channel and select the <k>API Keys</k> tab to copy your Write API Key.</ol>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ESP32-ESP8266-NodeMCU-ThingSpeak-View-API-Key-Write-Copy.png">
<h3>Code ESP32 HTTP POST ThingSpeak</h3>
Copy the next sketch to your Arduino IDE:
<k>/*
  Rui Santos
  Complete project details at Complete project details at https://RandomNerdTutorials.com/esp32-http-post-ifttt-thingspeak-arduino/ 
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;WiFi.h>
#include &lt;HTTPClient.h>
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
// Domain Name with full URL Path for HTTP POST Request
const char* serverName = "http://api.thingspeak.com/update";
// Service API Key
String apiKey = "REPLACE_WITH_YOUR_API_KEY";
// THE DEFAULT TIMER IS SET TO 10 SECONDS FOR TESTING PURPOSES
// For a final application, check the API call limits per hour/minute to avoid getting blocked/banned
unsigned long lastTime = 0;
// Set timer to 10 minutes (600000)
//unsigned long timerDelay = 600000;
// Timer set to 10 seconds (10000)
unsigned long timerDelay = 10000;
void setup() {
  Serial.begin(115200);
  WiFi.begin(ssid, password);
  Serial.println("Connecting");
  while(WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected to WiFi network with IP Address: ");
  Serial.println(WiFi.localIP());
 
  Serial.println("Timer set to 10 seconds (timerDelay variable), it will take 10 seconds before publishing the first reading.");
  // Random seed is a number used to initialize a pseudorandom number generator
  randomSeed(analogRead(33));
}
void loop() {
  //Send an HTTP POST request every 10 seconds
  if ((millis() - lastTime) > timerDelay) {
    //Check WiFi connection status
    if(WiFi.status()== WL_CONNECTED){
      WiFiClient client;
      HTTPClient http;
    
      // Your Domain name with URL path or IP address with path
      http.begin(client, serverName);
      
      // Specify content-type header
      http.addHeader("Content-Type", "application/x-www-form-urlencoded");
      // Data to send with HTTP POST
      String httpRequestData = "api_key=" + apiKey + "&field1=" + String(random(40));           
      // Send HTTP POST request
      int httpResponseCode = http.POST(httpRequestData);
      
      /*
      // If you need an HTTP request with a content type: application/json, use the following:
      http.addHeader("Content-Type", "application/json");
      // JSON data to send with HTTP POST
      String httpRequestData = "{\"api_key\":\"" + apiKey + "\",\"field1\":\"" + String(random(40)) + "\"}";           
      // Send HTTP POST request
      int httpResponseCode = http.POST(httpRequestData);*/
     
      Serial.print("HTTP Response code: ");
      Serial.println(httpResponseCode);
        
      // Free resources
      http.end();
    }
    else {
      Serial.println("WiFi Disconnected");
    }
    lastTime = millis();
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/HTTP/ESP32_HTTP_POST_Think_Speak.ino" target="_blank">View raw code</a>
<h4>Setting your network credentials</h4>
Modify the next lines with your network credentials: SSID and password. The code is well commented on where you should make the changes.
<k>// Replace with your network credentials
const char* ssid     = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h4>Setting your API Key</h4>
Modify the apiKey variable to include your ThingSpeak API key.
<k>String apiKey = "REPLACE_WITH_YOUR_API_KEY";</k>
Now, upload the code to your board and it should work straight away. Read the next section, if you want to learn how to make the HTTP POST request.
<h4>HTTP POST Request</h4>
In the loop() is where you make the HTTP POST request with URL encoded data every 10 seconds with random data:
<k>// Specify content-type header
http.addHeader("Content-Type", "application/x-www-form-urlencoded");
// Data to send with HTTP POST
String httpRequestData = "api_key=" + apiKey + "&field1=" + String(random(40));
// Send HTTP POST request
int httpResponseCode = http.POST(httpRequestData);</k>
For example, the ESP32 makes a URL encoded request to publish a new value (30) to field1. 
<k>POST /update HTTP/1.1
Host: api.thingspeak.com
api_key=api&field1=30
Content-Type: application/x-www-form-urlencoded</k>
Or you can uncomment these next lines to make a request with JSON data (instead of URL-encoded request):
<k>// If you need an HTTP request with a content type: application/json, use the following:
http.addHeader("Content-Type", "application/json");
// JSON data to send with HTTP POST
String httpRequestData = "{\"api_key\":\"" + apiKey + "\",\"field1\":\"" + String(random(40)) + "\"}";
// Send HTTP POST request
int httpResponseCode = http.POST(httpRequestData);</k>
Here's a sample HTTP POST request with JSON data:
<k>POST /update HTTP/1.1
Host: api.thingspeak.com
{api_key: "api", field1: 30}
Content-Type: application/json</k>
Then, the following lines print the server response code.
<k>Serial.print("HTTP Response code: ");
Serial.println(httpResponseCode);</k>
In the Arduino IDE serial monitor, you should see an HTTP response code of 200 (this means that the request has succeeded).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ESP32-ESP8266-NodeMCU-HTTP-POST-Arduino-IDE-Serial-Monitor-Response.png">
Your ThingSpeak Dashboard should be receiving new random readings every 10 seconds.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ESP32-ESP8266-NodeMCU-HTTP-GET-POST-ThingSpeak-chart.png">
For a final application, you might need to increase the timer or check the API call limits per hour/minute to avoid getting blocked/banned.
<h3>2. ESP32 HTTP POST (IFTTT.com)</h3>
In this example you'll learn how to trigger a web API to send email notifications. As an example, we'll use the IFTTT.com API. IFTTT has has a free plan with lots of useful automations.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/HTTP-POST-IFTTT-ESP32.png">
<h3>Using IFTTT.com Webhooks API</h3>
IFTTT stands for If This Than That, and it is a free web-based service to create chains of simple conditional statements called applets.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/Wordmark_on_gray.png">
This means you can trigger an event when something happens. In this example, the applet sends three random values to your email when the ESP32 makes a request. You can replace those random values with useful <a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/">sensor readings</a>.
<h4>Creating an IFTTT Account</h4>
If you don't have an IFTTT account, go the IFTTT website: <a href="https://ifttt.com/" target="_blank">ifttt.com</a> and enter your email to create an account and get started. Creating an account on IFTTT is free!
Next, you need to create a new applet. Follow the next steps to create a new
applet:
1. Open the left menu and click the <k>Create</k> button.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ifttt-discover-create-new-applet.png">
2. Click on the <k>this</k> word. Search for the <k>Webhooks</k> service and select the Webhooks icon.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/select-webhooks-ifttt-1.png">
3. Choose the <k>Receive a web request</k> trigger and give a name to the event. In this case, I've typed <k>test_event</k>. Then, click the <k>Create trigger</k> button.
4. Click the <k>that</k> word to proceed. Now, define what happens when the event you've defined is triggered. Search for the <k>Email</k> service and select it.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/select-email-service-ifttt.png">
5. Then, select <k>Send me an email</k>. You can leave the default options.
6. Press the <k>Create action</k> button to create your Applet. Then, click on <k>Continue</k>, and finally, <k>Finish</k>.
<h4>Testing Your Applet</h4>
Before proceeding with the project, it's important to test your Applet first. Follow the next steps to test it:
1. Search for <k>Webhooks </k>service or open this link: <a href="https://ifttt.com/maker_webhooks" target="_blank">https://ifttt.com/maker_webhooks</a>
2. Click the <k>Documentation</k> button. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/webhooks-documentation-ifttt.png">
A page showing your unique API key will show up.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/10/IFTTT-API-KEYU.png">
Save your API key because you'll need it later.
3. Fill the To trigger an Event with 3 JSON values section with the event name created previously, in our case <k>test_event</k>. Add some random values to the <k>value1</k>, <k>value2</k>, and <k>value 3</k> fields. Then, click the <k>Test it</k> button.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/10/IFTTT-Trigger-an-Event-3-JSON-Values.png">
4. The event should be successfully triggered, and you'll get a green message saying <k>Event has been triggered</k>.
5. Go to your Email account. You should have a new email in your inbox from the IFTTT service with the values you've defined in the previous step.
If you've received an email with the data entered in the test request, it means your Applet is working as expected. Now, we need to program the ESP32 to send an HTTP POST request to the IFTTT service with the sensor readings.
<h3>Code ESP32 HTTP POST Webhooks IFTTT.com</h3>
After installing the necessary board add-ons and libraries, copy the following code to your Arduino IDE, but don't upload it yet. You need to make some changes to make it work for you.
<k>/*
  Rui Santos
  Complete project details at Complete project details at https://RandomNerdTutorials.com/esp32-http-post-ifttt-thingspeak-arduino/
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;WiFi.h>
#include &lt;HTTPClient.h>
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
// Domain Name with full URL Path for HTTP POST Request
// REPLACE WITH YOUR EVENT NAME AND API KEY - open the documentation: https://ifttt.com/maker_webhooks
const char* serverName = "http://maker.ifttt.com/trigger/REPLACE_WITH_YOUR_EVENT/with/key/REPLACE_WITH_YOUR_API_KEY";
// Example:
//const char* serverName = "http://maker.ifttt.com/trigger/test_event/with/key/nAZjOphL3d-ZO4N3k64-1A7gTlNSrxMJdmqy3tC";
// THE DEFAULT TIMER IS SET TO 10 SECONDS FOR TESTING PURPOSES
// For a final application, check the API call limits per hour/minute to avoid getting blocked/banned
unsigned long lastTime = 0;
// Set timer to 10 minutes (600000)
//unsigned long timerDelay = 600000;
// Timer set to 10 seconds (10000)
unsigned long timerDelay = 10000;
void setup() {
  Serial.begin(115200);
  WiFi.begin(ssid, password);
  Serial.println("Connecting");
  while(WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected to WiFi network with IP Address: ");
  Serial.println(WiFi.localIP());
 
  Serial.println("Timer set to 10 seconds (timerDelay variable), it will take 10 seconds before publishing the first reading.");
  // Random seed is a number used to initialize a pseudorandom number generator
  randomSeed(analogRead(33));
}
void loop() {
  //Send an HTTP POST request every 10 seconds
  if ((millis() - lastTime) > timerDelay) {
    //Check WiFi connection status
    if(WiFi.status()== WL_CONNECTED){
      WiFiClient client;
      HTTPClient http;
    
      // Your Domain name with URL path or IP address with path
      http.begin(client, serverName);
      
      // Specify content-type header
      http.addHeader("Content-Type", "application/x-www-form-urlencoded");
      // Data to send with HTTP POST
      String httpRequestData = "value1=" + String(random(40)) + "&value2=" + String(random(40))+ "&value3=" + String(random(40));           
      // Send HTTP POST request
      int httpResponseCode = http.POST(httpRequestData);
      
      /*
      // If you need an HTTP request with a content type: application/json, use the following:
      http.addHeader("Content-Type", "application/json");
      // JSON data to send with HTTP POST
      String httpRequestData = "{\"value1\":\"" + String(random(40)) + "\",\"value2\":\"" + String(random(40)) + "\",\"value3\":\"" + String(random(40)) + "\"}";
      // Send HTTP POST request
      int httpResponseCode = http.POST(httpRequestData);
      */
     
      Serial.print("HTTP Response code: ");
      Serial.println(httpResponseCode);
        
      // Free resources
      http.end();
    }
    else {
      Serial.println("WiFi Disconnected");
    }
    lastTime = millis();
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/HTTP/ESP32_HTTP_POST_IFTTT.ino" target="_blank">View raw code</a>
<h4>Setting your network credentials</h4>
Modify the next lines with your network credentials: SSID and password. The code is well commented on where you should make the changes.
<k>// Replace with your network credentials
const char* ssid     = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h4>Setting your IFTTT.com API Key</h4>
Insert your event name and API key in the following line:
<k>const char* serverName = "http://maker.ifttt.com/trigger/REPLACE_WITH_YOUR_EVENT/with/key/REPLACE_WITH_YOUR_API_KEY";</k>
Example URL:
<k>const char* serverName = "http://maker.ifttt.com/trigger/test_event/with/key/nAZjOphL3d-ZO4N3k64-1A7gTlNSrxMJdmqy3t";</k>
<h4>HTTP POST Request</h4>
In the loop() is where you make the HTTP POST request every 10 seconds with sample data:
<k>// Specify content-type header
http.addHeader("Content-Type", "application/x-www-form-urlencoded");
// Data to send with HTTP POST
String httpRequestData = "value1=" + String(random(40)) + "&value2=" + String(random(40))+ "&value3=" + String(random(40));
// Send HTTP POST request
int httpResponseCode = http.POST(httpRequestData);</k>
The ESP32 makes a new URL encoded request to publish some random values in the value1, value2 and value3 fields. For example:
<k>POST /trigger/test_event/with/key/nAZjOphL3d-ZO4N3k64-1A7gTlNSrxMJdmqy3tC HTTP/1.1
Host: maker.ifttt.com
value1=15&value2=11&value3=30
Content-Type: application/x-www-form-urlencoded</k>
Alternatively, you can uncomment these next lines to make a request with JSON data:
<k>// If you need an HTTP request with a content type: application/json, use the following:
http.addHeader("Content-Type", "application/json");
// JSON data to send with HTTP POST
String httpRequestData = "{\"value1\":\"" + String(random(40)) + "\",\"value2\":\"" + String(random(40)) + "\",\"value3\":\"" + String(random(40)) + "\"}";
// Send HTTP POST request
int httpResponseCode = http.POST(httpRequestData);</k>
Here's an example of HTTP POST request with a JSON data object. 
<k>POST /trigger/test_event/with/key/nAZjOphL3d-ZO4N3k64-1A7gTlNSrxMJdmqy3tC HTTP/1.1
Host: maker.ifttt.com
{value1: 15, value2: 11, value3: 30}
Content-Type: application/json</k>
Then, the following lines of code print the HTTP response from the server.
<k>Serial.print("HTTP Response code: ");
Serial.println(httpResponseCode);</k>
<h3>HTTP POST Demonstration</h3>
After uploading the code, open the Serial Monitor and you'll see a message printing the HTTP response code 200 indicating that the request has succeeded.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ESP32-ESP8266-NodeMCU-HTTP-POST-Arduino-IDE-Serial-Monitor-Response.png">Go to your email account, and you should get a new email from IFTTT with three random values. In this case: 38, 20 and 13.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ESP32-ESP8266-NodeMCU-HTTP-POST-Arduino-IDE-IFTTT-Response.png">
For demonstration purposes, we're publishing new data every 10 seconds. However, for a long term project you should increase the timer or check the API call limits per hour/minute to avoid getting blocked/banned.
<h3>Wrapping Up</h3>
In this tutorial you've learned how to integrate your ESP32 with web services using HTTP POST requests. You can also make <a href="https://randomnerdtutorials.com/esp32-http-get-open-weather-map-thingspeak-arduino/">HTTP GET requests with the ESP32</a>.
If you're using an ESP8266 board, read:
<a href="https://randomnerdtutorials.com/esp8266-nodemcu-http-get-open-weather-map-thingspeak-arduino/">Guide for ESP8266 NodeMCU HTTP GET Request</a>
<a href="https://randomnerdtutorials.com/esp8266-nodemcu-http-post-ifttt-thingspeak-arduino/">Guide for ESP8266 NodeMCU HTTP POST Request</a>
<h2>ESP32 HTTP GET with Arduino IDE (OpenWeatherMap.org and ThingSpeak)</h2>
In this guide, you'll learn how to make HTTP GET requests using the ESP32 board with Arduino IDE. We'll demonstrate how to decode JSON data from OpenWeatherMap.org and plot values in charts using ThingSpeak.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ESP32-HTTP-GET-with-Arduino-IDE-OpenWeatherMap-ThingSpeak.jpg">
<k>Recommended:</k> <a href="https://randomnerdtutorials.com/esp32-http-post-ifttt-thingspeak-arduino/">ESP32 HTTP POST with Arduino IDE (ThingSpeak and IFTTT.com)</a>
<h3>HTTP GET Request Method</h3>
The Hypertext Transfer Protocol (HTTP) works as a request-response protocol between a client and server. Here's an example:
The ESP32 (client) submits an HTTP request to a Server (for example: OpenWeatherMap.org or ThingSpeak);
The server returns a response to the ESP32 (client);
Finally, the response contains status information about the request and may also contain the requested content.
<h3>HTTP GET</h3>
<k>GET </k>is used to request data from a specified resource. It is often used to get values from APIs.
For example, you can use a simple request to return a value or JSON object:
<k>GET /weather?countryCode=PT</k>
Additionally, you can also make a GET request to update a value (like with ThingSpeak). For example, you can use:
<k>GET /update?field1=value1</k>
Note that the query string (<em>name = field1</em> and <em>value = value1</em>) is sent in the URL of the HTTP GET request.
<em>(With HTTP GET, data is visible to everyone in the URL request.)</em>
<h3>Prerequisites</h3>
Before proceeding with this tutorial, make sure you complete the following prerequisites.
<h3>Arduino IDE</h3>
We'll program the <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32 </a>using Arduino IDE, so make sure you have the ESP32 add-on installed.
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<h3>Arduino_JSON Library</h3>
You also need to install the <a href="https://github.com/arduino-libraries/Arduino_JSON" target="_blank" aria-label=" (opens in a new tab)">Arduino_JSON library</a>. You can install this library in the Arduino IDE Library Manager. Just go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k> and search for the library name as follows:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/Install-Arduino-JSON-library-Arduino-IDE.png">
<h3>Other Web Services or APIs</h3>
In this guide, you'll learn how to setup your <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32 board</a> to perform HTTP requests to OpenWeatherMap.org and ThingSpeak. If you prefer to learn with a local solution you can use <a href="https://randomnerdtutorials.com/esp32-http-get-post-arduino/">HTTP with Node-RED</a>. All examples presented in this guide also work with other APIs.
In summary, to make this guide compatible with any service, you need to search for the service API documentation. Then, you need the server name (URL or IP address), and parameters to send in the request (URL path or request body). Finally, modify our examples to integrate with any API you want to use.
<h3>1. ESP32 HTTP GET: JSON Data (OpenWeatherMap.org)</h3>
In this example you'll learn how to make API requests to access data. As an example, we'll use the OpenWeatherMap API. This API has a free plan and provides lots of useful information about the weather in almost any location in the world.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/HTTP-GET-Open-Weather-Map-ESP32.png">
<h3>Using OpenWeatherMap API</h3>
An application programming interface (API) is a set of functions written by software developers to enable anyone to use their data or services. The <a href="https://openweathermap.org/" target="_blank" rel="noopener">OpenWeatherMap</a> project has an API that enables users to request weather data.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/logo.png">
In this project, you'll use that API to request the day's weather forecast for your chosen location. Learning to use APIs is a great skill because it allows you access to a wide variety of constantly changing information, such as current stock prices, currency exchange rates, the latest news, traffic updates, tweets, and much more.
<k>Note: </k> API keys are unique to the user and shouldn't be shared with anyone.
OpenWeatherMap's free plan provides everything you need to complete this project. To use the API you need an API key, known as the APIID. To get the APIID:
<ol>
Open a browser and go to <a href="https://openweathermap.org/appid/" target="_blank">https://openweathermap.org/appid/</a>
Press the <k>Sign up</k> button and create a free account.
Go to this link: <a href="https://home.openweathermap.org/api_keys" target="_blank">https://home.openweathermap.org/api_keys</a> and get your API key.
</ol>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/openweathermap-key.png">
<ol start="4">
On the <k>API keys</k> tab, you'll see a default key (highlighted in a red rectangle in figure above); this is a unique key you'll need to pull information from the site. Copy and paste this key somewhere; you'll need it in a moment.
To pull information on weather in your chosen location, enter the following URL:
</ol>
<k>http://api.openweathermap.org/data/2.5/weather?q=yourCityName,yourCountryCode&APPID=yourUniqueAPIkey</k>
Replace <k>yourCityName</k> with the city you want data for, <k>yourCountryCode </k>with the country code for that city, and <k>yourUniqueAPIkey</k> with the unique API key from step 4. For example, the updated API URL for the city of Porto, Portugal, would be: 
<k>http://api.openweathermap.org/data/2.5/weather?q=Porto,
PT&APPID=801d2603e9f2e1c70e042e4f5f6e0---</k>
<ol start="6">Copy your URL into your browser, and the API will return a bunch of information corresponding to your local weather. We got the following information about the weather in Porto, Portugal, on the day we wrote this tutorial.</ol>
<k>{"coord":{"lon":-8.611,"lat":41.1496},"weather":[{"id":803,"main":"Clouds","description":"broken clouds","icon":"04d"}],"base":"stations","main":{"temp":294.58,"feels_like":294.95,"temp_min":293.82,"temp_max":295.65,"pressure":1016,"humidity":83},"visibility":10000,"wind":{"speed":8.94,"deg":180,"gust":8.94},"clouds":{"all":75},"dt":1666877635,"sys":{"type":2,"id":2009460,"country":"PT","sunrise":1666853957,"sunset":1666892227},"timezone":3600,"id":2735943,"name":"Porto","cod":200}</k>
This is how it looks with indentation for better readability. 
<k>{
  "coord": {
    "lon": -8.611,
    "lat": 41.1496
  },
  "weather": [
    {
      "id": 803,
      "main": "Clouds",
      "description": "broken clouds",
      "icon": "04d"
    }
  ],
  "base": "stations",
  "main": {
    "temp": 294.58,
    "feels_like": 294.95,
    "temp_min": 293.82,
    "temp_max": 295.65,
    "pressure": 1016,
    "humidity": 83
  },
  "visibility": 10000,
  "wind": {
    "speed": 8.94,
    "deg": 180,
    "gust": 8.94
  },
  "clouds": {
    "all": 75
  },
  "dt": 1666877635,
  "sys": {
    "type": 2,
    "id": 2009460,
    "country": "PT",
    "sunrise": 1666853957,
    "sunset": 1666892227
  },
  "timezone": 3600,
  "id": 2735943,
  "name": "Porto",
  "cod": 200
}</k>
Next, you'll see how to use this information to get specific data like temperature, humidity, pressure, wind speed, etc.
<h3>Code ESP32 HTTP GET OpenWeatherMap.org</h3>
After installing the necessary board add-ons and libraries, copy the following code to your Arduino IDE, but don't upload it yet. You need to make some changes to make it work for you.
<k>/*
  Rui Santos
  Complete project details at Complete project details at https://RandomNerdTutorials.com/esp32-http-get-open-weather-map-thingspeak-arduino/
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;WiFi.h>
#include &lt;HTTPClient.h>
#include &lt;Arduino_JSON.h>
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
// Your Domain name with URL path or IP address with path
String openWeatherMapApiKey = "REPLACE_WITH_YOUR_OPEN_WEATHER_MAP_API_KEY";
// Example:
//String openWeatherMapApiKey = "bd939aa3d23ff33d3c8f5dd1dd435";
// Replace with your country code and city
String city = "Porto";
String countryCode = "PT";
// THE DEFAULT TIMER IS SET TO 10 SECONDS FOR TESTING PURPOSES
// For a final application, check the API call limits per hour/minute to avoid getting blocked/banned
unsigned long lastTime = 0;
// Timer set to 10 minutes (600000)
//unsigned long timerDelay = 600000;
// Set timer to 10 seconds (10000)
unsigned long timerDelay = 10000;
String jsonBuffer;
void setup() {
  Serial.begin(115200);
  WiFi.begin(ssid, password);
  Serial.println("Connecting");
  while(WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected to WiFi network with IP Address: ");
  Serial.println(WiFi.localIP());
 
  Serial.println("Timer set to 10 seconds (timerDelay variable), it will take 10 seconds before publishing the first reading.");
}
void loop() {
  // Send an HTTP GET request
  if ((millis() - lastTime) > timerDelay) {
    // Check WiFi connection status
    if(WiFi.status()== WL_CONNECTED){
      String serverPath = "http://api.openweathermap.org/data/2.5/weather?q=" + city + "," + countryCode + "&APPID=" + openWeatherMapApiKey;
      
      jsonBuffer = httpGETRequest(serverPath.c_str());
      Serial.println(jsonBuffer);
      JSONVar myObject = JSON.parse(jsonBuffer);
  
      // JSON.typeof(jsonVar) can be used to get the type of the var
      if (JSON.typeof(myObject) == "undefined") {
        Serial.println("Parsing input failed!");
        return;
      }
    
      Serial.print("JSON object = ");
      Serial.println(myObject);
      Serial.print("Temperature: ");
      Serial.println(myObject["main"]["temp"]);
      Serial.print("Pressure: ");
      Serial.println(myObject["main"]["pressure"]);
      Serial.print("Humidity: ");
      Serial.println(myObject["main"]["humidity"]);
      Serial.print("Wind Speed: ");
      Serial.println(myObject["wind"]["speed"]);
    }
    else {
      Serial.println("WiFi Disconnected");
    }
    lastTime = millis();
  }
}
String httpGETRequest(const char* serverName) {
  WiFiClient client;
  HTTPClient http;
    
  // Your Domain name with URL path or IP address with path
  http.begin(client, serverName);
  
  // Send HTTP POST request
  int httpResponseCode = http.GET();
  
  String payload = "{}"; 
  
  if (httpResponseCode>0) {
    Serial.print("HTTP Response code: ");
    Serial.println(httpResponseCode);
    payload = http.getString();
  }
  else {
    Serial.print("Error code: ");
    Serial.println(httpResponseCode);
  }
  // Free resources
  http.end();
  return payload;
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/HTTP/ESP32_HTTP_GET_Open_Weather_Map.ino" target="_blank">View raw code</a>
<h4>Setting your network credentials</h4>
Modify the next lines with your network credentials: SSID and password. The code is well commented on where you should make the changes.
<k>// Replace with your network credentials
const char* ssid     = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h4>Setting your OpenWeatherMap.org API Key</h4>
Insert your API key in the following like:
<k>String openWeatherMapApiKey = "REPLACE_WITH_YOUR_OPEN_WEATHER_MAP_API_KEY";</k>
<h4>Setting your city and country</h4>
Enter the city you want to get data for, as well as the country code in the following variables:
<k>// Replace with your country code and city
String city = "Porto";
String countryCode = "PT";</k>
After making these changes, you can upload the code to your board. Continue reading to learn how the code works.
<h3>HTTP GET Request (JSON Object)</h3>
In the loop(), call the httpGETRequest() function to make the HTTP GET request:
<k>String serverPath = "http://api.openweathermap.org/data/2.5/weather?q=" + city + "," + countryCode + "&APPID=" + openWeatherMapApiKey;
jsonBuffer = httpGETRequest(serverPath.c_str());</k>
The httpGETRequest() function makes a request to OpenWeatherMap and it retrieves a string with a JSON object that contains all the information about the weather for your city.
<k>String httpGETRequest(const char* serverName) {
  HTTPClient http;
  // Your IP address with path or Domain name with URL path 
  http.begin(serverName);
  // Send HTTP POST request
  int httpResponseCode = http.GET();
  String payload = "{}"; 
  if (httpResponseCode>0) {
    Serial.print("HTTP Response code: ");
    Serial.println(httpResponseCode);
    payload = http.getString();
  }
  else {
    Serial.print("Error code: ");
    Serial.println(httpResponseCode);
  }
  // Free resources
  http.end();
  return payload;
}</k>
<h3>Decoding JSON Object</h3>
To get access to the values, decode the JSON object and store all values in the jsonBuffer array.
<k>JSONVar myObject = JSON.parse(jsonBuffer);
// JSON.typeof(jsonVar) can be used to get the type of the var
if (JSON.typeof(myObject) == "undefined") {
  Serial.println("Parsing input failed!");
  return;
}
Serial.print("JSON object = ");
Serial.println(myObject);
Serial.print("Temperature: ");
Serial.println(myObject["main"]["temp"]);
Serial.print("Pressure: ");
Serial.println(myObject["main"]["pressure"]);
Serial.print("Humidity: ");
Serial.println(myObject["main"]["humidity"]);
Serial.print("Wind Speed: ");
Serial.println(myObject["wind"]["speed"]);</k>
<h3>HTTP GET Demonstration</h3>
After uploading the code, open the Serial Monitor and you'll see that it's receiving the following JSON data:
<k>{"coord":{"lon":-8.61,"lat":41.15},"weather":[{"id":801,"main":"Clouds","description":"few clouds","icon":"02d"}],"base":"stations","main":{"temp":294.44,"feels_like":292.82,"temp_min":292.15,"temp_max":297.04,"pressure":1008,"humidity":63},"visibility":10000,"wind":{"speed":4.1,"deg":240},"clouds":{"all":20},"dt":1589288330,"sys":{"type":1,"id":6900,"country":"PT","sunrise":1589260737,"sunset":1589312564},"timezone":3600,"id":2735943,"name":"Porto","cod":200}</k>
Then, it prints the decoded JSON object in the Arduino IDE Serial Monitor to get the temperature (in Kelvin), pressure, humidity and wind speed values.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ESP32-ESP8266-NodeMCU-HTTP-GET-with-Arduino-IDE-OpenWeatherMap-Response.png">
For demonstration purposes, we're requesting new data every 10 seconds. However, for a long term project you should increase the timer or check the API call limits per hour/minute to avoid getting blocked/banned.
<h3>2. ESP32 HTTP GET: Update Value (ThingSpeak)</h3>
In this example, the ESP32 makes an HTTP GET request to update a reading in ThingSpeak.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/HTTP-GET-Thingspeak-ESP32.png">
<h3>Using ThingSpeak API</h3>
ThingSpeak has a free API that allows you to store and retrieve data using HTTP. In this tutorial, you'll use the ThingSpeak API to publish and visualize data in charts from anywhere. As an example, we'll publish random values, but in a real application you would use real <a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/">sensor readings</a>.
To use ThingSpeak with your ESP, you need an API key. Follow the next steps:
<ol>
Go to <a href="https://thingspeak.com/" target="_blank">ThingSpeak.com</a> and create a free account.
Then, open the <a href="https://thingspeak.com/channels" target="_blank">Channels</a> tab.
Create a <k>New Channel</k>.
</ol>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ESP32-ESP8266-NodeMCU-ThingSpeak-New-Channel.png">
<ol start="4">Open your newly created channel and select the <k>API Keys</k> tab to copy your Write API Key.</ol>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ESP32-ESP8266-NodeMCU-ThingSpeak-View-API-Key-Write-Copy.png">
<h3>Code ESP32 HTTP GET ThingSpeak</h3>
Copy the next sketch to your Arduino IDE (type your SSID, password, and API Key):
<k>/*
  Rui Santos
  Complete project details at Complete project details at https://RandomNerdTutorials.com/esp32-http-get-open-weather-map-thingspeak-arduino/
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;WiFi.h>
#include &lt;HTTPClient.h>
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
// REPLACE WITH THINGSPEAK.COM API KEY
String serverName = "http://api.thingspeak.com/update?api_key=REPLACE_WITH_YOUR_API_KEY";
// EXAMPLE:
//String serverName = "http://api.thingspeak.com/update?api_key=7HQJM49R8JAPR";
// THE DEFAULT TIMER IS SET TO 10 SECONDS FOR TESTING PURPOSES
// For a final application, check the API call limits per hour/minute to avoid getting blocked/banned
unsigned long lastTime = 0;
// Timer set to 10 minutes (600000)
//unsigned long timerDelay = 600000;
// Set timer to 10 seconds (10000)
unsigned long timerDelay = 10000;
void setup() {
  Serial.begin(115200); 
  WiFi.begin(ssid, password);
  Serial.println("Connecting");
  while(WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected to WiFi network with IP Address: ");
  Serial.println(WiFi.localIP());
 
  Serial.println("Timer set to 10 seconds (timerDelay variable), it will take 10 seconds before publishing the first reading.");
  
  // Random seed is a number used to initialize a pseudorandom number generator
  randomSeed(analogRead(33));
}
void loop() {
  // Send an HTTP GET request
  if ((millis() - lastTime) > timerDelay) {
    // Check WiFi connection status
    if(WiFi.status()== WL_CONNECTED){
      WiFiClient client;
      HTTPClient http;
      String serverPath = serverName + "&field1=" + String(random(40));
      
      // Your Domain name with URL path or IP address with path
      http.begin(client, serverPath.c_str());
      
      // Send HTTP GET request
      int httpResponseCode = http.GET();
      
      if (httpResponseCode>0) {
        Serial.print("HTTP Response code: ");
        Serial.println(httpResponseCode);
        String payload = http.getString();
        Serial.println(payload);
      }
      else {
        Serial.print("Error code: ");
        Serial.println(httpResponseCode);
      }
      // Free resources
      http.end();
    }
    else {
      Serial.println("WiFi Disconnected");
    }
    lastTime = millis();
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/HTTP/ESP32_HTTP_GET_Think_Speak.ino" target="_blank">View raw code</a>
<h4>Setting your network credentials</h4>
Modify the next lines with your network credentials: SSID and password. The code is well commented on where you should make the changes.
<k>// Replace with your network credentials
const char* ssid     = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h4>Setting your serverName (API Key)</h4>
Modify the serverName variable to include your API key.
<k>String serverName = "http://api.thingspeak.com/update?api_key=REPLACE_WITH_YOUR_API_KEY";</k>
Now, upload the code to your board and it should work straight away. Read the next section, if you want to learn how to make the HTTP GET request.
<h4>HTTP GET Request</h4>
In the loop() is where you make the HTTP GET request every 10 seconds with random values:
<k>String serverPath = serverName + "&field1=" + String(random(40));
// Your Domain name with URL path or IP address with path
http.begin(serverPath.c_str());
// Send HTTP GET request
int httpResponseCode = http.GET();</k>
The ESP32 makes a new request in the following URL to update the sensor field1 with a new value (30). 
<k>http://api.thingspeak.com/update?api_key=REPLACE_WITH_YOUR_API_KEY&field1=30</k>
Then, the following lines of code save the HTTP response from the server.
<k>if (httpResponseCode>0) {
  Serial.print("HTTP Response code: ");
  Serial.println(httpResponseCode);
  String payload = http.getString();
  Serial.println(payload);
}
else {
  Serial.print("Error code: ");
  Serial.println(httpResponseCode);
}</k>
In the Arduino IDE serial monitor, you should see an HTTP response code of 200 (this means that the request has succeeded).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ESP32-ESP8266-NodeMCU-HTTP-POST-Arduino-IDE-Serial-Monitor-Response.png">
Your ThingSpeak Dashboard (under the <em>Private View </em>tab) should be receiving new readings every 10 seconds.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/05/ESP32-ESP8266-NodeMCU-HTTP-GET-POST-ThingSpeak-chart.png">
For a final application, you might need to increase the timer or check the API call limits per hour/minute to avoid getting blocked/banned.
<h3>Wrapping Up</h3>
In this tutorial you've learned how to integrate your ESP32 with web services using HTTP GET requests. You can also make <a href="https://randomnerdtutorials.com/esp32-http-post-ifttt-thingspeak-arduino/">HTTP POST requests with the ESP32</a>.
If you're using an ESP8266 board, read:
<a href="https://randomnerdtutorials.com/esp8266-nodemcu-http-get-open-weather-map-thingspeak-arduino/">Guide for ESP8266 NodeMCU HTTP GET Request</a>
<a href="https://randomnerdtutorials.com/esp8266-nodemcu-http-post-ifttt-thingspeak-arduino/">Guide for ESP8266 NodeMCU HTTP POST Request</a>
<h2>ESP32/ESP8266 Web Server: Control Outputs with Timer</h2>
In this tutorial you'll build a web server to control the ESP32 or ESP8266 NodeMCU outputs with a pulse using Arduino IDE. The pulse width (timer) can be adjusted using a slider on the web page. When you click the ON button, the ESP sets the output state to HIGH for the number of seconds defined in the slider. This can be specially useful to control appliances that need a HIGH signal for a predetermined number of seconds to actuate.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-ESP8266-NodeMCU-Web-Server-Control-Outputs-with-Timer-Pulse.jpg">
The ESP32/ESP8266 boards will be programmed using Arduino IDE. So make sure you have these boards installed:
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing ESP32 Board in Arduino IDE (Windows, Mac OS X, and Linux)</a>
<a href="https://randomnerdtutorials.com/how-to-install-esp8266-board-arduino-ide/">Installing ESP8266 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<h3>Project Overview</h3>
The following image shows an overview on how this project works.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-ESP8266-Control-Outputs-with-Timer-Web-Server-Project-Overview-How-it-Works.png">
The ESP32/ESP8266 hosts a web server that allows you to control an output with a pulse;
The web server contains a slider that allows you to define the pulse width (how many seconds the output should be HIGH);
There's an ON/OFF button. Set it to ON to send the pulse. After that, you'll see a timer decreasing for the duration of the pulse width;
When the timer is over, the output is set to LOW, and the web server button goes back to OFF state;
This web server can be useful to control devices that need a pulse to activate like garage door openers, for example.
<h3>Installing Libraries  Async Web Server</h3>
To build the web server you need to install the following libraries:
<k>ESP32:</k> install the <a href="https://github.com/me-no-dev/ESPAsyncWebServer" target="_blank">ESPAsyncWebServer</a> and the <a href="https://github.com/me-no-dev/AsyncTCP" target="_blank">AsyncTCP</a> libraries.
<k>ESP8266:</k> install the <a href="https://github.com/me-no-dev/ESPAsyncWebServer" target="_blank">ESPAsyncWebServer</a> and the <a href="https://github.com/me-no-dev/ESPAsyncTCP" target="_blank">ESPAsyncTCP</a> libraries.
These libraries aren't available to install through the Arduino Library Manager, so you need to copy the library files to the Arduino Installation Libraries folder. Alternatively, in your Arduino IDE, you can go to <k>Sketch </k>> <k>Include Library</k> > <k>Add .zip Library</k> and select the libraries you've just downloaded.
<h3>Code</h3>
Copy the following code to your Arduino IDE.
<k>/*********
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-esp8266-web-server-timer-pulse/
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*********/
// Import required libraries
#ifdef ESP32
  #include &lt;WiFi.h>
  #include &lt;AsyncTCP.h>
#else
  #include &lt;ESP8266WiFi.h>
  #include &lt;ESPAsyncTCP.h>
#endif
#include &lt;ESPAsyncWebServer.h>
// Replace with your network credentials
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
const char* PARAM_INPUT_1 = "state";
const char* PARAM_INPUT_2 = "value";
const int output = 2;
String timerSliderValue = "10";
// Create AsyncWebServer object on port 80
AsyncWebServer server(80);
const char index_html[] PROGMEM = R"rawliteral(
&lt;!DOCTYPE HTML>&lt;html>
&lt;head>
  &lt;meta name="viewport" content="width=device-width, initial-scale=1">
  &lt;title>ESP Web Server&lt;/title>
  &lt;style>
    html {font-family: Arial; display: inline-block; text-align: center;}
    h2 {font-size: 2.4rem;}
    p {font-size: 2.2rem;}
    body {max-width: 600px; margin:0px auto; padding-bottom: 25px;}
    .switch {position: relative; display: inline-block; width: 120px; height: 68px} 
    .switch input {display: none}
    .slider {position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; border-radius: 34px}
    .slider:before {position: absolute; content: ""; height: 52px; width: 52px; left: 8px; bottom: 8px; background-color: #fff; -webkit-transition: .4s; transition: .4s; border-radius: 68px}
    input:checked+.slider {background-color: #2196F3}
    input:checked+.slider:before {-webkit-transform: translateX(52px); -ms-transform: translateX(52px); transform: translateX(52px)}
    .slider2 { -webkit-appearance: none; margin: 14px; width: 300px; height: 20px; background: #ccc;
      outline: none; -webkit-transition: .2s; transition: opacity .2s;}
    .slider2::-webkit-slider-thumb {-webkit-appearance: none; appearance: none; width: 30px; height: 30px; background: #2f4468; cursor: pointer;}
    .slider2::-moz-range-thumb { width: 30px; height: 30px; background: #2f4468; cursor: pointer; } 
  &lt;/style>
&lt;/head>
&lt;body>
  &lt;h2>ESP Web Server&lt;/h2>
  &lt;p>&lt;span>%TIMERVALUE%&lt;/span> s&lt;/p>
  &lt;p>&lt;input type="range" onchange="updateSliderTimer(this)" min="1" max="20" value="%TIMERVALUE%" step="1">&lt;/p>
  %BUTTONPLACEHOLDER%
&lt;script>
function toggleCheckbox(element) {
  var sliderValue = document.getElementById("timerSlider").value;
  var xhr = new XMLHttpRequest();
  if(element.checked){ xhr.open("GET", "/update?state=1", true); xhr.send();
    var count = sliderValue, timer = setInterval(function() {
      count--; document.getElementById("timerValue").innerHTML = count;
      if(count == 0){ clearInterval(timer); document.getElementById("timerValue").innerHTML = document.getElementById("timerSlider").value; }
    }, 1000);
    sliderValue = sliderValue*1000;
    setTimeout(function(){ xhr.open("GET", "/update?state=0", true); 
    document.getElementById(element.id).checked = false; xhr.send(); }, sliderValue);
  }
}
function updateSliderTimer(element) {
  var sliderValue = document.getElementById("timerSlider").value;
  document.getElementById("timerValue").innerHTML = sliderValue;
  var xhr = new XMLHttpRequest();
  xhr.open("GET", "/slider?value="+sliderValue, true);
  xhr.send();
}
&lt;/script>
&lt;/body>
&lt;/html>
)rawliteral";
// Replaces placeholder with button section in your web page
String processor(const String& var){
  //Serial.println(var);
  if(var == "BUTTONPLACEHOLDER"){
    String buttons = "";
    String outputStateValue = outputState();
    buttons+= "&lt;p>&lt;label class=\"switch\">&lt;input type=\"checkbox\" onchange=\"toggleCheckbox(this)\" id=\"output\" " + outputStateValue + ">&lt;span class=\"slider\">&lt;/span>&lt;/label>&lt;/p>";
    return buttons;
  }
  else if(var == "TIMERVALUE"){
    return timerSliderValue;
  }
  return String();
}
String outputState(){
  if(digitalRead(output)){
    return "checked";
  }
  else {
    return "";
  }
  return "";
}
void setup(){
  // Serial port for debugging purposes
  Serial.begin(115200);
  pinMode(output, OUTPUT);
  digitalWrite(output, LOW);
  // Connect to Wi-Fi
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi..");
  }
  // Print ESP Local IP Address
  Serial.println(WiFi.localIP());
  // Route for root / web page
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send_P(200, "text/html", index_html, processor);
  });
  // Send a GET request to &lt;ESP_IP>/update?state=&lt;inputMessage>
  server.on("/update", HTTP_GET, [] (AsyncWebServerRequest *request) {
    String inputMessage;
    // GET input1 value on &lt;ESP_IP>/update?state=&lt;inputMessage>
    if (request->hasParam(PARAM_INPUT_1)) {
      inputMessage = request->getParam(PARAM_INPUT_1)->value();
      digitalWrite(output, inputMessage.toInt());
    }
    else {
      inputMessage = "No message sent";
    }
    Serial.println(inputMessage);
    request->send(200, "text/plain", "OK");
  });
  
  // Send a GET request to &lt;ESP_IP>/slider?value=&lt;inputMessage>
  server.on("/slider", HTTP_GET, [] (AsyncWebServerRequest *request) {
    String inputMessage;
    // GET input1 value on &lt;ESP_IP>/slider?value=&lt;inputMessage>
    if (request->hasParam(PARAM_INPUT_2)) {
      inputMessage = request->getParam(PARAM_INPUT_2)->value();
      timerSliderValue = inputMessage;
    }
    else {
      inputMessage = "No message sent";
    }
    Serial.println(inputMessage);
    request->send(200, "text/plain", "OK");
  });
  
  // Start server
  server.begin();
}
  
void loop() {
  
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_Web_Server_Timer_Pulse.ino" target="_blank">View raw code</a>
You just need to enter your network credentials (SSID and password) and the web server will work straight away. The code is compatible with both the <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> and <a href="https://makeradvisor.com/tools/esp8266-esp-12e-nodemcu-wi-fi-development-board/" target="_blank">ESP8266</a> boards and controls the on-board LED GPIO 2  you can change the code to control any other GPIO.
<h3>How the Code Works</h3>
We've already explained in great details how web servers like this work in previous tutorials (<a href="https://randomnerdtutorials.com/esp32-dht11-dht22-temperature-humidity-web-server-arduino-ide/">DHT Temperature Web Server</a> or <a href="https://randomnerdtutorials.com/esp32-esp8266-relay-web-server/">Relay Web Server</a>), so we'll just take a look at the relevant parts for this project.
<h3>Network Credentials</h3>
As said previously, insert your network credentials in the following lines:
<k>const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h3>Slider Label</h3>
Above the slider, there's a number showing the current slider value.
<k>&lt;p>&lt;span>%TIMERVALUE%&lt;/span> s&lt;/p></k>
By default, the slider value is set to the %TIMERVALUE% placeholder.
The %TIMERVALUE% is a placeholder that will be replaced with the value stored in the timerSliderValue variable which is set to 10 by default. But you can change that in the following line:
<k>String timerSliderValue = "10";</k>
This will also be changed when you move the slider. When the slider is moved, it calls a JavaScript function that updates the slider value.
<h3>Slider</h3>
The following line creates the slider. 
<k>&lt;input type="range" onchange="updateSliderTimer(this)" min="1" max="20" value="%TIMERVALUE%" step="1"></k>
Let's break this down into smaller sections.
In HTML, a slider is an input type. The &lt;input> tag specifies an input field where the user can enter data. The slider is an input field of type range. There are many other input field types.
<k>&lt;input type="range"></k>
The default range of the slider is 0 to 100. You can use the following attributes to customize the slider settings:
max: specifies the maximum value allowed. In our example, we're setting it to 20, but you can change that value.
min: specifies the minimum value. In this case, we're setting it to 1.
step: specifies the number interval. It's set to 1.
value: specifies the default value of the slider. In this case, it is equal to %TIMERVALUE%. 
<k>&lt;input type="range" onchange="updateSliderTimer(this)" min="1" max="20" value="%TIMERVALUE%" step="1"></k>
The %TIMERVALUE% is a placeholder that will be replaced with an actual value. In the code, it will be replaced with the value of the timerSliderValue variable that is set to 10 by default. But you can change that in the following line:
<k>String timerSliderValue = "10";</k>
The slider has two more attributes: id and onchange.
id: specifies a unique id for an HTML element (slider). The id allows us to manipulate the element using CSS or JavaScript.
onchange: is an event attribute that occurs when we change the value of the element (the slider). When you move the slider, it calls the updateSliderTimer() function. 
<h3>Update Slider Value (JavaScript)</h3>
When you move the slider, the updateSliderTimer() function is executed. 
It gets the current slider value by referring to its id timerSlider:
<k>var sliderValue = document.getElementById("timerSlider").value;</k>
Updates the slider label to the current slider value by referring to its id timerValue:
<k>document.getElementById("timerValue").innerHTML = sliderValue;</k>
Then, it makes a request on the <em>/slider?value=sliderValue</em> URL. Where the sliderValue is equal to the current slider value.
Then, the ESP32/ESP8266 handles what happens when it receives a request on that URL.
<h3>Control the Output with Timer (JavaScript)</h3>
When you click the ON/OFF button to control the output, it calls the toogleCheckbox() JavaScript function.
This function gets the current value of the slider label:
<k>var sliderValue = document.getElementById("timerSlider").value;</k>
Makes a request on the <em>/update?state=<k>1</k></em> URL so that the ESP knows it needs to set the output to HIGH.
<k>if(element.checked){ xhr.open("GET", "/update?state=1", true); xhr.send();</k>
The following lines decrease the slider label value every second creating the countdown timer. 
<k>var count = sliderValue, timer = setInterval(function() {
  count--; document.getElementById("timerValue").innerHTML = count;
  if(count == 0){ clearInterval(timer); document.getElementById("timerValue").innerHTML = document.getElementById("timerSlider").value; }
}, 1000);</k>
When the timer hits zero, the label value gets back to its original value and a request is made on the <em>/update?state=<k>0</k></em> URL, so that the ESP knows it is time to set the output to LOW. The button on the web server gets back to the off state.
<k>setTimeout(function(){ xhr.open("GET", "/update?state=0", true); 
document.getElementById(element.id).checked = false; xhr.send(); }, sliderValue);</k>
<h3>Handle Requests</h3>
The ESP32/ESP8266 needs to handle what happens when it receives a request on a certain URL.
<h4>Root URL</h4>
When you access the root URL <k>/</k>, send the HTML text saved on the index_html variable. All placeholders are replaced with the actual values by the processor() function.
<k>server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
  request->send_P(200, "text/html", index_html, processor);
});</k>
<h4>Control Output State</h4>
The following lines handle what happens when you receive a request on the <em>/update?state=<k>1</k></em> and <em>/update?state=<k>0</k></em> URLs. It sets the output state to HIGH or LOW accordingly.
<k>server.on("/update", HTTP_GET, [] (AsyncWebServerRequest *request) {
  String inputMessage;
  // GET input1 value on &lt;ESP_IP>/update?state=&lt;inputMessage>
  if (request->hasParam(PARAM_INPUT_1)) {
    inputMessage = request->getParam(PARAM_INPUT_1)->value();
    digitalWrite(output, inputMessage.toInt());
  }
  else {
    inputMessage = "No message sent";
  }
  Serial.println(inputMessage);
  request->send(200, "text/plain", "OK");
});</k>
The output state is updated in the following line:
<k>digitalWrite(output, inputMessage.toInt());</k>
<h3>Update Slider Value</h3>
Every time you drag the slider, the ESP receives a request with the new value. We store the new slider value and print it in the Serial Monitor.
<k>// Send a GET request to &lt;ESP_IP>/slider?value=&lt;inputMessage>
server.on("/slider", HTTP_GET, [] (AsyncWebServerRequest *request) {
  String inputMessage;
  // GET input1 value on &lt;ESP_IP>/slider?value=&lt;inputMessage>
  if (request->hasParam(PARAM_INPUT_2)) {
    inputMessage = request->getParam(PARAM_INPUT_2)->value();
    timerSliderValue = inputMessage;
  }
  else {
    inputMessage = "No message sent";
  }
  Serial.println(inputMessage);
  request->send(200, "text/plain", "OK");
});</k>
<h3>Demonstration</h3>
Upload the code to your ESP32 or ESP8266 NodeMCU board. Then, open the Serial Monitor and press the on-board RST/EN button to get is IP address.
Open a browser in your local network and type the ESP IP address. The following page should load.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-ESP8266-Control-Outputs-with-Timer-Web-Server.png">
Drag the slider to adjust the pulse width, and then, click the ON/OFF button. The output (in this case GPIO 2  built-in LED) will stay on for the period of time you've set on the slider.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-board-Built_in-LED-turned-on-HIGH.jpg">
Watch the next quick video for a live demonstration:

<h3>Wrapping Up</h3>
In this tutorial you've learned how to build a web server to control an output with a pulse. The pulse width can be adjusted with a slider on the web server page. This can be specially useful to control certain appliances that need a HIGH signal for a determined number of seconds to actuate, like garage door openers.
We hope you liked this tutorial. We have more web server projects you may like:
<a href="https://randomnerdtutorials.com/esp32-esp8266-input-data-html-form/">Input Data on HTML Form ESP32/ESP8266 Web Server using Arduino IDE</a>
<a href="https://randomnerdtutorials.com/esp32-esp8266-web-server-http-authentication/">ESP32/ESP8266 Web Server HTTP Authentication (Username and Password Protected)</a>
<a href="https://randomnerdtutorials.com/esp32-esp8266-web-server-physical-button/">ESP32/ESP8266: Control Outputs with Web Server and a Physical Button Simultaneously</a>
<a href="https://randomnerdtutorials.com/esp32-esp8266-web-server-outputs-momentary-switch/">ESP32/ESP8266 Web Server: Control Outputs with Momentary Switch</a>
Learn more about the ESP32 and ESP8266 board with our resources.
<a href="https://randomnerdtutorials.com/learn-esp32-with-arduino-ide/">Learn ESP32 using Arduino IDE</a>
<a href="https://randomnerdtutorials.com/home-automation-using-esp8266/">Home Automation using ESP8266</a>
<a href="https://randomnerdtutorials.com/projects-esp32/">More ESP32 tutorials</a>
<a href="https://randomnerdtutorials.com/projects-esp8266/">More ESP8266 tutorials</a>
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/smart-home-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px-pupj8i6e7hlzpgwxe82jjd8skst9vmrjt9lpqb0v0g.jpg" title="Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px" alt="SMART HOME with Raspberry Pi ESP32 and ESP8266 Node-RED InfluxDB eBook" loading="lazy" width="117" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/smart-home-ebook/">SMART HOME with Raspberry Pi, ESP32, ESP8266 [eBook] </a></h4>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>ESP32/ESP8266 Web Server HTTP Authentication (Username and Password Protected)</h2>
Learn how to add HTTP authentication with username and password to your ESP32 and ESP8266 NodeMCU web server projects using Arduino IDE. You can only access your web server if you type the correct user and pass. If you logout, you can only access again if you enter the right credentials.
The method we'll use can be applied to web servers built using the ESPAsyncWebServer library.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-ESP8266-NodeMCU-Web-Server-HTTP-Authentication-Username-and-Password-Protected-Arduino-IDE.jpg">
The ESP32/ESP8266 boards will be programmed using Arduino IDE. So make sure you have these boards installed:
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing ESP32 Board in Arduino IDE (Windows, Mac OS X, and Linux)</a>
<a href="https://randomnerdtutorials.com/how-to-install-esp8266-board-arduino-ide/">Installing ESP8266 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<h3>Security Concerns</h3>
This project is meant to be used in your local network to protect from anyone just typing the ESP IP address and accessing the web server (like unauthorized family member or friend). 
If your network is properly secured, running an HTTP server with basic authentication is enough for most applications. If someone has managed to hack your network, it doesn't matter if you use HTTP or HTTPS. The hacker can bypass HTTPS and get your user/pass.
<h3>Project Overview</h3>
Let's take a quick look at the features of the project we'll build.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-ESP8266-Password-Protected-Web-Server-Overview.png">
In this tutorial you'll learn how to password protect your web server;
When you try to access the web server page on the ESP IP address, a window pops up asking for a username and password;
To get access to the web server page, you need to enter the right username and password (defined in the ESP32/ESP8266 sketch);
There's a logout button on the web server. If you click the logout button, you'll be redirected to a logout page. Then, close all web browser tabs to complete the logout process;
You can only access the web server again if you login with the right credentials;
If you try to access the web server from a different device (on the local network) you also need to login with the right credentials (even if you have a successful login on another device);
The authentication is not encrypted.
<k>Note: </k> this project was tested on Google Chrome and Firefox web browsers and Android devices.
<h3>Installing Libraries  Async Web Server</h3>
To build the web server you need to install the following libraries:
<k>ESP32:</k> install the <a href="https://github.com/me-no-dev/ESPAsyncWebServer" target="_blank">ESPAsyncWebServer</a> and the <a href="https://github.com/me-no-dev/AsyncTCP" target="_blank">AsyncTCP</a> libraries.
<k>ESP8266:</k> install the <a href="https://github.com/me-no-dev/ESPAsyncWebServer" target="_blank">ESPAsyncWebServer</a> and the <a href="https://github.com/me-no-dev/ESPAsyncTCP" target="_blank">ESPAsyncTCP</a> libraries.
These libraries aren't available to install through the Arduino Library Manager, so you need to copy the library files to the Arduino Installation Libraries folder. Alternatively, in your Arduino IDE, you can go to <k>Sketch </k>> <k>Include Library</k> > <k>Add .zip Library</k> and select the libraries you've just downloaded.
<h3>Web Server Code with Authentication</h3>
Copy the following code to your Arduino IDE.
<k>/*********
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-esp8266-web-server-http-authentication/
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*********/
// Import required libraries
#ifdef ESP32
  #include &lt;WiFi.h>
  #include &lt;AsyncTCP.h>
#else
  #include &lt;ESP8266WiFi.h>
  #include &lt;ESPAsyncTCP.h>
#endif
#include &lt;ESPAsyncWebServer.h>
// Replace with your network credentials
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
const char* http_username = "admin";
const char* http_password = "admin";
const char* PARAM_INPUT_1 = "state";
const int output = 2;
// Create AsyncWebServer object on port 80
AsyncWebServer server(80);
const char index_html[] PROGMEM = R"rawliteral(
&lt;!DOCTYPE HTML>&lt;html>
&lt;head>
  &lt;title>ESP Web Server&lt;/title>
  &lt;meta name="viewport" content="width=device-width, initial-scale=1">
  &lt;style>
    html {font-family: Arial; display: inline-block; text-align: center;}
    h2 {font-size: 2.6rem;}
    body {max-width: 600px; margin:0px auto; padding-bottom: 10px;}
    .switch {position: relative; display: inline-block; width: 120px; height: 68px} 
    .switch input {display: none}
    .slider {position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; border-radius: 34px}
    .slider:before {position: absolute; content: ""; height: 52px; width: 52px; left: 8px; bottom: 8px; background-color: #fff; -webkit-transition: .4s; transition: .4s; border-radius: 68px}
    input:checked+.slider {background-color: #2196F3}
    input:checked+.slider:before {-webkit-transform: translateX(52px); -ms-transform: translateX(52px); transform: translateX(52px)}
  &lt;/style>
&lt;/head>
&lt;body>
  &lt;h2>ESP Web Server&lt;/h2>
  &lt;button onclick="logoutButton()">Logout&lt;/button>
  &lt;p>Ouput - GPIO 2 - State &lt;span>%STATE%&lt;/span>&lt;/p>
  %BUTTONPLACEHOLDER%
&lt;script>function toggleCheckbox(element) {
  var xhr = new XMLHttpRequest();
  if(element.checked){ 
    xhr.open("GET", "/update?state=1", true); 
    document.getElementById("state").innerHTML = "ON";  
  }
  else { 
    xhr.open("GET", "/update?state=0", true); 
    document.getElementById("state").innerHTML = "OFF";      
  }
  xhr.send();
}
function logoutButton() {
  var xhr = new XMLHttpRequest();
  xhr.open("GET", "/logout", true);
  xhr.send();
  setTimeout(function(){ window.open("/logged-out","_self"); }, 1000);
}
&lt;/script>
&lt;/body>
&lt;/html>
)rawliteral";
const char logout_html[] PROGMEM = R"rawliteral(
&lt;!DOCTYPE HTML>&lt;html>
&lt;head>
  &lt;meta name="viewport" content="width=device-width, initial-scale=1">
&lt;/head>
&lt;body>
  &lt;p>Logged out or &lt;a href="/">return to homepage&lt;/a>.&lt;/p>
  &lt;p>&lt;strong>Note:&lt;/strong> close all web browser tabs to complete the logout process.&lt;/p>
&lt;/body>
&lt;/html>
)rawliteral";
// Replaces placeholder with button section in your web page
String processor(const String& var){
  //Serial.println(var);
  if(var == "BUTTONPLACEHOLDER"){
    String buttons ="";
    String outputStateValue = outputState();
    buttons+= "&lt;p>&lt;label class=\"switch\">&lt;input type=\"checkbox\" onchange=\"toggleCheckbox(this)\" id=\"output\" " + outputStateValue + ">&lt;span class=\"slider\">&lt;/span>&lt;/label>&lt;/p>";
    return buttons;
  }
  if (var == "STATE"){
    if(digitalRead(output)){
      return "ON";
    }
    else {
      return "OFF";
    }
  }
  return String();
}
String outputState(){
  if(digitalRead(output)){
    return "checked";
  }
  else {
    return "";
  }
  return "";
}
void setup(){
  // Serial port for debugging purposes
  Serial.begin(115200);
  pinMode(output, OUTPUT);
  digitalWrite(output, LOW);
  
  // Connect to Wi-Fi
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi..");
  }
  // Print ESP Local IP Address
  Serial.println(WiFi.localIP());
  // Route for root / web page
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
    if(!request->authenticate(http_username, http_password))
      return request->requestAuthentication();
    request->send_P(200, "text/html", index_html, processor);
  });
    
  server.on("/logout", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send(401);
  });
  server.on("/logged-out", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send_P(200, "text/html", logout_html, processor);
  });
  // Send a GET request to &lt;ESP_IP>/update?state=&lt;inputMessage>
  server.on("/update", HTTP_GET, [] (AsyncWebServerRequest *request) {
    if(!request->authenticate(http_username, http_password))
      return request->requestAuthentication();
    String inputMessage;
    String inputParam;
    // GET input1 value on &lt;ESP_IP>/update?state=&lt;inputMessage>
    if (request->hasParam(PARAM_INPUT_1)) {
      inputMessage = request->getParam(PARAM_INPUT_1)->value();
      inputParam = PARAM_INPUT_1;
      digitalWrite(output, inputMessage.toInt());
    }
    else {
      inputMessage = "No message sent";
      inputParam = "none";
    }
    Serial.println(inputMessage);
    request->send(200, "text/plain", "OK");
  });
  
  // Start server
  server.begin();
}
  
void loop() {
  
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_Web_Server_HTTP_Auth_2.ino" target="_blank">View raw code</a>
You just need to enter your network credentials (SSID and password) and the web server will work straight away. The code is compatible with both the <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> and <a href="https://makeradvisor.com/tools/esp8266-esp-12e-nodemcu-wi-fi-development-board/" target="_blank">ESP8266</a> boards. 
As an example, we're building a web server that controls GPIO 2. You can use the HTTP authentication with any web server built with the <a href="https://github.com/me-no-dev/ESPAsyncWebServer" target="_blank">ESPAsyncWebServer library</a>.
<h3>How the Code Works</h3>
We've already explained in great details how web servers like this work in previous tutorials (<a href="https://randomnerdtutorials.com/esp32-dht11-dht22-temperature-humidity-web-server-arduino-ide/">DHT Temperature Web Server</a> or <a href="https://randomnerdtutorials.com/esp32-esp8266-relay-web-server/">Relay Web Server</a>), so we'll just take a look at the relevant parts to add username and password authentication to the web server.
<h3>Network Credentials</h3>
As mentioned previously, you need to insert your network credentials in the following lines:
<k>const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h3>Setting Your Username and Password</h3>
In the following variables set the username and password for your web server. By default, the username is <k>admin</k> and the password is also <k>admin</k>. We definitely recommend to change them.
<k>const char* http_username = "admin";
const char* http_password = "admin";</k>
<h3>Logout Button</h3>
In the index_html variable you should add some HTML text to add a logout button. In this example, it's a simple logout button without styling to make things simpler.
<k>&lt;button onclick="logoutButton()">Logout&lt;/button></k>
When clicked, the button calls the logoutButton() JavaScript function. This function makes an HTTP GET request to your ESP32/ESP8266 on the <k><em>/logout</em></k> URL. Then, in the ESP code, you should handle what happens after receiving this request.
<k>function logoutButton() {
  var xhr = new XMLHttpRequest();
  xhr.open("GET", "logout", true);
  xhr.send();</k>
One second after you click the logout button, you are redirected to the logout page on the <em><k>/logged-out</k></em> URL.
<k>  setTimeout(function(){ window.open("/logged-out","_self"); }, 1000);
}</k>
<h3>Handle Requests with Authentication</h3>
Every time you make a request to the ESP32 or ESP8266 to access the web server, it will check whether you've already entered the correct username and password to authenticate.
Basically, to add authentication to your web server, you just need to add the following lines after each request:
<k>if(!request->authenticate(http_username, http_password))
    return request->requestAuthentication();</k>
These lines continuously pop up the authentication window until you insert the right credentials.
You need to do this for all requests. This way, you ensure that you'll only get responses if you are logged in.
For example, when you try to access the root URL (ESP IP address), you add the previous two lines before sending the page. If you enter the wrong credentials, the browser will keep asking for them.
<k>server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
  if(!request->authenticate(http_username, http_password))
    return request->requestAuthentication();
  request->send_P(200, "text/html", index_html, processor);
});</k>
Here's another example for when the ESP receives a request on the <k><em>/state</em></k> URL.
<k>server.on("/state", HTTP_GET, [] (AsyncWebServerRequest *request) {
  if(!request->authenticate(http_username, http_password))
    return request->requestAuthentication();
  request->send(200, "text/plain", String(digitalRead(output)).c_str());
});</k>
<h3>Handle Logout Button</h3>
When you click the logout button, the ESP receives a request on the <k><em>/logout</em></k> URL. When that happens send the response code 401.
<k>server.on("/logout", HTTP_GET, [](AsyncWebServerRequest *request){
  request->send(401);
});</k>
The response code 401 is an unauthorized error HTTP response status code indicating that the request sent by the client could not be authenticated. So, it will have the same effect as a logout  it will ask for the username and password and won't let you access the web server again until you login.
When you click the web server logout button, after one second, the ESP receives another request on the <em><k>/logged-out</k></em> URL. When that happens, send the HTML text to build the logout page (logout_html variable).
<k>server.on("/logged-out", HTTP_GET, [](AsyncWebServerRequest *request){
  request->send_P(200, "text/html", logout_html, processor);
});</k>
<h3>Demonstration</h3>
Upload the code to your ESP32 or ESP8266 board. Then, open the Serial Monitor and press the on-board RST/EN button to get is IP address.
Open a browser in your local network and type the ESP IP address.
The following page should load asking for the username and password. Enter the username and password and you should get access to the web server. If you haven't modified the code, the username is <k>admin </k>and the password is <k>admin</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-ESP8266-Web-Server-Username-Password.png">
After typing the right username and password, you should get access to the web server.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-ESP8266-Web-Server-Logout-Button.png">
You can play with the web server and see that it actually controls the ESP32 or ESP8266 on-board LED.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-board-Built_in-LED-turned-on-HIGH.jpg">
In the web server page, there's a logout button. If you click that button, you'll be redirected to a logout page as shown below.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-Password-Protected-Web-Server-Logout.png">
If you click the return to homepage link, you'll be redirected to the main web server page. 
If you're using Google Chrome, you'll need to enter the username and password to access the web server again. 
If you're using Firefox, you need to close all web browser tabs to completely logout. Otherwise, if you go back to the main web server page, you'll still have access.
So, we advise that you close all web browser tabs after clicking the logout button.
You also need to enter the username and password if you try to get access using a different device on the local network, even though you have access on another device.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-ESP8266-NodeMCU-Web-Server-HTTP-Authentication-Username-and-Password-Protected-Arduino-IDE-Demonstration.jpg">
<h3>Wrapping Up</h3>
In this tutorial you've learned how to add authentication to your ESP32 and ESP8266 web servers (password protected web server). You can apply what you learned in this tutorial to any web server built with the ESPAsyncWebServer library.
We hope you've found this tutorial useful. Other web server projects you may like:
<a href="https://randomnerdtutorials.com/esp32-esp8266-web-server-physical-button/">ESP32/ESP8266: Control Outputs with Web Server and a Physical Button Simultaneously</a>
<a href="https://randomnerdtutorials.com/esp32-esp8266-web-server-outputs-momentary-switch/">ESP32/ESP8266 Web Server: Control Outputs with Momentary Switch</a>
<a href="https://randomnerdtutorials.com/esp32-esp8266-relay-web-server/">ESP32/ESP8266 Relay Module Web Server using Arduino IDE</a>
Learn more about the ESP32 and ESP8266 boards with our resources:
<a href="https://randomnerdtutorials.com/learn-esp32-with-arduino-ide/">Learn ESP32 with Arduino IDE</a>
<a href="https://randomnerdtutorials.com/home-automation-using-esp8266/">Home Automation using ESP8266</a>
<a style="font-size: inherit; background-color: initial;" href="https://randomnerdtutorials.com/projects-esp32/">Free ESP32 Projects, Tutorials and Guides</a>
<a href="https://randomnerdtutorials.com/projects-esp8266/">Free ESP8266 NodeMCU Projects, Tutorials and Guides</a>
Thanks for reading.
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/smart-home-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px-pupj8i6e7hlzpgwxe82jjd8skst9vmrjt9lpqb0v0g.jpg" title="Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px" alt="SMART HOME with Raspberry Pi ESP32 and ESP8266 Node-RED InfluxDB eBook" loading="lazy" width="117" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/smart-home-ebook/">SMART HOME with Raspberry Pi, ESP32, ESP8266 [eBook] </a></h4>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>ESP-NOW with ESP32: Receive Data from Multiple Boards (many-to-one)</h2>
This tutorial shows how to set up an ESP32 board to receive data from multiple ESP32 boards via ESP-NOW communication protocol (many-to-one configuration). This configuration is ideal if you want to collect data from several sensors nodes into one ESP32 board. The boards will be programmed using Arduino IDE.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP-NOW-ESP32-Receive-Data-Multiple-Boards-Many-to-One-Arduino-IDE.jpg">

This tutorial shows how to setup an ESP32 board to receive data from multiple ESP32 boards via ESP-NOW communication protocol (many-to-one configuration) as shown in the following figure.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP_NOW_one_slave_multiple_masters.png">
One ESP32 board acts as a receiver/slave;
Multiple ESP32 boards act as senders/masters. We've tested this example with 5 ESP32 sender boards and it worked fine. You should be able to add more boards to your setup;
The sender board receives an acknowledge message indicating if the message was successfully delivered or not;
The ESP32 receiver board receives the messages from all senders and identifies which board sent the message;
As an example, we'll exchange random values between the boards. You should modify this example to send commands or sensor readings (<a href="https://randomnerdtutorials.com/esp-now-two-way-communication-esp32/">exchange sensor readings using ESP-NOW</a>).
<k>Note: </k> in the ESP-NOW documentation there isn't such thing as sender/master and receiver/slave. Every board can be a sender or receiver. However, to keep things clear we'll use the terms sender and receiver or master and slave.
<h3>Prerequisites</h3>
We'll program the ESP32 boards using Arduino IDE, so before proceeding with this tutorial, make sure you have these boards installed in your Arduino IDE.
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing ESP32 Board in Arduino IDE (Windows, Mac OS X, and Linux)</a>
<h3>Parts Required</h3>
To follow this tutorial, you need multiple ESP32 boards. All ESP32 models should work. We've experimented with different models of ESP32 boards and all worked well (<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32 DOIT board</a>, <a href="https://randomnerdtutorials.com/ttgo-t-journal-esp32-camera-getting-started/">TTGO T-Journal</a>, <a href="https://randomnerdtutorials.com/esp32-built-in-oled-ssd1306/">ESP32 with OLED board</a> and <a href="https://randomnerdtutorials.com/esp32-cam-video-streaming-face-recognition-arduino-ide/">ESP32-CAM</a>).
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> (read <a href="https://makeradvisor.com/esp32-development-boards-review-comparison/" target="_blank">Best ESP32 development boards</a>)
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="eager" fetchpriority="high" decoding="async"></a>
<h3>Getting the Receiver Board MAC Address</h3>
To send messages via ESP-NOW, you need to know the receiver board's <a href="https://randomnerdtutorials.com/get-change-esp32-esp8266-mac-address-arduino/">MAC address</a>. Each board has a unique MAC address (learn how to <a href="https://randomnerdtutorials.com/get-change-esp32-esp8266-mac-address-arduino/">Get and Change the ESP32 MAC Address</a>).
Upload the following code to your ESP32 receiver board to get is MAC address.
<k>// Complete Instructions to Get and Change ESP MAC Address: https://RandomNerdTutorials.com/get-change-esp32-esp8266-mac-address-arduino/
#ifdef ESP32
  #include &lt;WiFi.h>
#else
  #include &lt;ESP8266WiFi.h>
#endif
void setup(){
  Serial.begin(115200);
  Serial.println();
  Serial.print("ESP Board MAC Address:  ");
  Serial.println(WiFi.macAddress());
}
 
void loop(){
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_Get_MAC_Address.ino" target="_blank">View raw code</a>
After uploading the code, press the RST/EN button, and the MAC address should be displayed on the Serial Monitor. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-MAC-Address-Serial-Monitor.png">
<h3>ESP32 Sender Code (ESP-NOW)</h3>
The receiver can identify each sender by its unique MAC address. However, dealing with different MAC addresses on the Receiver side to identify which board sent which message can be tricky. 
So, to make things easier, we'll identify each board with a unique number (id) that starts at 1. If you have three boards, one will have ID number 1, the other number 2, and finally number 3. The ID will be sent to the receiver alongside the other variables. 
As an example, we'll exchange a structure that contains the board id number and two random numbers x and y as shown in the figure below.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP-NOW-Receive-Data-Structures-from-multiple-boards.jpg">
Upload the following code to each of your sender boards. Don't forget to increment the id number for each sender board.
<k>/*********
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp-now-many-to-one-esp32/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*********/
#include &lt;esp_now.h>
#include &lt;WiFi.h>
// REPLACE WITH THE RECEIVER'S MAC Address
uint8_t broadcastAddress[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
// Structure example to send data
// Must match the receiver structure
typedef struct struct_message {
    int id; // must be unique for each sender board
    int x;
    int y;
} struct_message;
// Create a struct_message called myData
struct_message myData;
// Create peer interface
esp_now_peer_info_t peerInfo;
// callback when data is sent
void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
  Serial.print("\r\nLast Packet Send Status:\t");
  Serial.println(status == ESP_NOW_SEND_SUCCESS ? "Delivery Success" : "Delivery Fail");
}
 
void setup() {
  // Init Serial Monitor
  Serial.begin(115200);
  // Set device as a Wi-Fi Station
  WiFi.mode(WIFI_STA);
  // Init ESP-NOW
  if (esp_now_init() != ESP_OK) {
    Serial.println("Error initializing ESP-NOW");
    return;
  }
  // Once ESPNow is successfully Init, we will register for Send CB to
  // get the status of Trasnmitted packet
  esp_now_register_send_cb(OnDataSent);
  
  // Register peer
  memcpy(peerInfo.peer_addr, broadcastAddress, 6);
  peerInfo.channel = 0;  
  peerInfo.encrypt = false;
  
  // Add peer        
  if (esp_now_add_peer(&peerInfo) != ESP_OK){
    Serial.println("Failed to add peer");
    return;
  }
}
 
void loop() {
  // Set values to send
  myData.id = 1;
  myData.x = random(0,50);
  myData.y = random(0,50);
  // Send message via ESP-NOW
  esp_err_t result = esp_now_send(broadcastAddress, (uint8_t *) &myData, sizeof(myData));
   
  if (result == ESP_OK) {
    Serial.println("Sent with success");
  }
  else {
    Serial.println("Error sending the data");
  }
  delay(10000);
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_NOW/ESP_NOW_Sender_Multiple_Boards.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
Include the WiFi and esp_now libraries.
<k>#include &lt;esp_now.h>
#include &lt;WiFi.h></k>
Insert the receiver's MAC address on the following line.
<k>uint8_t broadcastAddress[] = {0x30, 0xAE, 0xA4, 0x15, 0xC7, 0xFC};</k>
Then, create a structure that contains the data we want to send. We called this structure struct_message and it contains three integer variables: the board id, x and y. You can change this to send whatever variable types you want (but don't forget to change that on the receiver side too).
<k>typedef struct struct_message {
  int id; // must be unique for each sender board
  int x;
  int y;
} struct_message;</k>
Create a new variable of type struct_message that is called myData that will store the variables' values.
<k>struct_message myData;</k>
Create a variable of type esp_now_peer_info_t to store information about the peer.
<k>esp_now_peer_info_t peerInfo;</k>
<h4>OnDataSent() callback function</h4>
Next, define the OnDataSent() function. This is a callback function that will be executed when a message is sent. In this case, this function prints if the message was successfully delivered or not.
<k>void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
  Serial.print("\r\nLast Packet Send Status:\t");
  Serial.println(status == ESP_NOW_SEND_SUCCESS ? "Delivery Success" : "Delivery Fail");
}</k>
<h4>setup()</h4>
In the setup(), initialize the serial monitor for debugging purposes:
<k>Serial.begin(115200);</k>
Set the device as a Wi-Fi station:
<k>WiFi.mode(WIFI_STA);</k>
Initialize ESP-NOW:
<k>if (esp_now_init() != ESP_OK) {
  Serial.println("Error initializing ESP-NOW");
  return;
}</k>
After successfully initializing ESP-NOW, register the callback function that will be called when a message is sent. In this case, register for the OnDataSent() function created previously.
<k>esp_now_register_send_cb(OnDataSent);</k>
<h3>Add peer device</h3>
To send data to another board (the receiver), you need to pair it as a peer. The following lines register and add a new peer.
<k>memcpy(peerInfo.peer_addr, broadcastAddress, 6);
peerInfo.channel = 0;
peerInfo.encrypt = false;
// Add peer
if (esp_now_add_peer(&peerInfo) != ESP_OK){
  Serial.println("Failed to add peer");
  return;
}</k>
<h4>loop()</h4>
In the loop(), we'll send a message via ESP-NOW every 10 seconds (you can change this delay time).
Assign a value to each variable.
<k>myData.id = 1;
myData.x = random(0,50);
myData.y = random(0,50);</k>
<k>Don't forget to change the id for each sender board.</k>
Remember that myData is a structure. Here assign the values that you want to send inside the structure. In this case, we're just sending the id and random values x and y. In a practical application these should be replaced with commands or sensor readings, for example.
<h4>Send ESP-NOW message</h4>
Finally, send the message via ESP-NOW.
<k>// Send message via ESP-NOW
esp_err_t result = esp_now_send(broadcastAddress, (uint8_t *) &myData, sizeof(myData));
 
if (result == ESP_OK) {
  Serial.println("Sent with success");
}
else {
  Serial.println("Error sending the data");
}</k>
<h3>ESP32 Receiver Code (ESP-NOW)</h3>
Upload the following code to your ESP32 receiver board. The code is prepared to receive data from three different boards. You can easily modify the code to receive data from a different number of boards.
<k>/*********
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp-now-many-to-one-esp32/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*********/
#include &lt;esp_now.h>
#include &lt;WiFi.h>
// Structure example to receive data
// Must match the sender structure
typedef struct struct_message {
  int id;
  int x;
  int y;
}struct_message;
// Create a struct_message called myData
struct_message myData;
// Create a structure to hold the readings from each board
struct_message board1;
struct_message board2;
struct_message board3;
// Create an array with all the structures
struct_message boardsStruct[3] = {board1, board2, board3};
// callback function that will be executed when data is received
void OnDataRecv(const uint8_t * mac_addr, const uint8_t *incomingData, int len) {
  char macStr[18];
  Serial.print("Packet received from: ");
  snprintf(macStr, sizeof(macStr), "%02x:%02x:%02x:%02x:%02x:%02x",
           mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5]);
  Serial.println(macStr);
  memcpy(&myData, incomingData, sizeof(myData));
  Serial.printf("Board ID %u: %u bytes\n", myData.id, len);
  // Update the structures with the new incoming data
  boardsStruct[myData.id-1].x = myData.x;
  boardsStruct[myData.id-1].y = myData.y;
  Serial.printf("x value: %d \n", boardsStruct[myData.id-1].x);
  Serial.printf("y value: %d \n", boardsStruct[myData.id-1].y);
  Serial.println();
}
 
void setup() {
  //Initialize Serial Monitor
  Serial.begin(115200);
  
  //Set device as a Wi-Fi Station
  WiFi.mode(WIFI_STA);
  //Init ESP-NOW
  if (esp_now_init() != ESP_OK) {
    Serial.println("Error initializing ESP-NOW");
    return;
  }
  
  // Once ESPNow is successfully Init, we will register for recv CB to
  // get recv packer info
  esp_now_register_recv_cb(OnDataRecv);
}
 
void loop() {
  // Acess the variables for each board
  /*int board1X = boardsStruct[0].x;
  int board1Y = boardsStruct[0].y;
  int board2X = boardsStruct[1].x;
  int board2Y = boardsStruct[1].y;
  int board3X = boardsStruct[2].x;
  int board3Y = boardsStruct[2].y;*/
  delay(10000);  
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_NOW/ESP_NOW_Receiver_Multiple_Boards.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
Similarly to the sender, start by including the libraries:
<k>#include &lt;esp_now.h>
#include &lt;WiFi.h></k>
Create a structure to receive the data. This structure should be the same defined in the sender sketch.
<k>typedef struct struct_message {
  int id;
  int x;
  int y;
} struct_message;</k>
Create a struct_message variable called myData that will hold the data received.
<k>struct_message myData;</k>
Then, create a struct_message variable for each board, so that we can assign the received data to the corresponding board. Here we're creating structures for three sender boards. If you have more sender boards, you need to create more structures.
<k>struct_message board1;
struct_message board2;
struct_message board3;</k>
Create an array that contains all the board structures. If you're using a different number of boards you need to change that.
<k>struct_message boardsStruct[3] = {board1, board2, board3};</k>
<h3>onDataRecv()</h3>
Create a callback function that is called when the ESP32 receives the data via ESP-NOW. The function is called onDataRecv() and should accept several parameters as follows:
<k>void OnDataRecv(const uint8_t * mac, const uint8_t *incomingData, int len) {</k>
Get the board MAC address:
<k>char macStr[18];
Serial.print("Packet received from: ");
snprintf(macStr, sizeof(macStr), "%02x:%02x:%02x:%02x:%02x:%02x",
         mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5]);
Serial.println(macStr);</k>
Copy the content of the incomingData data variable into the myData variable.
<k>memcpy(&myData, incomingData, sizeof(myData));</k>
Now, the myData structure contains several variables with the values sent by one of the ESP32 senders. We can identify which board send the packet by its ID: myData.id.
This way, we can assign the values received to the corresponding boards on the boardsStruct array:
<k>boardsStruct[myData.id-1].x = myData.x;
boardsStruct[myData.id-1].y = myData.y;</k>
For example, imagine you receive a packet from board with id 2. The value of myData.id, is 2.
So, you want to update the values of the board2 structure. The board2 structure is the element with index 1 on the boardsStruct array. That's why we subtract 1, because arrays in C have 0 indexing. It may help if you take a look at the following image.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP-NOW-Receive-Data-Multiple-Boards-Array-Structures.png">
<h3>setup()</h3>
In the setup(), initialize the Serial Monitor.
<k>Serial.begin(115200);</k>
Set the device as a Wi-Fi Station.
<k>WiFi.mode(WIFI_STA);</k>
Initialize ESP-NOW:
<k>if (esp_now_init() != ESP_OK) {
  Serial.println("Error initializing ESP-NOW");
  return;
}</k>
Register for a callback function that will be called when data is received. In this case, we register for the OnDataRecv() function that was created previously.
<k>esp_now_register_recv_cb(OnDataRecv);</k>
The following lines commented on the loop exemplify what you need to do if you want to access the variables of each board structure. For example, to access the x value of board1:
<k>int board1X = boardsStruct[0].x;</k>
<h3>Demonstration</h3>
Upload the sender code to each of your sender boards. Don't forget to give a different ID to each board.
Upload the receiver code to the ESP32 receiver board. Don't forget to modify the structure to match the number of sender boards.
On the senders' Serial Monitor, you should get a Delivery Success message if the messages are delivered correctly.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/Send-data-ESP-NOW-acknowledge-message-serial-monitor.png">
On the receiver board, you should be receiving the packets from all the other boards. In this test, we were receiving data from 5 different boards.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/Receive-data-multiple-ESP32-Serial-Monitor.png">
<h3>Wrapping Up</h3>
In this tutorial, you've learned how to set up an ESP32 to receive data from multiple ESP32 boards using ESP-NOW (many-to-one configuration).
As an example, we've exchanged random numbers. In a real application, those can be replaced with actual sensor readings or commands. This is ideal if you want to collect data from several sensor nodes. You can take this project further and create a web server on the receiver board to displays the received messages.
To use Wi-Fi to create a web server and use ESP-NOW simultaneously, you need to set up the ESP32 both as a Wi-Fi station and access point. Additionally, you need to set a different Wi-Fi channel: one for ESP-NOW and the other for the station. You can follow the next tutorial:
<a href="https://randomnerdtutorials.com/esp32-esp-now-wi-fi-web-server/">ESP32: ESP-NOW Web Server Sensor Dashboard (ESP-NOW + Wi-Fi)</a>
We have other tutorials related with ESP-NOW that you may like:
<a href="https://randomnerdtutorials.com/esp-now-esp32-arduino-ide/">Getting Started with ESP-NOW (ESP32 with Arduino IDE)</a>
<a href="https://randomnerdtutorials.com/esp-now-two-way-communication-esp32/">ESP-NOW Two-Way Communication Between ESP32 Boards</a>
<a href="https://randomnerdtutorials.com/esp-now-one-to-many-esp32-esp8266/">ESP-NOW with ESP32: Send Data to Multiple Boards (one-to-many)</a>
<a href="https://randomnerdtutorials.com/esp-now-esp8266-nodemcu-arduino-ide/">Getting Started with ESP-NOW (ESP8266 NodeMCU with Arduino IDE)</a>
Learn more about ESP32 with our resources:
<a href="https://randomnerdtutorials.com/learn-esp32-with-arduino-ide/">Learn ESP32 with Arduino IDE (eBook + video course)</a>
<a href="https://randomnerdtutorials.com/projects-esp32/">More ESP32 tutorials and projects</a>
Thanks for reading.
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/smart-home-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px-pupj8i6e7hlzpgwxe82jjd8skst9vmrjt9lpqb0v0g.jpg" title="Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px" alt="SMART HOME with Raspberry Pi ESP32 and ESP8266 Node-RED InfluxDB eBook" loading="lazy" width="117" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/smart-home-ebook/">SMART HOME with Raspberry Pi, ESP32, ESP8266 [eBook] </a></h4>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>ESP32/ESP8266: Control Outputs with Web Server and a Physical Button Simultaneously</h2>
This tutorial shows how to control the ESP32 or ESP8266 outputs using a web server and a physical button simultaneously. The output state is updated on the web page whether it is changed via physical button or web server.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-ESP8266-Control-Outputs-with-Web-Server-and-Physical-Button-Simultaneously.jpg">
<k>Recommended reading:</k> <a href="https://randomnerdtutorials.com/esp32-esp8266-input-data-html-form/">Input Data on HTML Form ESP32/ESP8266 Web Server</a>
The ESP32/ESP8266 boards will be programmed using Arduino IDE. So make sure you have these boards installed:
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, and Linux)</a>
<a href="https://randomnerdtutorials.com/how-to-install-esp8266-board-arduino-ide/">Installing ESP8266 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<h3>Project Overview</h3>
Let's take a quick look at how the project works.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-ESP8266-Web-Server-With-Physical-Button-Project-Overview.png">
The ESP32 or ESP8266 hosts a web server that allows you to control the state of an output;
The current output state is displayed on the web server; 
The ESP is also connected to a physical pushbutton that controls the same output;
If you change the output state using the physical puhsbutton, its current state is also updated on the web server.
In summary, this project allows you to control the same output using a web server and a push button simultaneously. Whenever the output state changes, the web server is updated.
<h3>Schematic Diagram</h3>
Before proceeding, you need to assemble a circuit with an LED and a pushbutton. We'll connect the LED to GPIO 2 and the pushbutton to GPIO 4.
<h3>Parts Required</h3>
Here's a list of the parts to you need to build the circuit:
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> (read <a href="https://makeradvisor.com/esp32-development-boards-review-comparison/" target="_blank">Best ESP32 Dev Boards</a>) or <a href="https://makeradvisor.com/tools/esp8266-esp-12e-nodemcu-wi-fi-development-board/" target="_blank">ESP8266</a>
<a href="https://makeradvisor.com/tools/3mm-5mm-leds-kit-storage-box/" target="_blank">5 mm LED</a>
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">330 Ohm resistor</a>
<a href="https://makeradvisor.com/tools/pushbuttons-kit/">Pushbutton</a>
<a href="https://makeradvisor.com/tools/resistors-kits/">10k Ohm resistor</a>
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a>
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="eager" fetchpriority="high" decoding="async"></a>
<h3>ESP32 Schematic</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-LED-Pushbutton.png">
<h3>ESP8266 NodeMCU Schematic</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP8266-LED-pushbutton_bb.png">
<h3>Installing Libraries  Async Web Server</h3>
To build the web server you need to install the following libraries:
<k>ESP32:</k> install the <a href="https://github.com/me-no-dev/ESPAsyncWebServer" target="_blank">ESPAsyncWebServer</a> and the <a href="https://github.com/me-no-dev/AsyncTCP" target="_blank">AsyncTCP</a> libraries.
<k>ESP8266:</k> install the <a href="https://github.com/me-no-dev/ESPAsyncWebServer" target="_blank">ESPAsyncWebServer</a> and the <a href="https://github.com/me-no-dev/ESPAsyncTCP" target="_blank">ESPAsyncTCP</a> libraries.
These libraries aren't available to install through the Arduino Library Manager, so you need to copy the library files to the Arduino Installation Libraries folder. Alternatively, in your Arduino IDE, you can go to <k>Sketch </k>> <k>Include Library</k> > <k>Add .zip Library</k> and select the libraries you've just downloaded.
<h3>ESP Web Server Code</h3>
Copy the following code to your Arduino IDE.
<k>/*********
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-esp8266-web-server-physical-button/
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*********/
// Import required libraries
#ifdef ESP32
  #include &lt;WiFi.h>
  #include &lt;AsyncTCP.h>
#else
  #include &lt;ESP8266WiFi.h>
  #include &lt;ESPAsyncTCP.h>
#endif
#include &lt;ESPAsyncWebServer.h>
// Replace with your network credentials
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
const char* PARAM_INPUT_1 = "state";
const int output = 2;
const int buttonPin = 4;
// Variables will change:
int ledState = LOW;          // the current state of the output pin
int buttonState;             // the current reading from the input pin
int lastButtonState = LOW;   // the previous reading from the input pin
// the following variables are unsigned longs because the time, measured in
// milliseconds, will quickly become a bigger number than can be stored in an int.
unsigned long lastDebounceTime = 0;  // the last time the output pin was toggled
unsigned long debounceDelay = 50;    // the debounce time; increase if the output flickers
// Create AsyncWebServer object on port 80
AsyncWebServer server(80);
const char index_html[] PROGMEM = R"rawliteral(
&lt;!DOCTYPE HTML>&lt;html>
&lt;head>
  &lt;title>ESP Web Server&lt;/title>
  &lt;meta name="viewport" content="width=device-width, initial-scale=1">
  &lt;style>
    html {font-family: Arial; display: inline-block; text-align: center;}
    h2 {font-size: 3.0rem;}
    p {font-size: 3.0rem;}
    body {max-width: 600px; margin:0px auto; padding-bottom: 25px;}
    .switch {position: relative; display: inline-block; width: 120px; height: 68px} 
    .switch input {display: none}
    .slider {position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; border-radius: 34px}
    .slider:before {position: absolute; content: ""; height: 52px; width: 52px; left: 8px; bottom: 8px; background-color: #fff; -webkit-transition: .4s; transition: .4s; border-radius: 68px}
    input:checked+.slider {background-color: #2196F3}
    input:checked+.slider:before {-webkit-transform: translateX(52px); -ms-transform: translateX(52px); transform: translateX(52px)}
  &lt;/style>
&lt;/head>
&lt;body>
  &lt;h2>ESP Web Server&lt;/h2>
  %BUTTONPLACEHOLDER%
&lt;script>function toggleCheckbox(element) {
  var xhr = new XMLHttpRequest();
  if(element.checked){ xhr.open("GET", "/update?state=1", true); }
  else { xhr.open("GET", "/update?state=0", true); }
  xhr.send();
}
setInterval(function ( ) {
  var xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
      var inputChecked;
      var outputStateM;
      if( this.responseText == 1){ 
        inputChecked = true;
        outputStateM = "On";
      }
      else { 
        inputChecked = false;
        outputStateM = "Off";
      }
      document.getElementById("output").checked = inputChecked;
      document.getElementById("outputState").innerHTML = outputStateM;
    }
  };
  xhttp.open("GET", "/state", true);
  xhttp.send();
}, 1000 ) ;
&lt;/script>
&lt;/body>
&lt;/html>
)rawliteral";
// Replaces placeholder with button section in your web page
String processor(const String& var){
  //Serial.println(var);
  if(var == "BUTTONPLACEHOLDER"){
    String buttons ="";
    String outputStateValue = outputState();
    buttons+= "&lt;h4>Output - GPIO 2 - State &lt;span id=\"outputState\">&lt;/span>&lt;/h4>&lt;label class=\"switch\">&lt;input type=\"checkbox\" onchange=\"toggleCheckbox(this)\" id=\"output\" " + outputStateValue + ">&lt;span class=\"slider\">&lt;/span>&lt;/label>";
    return buttons;
  }
  return String();
}
String outputState(){
  if(digitalRead(output)){
    return "checked";
  }
  else {
    return "";
  }
  return "";
}
void setup(){
  // Serial port for debugging purposes
  Serial.begin(115200);
  pinMode(output, OUTPUT);
  digitalWrite(output, LOW);
  pinMode(buttonPin, INPUT);
  
  // Connect to Wi-Fi
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi..");
  }
  // Print ESP Local IP Address
  Serial.println(WiFi.localIP());
  // Route for root / web page
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send_P(200, "text/html", index_html, processor);
  });
  // Send a GET request to &lt;ESP_IP>/update?state=&lt;inputMessage>
  server.on("/update", HTTP_GET, [] (AsyncWebServerRequest *request) {
    String inputMessage;
    String inputParam;
    // GET input1 value on &lt;ESP_IP>/update?state=&lt;inputMessage>
    if (request->hasParam(PARAM_INPUT_1)) {
      inputMessage = request->getParam(PARAM_INPUT_1)->value();
      inputParam = PARAM_INPUT_1;
      digitalWrite(output, inputMessage.toInt());
      ledState = !ledState;
    }
    else {
      inputMessage = "No message sent";
      inputParam = "none";
    }
    Serial.println(inputMessage);
    request->send(200, "text/plain", "OK");
  });
  // Send a GET request to &lt;ESP_IP>/state
  server.on("/state", HTTP_GET, [] (AsyncWebServerRequest *request) {
    request->send(200, "text/plain", String(digitalRead(output)).c_str());
  });
  // Start server
  server.begin();
}
  
void loop() {
  // read the state of the switch into a local variable:
  int reading = digitalRead(buttonPin);
  // check to see if you just pressed the button
  // (i.e. the input went from LOW to HIGH), and you've waited long enough
  // since the last press to ignore any noise:
  // If the switch changed, due to noise or pressing:
  if (reading != lastButtonState) {
    // reset the debouncing timer
    lastDebounceTime = millis();
  }
  if ((millis() - lastDebounceTime) > debounceDelay) {
    // whatever the reading is at, it's been there for longer than the debounce
    // delay, so take it as the actual current state:
    // if the button state has changed:
    if (reading != buttonState) {
      buttonState = reading;
      // only toggle the LED if the new button state is HIGH
      if (buttonState == HIGH) {
        ledState = !ledState;
      }
    }
  }
  // set the LED:
  digitalWrite(output, ledState);
  // save the reading. Next time through the loop, it'll be the lastButtonState:
  lastButtonState = reading;
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_Web_Server_Physical_Button.ino" target="_blank">View raw code</a>
You just need to enter your network credentials (SSID and password) and the web server will work straight away. The code is compatible with both the <a aria-label="ESP32 (opens in a new tab)" href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> and <a aria-label="ESP8266 (opens in a new tab)" href="https://makeradvisor.com/tools/esp8266-esp-12e-nodemcu-wi-fi-development-board/" target="_blank">ESP8266</a> boards and controls GPIO 2  you can change the code to control any other GPIO.
<h3>How the Code Works</h3>
We've already explained in great details how web servers like this work in previous tutorials (<a href="https://randomnerdtutorials.com/esp32-dht11-dht22-temperature-humidity-web-server-arduino-ide/">DHT Temperature Web Server</a>), so we'll just take a look at the relevant parts for this project.
<h3>Network Credentials</h3>
As said previously, you need to insert your network credentials in the following lines:
<k>const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h3>Button State and Output State</h3>
The ledState variable holds the LED output state. For default, when the web server starts, it is LOW.
<k>int ledState = LOW; // the current state of the output pin</k>
The buttonState and lastButtonState are used to detect whether the pushbutton was pressed or not.
<k>int buttonState;            // the current reading from the input pin
int lastButtonState = LOW;  // the previous reading from the input pin</k>
<h3>Button (web server)</h3>
We didn't include the HTML to create the button on the the index_html variable. That's because we want to be able to change it depending on the current LED state that can also be changed with the pushbutton.
So, we've create a placeholder for the button %BUTTONPLACEHOLDER% that will be replaced with HTML text to create the button later on the code (this is done in the processor() function).
<k>&lt;h2>ESP Web Server&lt;/h2>
%BUTTONPLACEHOLDER%</k>
<h3>processor()</h3>
The processor() function replaces any placeholders on the HTML text with actual values. First, it checks whether the HTML texts contains any placeholders %BUTTONPLACEHOLDER%.
<k>if(var == "BUTTONPLACEHOLDER"){</k>
Then, call the outputState() function that returns the current output state. We save it in the outputStateValue variable.
<k>String outputStateValue = outputState();</k>
After that, use that value to create the HTML text to display the button with the right state:
<k>buttons+= "&lt;h4>Output - GPIO 2 - State &lt;span id=\"outputState\">&lt;span>&lt;/h4>&lt;label class=\"switch\">&lt;input type=\"checkbox\" onchange=\"toggleCheckbox(this)\" id=\"output\" " + outputStateValue + ">&lt;span class=\"slider\">&lt;/span>&lt;/label>";</k>
<h3>HTTP GET Request to Change Output State (JavaScript)</h3>
When you press the button, the toggleCheckbox() function is called. This function will make a request on different URLs to turn the LED on or off.
<k>function toggleCheckbox(element) {
  var xhr = new XMLHttpRequest();
  if(element.checked){ xhr.open("GET", "/update?state=1", true); }
  else { xhr.open("GET", "/update?state=0", true); }
  xhr.send();
}</k>
To turn on the LED, it makes a request on the <em><k>/update?state=1</k></em> URL:
<k>if(element.checked){ xhr.open("GET", "/update?state=1", true); }</k>
Otherwise, it makes a request on the<k><em> /update?state=0</em></k> URL.
<h3>HTTP GET Request to Update State (JavaScript)</h3>
To keep the output state updated on the web server, we call the following function that makes a new request on the <k><em>/state</em></k> URL every second.
<k>setInterval(function ( ) {
  var xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
      var inputChecked;
      var outputStateM;
      if( this.responseText == 1){ 
        inputChecked = true;
        outputStateM = "On";
      }
      else { 
        inputChecked = false;
        outputStateM = "Off";
      }
      document.getElementById("output").checked = inputChecked;
      document.getElementById("outputState").innerHTML = outputStateM;
    }
  };
  xhttp.open("GET", "/state", true);
  xhttp.send();
}, 1000 ) ;</k>
<h3>Handle Requests</h3>
Then, we need to handle what happens when the ESP32 or ESP8266 receives requests on those URLs.
When a request is received on the root <k><em>/</em></k> URL, we send the HTML page as well as the processor.
<k>server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
  request->send_P(200, "text/html", index_html, processor);
});</k>
The following lines check whether you received a request on the <k><em>/update?state=1</em></k> or <k><em>/update?state=0</em></k> URL and changes the ledState accordingly.
<k>server.on("/update", HTTP_GET, [] (AsyncWebServerRequest *request) {
  String inputMessage;
  String inputParam;
  // GET input1 value on &lt;ESP_IP>/update?state=&lt;inputMessage>
  if (request->hasParam(PARAM_INPUT_1)) {
    inputMessage = request->getParam(PARAM_INPUT_1)->value();
    inputParam = PARAM_INPUT_1;
    digitalWrite(output, inputMessage.toInt());
    ledState = !ledState;
  }
  else {
    inputMessage = "No message sent";
    inputParam = "none";
  }
  Serial.println(inputMessage);
  request->send(200, "text/plain", "OK");
});</k>
When a request is received on the <k><em>/state</em></k> URL, we send the current output state:
<k>server.on("/state", HTTP_GET, [] (AsyncWebServerRequest *request) {
  request->send(200, "text/plain", String(digitalRead(output)).c_str());
});</k>
<h3>loop()</h3>
In the loop(), we debounce the pushbutton and turn the LED on or off depending on the value of the ledState variable.
<k>digitalWrite(output, ledState);</k>
<h3>Demonstration</h3>
Upload the code to your ESP32 or ESP8266 board. 
Then, open the Serial Monitor at a baud rate of 115200. Press the on-board EN/RST button to get is IP address.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-IP-Address.png">
Open a browser on your local network, and type the ESP IP address. You should have access to the web server as shown below.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/Output-web-server-ESP8266-ESP32-physical-button.png">
You can toggle the button on the web server to turn the LED on.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/Output-web-server-on-ESP8266-ESP32-physical-button.png">
You can also control the same LED with the physical pushbutton. Its state will always be updated automatically on the web server.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-Input-Output-Button-Pressed-LED-On-Arduino-IDE.jpg">Watch the next quick video for a live demonstration:

<h3>Wrapping Up</h3>
In this tutorial you've learned how to control ESP32/ESP8266 outputs with a web server and a physical button at the same time. The output state is always updated whether it is changed via web server or with the physical button.
Other projects you may like:
<a href="https://randomnerdtutorials.com/esp32-esp8266-web-server-outputs-momentary-switch/">ESP32/ESP8266 Web Server: Control Outputs with Momentary Switch</a>
<a href="https://randomnerdtutorials.com/display-images-esp32-esp8266-web-server/">Display Images in ESP32 and ESP8266 Web Server</a>
<a href="https://randomnerdtutorials.com/esp32-esp8266-input-data-html-form/">Input Data on HTML Form ESP32/ESP8266 Web Server</a>
<a style="font-size: inherit; background-color: initial;" href="https://randomnerdtutorials.com/esp32-web-server-spiffs-spi-flash-file-system/">ESP32 Web Server using SPIFFS (SPI Flash File System)</a>
Learn more about the ESP32 and ESP8266 with our resources:
<a href="https://randomnerdtutorials.com/learn-esp32-with-arduino-ide/">Learn ESP32 using Arduino IDE</a>
<a href="https://randomnerdtutorials.com/home-automation-using-esp8266/">Home Automation using ESP8266</a>
<a href="https://randomnerdtutorials.com/projects-esp32/">More ESP32 tutorials </a>
<a href="https://randomnerdtutorials.com/projects-esp8266/">More ESP8266 tutorials </a>
Thanks for reading.
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/smart-home-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px-pupj8i6e7hlzpgwxe82jjd8skst9vmrjt9lpqb0v0g.jpg" title="Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px" alt="SMART HOME with Raspberry Pi ESP32 and ESP8266 Node-RED InfluxDB eBook" loading="lazy" width="117" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/smart-home-ebook/">SMART HOME with Raspberry Pi, ESP32, ESP8266 [eBook] </a></h4>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>ESP32/ESP8266 Web Server: Control Outputs with Momentary Switch</h2>
This tutorial shows how to create a web server with a button that acts as momentary switch to remotely control ESP32 or ESP8266 outputs. The output state is HIGH as long as you keep holding the button in your web page. Once you release it, it changes to LOW. As an example, we'll control an LED, but you can control any other output.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-ESP8266-Web-Server-Control-Outpus-with-Momentary-Switch-Arduino-IDE.jpg">
The ESP32/ESP8266 boards will be programmed using Arduino IDE. So make sure you have these boards installed:
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing ESP32 Board in Arduino IDE (Windows, Mac OS X, and Linux)</a>
<a href="https://randomnerdtutorials.com/how-to-install-esp8266-board-arduino-ide/">Installing ESP8266 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<h3>Project Overview</h3>
The following diagram shows a simple overview of the project we'll build.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/Momentary-switch-web-server-esp32-esp8266-project-overview.png">
The ESP32 or ESP8266 hosts a web server that you can access to control an output;
The output's default state is LOW, but you can change it depending on your project application;
There's a button that acts like a momentary switch:
if you press the button, the output changes its state to HIGH as long as you keep holding the button;
once the button is released, the output state goes back to LOW.
<h3>Installing Libraries  Async Web Server</h3>
To build the web server you need to install the following libraries:
<k>ESP32:</k> install the <a href="https://github.com/me-no-dev/ESPAsyncWebServer" target="_blank">ESPAsyncWebServer</a> and the <a href="https://github.com/me-no-dev/AsyncTCP" target="_blank">AsyncTCP</a> libraries.
<k>ESP8266:</k> install the <a href="https://github.com/me-no-dev/ESPAsyncWebServer" target="_blank">ESPAsyncWebServer</a> and the <a href="https://github.com/me-no-dev/ESPAsyncTCP" target="_blank">ESPAsyncTCP</a> libraries.
These libraries aren't available to install through the Arduino Library Manager, so you need to copy the library files to the Arduino Installation Libraries folder. Alternatively, in your Arduino IDE, you can go to <k>Sketch </k>> <k>Include Library</k> > <k>Add .zip Library</k> and select the libraries you've just downloaded.
<h3>Code</h3>
Copy the following code to your Arduino IDE.
<k>/*********
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-esp8266-web-server-outputs-momentary-switch/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*********/
#ifdef ESP32
  #include &lt;WiFi.h>
  #include &lt;AsyncTCP.h>
#else
  #include &lt;ESP8266WiFi.h>
  #include &lt;ESPAsyncTCP.h>
#endif
#include &lt;ESPAsyncWebServer.h>
// REPLACE WITH YOUR NETWORK CREDENTIALS
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
const int output = 2;
// HTML web page
const char index_html[] PROGMEM = R"rawliteral(
&lt;!DOCTYPE HTML>&lt;html>
  &lt;head>
    &lt;title>ESP Pushbutton Web Server&lt;/title>
    &lt;meta name="viewport" content="width=device-width, initial-scale=1">
    &lt;style>
      body { font-family: Arial; text-align: center; margin:0px auto; padding-top: 30px;}
      .button {
        padding: 10px 20px;
        font-size: 24px;
        text-align: center;
        outline: none;
        color: #fff;
        background-color: #2f4468;
        border: none;
        border-radius: 5px;
        box-shadow: 0 6px #999;
        cursor: pointer;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        -webkit-tap-highlight-color: rgba(0,0,0,0);
      }  
      .button:hover {background-color: #1f2e45}
      .button:active {
        background-color: #1f2e45;
        box-shadow: 0 4px #666;
        transform: translateY(2px);
      }
    &lt;/style>
  &lt;/head>
  &lt;body>
    &lt;h1>ESP Pushbutton Web Server&lt;/h2>
    &lt;button onmousedown="toggleCheckbox('on');" ontouchstart="toggleCheckbox('on');" onmouseup="toggleCheckbox('off');" ontouchend="toggleCheckbox('off');">LED PUSHBUTTON&lt;/button>
   &lt;script>
   function toggleCheckbox(x) {
     var xhr = new XMLHttpRequest();
     xhr.open("GET", "/" + x, true);
     xhr.send();
   }
  &lt;/script>
  &lt;/body>
&lt;/html>)rawliteral";
void notFound(AsyncWebServerRequest *request) {
  request->send(404, "text/plain", "Not found");
}
AsyncWebServer server(80);
void setup() {
  Serial.begin(115200);
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  if (WiFi.waitForConnectResult() != WL_CONNECTED) {
    Serial.println("WiFi Failed!");
    return;
  }
  Serial.println();
  Serial.print("ESP IP Address: http://");
  Serial.println(WiFi.localIP());
  
  pinMode(output, OUTPUT);
  digitalWrite(output, LOW);
  
  // Send web page to client
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send_P(200, "text/html", index_html);
  });
  // Receive an HTTP GET request
  server.on("/on", HTTP_GET, [] (AsyncWebServerRequest *request) {
    digitalWrite(output, HIGH);
    request->send(200, "text/plain", "ok");
  });
  // Receive an HTTP GET request
  server.on("/off", HTTP_GET, [] (AsyncWebServerRequest *request) {
    digitalWrite(output, LOW);
    request->send(200, "text/plain", "ok");
  });
  
  server.onNotFound(notFound);
  server.begin();
}
void loop() {
 
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_Web_Server_Momentary_Switch.ino" target="_blank">View raw code</a>
You just need to enter your network credentials (SSID and password) and the web server will work straight away. The code is compatible with both the <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank" aria-label="ESP32 (opens in a new tab)">ESP32</a> and <a href="https://makeradvisor.com/tools/esp8266-esp-12e-nodemcu-wi-fi-development-board/" target="_blank" aria-label="ESP8266 (opens in a new tab)">ESP8266</a> boards and controls the on-board LED GPIO 2  you can change the code to control any other GPIO.
<h3>How the Code Works</h3>
We've already explained in great details how web servers like this work in previous tutorials (<a href="https://randomnerdtutorials.com/esp32-dht11-dht22-temperature-humidity-web-server-arduino-ide/">DHT Temperature Web Server</a>), so we'll just take a look at the relevant parts for this project.
<h3>Network Credentials</h3>
As said previously, you need to insert your network credentials in the following lines:
<k>const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h3>Momentary Switch Button (web server)</h3>
The following line creates the momentary switch button.
<k>&lt;button onmousedown="toggleCheckbox('on');" ontouchstart="toggleCheckbox('on');" onmouseup="toggleCheckbox('off');" ontouchend="toggleCheckbox('off');">LED PUSHBUTTON&lt;/button></k>
Let's break this down into small parts.
In HTML, to create a button, use the &lt;button>&lt;/button> tags. In between you write the button text. For example:
<k>&lt;button>LED PUSHBUTTON&lt;/button></k>
The button can have several attributes. In HTML, the attributes provide additional information about HTML elements, in this case, about the button.
Here, we have the following attributes:
<k>class:</k> provides a class name for the button. This way, it can be used by CSS or JavaScript to perform certain tasks for the button. In this case, it is used to format the button using CSS. The class attribute has the name button, but you could have called it any other name.
<k>&lt;button>LED PUSHBUTTON&lt;/button></k>
<k>onmousedown:</k> this is an event attribute. It executes a JavaScript function when you press the button. In this case it calls toggleCheckbox(on'). This function makes a request to the ESP32/ESP8266 on a specific URL, so that it knows it needs to change the output state to HIGH. 
<k>ontouchstart:</k> this is an event attribute similar to the previous one, but it works for devices with a touch screen like a smartphone or table. It calls the same JavaScript function to change the output state to HIGH.
<k>onmouseup:</k> this is an event attribute that executes a JavaScript function when you release the mouse over the button. In this case, it calls toggleCheckbox(off'). This function makes a request to the ESP32/ESP8266 on a specific URL, so that it knows it needs to change the output state to LOW.
<k>ontouchend:</k> similar to the previous attribute but for devices with touchscreen.
So, in the end, our button looks like this:
<k>&lt;button onmousedown="toggleCheckbox('on');" ontouchstart="toggleCheckbox('on');" onmouseup="toggleCheckbox('off');" ontouchend="toggleCheckbox('off');">LED PUSHBUTTON&lt;/button></k>
<h3>HTTP GET Request to Change Button State (JavaScript)</h3>
We've seen previously, that when you press or release the button, the toggleCheckbox() function is called. You either pass the on or off arguments, depending on the state you want.
That function, makes an HTTP request to the ESP32 either on the <em><k>/on</k></em> or <k><em>/off</em></k> URLs:
<k>function toggleCheckbox(x) {
  var xhr = new XMLHttpRequest();
  xhr.open("GET", "/" + x, true);
  xhr.send();
}</k>
<h3>Handle Requests</h3>
Then, we need to handle what happens when the ESP32 or ESP8266 receives requests on those URLs.
When a request is received on the <k><em>/on</em></k> URL, we turn the GPIO on (HIGH) as shown below:
<k>server.on("/on", HTTP_GET, [] (AsyncWebServerRequest *request) {
  digitalWrite(output, HIGH);
  request->send(200, "text/plain", "ok");
});</k>
When a request is received on the <k><em>/off</em></k> URL, we turn the GPIO off (LOW):
<k>server.on("/off", HTTP_GET, [] (AsyncWebServerRequest *request) {
  digitalWrite(output, LOW);
  request->send(200, "text/plain", "ok");
});</k>
<h3>Demonstration</h3>
Upload the code to your ESP32 or ESP8266 board. 
Then, open the Serial Monitor at a baud rate of 115200. Press the on-board EN/RST button to get is IP address.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-IP-Address-Serial-Monitor.png">
Open a browser on your local network, and type the ESP IP address. You should have access to the web server as shown below.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/Momentary-switch-web-server-esp32-esp8266.png">
The on-board LED stays on as long as you keep holding down the button on the web page.
<k>Note: </k> it works the other way around for the ESP8266 because the on-board LED works with inverted logic.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-board-Built_in-LED-turned-on-HIGH.jpg">
When you release the button, the LED goes back to its default state (LOW).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-board-Built_in-LED-turned-off-LOW.jpg">
Watch the next quick video for a live demonstration:

<h3>Wrapping Up</h3>
In this tutorial you've learned how to add event attributes to the buttons on your web server to make them act as momentary switches. This allows you to change the default's output state as long as you're pressing the button.
Other projects you may like:
<a href="https://randomnerdtutorials.com/display-images-esp32-esp8266-web-server/">Display Images in ESP32 and ESP8266 Web Server</a>
<a href="https://randomnerdtutorials.com/esp32-esp8266-input-data-html-form/">Input Data on HTML Form ESP32/ESP8266 Web Server</a>
<a href="https://randomnerdtutorials.com/esp32-esp8266-thermostat-web-server/">ESP32/ESP8266 Thermostat Web Server  Control Output Based on Temperature</a>
<a href="https://randomnerdtutorials.com/esp32-esp8266-web-server-physical-button/">ESP32/ESP8266: Control Outputs with Web Server and a Physical Button Simultaneously</a>
<a href="https://randomnerdtutorials.com/esp32-web-server-spiffs-spi-flash-file-system/">ESP32 Web Server using SPIFFS (SPI Flash File System)</a>
Learn more about the ESP32 and ESP8266 with our resources:
<a href="https://randomnerdtutorials.com/learn-esp32-with-arduino-ide/">Learn ESP32 using Arduino IDE</a>
<a href="https://randomnerdtutorials.com/home-automation-using-esp8266/">Home Automation using ESP8266</a>
<a href="https://randomnerdtutorials.com/micropython-programming-with-esp32-and-esp8266/">MicroPython Programming using ESP32/ESP8266</a>
<a href="https://randomnerdtutorials.com/projects-esp32/">More ESP32 tutorials </a>
<a href="https://randomnerdtutorials.com/projects-esp8266/">More ESP8266 tutorials </a>
Thanks for reading.
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/smart-home-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px-pupj8i6e7hlzpgwxe82jjd8skst9vmrjt9lpqb0v0g.jpg" title="Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px" alt="SMART HOME with Raspberry Pi ESP32 and ESP8266 Node-RED InfluxDB eBook" loading="lazy" width="117" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/smart-home-ebook/">SMART HOME with Raspberry Pi, ESP32, ESP8266 [eBook] </a></h4>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>ESP-NOW with ESP32: Send Data to Multiple Boards (one-to-many)</h2>
In this tutorial, you'll learn how to use ESP-NOW communication protocol to send data from one ESP32 to multiple ESP32 or ESP8266 boards (one-to-many configuration). The boards will be programmed using Arduino IDE.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP-NOW-ESP32-ESP8266-NodeMCU-Send-Data-Multiple-Boards-Arduino-IDE.jpg">
To get started with ESP-NOW on the ESP32 or ESP8266, read the following ESP-NOW guides first:
<a href="https://randomnerdtutorials.com/esp-now-esp32-arduino-ide/">Getting Started with ESP-NOW (ESP32 with Arduino IDE)</a>
<a href="https://randomnerdtutorials.com/esp-now-esp8266-nodemcu-arduino-ide/">Getting Started with ESP-NOW (ESP8266 NodeMCU with Arduino IDE)</a>
<a href="https://randomnerdtutorials.com/esp-now-many-to-one-esp32/">ESP-NOW with ESP32: Receive Data from Multiple Boards (many-to-one)</a>
<h3>Project Overview</h3>
This tutorial shows how to send data from one ESP32 to multiple ESP32 or ESP8266 boards using ESP-NOW (one-to-many configuration).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP-NOW-ESP32-one-to-many-configuration-project-overview.png">
One ESP32 acts as a sender; 
Multiple ESP32 or ESP8266 boards act as receivers. We tested this setup with two ESP32 boards and one ESP8266 board simultaneously. You should be able to add more boards to your setup; 
The ESP32 sender receives an acknowledge message if the messages are successfully delivered. You know which boards received the message and which boards didn't; 
You need to upload a slightly different receiver code depending if you're using an ESP32 or ESP8266;
As an example, we'll exchange random values between the boards. You should modify this example to send commands or sensor readings (<a href="https://randomnerdtutorials.com/esp-now-two-way-communication-esp32/">exchange sensor readings using ESP-NOW</a>).
This tutorial covers these two scenarios: 
sending the same message to all boards;
sending a different message to each board.
You may also like reading: <a href="https://randomnerdtutorials.com/esp-now-two-way-communication-esp32/">ESP-NOW Two-Way Communication Between ESP32 Boards</a>.
<h3>Prerequisites</h3>
We'll program the ESP32/ESP8266 boards using Arduino IDE, so before proceeding with this tutorial, make sure you have these boards installed in your Arduino IDE.
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing ESP32 Board in Arduino IDE (Windows, Mac OS X, and Linux)</a>
<a href="https://randomnerdtutorials.com/how-to-install-esp8266-board-arduino-ide/">Installing ESP8266 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<h3>Parts Required</h3>
To follow this tutorial, you need multiple ESP32 boards and/or ESP8266 boards.
<a aria-label="ESP32 (opens in a new tab)" href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> (read <a href="https://makeradvisor.com/esp32-development-boards-review-comparison/" target="_blank">Best ESP32 development boards</a>)
<a href="https://makeradvisor.com/tools/esp8266-esp-12e-nodemcu-wi-fi-development-board/" target="_blank">ESP8266</a> (read <a href="https://makeradvisor.com/best-esp8266-wi-fi-development-board/" target="_blank">Best ESP8266 development boards</a>) 
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="eager" fetchpriority="high" decoding="async"></a>
<h3>Getting the Boards MAC Address</h3>
To send messages via ESP-NOW, you need to know the receiver boards' <a href="https://randomnerdtutorials.com/get-change-esp32-esp8266-mac-address-arduino/">MAC address</a>. Each board has a unique MAC address (learn how to <a href="https://randomnerdtutorials.com/get-change-esp32-esp8266-mac-address-arduino/">Get and Change the ESP32 MAC Address</a>).
Upload the following code to each of your receiver boards to get its MAC address.
<k>// Complete Instructions to Get and Change ESP MAC Address: https://RandomNerdTutorials.com/get-change-esp32-esp8266-mac-address-arduino/
#ifdef ESP32
  #include &lt;WiFi.h>
#else
  #include &lt;ESP8266WiFi.h>
#endif
void setup(){
  Serial.begin(115200);
  Serial.println();
  Serial.print("ESP Board MAC Address:  ");
  Serial.println(WiFi.macAddress());
}
 
void loop(){
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_Get_MAC_Address.ino" target="_blank">View raw code</a>
After uploading the code, press the RST/EN button, and the MAC address should be displayed on the Serial Monitor.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP32_MAC_Address_Serial_monitor.jpg">
You can write down the boards' MAC address on a label to clearly identify each board.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/Getting-the-ESP32-Board-MAC-Address-Arduino-IDE.jpg">
<h3>ESP32 Sender Code (ESP-NOW) </h3>
The following code sends data to multiple (three) ESP boards via ESP-NOW. You should modify the code with your receiver boards' MAC address. You should also add or delete lines of code depending on the number of receiver boards.
<k>/*********
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp-now-one-to-many-esp32-esp8266/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*********/
#include &lt;esp_now.h>
#include &lt;WiFi.h>
// REPLACE WITH YOUR ESP RECEIVER'S MAC ADDRESS
uint8_t broadcastAddress1[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
uint8_t broadcastAddress2[] = {0xFF, , , , , };
uint8_t broadcastAddress3[] = {0xFF, , , , , };
typedef struct test_struct {
  int x;
  int y;
} test_struct;
test_struct test;
esp_now_peer_info_t peerInfo;
// callback when data is sent
void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
  char macStr[18];
  Serial.print("Packet to: ");
  // Copies the sender mac address to a string
  snprintf(macStr, sizeof(macStr), "%02x:%02x:%02x:%02x:%02x:%02x",
           mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5]);
  Serial.print(macStr);
  Serial.print(" send status:\t");
  Serial.println(status == ESP_NOW_SEND_SUCCESS ? "Delivery Success" : "Delivery Fail");
}
 
void setup() {
  Serial.begin(115200);
 
  WiFi.mode(WIFI_STA);
 
  if (esp_now_init() != ESP_OK) {
    Serial.println("Error initializing ESP-NOW");
    return;
  }
  
  esp_now_register_send_cb(OnDataSent);
   
  // register peer
  peerInfo.channel = 0;  
  peerInfo.encrypt = false;
  // register first peer  
  memcpy(peerInfo.peer_addr, broadcastAddress1, 6);
  if (esp_now_add_peer(&peerInfo) != ESP_OK){
    Serial.println("Failed to add peer");
    return;
  }
  // register second peer  
  memcpy(peerInfo.peer_addr, broadcastAddress2, 6);
  if (esp_now_add_peer(&peerInfo) != ESP_OK){
    Serial.println("Failed to add peer");
    return;
  }
  /// register third peer
  memcpy(peerInfo.peer_addr, broadcastAddress3, 6);
  if (esp_now_add_peer(&peerInfo) != ESP_OK){
    Serial.println("Failed to add peer");
    return;
  }
}
 
void loop() {
  test.x = random(0,20);
  test.y = random(0,20);
 
  esp_err_t result = esp_now_send(0, (uint8_t *) &test, sizeof(test_struct));
   
  if (result == ESP_OK) {
    Serial.println("Sent with success");
  }
  else {
    Serial.println("Error sending the data");
  }
  delay(2000);
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_NOW/ESP_NOW_Sender_Multiple_Boards_Same_Messages.ino" target="_blank">View raw code</a>
<h3>How the code works</h3>
First, include the esp_now.h and WiFi.h libraries.
<k>#include &lt;esp_now.h>
#include &lt;WiFi.h></k>
<h4>Receivers' MAC Address</h4>
Insert the receivers' MAC address. In our example, we're sending data to three boards.
<k>uint8_t broadcastAddress1[] = {0x3C, 0x71, 0xBF, 0xC3, 0xBF, 0xB0};
uint8_t broadcastAddress2[] = {0x24, 0x0A, 0xC4, 0xAE, 0xAE, 0x44};
uint8_t broadcastAddress3[] = {0x80, 0x7D, 0x3A, 0x58, 0xB4, 0xB0};</k>
Then, create a structure that contains the data we want to send. We called this structure test_struct and it contains two integer variables. You can change this to send whatever variable types you want.
<k>typedef struct test_struct {
  int x;
  int y;
} test_struct;</k>
Create a new variable of type test_struct that is called test that will store the variables' values.
<k>test_struct test;</k>
Create a variable of type esp_now_peer_info_t to store information about the peer.
<k>esp_now_peer_info_t peerInfo;</k>
<h4>OnDataSent() callback function </h4>
Next, define the OnDataSent() function. This is a callback function that will be executed when a message is sent. In this case, this function prints if the message was successfully delivered or not and for which MAC address. So, you know which boards received the message or and which boards didn't.
<k>void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
  char macStr[18];
  Serial.print("Packet from: ");
  // Copies the sender mac address to a string
  snprintf(macStr, sizeof(macStr), "%02x:%02x:%02x:%02x:%02x:%02x",
           mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5]);
  Serial.print(macStr);
  Serial.print(" send status:\t");
  Serial.println(status == ESP_NOW_SEND_SUCCESS ? "Delivery Success" : "Delivery Fail");
}</k>
<h4>setup()</h4>
In the setup(), initialize the serial monitor for debugging purposes:
<k>Serial.begin(115200);</k>
Set the device as a Wi-Fi station:
<k>WiFi.mode(WIFI_STA);</k>
Initialize ESP-NOW:
<k>if (esp_now_init() != ESP_OK) {
  Serial.println("Error initializing ESP-NOW");
  return;
}</k>
After successfully initializing ESP-NOW, register the callback function that will be called when a message is sent. In this case, register for the OnDataSent() function created previously.
<k>esp_now_register_send_cb(OnDataSent);</k>
<h4>Add peers</h4>
After that, we need to pair with other ESP-NOW devices to send data. That's what we do in the next lines  register peers:
<k>// register peer
peerInfo.channel = 0;
peerInfo.encrypt = false;
// register first peer
memcpy(peerInfo.peer_addr, broadcastAddress1, 6);
if (esp_now_add_peer(&peerInfo) != ESP_OK){
  Serial.println("Failed to add peer");
  return;
}
// register second peer
memcpy(peerInfo.peer_addr, broadcastAddress2, 6);
if (esp_now_add_peer(&peerInfo) != ESP_OK){
  Serial.println("Failed to add peer");
  return;
}
/// register third peer
memcpy(peerInfo.peer_addr, broadcastAddress3, 6);
if (esp_now_add_peer(&peerInfo) != ESP_OK){
  Serial.println("Failed to add peer");
  return;
}</k>
If you want to add more peers you just need to duplicate these lines and pass the peer MAC address:
<k>memcpy(peerInfo.peer_addr, broadcastAddress, 6);
if (esp_now_add_peer(&peerInfo) != ESP_OK){
  Serial.println("Failed to add peer");
  return;
}</k>
<h4>loop()</h4>
In the loop(), we'll send a message via ESP-NOW every 2 seconds (you can change this delay time).
Assign a value to each variable:
<k>test.x = random(0,20);
test.y = random(0,20);</k>
Remember that test is a structure. Here assign the values that you want to send inside the structure. In this case, we're just sending random values. In a practical application these should be replaced with commands or sensor readings, for example.
<h4>Send the same data to multiple boards</h4>
Finally, send the message as follows:
<k>esp_err_t result = esp_now_send(0, (uint8_t *) &test, sizeof(test_struct));</k>
The first argument of the esp_now_send() function is the receiver's MAC address. If you pass 0 as an argument, it will send the same message to <k>all registered peers</k>. If you want to send a different message to each peer, follow the next section.
Check if the message was successfully sent:
<k>if (result == ESP_OK) {
  Serial.println("Sent with success");
}
else {
  Serial.println("Error sending the data");
}</k>
The loop() is executed every 2000 milliseconds (2 seconds).
<k>delay(2000);</k>
<h4>Send different data to each board</h4>
The code to send a different message to each board is very similar tothe previous one. So, we'll just take a look at the differences.
If you want to send a different message to each board, you need to create a data structure for each of your boards, for example:
<k>test_struct test;
test_struct test2;
test_struct test3;</k>
In this case, we're sending the same structure type (test_struct). You can send a different structure type as long as the receiver code is prepared to receive that type of structure.
Then, assign different values to the variables of each structure. In this example, we're just setting them to random numbers.
<k>test.x = random(0,20);
test.y = random(0,20);
test2.x = random(0,20);
test2.y = random(0,20);
test3.x = random(0,20);
test3.y = random(0,20);</k>
Finally, you need to call the esp_now_send() function for each receiver.
For example, send the test structure to the board whose MAC address is broadcastAddress1.
<k>esp_err_t result1 = esp_now_send(
  broadcastAddress1, 
  (uint8_t *) &test,
  sizeof(test_struct));
   
if (result1 == ESP_OK) {
  Serial.println("Sent with success");
}
else {
  Serial.println("Error sending the data");
}</k>
Do the same for the other boards. For the second board send the test2 structure:
<k>esp_err_t result2 = esp_now_send(
  broadcastAddress2, 
  (uint8_t *) &test2,
  sizeof(test_struct));
if (result2 == ESP_OK) {
  Serial.println("Sent with success");
}
else {
  Serial.println("Error sending the data");
}</k>
And finally, for the third board, send the test3 structure:
<k>esp_err_t result3 = esp_now_send(
  broadcastAddress3, 
  (uint8_t *) &test3,
  sizeof(test_struct));
if (result3 == ESP_OK) {
  Serial.println("Sent with success");
}
else {
  Serial.println("Error sending the data");
}</k>
Here's the complete code that sends a different message to each board.
<k>/*********
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp-now-one-to-many-esp32-esp8266/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*********/
#include &lt;esp_now.h>
#include &lt;WiFi.h>
// REPLACE WITH YOUR ESP RECEIVER'S MAC ADDRESS
uint8_t broadcastAddress1[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
uint8_t broadcastAddress2[] = {0xFF, , , , , };
uint8_t broadcastAddress3[] = {0xFF, , , , , };
typedef struct test_struct {
  int x;
  int y;
} test_struct;
void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
  char macStr[18];
  Serial.print("Packet to: ");
  // Copies the sender mac address to a string
  snprintf(macStr, sizeof(macStr), "%02x:%02x:%02x:%02x:%02x:%02x",
           mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5]);
  Serial.print(macStr);
  Serial.print(" send status:\t");
  Serial.println(status == ESP_NOW_SEND_SUCCESS ? "Delivery Success" : "Delivery Fail");
}
 
void setup() {
 
  Serial.begin(115200);
 
  WiFi.mode(WIFI_STA);
 
  if (esp_now_init() != ESP_OK) {
    Serial.println("Error initializing ESP-NOW");
    return;
  }
  esp_now_register_send_cb(OnDataSent);
  // register peer
  esp_now_peer_info_t peerInfo;
  peerInfo.channel = 0;  
  peerInfo.encrypt = false;
    
  memcpy(peerInfo.peer_addr, broadcastAddress1, 6);
  if (esp_now_add_peer(&peerInfo) != ESP_OK){
    Serial.println("Failed to add peer");
    return;
  }
  
  memcpy(peerInfo.peer_addr, broadcastAddress2, 6);
  if (esp_now_add_peer(&peerInfo) != ESP_OK){
    Serial.println("Failed to add peer");
    return;
  }
  memcpy(peerInfo.peer_addr, broadcastAddress3, 6);
  if (esp_now_add_peer(&peerInfo) != ESP_OK){
    Serial.println("Failed to add peer");
    return;
  }
}
 
void loop() {
  test_struct test;
  test_struct test2;
  test_struct test3;
  test.x = random(0,20);
  test.y = random(0,20);
  test2.x = random(0,20);
  test2.y = random(0,20);
  test3.x = random(0,20);
  test3.y = random(0,20);
 
  esp_err_t result1 = esp_now_send(
    broadcastAddress1, 
    (uint8_t *) &test,
    sizeof(test_struct));
   
  if (result1 == ESP_OK) {
    Serial.println("Sent with success");
  }
  else {
    Serial.println("Error sending the data");
  }
  delay(500);
  esp_err_t result2 = esp_now_send(
    broadcastAddress2, 
    (uint8_t *) &test2,
    sizeof(test_struct));
  if (result2 == ESP_OK) {
    Serial.println("Sent with success");
  }
  else {
    Serial.println("Error sending the data");
  }
  
  delay(500);  
  esp_err_t result3 = esp_now_send(
    broadcastAddress3, 
    (uint8_t *) &test3,
    sizeof(test_struct));
   
  if (result3 == ESP_OK) {
    Serial.println("Sent with success");
  }
  else {
    Serial.println("Error sending the data");
  }
  delay(2000);
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_NOW/ESP_NOW_Sender_Multiple_Boards_Different_Messages.ino" target="_blank">View raw code</a>
<h3>ESP32 Receiver Code (ESP-NOW) </h3>
Upload the next code to the receiver boards (in our example, we've used three receiver boards).
<k>/*********
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp-now-one-to-many-esp32-esp8266/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*********/
#include &lt;esp_now.h>
#include &lt;WiFi.h>
//Structure example to receive data
//Must match the sender structure
typedef struct test_struct {
  int x;
  int y;
} test_struct;
//Create a struct_message called myData
test_struct myData;
//callback function that will be executed when data is received
void OnDataRecv(const uint8_t * mac, const uint8_t *incomingData, int len) {
  memcpy(&myData, incomingData, sizeof(myData));
  Serial.print("Bytes received: ");
  Serial.println(len);
  Serial.print("x: ");
  Serial.println(myData.x);
  Serial.print("y: ");
  Serial.println(myData.y);
  Serial.println();
}
 
void setup() {
  //Initialize Serial Monitor
  Serial.begin(115200);
  
  //Set device as a Wi-Fi Station
  WiFi.mode(WIFI_STA);
  //Init ESP-NOW
  if (esp_now_init() != ESP_OK) {
    Serial.println("Error initializing ESP-NOW");
    return;
  }
  
  // Once ESPNow is successfully Init, we will register for recv CB to
  // get recv packer info
  esp_now_register_recv_cb(OnDataRecv);
}
 
void loop() {
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_NOW/ESP_NOW_Receiver_ESP32.ino" target="_blank">View raw code</a>
<h3>How the code works</h3>
Similarly to the sender, start by including the libraries:
<k>#include &lt;esp_now.h>
#include &lt;WiFi.h></k>
Create a structure to receive the data. This structure should be the same defined in the sender sketch.
<k>typedef struct test_struct {
  int x;
  int y;
} test_struct;</k>
Create a test_struct variable called myData.
<k>test_struct myData;</k>
Create a callback function that is called when the ESP32 receives the data via ESP-NOW. The function is called onDataRecv() and should accept several parameters as follows:
<k>void OnDataRecv(const uint8_t * mac, const uint8_t *incomingData, int len) {</k>
Copy the content of the incomingData data variable into the myData variable.
<k>memcpy(&myData, incomingData, sizeof(myData));</k>
Now, the myData structure contains several variables inside with the values sent by the sender ESP32. To access variable x, for example, call myData.x.
In this example, we print the received data, but in a practical application you can print the data on an <a href="https://randomnerdtutorials.com/esp32-ssd1306-oled-display-arduino-ide/">OLED display</a>, for example.
<k>Serial.print("Bytes received: ");
Serial.println(len);
Serial.print("x: ");
Serial.println(myData.x);
Serial.print("y: ");
Serial.println(myData.y);
Serial.println();</k>
In the setup(), intialize the Serial Monitor.
<k>Serial.begin(115200);</k>
Set the device as a Wi-Fi Station.
<k>WiFi.mode(WIFI_STA);</k>
Initialize ESP-NOW:
<k>if (esp_now_init() != ESP_OK) {
  Serial.println("Error initializing ESP-NOW");
  return;
}</k>
Register for a callback function that will be called when data is received. In this case, we register for the OnDataRecv() function that was created previously.
<k>esp_now_register_recv_cb(OnDataRecv);</k>
<h3>ESP8266 Receiver Code (ESP-NOW)</h3>
If you're using an ESP8266 board as a receiver, upload the following code instead.
<k>/*********
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp-now-one-to-many-esp32-esp8266/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*********/
#include &lt;ESP8266WiFi.h>
#include &lt;espnow.h>
//Structure example to receive data
//Must match the sender structure
typedef struct test_struct {
  int x;
  int y;
} test_struct;
//Create a struct_message called myData
test_struct myData;
//callback function that will be executed when data is received
void OnDataRecv(uint8_t * mac, uint8_t *incomingData, uint8_t len) {
  memcpy(&myData, incomingData, sizeof(myData));
  Serial.print("Bytes received: ");
  Serial.println(len);
  Serial.print("x: ");
  Serial.println(myData.x);
  Serial.print("y: ");
  Serial.println(myData.y);
  Serial.println();
}
 
void setup() {
  //Initialize Serial Monitor
  Serial.begin(115200);
  
  //Set device as a Wi-Fi Station
  WiFi.mode(WIFI_STA);
  //Init ESP-NOW
  if (esp_now_init() != 0) {
    Serial.println("Error initializing ESP-NOW");
    return;
  }
  
  // Once ESPNow is successfully Init, we will register for recv CB to
  // get recv packer info
  esp_now_set_self_role(ESP_NOW_ROLE_SLAVE);
  esp_now_register_recv_cb(OnDataRecv);
}
 
void loop() {
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_NOW/ESP_NOW_Receiver_ESP8266.ino" target="_blank">View raw code</a>
Apart from small details, this code is very similar tothe ESP32 receiver code. So, we won't explain how it works. To learn more you can read our <a href="https://randomnerdtutorials.com/esp-now-esp8266-nodemcu-arduino-ide/">ESP-NOW Getting Started Guide with ESP8266 NodeMCU</a>.
<h3>Demonstration</h3>
Having all your boards powered on, open the Arduino IDE Serial Monitor for the COM port the sender is connected to.
You should start receiving <k>Delivery Success</k> messages with the corresponding receiver's MAC address in the Serial Monitor. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-ESP-NOW-Send-Data-To-Multiple-Boards-Delivery-Status-Serial-Monitor.png">
If you remove power from one of the boards, you'll receive a <k>Delivery Fail</k> message for that specific board. So, you can quickly identify which board didn't receive the message.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-ESP-NOW-Send-Data-To-Multiple-Boards-Delivery-Status-Serial-Monitor2.png">
If you want to check if the boards are actually receiving the messages, you can open the Serial Monitor for the COM port they are connected to, or you can use <a href="https://www.putty.org/" target="_blank" aria-label="PuTTY (opens in a new tab)">PuTTY</a> to establish a serial communication with your boards.
If you're using PuTTY, select Serial communication, write the COM port number and the baud rate (115200) as shown below and click <k>Open</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/Serial-Communication-ESP-Boards-PuTTY.png">
Then, you should see the messages being received.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP-NOW-Receive-Messages-Putty.png">
Open a serial communication for each of your boards and check that they are receiving the messages.
<h3>Wrapping Up</h3>
In this tutorial, you've learned how to send data to multiple ESP32 or ESP8266 boards from a single ESP32 using ESP-NOW (one-to-many communication).
We hope you've found this tutorial useful. We have other ESP-NOW tutorials that you may like:
<a href="https://randomnerdtutorials.com/esp-now-esp32-arduino-ide/">Getting Started with ESP-NOW (ESP32 with Arduino IDE)</a>
<a href="https://randomnerdtutorials.com/esp-now-esp8266-nodemcu-arduino-ide/">Getting Started with ESP-NOW (ESP8266 NodeMCU with Arduino IDE)</a>
<a href="https://randomnerdtutorials.com/esp-now-two-way-communication-esp32/">ESP-NOW Two-Way Communication Between ESP32 Boards (sensor readings)</a>
<a href="https://randomnerdtutorials.com/esp-now-many-to-one-esp32/">ESP-NOW with ESP32: Receive Data from Multiple Boards (many-to-one)</a>
<h2>MicroPython: MQTT  Publish DHT11/DHT22 Sensor Readings (ESP32/ESP8266)</a8></h2>
Learn how to program the ESP32 or ESP8266 boards with MicroPython to publish DHT11 or DHT22 sensor readings (temperature and humidity) via MQTT to any platform that supports MQTT or any MQTT client. As an example, we'll publish sensor readings to Node-RED Dashboard.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-ESP8266-DHT11-DHT22-MQTT-MicroPython.jpg">
<k>Recommended reading:</k> <a href="https://randomnerdtutorials.com/what-is-mqtt-and-how-it-works/">What is MQTT and How It Works</a> 
<k>Note: </k> <em>this tutorial is compatible with both the ESP32 and ESP8266 development boards.</em>
<h3>Project Overview</h3>
The following diagram shows a high-level overview of the project we'll build.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/DHT-ESP32-ESP8266-MicroPython-MQTT-Project-Overview-f.png">
The ESP requests temperature and humidity readings from the DHT11 or DHT22 sensor;
Temperature readings are published in the <k>esp/dht/temperature</k> topic;
Humidity readings are published in the <k>esp/dht/humidity</k> topic;
Node-RED is subscribed to those topics;
Node-RED receives the sensor readings and displays them on gauges;
You can receive the readings in any other platform that supports MQTT and handle the readings as you want.
<h3>Prerequisites</h3>
Before continuing with this tutorial, make sure you complete the following prerequisites:
To follow this tutorial you need MicroPython firmware installed in your ESP32 or ESP8266 boards. You also need an IDE to write and upload the code to your board. We suggest using Thonny IDE or uPyCraft IDE:
Thonny IDE:
<a href="https://randomnerdtutorials.com/getting-started-thonny-micropython-python-ide-esp32-esp8266/">Installing and getting started with Thonny IDE</a>
<a href="https://randomnerdtutorials.com/flashing-micropython-firmware-esptool-py-esp32-esp8266/">Flashing MicroPython Firmware with esptool.py</a>
uPyCraft IDE:
<a href="https://randomnerdtutorials.com/getting-started-micropython-esp32-esp8266/">Getting Started with uPyCraft IDE</a>
Install uPyCraft IDE (<a href="https://randomnerdtutorials.com/install-upycraft-ide-windows-pc-instructions/">Windows</a>, <a href="https://randomnerdtutorials.com/install-upycraft-ide-mac-os-x-instructions/">Mac OS X</a>, <a href="https://randomnerdtutorials.com/install-upycraft-ide-linux-ubuntu-instructions/">Linux</a>)
<a href="https://randomnerdtutorials.com/flash-upload-micropython-firmware-esp32-esp8266/">Flash/Upload MicroPython Firmware to ESP32 and ESP8266</a>
<h3>MQTT Broker</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/01/mosquitto-broker.png">
To use MQTT, you need a broker. We'll be using <a href="https://mosquitto.org/" target="_blank">Mosquitto broker</a> installed on a Raspberry Pi. Read <a href="https://randomnerdtutorials.com/how-to-install-mosquitto-broker-on-raspberry-pi/" target="_blank">How to Install Mosquitto Broker on Raspberry Pi</a>.
If you're not familiar with MQTT make sure you read our introductory tutorial: <a href="https://randomnerdtutorials.com/what-is-mqtt-and-how-it-works/" target="_blank">What is MQTT and How It Works</a>
<h3>Parts Required</h3>
For this tutorial you need the following parts:
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> (read <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">Best ESP32 development boards</a>) or <a aria-label="ESP8266 (opens in a new tab)" href="https://makeradvisor.com/tools/esp8266-esp-12e-nodemcu-wi-fi-development-board/" target="_blank">ESP8266</a>
<a href="https://makeradvisor.com/tools/dht11-temperature-humidity-sensor/" target="_blank">DHT11</a> or <a href="https://makeradvisor.com/tools/dht22-temperature-humidity-sensor/" target="_blank">DHT22</a>  <a href="https://randomnerdtutorials.com/esp32-esp8266-dht11-dht22-micropython-temperature-humidity-sensor/">DHT with ESP32 Guide</a>
<a href="https://makeradvisor.com/tools/resistors-kits/" target="_blank">4.7k Ohm resistor</a>
<a href="https://makeradvisor.com/raspberry-pi-board/" target="_blank">Raspberry Pi board</a> (read <a href="https://makeradvisor.com/best-raspberry-pi-starter-kits/" target="_blank">Best Raspberry Pi Starter Kits</a>)
<a href="https://makeradvisor.com/tools/microsd-card-raspberry-pi-16gb-class-10/" target="_blank">MicroSD Card  16GB Class10</a>
<a href="https://makeradvisor.com/tools/raspberry-pi-power-supply/" target="_blank">Raspberry Pi Power Supply (5V 2.5A)</a> 
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a> 
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="eager" fetchpriority="high" decoding="async"></a>
<h3>umqtttsimple Library</h3>
To use MQTT with the ESP32/ESP8266 and MicroPython, we'll use the <em>umqttsimple</em>.py library. Follow the next set of instructions for the IDE you're using:
A. Upload umqttsimple library with uPyCraft IDE
B. Upload umqttsimple library with Thonny IDE
<k>try:
    import usocket as socket
except:
    import socket
import ustruct as struct
from ubinascii import hexlify
class MQTTException(Exception):
    pass
class MQTTClient:
    def __init__(self, client_id, server, port=0, user=None, password=None, keepalive=0,
                 ssl=False, ssl_params={}):
        if port == 0:
            port = 8883 if ssl else 1883
        self.client_id = client_id
        self.sock = None
        self.server = server
        self.port = port
        self.ssl = ssl
        self.ssl_params = ssl_params
        self.pid = 0
        self.cb = None
        self.user = user
        self.pswd = password
        self.keepalive = keepalive
        self.lw_topic = None
        self.lw_msg = None
        self.lw_qos = 0
        self.lw_retain = False
    def _send_str(self, s):
        self.sock.write(struct.pack("!H", len(s)))
        self.sock.write(s)
    def _recv_len(self):
        n = 0
        sh = 0
        while 1:
            b = self.sock.read(1)[0]
            n |= (b & 0x7f) &lt;&lt; sh
            if not b & 0x80:
                return n
            sh += 7
    def set_callback(self, f):
        self.cb = f
    def set_last_will(self, topic, msg, retain=False, qos=0):
        assert 0 &lt;= qos &lt;= 2
        assert topic
        self.lw_topic = topic
        self.lw_msg = msg
        self.lw_qos = qos
        self.lw_retain = retain
    def connect(self, clean_session=True):
        self.sock = socket.socket()
        addr = socket.getaddrinfo(self.server, self.port)[0][-1]
        self.sock.connect(addr)
        if self.ssl:
            import ussl
            self.sock = ussl.wrap_socket(self.sock, **self.ssl_params)
        premsg = bytearray(b"\x10\0\0\0\0\0")
        msg = bytearray(b"\x04MQTT\x04\x02\0\0")
        sz = 10 + 2 + len(self.client_id)
        msg[6] = clean_session &lt;&lt; 1
        if self.user is not None:
            sz += 2 + len(self.user) + 2 + len(self.pswd)
            msg[6] |= 0xC0
        if self.keepalive:
            assert self.keepalive &lt; 65536
            msg[7] |= self.keepalive >> 8
            msg[8] |= self.keepalive & 0x00FF
        if self.lw_topic:
            sz += 2 + len(self.lw_topic) + 2 + len(self.lw_msg)
            msg[6] |= 0x4 | (self.lw_qos & 0x1) &lt;&lt; 3 | (self.lw_qos & 0x2) &lt;&lt; 3
            msg[6] |= self.lw_retain &lt;&lt; 5
        i = 1
        while sz > 0x7f:
            premsg[i] = (sz & 0x7f) | 0x80
            sz >>= 7
            i += 1
        premsg[i] = sz
        self.sock.write(premsg, i + 2)
        self.sock.write(msg)
        #print(hex(len(msg)), hexlify(msg, ":"))
        self._send_str(self.client_id)
        if self.lw_topic:
            self._send_str(self.lw_topic)
            self._send_str(self.lw_msg)
        if self.user is not None:
            self._send_str(self.user)
            self._send_str(self.pswd)
        resp = self.sock.read(4)
        assert resp[0] == 0x20 and resp[1] == 0x02
        if resp[3] != 0:
            raise MQTTException(resp[3])
        return resp[2] & 1
    def disconnect(self):
        self.sock.write(b"\xe0\0")
        self.sock.close()
    def ping(self):
        self.sock.write(b"\xc0\0")
    def publish(self, topic, msg, retain=False, qos=0):
        pkt = bytearray(b"\x30\0\0\0")
        pkt[0] |= qos &lt;&lt; 1 | retain
        sz = 2 + len(topic) + len(msg)
        if qos > 0:
            sz += 2
        assert sz &lt; 2097152
        i = 1
        while sz > 0x7f:
            pkt[i] = (sz & 0x7f) | 0x80
            sz >>= 7
            i += 1
        pkt[i] = sz
        #print(hex(len(pkt)), hexlify(pkt, ":"))
        self.sock.write(pkt, i + 1)
        self._send_str(topic)
        if qos > 0:
            self.pid += 1
            pid = self.pid
            struct.pack_into("!H", pkt, 0, pid)
            self.sock.write(pkt, 2)
        self.sock.write(msg)
        if qos == 1:
            while 1:
                op = self.wait_msg()
                if op == 0x40:
                    sz = self.sock.read(1)
                    assert sz == b"\x02"
                    rcv_pid = self.sock.read(2)
                    rcv_pid = rcv_pid[0] &lt;&lt; 8 | rcv_pid[1]
                    if pid == rcv_pid:
                        return
        elif qos == 2:
            assert 0
    def subscribe(self, topic, qos=0):
        assert self.cb is not None, "Subscribe callback is not set"
        pkt = bytearray(b"\x82\0\0\0")
        self.pid += 1
        struct.pack_into("!BH", pkt, 1, 2 + 2 + len(topic) + 1, self.pid)
        #print(hex(len(pkt)), hexlify(pkt, ":"))
        self.sock.write(pkt)
        self._send_str(topic)
        self.sock.write(qos.to_bytes(1, "little"))
        while 1:
            op = self.wait_msg()
            if op == 0x90:
                resp = self.sock.read(4)
                #print(resp)
                assert resp[1] == pkt[2] and resp[2] == pkt[3]
                if resp[3] == 0x80:
                    raise MQTTException(resp[3])
                return
    # Wait for a single incoming MQTT message and process it.
    # Subscribed messages are delivered to a callback previously
    # set by .set_callback() method. Other (internal) MQTT
    # messages processed internally.
    def wait_msg(self):
        res = self.sock.read(1)
        self.sock.setblocking(True)
        if res is None:
            return None
        if res == b"":
            raise OSError(-1)
        if res == b"\xd0":  # PINGRESP
            sz = self.sock.read(1)[0]
            assert sz == 0
            return None
        op = res[0]
        if op & 0xf0 != 0x30:
            return op
        sz = self._recv_len()
        topic_len = self.sock.read(2)
        topic_len = (topic_len[0] &lt;&lt; 8) | topic_len[1]
        topic = self.sock.read(topic_len)
        sz -= topic_len + 2
        if op & 6:
            pid = self.sock.read(2)
            pid = pid[0] &lt;&lt; 8 | pid[1]
            sz -= 2
        msg = self.sock.read(sz)
        self.cb(topic, msg)
        if op & 6 == 2:
            pkt = bytearray(b"\x40\x02\0\0")
            struct.pack_into("!H", pkt, 2, pid)
            self.sock.write(pkt)
        elif op & 6 == 4:
            assert 0
    # Checks whether a pending message from server is available.
    # If not, returns immediately with None. Otherwise, does
    # the same processing as wait_msg.
    def check_msg(self):
        self.sock.setblocking(False)
        return self.wait_msg()
</k>
<a href="https://github.com/RuiSantosdotme/ESP-MicroPython/raw/master/code/MQTT/umqttsimple.py" target="_blank">View raw code</a>
<h3>A. Upload umqttsimple library with uPyCraft IDE</h3>
<k>1.</k> Create a new file by pressing the <k>New File</k> button.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/10/uPycraft-ide-tools-menu-new-file.png">
<k>2.</k> Copy the <em>umqttsimple</em> library code into it. You can access the <em>umqttsimple</em> library code in the following link:
<a href="https://raw.githubusercontent.com/RuiSantosdotme/ESP-MicroPython/master/code/MQTT/umqttsimple.py" target="_blank">https://raw.githubusercontent.com/RuiSantosdotme/ESP-MicroPython/master/code/MQTT/umqttsimple.py</a>
<k>3.</k> Save the file by pressing the <k>Save</k> button.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/10/uPycraft-ide-tools-menu-save-file.png">
<k>4.</k> Call this new file <k>umqttsimple.py</k> and press <k>ok</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/12/import-umqttsimple-library.png">
<k>5.</k> Click the <k>Download and Run</k> button.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/10/uPycraft-ide-tools-menu-download-and-run.png">
<k>6.</k> The file should be saved on the <em>device</em> folder with the name <k>umqttsimple.py</k> as highlighted in the figure below.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/12/umqttsimple-library-installed.png">
Now, you can use the library functionalities in your code by importing the library.
<h3>B. Upload umqttsimple library with Thonny IDE</h3>
<k>1.</k> Copy the library code to a new file. The <a aria-label="umqttsimple library code can be found here (opens in a new tab)" href="https://raw.githubusercontent.com/RuiSantosdotme/ESP-MicroPython/master/code/MQTT/umqttsimple.py" target="_blank">umqttsimple library code can be found here</a>.
<k>2.</k> Go to <k>File</k> > <k>Save as</k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/Thonny-IDE-ESP32-ESP8266-MicroPython-Save-file-library-to-device-save-as.png">
If the Save as menu is missing, check that you have properly set up Thonny IDE as in the following tutorial:
<a href="https://randomnerdtutorials.com/getting-started-thonny-micropython-python-ide-esp32-esp8266/">Getting Started with Thonny MicroPython (Python) IDE for ESP32 and ESP8266</a>
<k>3.</k> Select save to <k>MicroPython device</k>:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/Thonny-IDE-ESP32-ESP8266-MicroPython-Save-file-library-to-device-select.png">
<k>4.</k> Name your file as <em>umqttsimple.py</em> and press the OK button:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/umqttsimple-library-new-MicroPython-file-Thonny-IDE.png">
And that's it. The library was uploaded to your board. To make sure that it was uploaded successfully, go to File > Save as and select the MicroPython device. Your file should be listed there:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/umqttsimple-library-MicroPython-file-created-Thonny-IDE.png">
After uploading the library to your board, you can use the library functionalities in your code by importing the library.
<h3> Schematic: ESP32 with DHT11/DHT22</h3>
Wire the <a href="https://randomnerdtutorials.com/esp32-esp8266-dht11-dht22-micropython-temperature-humidity-sensor/">DHT22 or DHT11</a> sensor to the ESP32 development board as shown in the following schematic diagram. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/04/dht_esp32_bb-1.png">
In this example, we're connecting the DHT data pin to GPIO 14. However, you can use any other suitable digital pin. 
Learn how to use the ESP32 GPIOs with our guide: <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">ESP32 Pinout Reference: Which GPIO pins should you use?</a> 
<h3> Schematic: ESP8266 NodeMCU with DHT11/DHT22 </h3>
If you're using an ESP8266 NodeMCU, follow the next diagram instead.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/04/dht_esp8266_bb.png">
In this example, we're connecting the DHT data pin to GPIO 14 (D5). However, you can use any other suitable digital pin.
Learn how to use the ESP8266 GPIOs with our guide: <a href="https://randomnerdtutorials.com/esp8266-pinout-reference-gpios/">ESP8266 Pinout Reference: Which GPIO pins should you use?</a>
<h3>Code</h3>
After uploading the library to the ESP32 or ESP8266, copy the following code to the <em>main.py</em> file. It publishes the temperature and humidity on the <k>esp/dht/temperature</k> and <k>esp/dht/humidity</k> topics every 5 seconds.
<k># Complete project details at https://RandomNerdTutorials.com/micropython-mqtt-publish-dht11-dht22-esp32-esp8266/
import time
from umqttsimple import MQTTClient
import ubinascii
import machine
import micropython
import network
import esp
from machine import Pin
import dht
esp.osdebug(None)
import gc
gc.collect()
ssid = 'REPLACE_WITH_YOUR_SSID'
password = 'REPLACE_WITH_YOUR_PASSWORD'
mqtt_server = '192.168.1.XXX'
#EXAMPLE IP ADDRESS or DOMAIN NAME
#mqtt_server = '192.168.1.106'
client_id = ubinascii.hexlify(machine.unique_id())
topic_pub_temp = b'esp/dht/temperature'
topic_pub_hum = b'esp/dht/humidity'
last_message = 0
message_interval = 5
station = network.WLAN(network.STA_IF)
station.active(True)
station.connect(ssid, password)
while station.isconnected() == False:
  pass
print('Connection successful')
sensor = dht.DHT22(Pin(14))
#sensor = dht.DHT11(Pin(14))
def connect_mqtt():
  global client_id, mqtt_server
  client = MQTTClient(client_id, mqtt_server)
  #client = MQTTClient(client_id, mqtt_server, user=your_username, password=your_password)
  client.connect()
  print('Connected to %s MQTT broker' % (mqtt_server))
  return client
def restart_and_reconnect():
  print('Failed to connect to MQTT broker. Reconnecting...')
  time.sleep(10)
  machine.reset()
def read_sensor():
  try:
    sensor.measure()
    temp = sensor.temperature()
    # uncomment for Fahrenheit
    #temp = temp * (9/5) + 32.0
    hum = sensor.humidity()
    if (isinstance(temp, float) and isinstance(hum, float)) or (isinstance(temp, int) and isinstance(hum, int)):
      temp = (b'{0:3.1f},'.format(temp))
      hum =  (b'{0:3.1f},'.format(hum))
      return temp, hum
    else:
      return('Invalid sensor readings.')
  except OSError as e:
    return('Failed to read sensor.')
try:
  client = connect_mqtt()
except OSError as e:
  restart_and_reconnect()
while True:
  try:
    if (time.time() - last_message) > message_interval:
      temp, hum = read_sensor()
      print(temp)
      print(hum)
      client.publish(topic_pub_temp, temp)
      client.publish(topic_pub_hum, hum)
      last_message = time.time()
  except OSError as e:
    restart_and_reconnect()
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP-MicroPython/MQTT/esp_dht_mqtt.py" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
Import the following libraries:
<k>import time
from umqttsimple import MQTTClient
import ubinascii
import machine
import micropython
import network
import esp
from machine import Pin
import dht
esp.osdebug(None)
import gc
gc.collect()</k>
In the following variables, you need to enter your network credentials and your broker IP address.
<k>ssid = 'REPLACE_WITH_YOUR_SSID'
password = 'REPLACE_WITH_YOUR_PASSWORD'
mqtt_server = 'REPLACE_WITH_YOUR_MQTT_BROKER_IP'</k>
For example, our broker IP address is: 192.168.1.106.
<k>mqtt_server = '192.168.1.106'</k>
<k>Note:</k> read <a href="https://randomnerdtutorials.com/how-to-install-mosquitto-broker-on-raspberry-pi/" target="_blank">this tutorial</a> to see how to get your broker IP address.
To create an MQTT client, we need to get the ESP unique ID. That's what we do in the following line (it is saved on the client_id variable).
<k>client_id = ubinascii.hexlify(machine.unique_id())</k>
Next, create the topics you want your ESP to be publishing in. In our example, it will publish temperature on the <k>esp/dht/temperature</k> topic and humidity on the <k>esp/dht/humidity</k> topic.
<k>topic_pub_temp = b'esp/dht/temperature'
topic_pub_hum = b'esp/dht/humidity'</k>
Then, create the following variables:
<k>last_message = 0
message_interval = 5</k>
The last_message variable will hold the last time a message was sent. The message_interval is the time between each message sent. Here, we're setting it to 5 seconds (this means a new message will be sent every 5 seconds). You can change it, if you want. 
After that, connect the ESP to your local network.
<k>station = network.WLAN(network.STA_IF)
station.active(True)
station.connect(ssid, password)
while station.isconnected() == False:
  pass
print('Connection successful')</k>
Initialize the DHT sensor by creating a dht instance on GPIO 4 as follows:
<k>sensor = dht.DHT22(Pin(4))</k>
If you're using a DHT11 sensor, uncomment the next line, and comment the previous one:
<k>sensor = dht.DHT11(Pin(4))</k>
<h3>Connect to MQTT Broker</h3>
The connect_mqtt() function creates an MQTT Client and connects to your broker.
<k>def connect_mqtt():
  global client_id, mqtt_server
  client = MQTTClient(client_id, mqtt_server)
  #client = MQTTClient(client_id, mqtt_server, user=your_username, password=your_password)
  client.connect()
  print('Connected to %s MQTT broker' % (mqtt_server))
  return client</k>
If your MQTT broker requires username and password, you should use the following line to pass your broker username and password as arguments.
<k>client = MQTTClient(client_id, mqtt_server, user=your_username, password=your_password)</k>
<h3>Restart and Reconnect</h3>
The restart_and_reconnect() function resets the ESP32/ESP8266 board. This function will be called if we're not able to publish the readings via MQTT in case the broker disconnects.
<k>def restart_and_reconnect():
  print('Failed to connect to MQTT broker. Reconnecting...')
  time.sleep(10)
  machine.reset()</k>
<h3>Read DHT Sensor</h3>
We created a function called read_sensor() that returns the current temperature and humidity from the DHT sensor and handles any exceptions, in case we're not able to get readings from the sensor.
<k>def read_sensor():
  try:
    sensor.measure()
    temp = sensor.temperature()
    hum = sensor.humidity()
    if (isinstance(temp, float) and isinstance(hum, float)) or (isinstance(temp, int) and isinstance(hum, int)):
      temp = (b'{0:3.1f},'.format(temp))
      hum =  (b'{0:3.1f},'.format(hum))
      # uncomment for Fahrenheit
      #temp = temp * (9/5) + 32.0
      return temp, hum
    else:
      return('Invalid sensor readings.')
  except OSError as e:
    return('Failed to read sensor.')</k>
<h3>Publishing MQTT Messages</h3>
In the while loop, we publish new temperature and humidity readings every 5 seconds.
First, we check if it is time to get new readings:
<k>if (time.time() - last_message) > message_interval:</k>
If it is, request new readings from the DHT sensor by calling the read_sensor() function. The temperature is saved on the temp variable and the humidity is saved on the hum variable.
<k>temp, hum = read_sensor()</k>
Finally, publish the readings by using the publish() method on the client object. The publish() method accepts as arguments the topic and the message, as follows:
<k>client.publish(topic_pub_temp, temp)
client.publish(topic_pub_hum, hum)</k>
Finally, update the time when the last message was sent:
<k>last_message = time.time()</k>
In case the ESP32 or ESP8266 disconnects from the broker, and we're not able to publish the readings, call the restart_and_reconnect() function to reset the ESP board and try to reconnect to the broker.
<k>except OSError as e:
  restart_and_reconnect()</k>
After uploading the code, you should get new sensor readings on the shell every 5 seconds.
Now, go to the next section to prepare Node-RED to receive the readings the ESP is publishing.
<h3>Preparing Node-RED Dashboard</h3>
The ESP32 or ESP8266 is publishing temperature readings every 5 seconds on the <k>esp/dht/temperature</k> and <k>esp/dht/humidity</k> topics. Now, you can use any dashboard that supports MQTT or any other device that supports MQTT to subscribe to those topics and receive the readings.
As an example, we'll create a simple flow using Node-RED to subscribe to those topics and display the readings on gauges.
If you don't have Node-RED installed, follow the next tutorials:
<a href="https://randomnerdtutorials.com/getting-started-with-node-red-on-raspberry-pi/">Getting Started with Node-RED on Raspberry Pi</a>
<a href="https://randomnerdtutorials.com/getting-started-with-node-red-dashboard/">Installing and Getting Started with Node-RED Dashboard</a>
Having Node-RED running on your Raspberry Pi, go to your Raspberry Pi IP address followed by :1880.
<k>http://raspberry-pi-ip-address:1880</k>
The Node-RED interface should open. Drag two MQTT in nodes, and two gauge nodes to the flow.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/0-ESP32-DHT11-DHT22-Arduino-IDE.png">
Click the MQTT node and edit its properties.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/MQTT-In-Node-ESP32-ESP8266-Publish-Temperature-Humidity-Node-RED-Flow.png">
The Server field refers to the MQTT broker. In our case, the MQTT broker is the Raspberry Pi, so it is set to localhost:1883. If you're using a Cloud MQTT broker, you should change that field. 
Insert the topic you want to be subscribed to and the QoS. This previous MQTT node is subscribed to the <k>esp/dht/temperature</k> topic. 
Click on the other MQTT in node and edit its properties with the same server, but for the other topic: <k>esp/dht/humidity</k>. 
Click on the gauge nodes and edit its properties for each reading. The following node is set for the temperature readings. Edit the other chart node for the humidity readings.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/2-ESP32-Gauge-Temperature-Humidity-Node-RED-Flow.png">
Wire your nodes as shown below:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-MQTT-Publish-DHT-Temperature-Humidity-Node-RED-Flow.png">
Finally, deploy your flow (press the button on the upper right corner).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/06/11_deploy_button.png">
Alternatively, you can go to <k>Menu </k>> <k>Import </k>and copy the following to your <k>Clipboard</k> to create your Node-RED flow.
<k>[{"id":"59f95d85.b6f0b4","type":"mqtt in","z":"b01416d3.f69f38","name":"","topic":"esp/dht/temperature","qos":"1","datatype":"auto","broker":"8db3fac0.99dd48","x":910,"y":340,"wires":[["2babfd19.559212"]]},{"id":"2babfd19.559212","type":"ui_gauge","z":"b01416d3.f69f38","name":"","group":"37de8fe8.46846","order":2,"width":0,"height":0,"gtype":"gage","title":"Temperature","label":"oC","format":"{{value}}","min":0,"max":"40","colors":["#00b500","#f7df09","#ca3838"],"seg1":"","seg2":"","x":1210,"y":340,"wires":[]},{"id":"b9aa2398.37ca3","type":"mqtt in","z":"b01416d3.f69f38","name":"","topic":"esp/dht/humidity","qos":"1","datatype":"auto","broker":"8db3fac0.99dd48","x":900,"y":420,"wires":[["d0f75e86.1c9ae"]]},{"id":"d0f75e86.1c9ae","type":"ui_gauge","z":"b01416d3.f69f38","name":"","group":"37de8fe8.46846","order":2,"width":0,"height":0,"gtype":"gage","title":"Humidity","label":"%","format":"{{value}}","min":"30","max":"100","colors":["#53a4e6","#1d78a9","#4e38c9"],"seg1":"","seg2":"","x":1200,"y":420,"wires":[]},{"id":"8db3fac0.99dd48","type":"mqtt-broker","z":"","name":"","broker":"localhost","port":"1883","clientid":"","usetls":false,"compatmode":false,"keepalive":"60","cleansession":true,"birthTopic":"","birthQos":"0","birthPayload":"","closeTopic":"","closeQos":"0","closePayload":"","willTopic":"","willQos":"0","willPayload":""},{"id":"37de8fe8.46846","type":"ui_group","z":"","name":"BME280","tab":"53b8c8f9.cfbe48","order":1,"disp":true,"width":"6","collapse":false},{"id":"53b8c8f9.cfbe48","type":"ui_tab","z":"","name":"Home","icon":"dashboard","order":2,"disabled":false,"hidden":false}]
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP-MicroPython/MQTT/esp_dht_mqtt_flow.txt" target="_blank">View raw code</a>
<h3>Demonstration</h3>
Go to your Raspberry Pi IP address followed by <em>:1880/ui</em>.
<k>http://raspberry-pi-ip-address:1880/ui</k>
You should get access to the current DHT temperature and humidity readings on the Dashboard. You can use other dashboard-type nodes to display the readings on different ways.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/4-ESP32-MQTT-Publish-Temperature-Humidity-Node-RED-Dashboard.png">
That's it! You have your ESP32 or ESP8266 boards publishing DHT temperature and humidity readings to Node-RED via MQTT using MicroPython.
<h3>Wrapping Up</h3>
MQTT is a great communication protocol to exchange small amounts of data between IoT devices. In this tutorial you've learned how to publish temperature and humidity readings from a DHT sensor with the ESP32 and ESP8266 using MicroPython to different MQTT topics. Then, you can use any device or home automation platform to subscribe to those topics and receive the readings.
Instead of a <a href="https://randomnerdtutorials.com/esp32-esp8266-dht11-dht22-micropython-temperature-humidity-sensor/">DHT11 or DHT22 sensor</a>, you can use any other sensor like a <a href="https://randomnerdtutorials.com/micropython-ds18b20-esp32-esp8266/">DS18B20 temperature sensor</a> or <a href="https://randomnerdtutorials.com/micropython-bme280-esp32-esp8266/">BME280 sensor</a>.
We have other projects/tutorials related with the DHT sensor that you may also like:
<a href="https://randomnerdtutorials.com/esp32-esp8266-dht11-dht22-micropython-temperature-humidity-sensor/">MicroPython: ESP32/ESP8266 with DHT11/DHT22 Temperature and Humidity Sensor</a>
<a href="https://randomnerdtutorials.com/micropython-esp32-esp8266-dht11-dht22-web-server/">MicroPython: ESP32/ESP8266 with DHT11/DHT22 Web Server</a>
Learn more about MicroPython with our eBook: <a href="https://randomnerdtutorials.com/micropython-programming-with-esp32-and-esp8266/">MicroPython Programming using ESP32/ESP8266</a>.
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h-p2lw6wwnkk9ystvwe9iof8zx6yt4x7uma3cqfup534.jpg" title="Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h" alt="Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h" loading="lazy" width="129" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/">[eBook] Build Web Servers with ESP32 and ESP8266 (2nd Edition)</a></h4>
Build Web Server projects with the ESP32 and ESP8266 boards to control outputs and monitor sensors remotely. Learn HTML, CSS, JavaScript and client-server communication protocols <k><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Build Web Server projects with the ESP32 and ESP8266 boards to control outputs and monitor sensors remotely. Learn HTML, CSS, JavaScript and client-server communication protocols <k><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>ESP32 HTTP GET and HTTP POST with Arduino IDE (JSON, URL Encoded, Text)</h2>
In this guide, you'll learn how to make HTTP GET and HTTP POST requests with the ESP32 board with Arduino IDE. We'll cover examples on how to get values, post JSON objects, URL encoded requests, and more.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-HTTP-GET-HTTP-POST-with-Arduino-IDE-JSON-URL-Encoded-Text.jpg">
<k>Recommended:</k> <a href="https://randomnerdtutorials.com/esp8266-nodemcu-http-get-post-arduino/">ESP8266 NodeMCU HTTP GET and HTTP POST with Arduino IDE (JSON, URL Encoded, Text)</a>
<h3>HTTP Request Methods: GET vs POST</h3>
The Hypertext Transfer Protocol (HTTP) works as a request-response protocol between a client and server. Here's an example:
The ESP32 (client) submits an HTTP request to a Raspberry Pi running Node-RED (server);
The server returns a response to the ESP32 (client);
Finally, the response contains status information about the request and may also contain the requested content.
<h3>HTTP GET</h3>
<k>GET </k>is used to request data from a specified resource. It is often used to get values from APIs.
For example, you can have:
<k>GET /update-sensor?temperature=value1</k>
Note that the query string (<em>name = temperature</em> and <em>value = value1</em>) is sent in the URL of the HTTP GET request.
Or you can use a simple request to return a value or JSON object, for example:
<k>GET /get-sensor</k>
<em>(With HTTP GET, data is visible to everyone in the URL request.)</em>
<h3>HTTP POST</h3>
<k>POST </k>is used to send data to a server to create/update a resource. For example, publish sensor readings to a server.
The data sent to the server with POST is stored in the request body of the HTTP request:
<k>POST /update-sensor HTTP/1.1
Host: example.com
api_key=api&sensor_name=name&temperature=value1&humidity=value2&pressure=value3
Content-Type: application/x-www-form-urlencoded</k>
In the body request, you can also send a JSON object:
<k>POST /update-sensor HTTP/1.1
Host: example.com
{api_key: "api", sensor_name: "name", temperature: value1, humidity: value2, pressure: value3}
Content-Type: application/json</k>
<em>(With HTTP POST, data is not visible in the URL request. However, if it's not encrypted, it's still visible in the request body.)</em>
<h3>HTTP GET/POST with ESP32</h3>
In this guide, we'll explore the following scenarios:
<ol>
ESP32 HTTP GET: Value or Query in URL
ESP32 HTTP GET: JSON Data Object or Plain Text
ESP32 HTTP POST: URL Encoded, JSON Data Object, Plain Text
</ol>
<h3>Prerequisites</h3>
Before proceeding with this tutorial, make sure you complete the following prerequisites.
<h3>Arduino IDE</h3>
We'll program the ESP32 using Arduino IDE, so make sure you have the ESP32 add-on installed.
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<h3>Arduino_JSON Library</h3>
You also need to install the <a href="https://github.com/arduino-libraries/Arduino_JSON" target="_blank" aria-label=" (opens in a new tab)">Arduino_JSON library</a>. You can install this library in the Arduino IDE Library Manager. Just go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k> and search for the library name as follows:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/Install-Arduino-JSON-library-Arduino-IDE.png">
<h3>Parts Required</h3>
For this tutorial you need the following parts:
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> (read <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">Best ESP32 development boards</a>)
<a href="https://makeradvisor.com/raspberry-pi-board/" target="_blank">Raspberry Pi board</a> (read <a href="https://makeradvisor.com/best-raspberry-pi-starter-kits/" target="_blank">Best Raspberry Pi Starter Kits</a>)
<a href="https://makeradvisor.com/tools/microsd-card-raspberry-pi-16gb-class-10/" target="_blank">MicroSD Card  16GB Class10</a>
<a href="https://makeradvisor.com/tools/raspberry-pi-power-supply/" target="_blank">Raspberry Pi Power Supply (5V 2.5A)</a> 
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a> 
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="eager" fetchpriority="high" decoding="async"></a>
<h3>Preparing Node-RED (optional)</h3>
As an example, we'll create a web service with a Raspberry Pi and Node-RED to act as a web service (like an API). Basically, you'll make HTTP GET and HTTP POST requests to your Raspberry Pi to get values or update them. You can use any other web service.
If you don't have Node-RED installed, follow the next tutorials:
<a href="https://randomnerdtutorials.com/getting-started-with-node-red-on-raspberry-pi/">Getting Started with Node-RED on Raspberry Pi</a>
<a href="https://randomnerdtutorials.com/getting-started-with-node-red-dashboard/">Installing and Getting Started with Node-RED Dashboard</a>
Having Node-RED running on your Raspberry Pi, go to your Raspberry Pi IP address followed by :1880.
<k>http://raspberry-pi-ip-address:1880</k>
The Node-RED interface should open. You can simply import the final flow:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/Node-RED-Flow-HTTP-GET-POST-Request-Methods-ESP32-ESP8266-Arduino.png">
Go to <k>Menu</k> > <k>Import</k> and copy the following to your Clipboard to create your Node-RED flow.
<k>[{"id":"599740b7.efde9","type":"http response","z":"b01416d3.f69f38","name":"","statusCode":"200","headers":{},"x":420,"y":689,"wires":[]},{"id":"1618a829.76f638","type":"json","z":"b01416d3.f69f38","name":"","property":"payload","action":"obj","pretty":true,"x":410,"y":809,"wires":[["d0089cc7.d25ac"]]},{"id":"c7410fa2.1c2fa","type":"debug","z":"b01416d3.f69f38","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","x":850,"y":709,"wires":[]},{"id":"75a22f74.f1aba","type":"ui_text","z":"b01416d3.f69f38","group":"2b7ac01b.fc984","order":1,"width":0,"height":0,"name":"","label":"Sensor Name","format":"{{msg.payload}}","layout":"row-spread","x":860,"y":769,"wires":[]},{"id":"1c8f9093.8bc2bf","type":"ui_gauge","z":"b01416d3.f69f38","name":"","group":"2b7ac01b.fc984","order":2,"width":0,"height":0,"gtype":"gage","title":"Temperature","label":"oC","format":"{{value}}","min":0,"max":"38","colors":["#00b500","#e6e600","#ca3838"],"seg1":"","seg2":"","x":850,"y":829,"wires":[]},{"id":"a5bd2706.54e108","type":"ui_gauge","z":"b01416d3.f69f38","name":"","group":"2b7ac01b.fc984","order":3,"width":0,"height":0,"gtype":"gage","title":"Humidity","label":"%","format":"{{value}}","min":0,"max":"100","colors":["#0080ff","#0062c4","#002f5e"],"seg1":"","seg2":"","x":840,"y":889,"wires":[]},{"id":"105ac2cc.7b3cfd","type":"ui_gauge","z":"b01416d3.f69f38","name":"","group":"2b7ac01b.fc984","order":4,"width":0,"height":0,"gtype":"gage","title":"Pressure","label":"hPa","format":"{{value}}","min":0,"max":"1200","colors":["#b366ff","#8000ff","#440088"],"seg1":"","seg2":"","x":840,"y":949,"wires":[]},{"id":"d0089cc7.d25ac","type":"function","z":"b01416d3.f69f38","name":"JSON or URL Encoded","func":"var msg0 = { payload: msg.payload.api_key };\nvar msg1 = { payload: msg.payload.sensor };\nvar msg2 = { payload: msg.payload.value1 };\nvar msg3 = { payload: msg.payload.value2 };\nvar msg4 = { payload: msg.payload.value3 };\n\nreturn [msg0, msg1, msg2, msg3, msg4];","outputs":5,"noerr":0,"x":610,"y":809,"wires":[["c7410fa2.1c2fa"],["75a22f74.f1aba"],["1c8f9093.8bc2bf"],["a5bd2706.54e108"],["105ac2cc.7b3cfd"]]},{"id":"5d9ab0d2.66b92","type":"http in","z":"b01416d3.f69f38","name":"","url":"update-sensor","method":"post","upload":false,"swaggerDoc":"","x":200,"y":740,"wires":[["599740b7.efde9","c7410fa2.1c2fa","1618a829.76f638"]]},{"id":"7f5cf345.63f56c","type":"http response","z":"b01416d3.f69f38","name":"","statusCode":"200","headers":{},"x":540,"y":420,"wires":[]},{"id":"6530621.95b429c","type":"http in","z":"b01416d3.f69f38","name":"","url":"/get-sensor","method":"get","upload":false,"swaggerDoc":"","x":180,"y":600,"wires":[["9471d1a0.68588"]]},{"id":"5ddc9f47.4b555","type":"http response","z":"b01416d3.f69f38","name":"","statusCode":"200","headers":{},"x":540,"y":560,"wires":[]},{"id":"9471d1a0.68588","type":"function","z":"b01416d3.f69f38","name":"","func":"msg.payload = {\"value1\":24.25, \"value2\":49.54, \"value3\":1005.14};\nreturn msg;","outputs":1,"noerr":0,"x":350,"y":600,"wires":[["5ddc9f47.4b555","13aea59.7430e5a"]]},{"id":"13aea59.7430e5a","type":"debug","z":"b01416d3.f69f38","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","x":550,"y":628,"wires":[]},{"id":"e71c7a7d.e7c598","type":"debug","z":"b01416d3.f69f38","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","x":550,"y":500,"wires":[]},{"id":"c7807102.3f433","type":"http in","z":"b01416d3.f69f38","name":"","url":"/update-sensor","method":"get","upload":false,"swaggerDoc":"","x":190,"y":460,"wires":[["60410cde.562a34"]]},{"id":"60410cde.562a34","type":"function","z":"b01416d3.f69f38","name":"","func":"msg.payload = msg.payload.temperature;\nreturn msg;","outputs":1,"noerr":0,"x":390,"y":460,"wires":[["e71c7a7d.e7c598","7f5cf345.63f56c"]]},{"id":"2b7ac01b.fc984","type":"ui_group","z":"","name":"SENSORS","tab":"99ab8dc5.f435c","disp":true,"width":"6","collapse":false},{"id":"99ab8dc5.f435c","type":"ui_tab","z":"","name":"HTTP","icon":"dashboard","order":1,"disabled":false,"hidden":false}]
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/HTTP/HTTP_NodeRED_Flow.txt" target="_blank">View raw code</a>
<h3>Other Web Services or APIs</h3>
In this guide, the ESP32 performs HTTP requests to Node-RED, but you can use these examples with other services like <a href="https://randomnerdtutorials.com/esp32-http-get-open-weather-map-thingspeak-arduino/">ThingSpeak</a>, <a href="https://randomnerdtutorials.com/esp32-http-post-ifttt-thingspeak-arduino/">IFTTT.com</a> (WebHooks service), <a href="https://randomnerdtutorials.com/esp32-http-get-open-weather-map-thingspeak-arduino/">OpenWeatherMap.org</a>, <a href="https://randomnerdtutorials.com/control-esp32-esp8266-gpios-from-anywhere/">PHP server</a>, etc All examples presented in this guide will also work with other APIs.
In summary, to make this guide compatible with any service, you need to search for the service API documentation. Then, you need the server name (URL or IP address), and parameters to send in the request (URL path or request body). Finally, modify our examples to integrate with any API you want to use.
<h3>1. ESP32 HTTP GET: Value or Query in URL</h3>
In the first example, the ESP32 will make an HTTP GET request to update a reading in a service. This type of request could also be used to filter a value, request a value, or return a JSON object.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/HTTP-GET-ESP32-Get-Sensor-Value-Plain-Text-OK.png">
<h3>Code ESP32 HTTP GET with Arduino IDE</h3>
After installing the necessary board add-ons and libraries, copy the following code to your Arduino IDE, but don't upload it yet. You need to make some changes to make it work for you.
<k>/*
  Rui Santos
  Complete project details at Complete project details at https://RandomNerdTutorials.com/esp32-http-get-post-arduino/
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;WiFi.h>
#include &lt;HTTPClient.h>
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
//Your Domain name with URL path or IP address with path
String serverName = "http://192.168.1.106:1880/update-sensor";
// the following variables are unsigned longs because the time, measured in
// milliseconds, will quickly become a bigger number than can be stored in an int.
unsigned long lastTime = 0;
// Timer set to 10 minutes (600000)
//unsigned long timerDelay = 600000;
// Set timer to 5 seconds (5000)
unsigned long timerDelay = 5000;
void setup() {
  Serial.begin(115200); 
  WiFi.begin(ssid, password);
  Serial.println("Connecting");
  while(WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected to WiFi network with IP Address: ");
  Serial.println(WiFi.localIP());
 
  Serial.println("Timer set to 5 seconds (timerDelay variable), it will take 5 seconds before publishing the first reading.");
}
void loop() {
  //Send an HTTP POST request every 10 minutes
  if ((millis() - lastTime) > timerDelay) {
    //Check WiFi connection status
    if(WiFi.status()== WL_CONNECTED){
      HTTPClient http;
      String serverPath = serverName + "?temperature=24.37";
      
      // Your Domain name with URL path or IP address with path
      http.begin(serverPath.c_str());
      
      // If you need Node-RED/server authentication, insert user and password below
      //http.setAuthorization("REPLACE_WITH_SERVER_USERNAME", "REPLACE_WITH_SERVER_PASSWORD");
      
      // Send HTTP GET request
      int httpResponseCode = http.GET();
      
      if (httpResponseCode>0) {
        Serial.print("HTTP Response code: ");
        Serial.println(httpResponseCode);
        String payload = http.getString();
        Serial.println(payload);
      }
      else {
        Serial.print("Error code: ");
        Serial.println(httpResponseCode);
      }
      // Free resources
      http.end();
    }
    else {
      Serial.println("WiFi Disconnected");
    }
    lastTime = millis();
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/HTTP/ESP32_HTTP_GET_Update.ino" target="_blank">View raw code</a>
<h4>Setting your network credentials</h4>
Modify the next lines with your network credentials: SSID and password. The code is well commented on where you should make the changes.
<k>// Replace with your network credentials
const char* ssid     = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h4>Setting your serverName</h4>
You also need to type your domain name or Node-RED IP address, so the ESP publishes the readings to your own server.
<k>String serverName = "http://192.168.1.106:1880/update-sensor";</k>
Now, upload the code to your board and it should work straight away. 
Read the next section, if you want to learn how to make the HTTP GET request.
<h4>HTTP GET Request</h4>
In the loop() is where you actually make the HTTP GET request every 5 seconds with sample data:
<k>String serverPath = serverName + "?temperature=24.37";
// Your Domain name with URL path or IP address with path
http.begin(serverPath.c_str());
// If your need Node-RED/server authentication, insert user and password below
//http.setAuthorization("REPLACE_WITH_SERVER_USERNAME", "REPLACE_WITH_SERVER_PASSWORD");
// Send HTTP GET request
int httpResponseCode = http.GET();</k>
Note: if Node-RED requires authentication, uncomment the following line and insert the Node-RED username and password.
<k>// If you need Node-RED/server authentication, insert user and password below
//http.setAuthorization("REPLACE_WITH_SERVER_USERNAME", "REPLACE_WITH_SERVER_PASSWORD");</k>
The ESP32 makes a new request in the following URL to update the sensor field with a new temperature.
<k>http://192.168.1.106:1880/update-sensor?temperature=24.37</k>
Then, the following lines of code save the HTTP response from the server.
<k>if (httpResponseCode>0) {
  Serial.print("HTTP Response code: ");
  Serial.println(httpResponseCode);
  String payload = http.getString();
  Serial.println(payload);
}
else {
  Serial.print("Error code: ");
  Serial.println(httpResponseCode);
}</k>
<h3>Demonstration</h3>
With your board running the new sketch, open the Node-RED debug window. You'll see that the sample values are being printed successfully (24.37).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/udpate-data-esp32-HTTP-GET-ESP8266-NodeMCU-Arduino-value.png">
<h3>2. ESP32 HTTP GET: JSON Data Object or Plain Text</h3>
This next example shows how to make an HTTP GET request to get a JSON object and decode it with the ESP32. Many APIs return data in JSON format.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/HTTP-GET-ESP32-Get-Sensor-JSON-Data.png">
Copy the next sketch to your Arduino IDE (type your SSID and password):
<k>/*
  Rui Santos
  Complete project details at Complete project details at https://RandomNerdTutorials.com/esp32-http-get-post-arduino/
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;WiFi.h>
#include &lt;HTTPClient.h>
#include &lt;Arduino_JSON.h>
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
//Your Domain name with URL path or IP address with path
const char* serverName = "http://192.168.1.106:1880/get-sensor";
// the following variables are unsigned longs because the time, measured in
// milliseconds, will quickly become a bigger number than can be stored in an int.
unsigned long lastTime = 0;
// Timer set to 10 minutes (600000)
//unsigned long timerDelay = 600000;
// Set timer to 5 seconds (5000)
unsigned long timerDelay = 5000;
String sensorReadings;
float sensorReadingsArr[3];
void setup() {
  Serial.begin(115200);
  WiFi.begin(ssid, password);
  Serial.println("Connecting");
  while(WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected to WiFi network with IP Address: ");
  Serial.println(WiFi.localIP());
 
  Serial.println("Timer set to 5 seconds (timerDelay variable), it will take 5 seconds before publishing the first reading.");
}
void loop() {
  //Send an HTTP POST request every 10 minutes
  if ((millis() - lastTime) > timerDelay) {
    //Check WiFi connection status
    if(WiFi.status()== WL_CONNECTED){
              
      sensorReadings = httpGETRequest(serverName);
      Serial.println(sensorReadings);
      JSONVar myObject = JSON.parse(sensorReadings);
  
      // JSON.typeof(jsonVar) can be used to get the type of the var
      if (JSON.typeof(myObject) == "undefined") {
        Serial.println("Parsing input failed!");
        return;
      }
    
      Serial.print("JSON object = ");
      Serial.println(myObject);
    
      // myObject.keys() can be used to get an array of all the keys in the object
      JSONVar keys = myObject.keys();
    
      for (int i = 0; i &lt; keys.length(); i++) {
        JSONVar value = myObject[keys[i]];
        Serial.print(keys[i]);
        Serial.print(" = ");
        Serial.println(value);
        sensorReadingsArr[i] = double(value);
      }
      Serial.print("1 = ");
      Serial.println(sensorReadingsArr[0]);
      Serial.print("2 = ");
      Serial.println(sensorReadingsArr[1]);
      Serial.print("3 = ");
      Serial.println(sensorReadingsArr[2]);
    }
    else {
      Serial.println("WiFi Disconnected");
    }
    lastTime = millis();
  }
}
String httpGETRequest(const char* serverName) {
  WiFiClient client;
  HTTPClient http;
    
  // Your Domain name with URL path or IP address with path
  http.begin(client, serverName);
  
  // If you need Node-RED/server authentication, insert user and password below
  //http.setAuthorization("REPLACE_WITH_SERVER_USERNAME", "REPLACE_WITH_SERVER_PASSWORD");
  
  // Send HTTP POST request
  int httpResponseCode = http.GET();
  
  String payload = "{}"; 
  
  if (httpResponseCode>0) {
    Serial.print("HTTP Response code: ");
    Serial.println(httpResponseCode);
    payload = http.getString();
  }
  else {
    Serial.print("Error code: ");
    Serial.println(httpResponseCode);
  }
  // Free resources
  http.end();
  return payload;
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/HTTP/ESP32_HTTP_GET_JSON.ino" target="_blank">View raw code</a>
<h3>Setting your serverName</h3>
Enter your domain name or Node-RED IP address, so the ESP requests the sensor readings that will be retrieved in a JSON object.
<k>String serverName = "http://192.168.1.106:1880/get-sensor";</k>
Now, upload the code to your board.
<h3>HTTP GET Request (JSON Object)</h3>
In the loop(), call the httpGETRequest() function to make the HTTP GET request:
<k>sensorReadings = httpGETRequest(serverName);</k>
The httpGETRequest() function makes a request to Node-RED address <em>http://192.168.1.106:1880/get-sensor</em> and it retrieves a string with a JSON object.
<k>String httpGETRequest(const char* serverName) {
  HTTPClient http;
  // Your IP address with path or Domain name with URL path 
  http.begin(serverName);
  // If you need Node-RED/server authentication, insert user and password below
  //http.setAuthorization("REPLACE_WITH_SERVER_USERNAME", "REPLACE_WITH_SERVER_PASSWORD");
  // Send HTTP POST request
  int httpResponseCode = http.GET();
  String payload = "{}"; 
  if (httpResponseCode>0) {
    Serial.print("HTTP Response code: ");
    Serial.println(httpResponseCode);
    payload = http.getString();
  }
  else {
    Serial.print("Error code: ");
    Serial.println(httpResponseCode);
  }
  // Free resources
  http.end();
  return payload;
}</k>
Note: if Node-RED requires authentication, uncomment the following line and insert the Node-RED username and password.
<k>// If you need Node-RED/server authentication, insert user and password below
//http.setAuthorization("REPLACE_WITH_SERVER_USERNAME", "REPLACE_WITH_SERVER_PASSWORD");</k>
<h3>Decoding JSON Object</h3>
To get access to the values, decode the JSON object and store all values in the sensorReadingsArr array.
<k>JSONVar myObject = JSON.parse(sensorReadings);
// JSON.typeof(jsonVar) can be used to get the type of the var
if (JSON.typeof(myObject) == "undefined") {
  Serial.println("Parsing input failed!");
  return;
}
Serial.print("JSON object = ");
Serial.println(myObject);
// myObject.keys() can be used to get an array of all the keys in the object
JSONVar keys = myObject.keys();
for (int i = 0; i &lt; keys.length(); i++) {
  JSONVar value = myObject[keys[i]];
  Serial.print(keys[i]);
  Serial.print(" = ");
  Serial.println(value);
  sensorReadingsArr[i] = double(value);
}
Serial.print("1 = ");
Serial.println(sensorReadingsArr[0]);
Serial.print("2 = ");
Serial.println(sensorReadingsArr[1]);
Serial.print("3 = ");
Serial.println(sensorReadingsArr[2]);</k>
<h3>HTTP GET Demonstration</h3>
After uploading the code, open the Arduino IDE and you'll see that it's receiving the following JSON data:
<k>{"value1":24.25,"value2":49.54,"value3":1005.14}</k>
Then, you print the decoded JSON object in the Arduino IDE Serial Monitor.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/JSON-Data-object-HTTP-POST-Request-Method.png">
For debugging purposes, the requested information is also printed in the Node-RED debug window.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/udpate-data-esp32-HTTP-GET-ESP8266-NodeMCU-Arduino-JSON-object.png">
<h3>3. ESP32 HTTP POST: URL Encoded, JSON Data Object, Plain Text</h3>
Finally, you'll learn how to make an HTTP POST request with an ESP32.
With this example, your ESP32 can make HTTP POST requests using three different types of body requests: URL encoded, JSON object or plain text. These are the most common methods and should integrate with most APIs or web services.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/HTTP-POST-ESP32-URL-Encoded-JSON-Object-Data-Plain-Text.png">
Copy the next sketch to your Arduino IDE (type your SSID and password):
<k>/*
  Rui Santos
  Complete project details at Complete project details at https://RandomNerdTutorials.com/esp32-http-get-post-arduino/
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;WiFi.h>
#include &lt;HTTPClient.h>
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
//Your Domain name with URL path or IP address with path
const char* serverName = "http://192.168.1.106:1880/update-sensor";
// the following variables are unsigned longs because the time, measured in
// milliseconds, will quickly become a bigger number than can be stored in an int.
unsigned long lastTime = 0;
// Timer set to 10 minutes (600000)
//unsigned long timerDelay = 600000;
// Set timer to 5 seconds (5000)
unsigned long timerDelay = 5000;
void setup() {
  Serial.begin(115200);
  WiFi.begin(ssid, password);
  Serial.println("Connecting");
  while(WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected to WiFi network with IP Address: ");
  Serial.println(WiFi.localIP());
 
  Serial.println("Timer set to 5 seconds (timerDelay variable), it will take 5 seconds before publishing the first reading.");
}
void loop() {
  //Send an HTTP POST request every 10 minutes
  if ((millis() - lastTime) > timerDelay) {
    //Check WiFi connection status
    if(WiFi.status()== WL_CONNECTED){
      WiFiClient client;
      HTTPClient http;
    
      // Your Domain name with URL path or IP address with path
      http.begin(client, serverName);
      
      // If you need Node-RED/server authentication, insert user and password below
      //http.setAuthorization("REPLACE_WITH_SERVER_USERNAME", "REPLACE_WITH_SERVER_PASSWORD");
      
      // Specify content-type header
      http.addHeader("Content-Type", "application/x-www-form-urlencoded");
      // Data to send with HTTP POST
      String httpRequestData = "api_key=tPmAT5Ab3j7F9&sensor=BME280&value1=24.25&value2=49.54&value3=1005.14";           
      // Send HTTP POST request
      int httpResponseCode = http.POST(httpRequestData);
      
      // If you need an HTTP request with a content type: application/json, use the following:
      //http.addHeader("Content-Type", "application/json");
      //int httpResponseCode = http.POST("{\"api_key\":\"tPmAT5Ab3j7F9\",\"sensor\":\"BME280\",\"value1\":\"24.25\",\"value2\":\"49.54\",\"value3\":\"1005.14\"}");
      // If you need an HTTP request with a content type: text/plain
      //http.addHeader("Content-Type", "text/plain");
      //int httpResponseCode = http.POST("Hello, World!");
     
      Serial.print("HTTP Response code: ");
      Serial.println(httpResponseCode);
        
      // Free resources
      http.end();
    }
    else {
      Serial.println("WiFi Disconnected");
    }
    lastTime = millis();
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/HTTP/ESP32_HTTP_POST.ino" target="_blank">View raw code</a>
<h3>Setting your serverName</h3>
Enter your domain name or Node-RED IP address, so the ESP posts sample sensor readings.
<k>String serverName = "http://192.168.1.106:1880/update-sensor";</k>
Now, upload the code to your board.
<h3>HTTP POST URL Encoded</h3>
To make an HTTP POST request of type URL encoded, like this
<k>POST /update-sensor HTTP/1.1
Host: 192.168.1.106:1880
api_key=tPmAT5Ab3j7F9&sensor=BME280&value1=24.25&value2=49.54&value3=1005.14
Content-Type: application/x-www-form-urlencoded</k>
You need to run the following in your Arduino code:
<k>// Your Domain name with URL path or IP address with path
http.begin(serverName);
// If you need Node-RED/server authentication, insert user and password below
//http.setAuthorization("REPLACE_WITH_SERVER_USERNAME", "REPLACE_WITH_SERVER_PASSWORD");
// Specify content-type header
http.addHeader("Content-Type", "application/x-www-form-urlencoded");
// Data to send with HTTP POST
String httpRequestData = "api_key=tPmAT5Ab3j7F9&sensor=BME280&value1=24.25&value2=49.54&value3=1005.14";
// Send HTTP POST request
int httpResponseCode = http.POST(httpRequestData);</k>
Note: if Node-RED requires authentication, uncomment the following line and insert the Node-RED username and password.
<k>// If you need Node-RED/server authentication, insert user and password below
//http.setAuthorization("REPLACE_WITH_SERVER_USERNAME", "REPLACE_WITH_SERVER_PASSWORD");</k>
<h3>HTTP POST JSON Object</h3>
Or if you prefer to make an HTTP POST request with a JSON object:
<k>POST /update-sensor HTTP/1.1
Host: example.com
{api_key: "tPmAT5Ab3j7F9", sensor_name: "BME280", temperature: 24.25; humidity: 49.54; pressure: 1005.14}
Content-Type: application/json</k>
Use the next snippet:
<k>http.addHeader("Content-Type", "application/json");
int httpResponseCode = http.POST("{\"api_key\":\"tPmAT5Ab3j7F9\",\"sensor\":\"BME280\",\"value1\":\"24.25\",\"value2\":\"49.54\",\"value3\":\"1005.14\"}");</k>
<h3>HTTP Plain Text</h3>
If you want to send plain text or a value, use the following:
<k>http.addHeader("Content-Type", "text/plain");
int httpResponseCode = http.POST("Hello, World!");</k>
<k>Note: </k> the Node-RED flow we're using (web service) is not setup to receive plain text, but if the API that you plan to integrate only accepts plain text or a value, you can use the previous snippet. 
<h3>HTTP POST Demonstration</h3>
In the Node-RED debug window, you can view that your ESP is making an HTTP POST request every 5 seconds.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/udpate-data-esp32-HTTP-POST-ESP8266-NodeMCU-Arduino-value.png">
And in this example, those values are also sent to 3 Gauges and are displayed in Node-RED Dashboard:
<k>http://raspberry-pi-ip-address:1880/ui</k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-ESP8266-HTTP-GET-POST-Demonstration.png">
<h3>Wrapping Up</h3>
In this tutorial you've learned how to integrate your ESP32 with online services using HTTP GET and HTTP POST requests.
HTTP GET and HTTP POST are commonly used in most web services and APIs. These can be useful in your projects to: publish your sensor readings to a web service like IFTTT, ThingSpeak; to an ESP32 or Raspberry Pi web server or to your own server; to request data from the internet or from your database, and much more.
If you're using an ESP8266 board, read: <a href="https://randomnerdtutorials.com/esp8266-nodemcu-http-get-post-arduino/">Guide for ESP8266 NodeMCU HTTP GET and HTTP Post Requests</a>.
<h2>MicroPython: SSD1306 OLED Display Scroll Functions and Draw Shapes (ESP32/ESP8266)</h2>
This guide shows additional functions to control an OLED display with MicroPython using the ESP32 or ESP8266. You'll learn how to scroll the entire screen horizontally and vertically and how to draw shapes.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-ESP8266-SSD1306-OLED-MicroPython-Shapes-Scroll.jpg">
We recommend that you follow this getting started guide for the OLED display with MicroPython, first: <a href="https://randomnerdtutorials.com/micropython-oled-display-esp32-esp8266/">MicroPython OLED Display with ESP32 and ESP8266</a>.
<h3>Prerequisites</h3>
To follow this tutorial you need MicroPython firmware installed in your ESP32 or ESP8266 boards. You also need an IDE to write and upload the code to your board. We suggest using Thonny IDE or uPyCraft IDE:
Thonny IDE:
<a href="https://randomnerdtutorials.com/getting-started-thonny-micropython-python-ide-esp32-esp8266/">Installing and getting started with Thonny IDE</a>
<a href="https://randomnerdtutorials.com/flashing-micropython-firmware-esptool-py-esp32-esp8266/">Flashing MicroPython Firmware with esptool.py</a>
uPyCraft IDE:
<a href="https://randomnerdtutorials.com/getting-started-micropython-esp32-esp8266/">Getting Started with uPyCraft IDE</a>
Install uPyCraft IDE (<a href="https://randomnerdtutorials.com/install-upycraft-ide-windows-pc-instructions/">Windows</a>, <a href="https://randomnerdtutorials.com/install-upycraft-ide-mac-os-x-instructions/">Mac OS X</a>, <a href="https://randomnerdtutorials.com/install-upycraft-ide-linux-ubuntu-instructions/">Linux</a>)
<a href="https://randomnerdtutorials.com/flash-upload-micropython-firmware-esp32-esp8266/">Flash/Upload MicroPython Firmware to ESP32 and ESP8266</a>
Learn more about MicroPython: <a href="https://randomnerdtutorials.com/micropython-programming-with-esp32-and-esp8266/">MicroPython Programming with ESP32 and ESP8266 eBook</a>
<h3>Parts Required</h3>
Here's a list of parts you need for this tutorial:
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> or <a href="https://makeradvisor.com/tools/esp8266-esp-12e-nodemcu-wi-fi-development-board/" target="_blank">ESP8266</a> (read <a href="https://makeradvisor.com/esp32-vs-esp8266/" target="_blank">ESP32 vs ESP8266</a>)
<a href="https://makeradvisor.com/tools/oled-display-128x64-0-96-inch/" target="_blank">0.96 inch OLED display</a>
<a style="font-size: inherit; background-color: initial;" href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a>
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="eager" fetchpriority="high" decoding="async"></a>
<h3>Schematic  ESP32</h3>
Follow the next schematic diagram if you're using an ESP32 board:
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/05/ESP32_OLED.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/05/ESP32_OLED.png"></a>
<k>Recommended reading:</k> <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">ESP32 Pinout Reference Guide</a>
<h3>Schematic  ESP8266 NodeMCU</h3>
Follow the next schematic diagram if you're using an ESP8266 NodeMCU board:
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/05/es8266-oled_bb-1.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/05/es8266-oled_bb-1.png"></a>
<k>Recommended reading:</k> <a href="https://randomnerdtutorials.com/esp8266-pinout-reference-gpios/">ESP8266 Pinout Reference Guide</a> 
<h3>SSD1306 OLED Library</h3>
The library to write to the OLED display isn't part of the standard MicroPython library by default. So, you need to upload the library to your ESP32/ESP8266 board. 
<k>#MicroPython SSD1306 OLED driver, I2C and SPI interfaces created by Adafruit
import time
import framebuf
# register definitions
SET_CONTRAST        = const(0x81)
SET_ENTIRE_ON       = const(0xa4)
SET_NORM_INV        = const(0xa6)
SET_DISP            = const(0xae)
SET_MEM_ADDR        = const(0x20)
SET_COL_ADDR        = const(0x21)
SET_PAGE_ADDR       = const(0x22)
SET_DISP_START_LINE = const(0x40)
SET_SEG_REMAP       = const(0xa0)
SET_MUX_RATIO       = const(0xa8)
SET_COM_OUT_DIR     = const(0xc0)
SET_DISP_OFFSET     = const(0xd3)
SET_COM_PIN_CFG     = const(0xda)
SET_DISP_CLK_DIV    = const(0xd5)
SET_PRECHARGE       = const(0xd9)
SET_VCOM_DESEL      = const(0xdb)
SET_CHARGE_PUMP     = const(0x8d)
class SSD1306:
    def __init__(self, width, height, external_vcc):
        self.width = width
        self.height = height
        self.external_vcc = external_vcc
        self.pages = self.height // 8
        # Note the subclass must initialize self.framebuf to a framebuffer.
        # This is necessary because the underlying data buffer is different
        # between I2C and SPI implementations (I2C needs an extra byte).
        self.poweron()
        self.init_display()
    def init_display(self):
        for cmd in (
            SET_DISP | 0x00, # off
            # address setting
            SET_MEM_ADDR, 0x00, # horizontal
            # resolution and layout
            SET_DISP_START_LINE | 0x00,
            SET_SEG_REMAP | 0x01, # column addr 127 mapped to SEG0
            SET_MUX_RATIO, self.height - 1,
            SET_COM_OUT_DIR | 0x08, # scan from COM[N] to COM0
            SET_DISP_OFFSET, 0x00,
            SET_COM_PIN_CFG, 0x02 if self.height == 32 else 0x12,
            # timing and driving scheme
            SET_DISP_CLK_DIV, 0x80,
            SET_PRECHARGE, 0x22 if self.external_vcc else 0xf1,
            SET_VCOM_DESEL, 0x30, # 0.83*Vcc
            # display
            SET_CONTRAST, 0xff, # maximum
            SET_ENTIRE_ON, # output follows RAM contents
            SET_NORM_INV, # not inverted
            # charge pump
            SET_CHARGE_PUMP, 0x10 if self.external_vcc else 0x14,
            SET_DISP | 0x01): # on
            self.write_cmd(cmd)
        self.fill(0)
        self.show()
    def poweroff(self):
        self.write_cmd(SET_DISP | 0x00)
    def contrast(self, contrast):
        self.write_cmd(SET_CONTRAST)
        self.write_cmd(contrast)
    def invert(self, invert):
        self.write_cmd(SET_NORM_INV | (invert & 1))
    def show(self):
        x0 = 0
        x1 = self.width - 1
        if self.width == 64:
            # displays with width of 64 pixels are shifted by 32
            x0 += 32
            x1 += 32
        self.write_cmd(SET_COL_ADDR)
        self.write_cmd(x0)
        self.write_cmd(x1)
        self.write_cmd(SET_PAGE_ADDR)
        self.write_cmd(0)
        self.write_cmd(self.pages - 1)
        self.write_framebuf()
    def fill(self, col):
        self.framebuf.fill(col)
    def pixel(self, x, y, col):
        self.framebuf.pixel(x, y, col)
    def scroll(self, dx, dy):
        self.framebuf.scroll(dx, dy)
    def text(self, string, x, y, col=1):
        self.framebuf.text(string, x, y, col)
class SSD1306_I2C(SSD1306):
    def __init__(self, width, height, i2c, addr=0x3c, external_vcc=False):
        self.i2c = i2c
        self.addr = addr
        self.temp = bytearray(2)
        # Add an extra byte to the data buffer to hold an I2C data/command byte
        # to use hardware-compatible I2C transactions.  A memoryview of the
        # buffer is used to mask this byte from the framebuffer operations
        # (without a major memory hit as memoryview doesn't copy to a separate
        # buffer).
        self.buffer = bytearray(((height // 8) * width) + 1)
        self.buffer[0] = 0x40  # Set first byte of data buffer to Co=0, D/C=1
        self.framebuf = framebuf.FrameBuffer1(memoryview(self.buffer)[1:], width, height)
        super().__init__(width, height, external_vcc)
    def write_cmd(self, cmd):
        self.temp[0] = 0x80 # Co=1, D/C#=0
        self.temp[1] = cmd
        self.i2c.writeto(self.addr, self.temp)
    def write_framebuf(self):
        # Blast out the frame buffer using a single I2C transaction to support
        # hardware I2C interfaces.
        self.i2c.writeto(self.addr, self.buffer)
    def poweron(self):
        pass
class SSD1306_SPI(SSD1306):
    def __init__(self, width, height, spi, dc, res, cs, external_vcc=False):
        self.rate = 10 * 1024 * 1024
        dc.init(dc.OUT, value=0)
        res.init(res.OUT, value=0)
        cs.init(cs.OUT, value=1)
        self.spi = spi
        self.dc = dc
        self.res = res
        self.cs = cs
        self.buffer = bytearray((height // 8) * width)
        self.framebuf = framebuf.FrameBuffer1(self.buffer, width, height)
        super().__init__(width, height, external_vcc)
    def write_cmd(self, cmd):
        self.spi.init(baudrate=self.rate, polarity=0, phase=0)
        self.cs.high()
        self.dc.low()
        self.cs.low()
        self.spi.write(bytearray([cmd]))
        self.cs.high()
    def write_framebuf(self):
        self.spi.init(baudrate=self.rate, polarity=0, phase=0)
        self.cs.high()
        self.dc.high()
        self.cs.low()
        self.spi.write(self.buffer)
        self.cs.high()
    def poweron(self):
        self.res.high()
        time.sleep_ms(1)
        self.res.low()
        time.sleep_ms(10)
        self.res.high()</k>
<a href="https://github.com/RuiSantosdotme/ESP-MicroPython/raw/master/code/Others/OLED/ssd1306.py" target="_blank">View raw code</a>
Follow the next set of instructions for the IDE you're using:
A. Upload OLED library with <k>uPyCraft IDE</k>
B. Upload OLED library with <k>Thonny IDE</k>
<h3>A. Upload OLED library with uPyCraft IDE</h3>
This section shows how to upload a library using uPyCraft IDE. If you're using Thonny IDE, read the next section.
<k>1.</k> Create a new file by pressing the <k>New File</k> button.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/10/uPycraft-ide-tools-menu-new-file.png">
<k>2.</k> Copy the OLED library code into that file. The <a href="https://raw.githubusercontent.com/RuiSantosdotme/ESP-MicroPython/master/code/Others/OLED/ssd1306.py" target="_blank" aria-label=" (opens in a new tab)">OLED library code can be found here</a>.
<k>Note:</k> the SSD1306 OLED display library was built by Adafruit and will no longer
be updated. At the moment, it works fine. However, we'll update this guide if we
find a similar library that works as well as this one.
<k>3.</k> After copying the code, save the file by pressing the <k>Save </k>button.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/10/uPycraft-ide-tools-menu-save-file.png">
<k>4.</k> Call this new file <k>ssd1306.py</k> and press <k>ok</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/05/install_ssd1306.png">
<k>5.</k> Click the <k>Download and Run</k> button.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/10/download-run.png">
The file should be saved on the device folder with the name <k>ssd1306.py</k> as
highlighted in the following figure.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/05/ssd1306_installed.png">
Now, you can use the library functionalities in your code by importing the library.
<h3>B. Upload OLED library with Thonny IDE</h3>
If you're using Thonny IDE, follow the next steps:
<k>1.</k> Copy the library code to a new file. The <a href="https://raw.githubusercontent.com/RuiSantosdotme/ESP-MicroPython/master/code/Others/OLED/ssd1306.py" target="_blank">OLED library code can be found here</a>.
<k>2</k>. Save that file as <em>ssd1306.py</em>.
<k>3.</k> Go to <k>Device </k>> <k>Upload current script with the current name</k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/05/upload-current-script-with-current-name-oled.png">
And that's it. The library was uploaded to your board. To make sure that it was uploaded successfully, in the Shell you can type:
<k>%lsdevice</k>
It should return the files currently saved on your board. One of them should be the <em>ssd1306.py</em> file.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/05/lsdevice.png">
After uploading the library to your board, you can use the library functionalities in your code by importing the library.
<h3>MicroPython OLED Scroll Functions</h3>
The ss1306.py library comes with a scroll(x, y) function. It scroll x number of pixels to the right and y number of pixels down.
<h3>Scroll OLED Screen Horizontally</h3>
Sometimes you want to display different screens on the OLED display. For example, the first screen shows sensor readings, and the second screen shows GPIO states. 
<h4>Scroll in horizontally</h4>
The following function scroll_in_screen(screen) scrolls the content of an entire screen (right to left).
<k>def scroll_in_screen(screen):
  for i in range (0, oled_width+1, 4):
    for line in screen:
      oled.text(line[2], -oled_width+i, line[1])
    oled.show()
    if i!= oled_width:
      oled.fill(0)</k>
This function accepts as argument a list of lists. For example:
<k>screen1 = [[0, 0 , screen1_row1], [0, 16, screen1_row2], [0, 32, screen1_row3]]</k>
Each list of the list contains the x coordinate, the y coordinate and the message [x, y, message].
As an example, we'll display three rows on the first screen with the following messages.
<k>screen1_row1 = "Screen 1, row 1"
screen1_row2 = "Screen 1, row 2"
screen1_row3 = "Screen 1, row 3"</k>
Then, to make your screen scrolling from left to right, you just need to call the scroll_in_screen() function and pass as argument the list of lists:
<k>scroll_in_screen(screen1)</k>
You'll get something as follows:

<h4>Scroll out horizontally</h4>
To make the screen scroll out, you can use the scroll_out_screen(speed) function that scrolls the entire screen out of the OLED. It accepts as argument a number that controls the scrolling speed. The speed must be a divisor of 128 (oled_width)
<k>def scroll_out_screen(speed):
  for i in range ((oled_width+1)/speed):
    for j in range (oled_height):
      oled.pixel(i, j, 0)
    oled.scroll(speed,0)
    oled.show()</k>

Now, you can use both functions to scroll between screens. For example:
<k>scroll_in_screen(screen1)
scroll_out_screen(4)
scroll_in_screen(screen2)
scroll_out_screen(4)</k>
<h4>Continuous horizontal scroll</h4>
If you want to scroll the screen in and out continuously, you can use the scroll_screen_in_out(screen) function instead.
<k>def scroll_screen_in_out(screen):
  for i in range (0, (oled_width+1)*2, 1):
    for line in screen:
      oled.text(line[2], -oled_width+i, line[1])
    oled.show()
    if i!= oled_width:
      oled.fill(0)</k>
You can use this function to scroll between screens, or to scroll the same screen over and over again. 
<k>scroll_screen_in_out(screen1)
scroll_screen_in_out(screen2)
scroll_screen_in_out(screen3)</k>

<h3>Scroll OLED Screen Vertically</h3>
We also created similar functions to scroll the screen vertically.
<h4>Scroll in vertically</h4>
The scroll_in_screen_v(screen) scrolls in the content of the entire screen.
<k>def scroll_in_screen_v(screen):
  for i in range (0, (oled_height+1), 1):
    for line in screen:
      oled.text(line[2], line[0], -oled_height+i+line[1])
    oled.show()
    if i!= oled_height:
      oled.fill(0)</k>

<h4> Scroll out vertically</h4>
You can use the scroll_out_screen_v(speed) function to scroll out the screen vertically. Similarly to the horizontal function, it accepts as argument, the scrolling speed that must be a number divisor of 64 (oled_height).
<k>def scroll_out_screen_v(speed):
  for i in range ((oled_height+1)/speed):
    for j in range (oled_width):
      oled.pixel(j, i, 0)
    oled.scroll(0,speed)
    oled.show()</k>

<h4>Continuous vertical scroll</h4>
If you want to scroll the screen in and out vertically continuously, you can use the scroll_in_out_screen_v(screen) function.
<k>def scroll_screen_in_out_v(screen):
  for i in range (0, (oled_height*2+1), 1):
    for line in screen:
      oled.text(line[2], line[0], -oled_height+i+line[1])
    oled.show()
    if i!= oled_height:
      oled.fill(0)</k>

<h3>Scroll OLED Screen MicroPython Script</h3>
The following script applies all the functions we've described previously. You can upload the following code to your board to see all the scrolling effects.
<k># Complete project details at https://RandomNerdTutorials.com/micropython-ssd1306-oled-scroll-shapes-esp32-esp8266/
from machine import Pin, SoftI2C
import ssd1306
from time import sleep
# ESP32 Pin assignment
i2c = SoftI2C(scl=Pin(22), sda=Pin(21))
# ESP8266 Pin assignment
#i2c = SoftI2C(scl=Pin(5), sda=Pin(4))
oled_width = 128
oled_height = 64
oled = ssd1306.SSD1306_I2C(oled_width, oled_height, i2c)
screen1_row1 = "Screen 1, row 1"
screen1_row2 = "Screen 1, row 2"
screen1_row3 = "Screen 1, row 3"
screen2_row1 = "Screen 2, row 1"
screen2_row2 = "Screen 2, row 2"
screen3_row1 = "Screen 3, row 1"
screen1 = [[0, 0 , screen1_row1], [0, 16, screen1_row2], [0, 32, screen1_row3]]
screen2 = [[0, 0 , screen2_row1], [0, 16, screen2_row2]]
screen3 = [[0, 40 , screen3_row1]]
# Scroll in screen horizontally from left to right
def scroll_in_screen(screen):
  for i in range (0, oled_width+1, 4):
    for line in screen:
      oled.text(line[2], -oled_width+i, line[1])
    oled.show()
    if i!= oled_width:
      oled.fill(0)
# Scroll out screen horizontally from left to right
def scroll_out_screen(speed):
  for i in range ((oled_width+1)/speed):
    for j in range (oled_height):
      oled.pixel(i, j, 0)
    oled.scroll(speed,0)
    oled.show()
# Continuous horizontal scroll
def scroll_screen_in_out(screen):
  for i in range (0, (oled_width+1)*2, 1):
    for line in screen:
      oled.text(line[2], -oled_width+i, line[1])
    oled.show()
    if i!= oled_width:
      oled.fill(0)
# Scroll in screen vertically
def scroll_in_screen_v(screen):
  for i in range (0, (oled_height+1), 1):
    for line in screen:
      oled.text(line[2], line[0], -oled_height+i+line[1])
    oled.show()
    if i!= oled_height:
      oled.fill(0)
# Scroll out screen vertically
def scroll_out_screen_v(speed):
  for i in range ((oled_height+1)/speed):
    for j in range (oled_width):
      oled.pixel(j, i, 0)
    oled.scroll(0,speed)
    oled.show()
# Continous vertical scroll
def scroll_screen_in_out_v(screen):
  for i in range (0, (oled_height*2+1), 1):
    for line in screen:
      oled.text(line[2], line[0], -oled_height+i+line[1])
    oled.show()
    if i!= oled_height:
      oled.fill(0)
while True:
  # Scroll in, stop, scroll out (horizontal)
  scroll_in_screen(screen1)
  sleep(2)
  scroll_out_screen(4)
  scroll_in_screen(screen2)
  sleep(2)
  scroll_out_screen(4)
  scroll_in_screen(screen3)
  sleep(2)
  scroll_out_screen(4)
  # Continuous horizontal scroll
  scroll_screen_in_out(screen1)
  scroll_screen_in_out(screen2)
  scroll_screen_in_out(screen3)
  # Scroll in, stop, scroll out (vertical)
  scroll_in_screen_v(screen1)
  sleep(2)
  scroll_out_screen_v(4)
  scroll_in_screen_v(screen2)
  sleep(2)
  scroll_out_screen_v(4)
  scroll_in_screen_v(screen3)
  sleep(2)
  scroll_out_screen_v(4)
  # Continuous verticall scroll
  scroll_screen_in_out_v(screen1)
  scroll_screen_in_out_v(screen2)
  scroll_screen_in_out_v(screen3)
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP-MicroPython/oled/screen_scroll.py" target="_blank">View raw code</a>
<h3>MicroPython OLED Draw Shapes</h3>
To draw shapes on the OLED display using MicroPython we'll use the Adafruit_GFX MicroPython Library.
<h3>Adafruit GFX Library</h3>
To draw shapes on the OLED display, we'll use the <a href="https://github.com/adafruit/micropython-adafruit-gfx/blob/master/gfx.py" target="_blank" aria-label=" (opens in a new tab)">Adafruit GFX Library</a>. This library isn't part of the standard MicroPython library by default. So, you need to upload the library to your ESP32/ESP8266 board. 
<k># Port of Adafruit GFX Arduino library to MicroPython.
# Based on: https://github.com/adafruit/Adafruit-GFX-Library
# Author: Tony DiCola (original GFX author Phil Burgess)
# License: MIT License (https://opensource.org/licenses/MIT)
class GFX:
    def __init__(self, width, height, pixel, hline=None, vline=None):
        # Create an instance of the GFX drawing class.  You must pass in the
        # following parameters:
        #  - width = The width of the drawing area in pixels.
        #  - height = The height of the drawing area in pixels.
        #  - pixel = A function to call when a pixel is drawn on the display.
        #            This function should take at least an x and y position
        #            and then any number of optional color or other parameters.
        #  You can also provide the following optional keyword argument to
        #  improve the performance of drawing:
        #  - hline = A function to quickly draw a horizontal line on the display.
        #            This should take at least an x, y, and width parameter and
        #            any number of optional color or other parameters.
        #  - vline = A function to quickly draw a vertical line on the display.
        #            This should take at least an x, y, and height paraemter and
        #            any number of optional color or other parameters.
        self.width = width
        self.height = height
        self._pixel = pixel
        # Default to slow horizontal & vertical line implementations if no
        # faster versions are provided.
        if hline is None:
            self.hline = self._slow_hline
        else:
            self.hline = hline
        if vline is None:
            self.vline = self._slow_vline
        else:
            self.vline = vline
    def _slow_hline(self, x0, y0, width, *args, **kwargs):
        # Slow implementation of a horizontal line using pixel drawing.
        # This is used as the default horizontal line if no faster override
        # is provided.
        if y0 &lt; 0 or y0 > self.height or x0 &lt; -width or x0 > self.width:
            return
        for i in range(width):
            self._pixel(x0+i, y0, *args, **kwargs)
    def _slow_vline(self, x0, y0, height, *args, **kwargs):
        # Slow implementation of a vertical line using pixel drawing.
        # This is used as the default vertical line if no faster override
        # is provided.
        if y0 &lt; -height or y0 > self.height or x0 &lt; 0 or x0 > self.width:
            return
        for i in range(height):
            self._pixel(x0, y0+i, *args, **kwargs)
    def rect(self, x0, y0, width, height, *args, **kwargs):
        # Rectangle drawing function.  Will draw a single pixel wide rectangle
        # starting in the upper left x0, y0 position and width, height pixels in
        # size.
        if y0 &lt; -height or y0 > self.height or x0 &lt; -width or x0 > self.width:
            return
        self.hline(x0, y0, width, *args, **kwargs)
        self.hline(x0, y0+height-1, width, *args, **kwargs)
        self.vline(x0, y0, height, *args, **kwargs)
        self.vline(x0+width-1, y0, height, *args, **kwargs)
    def fill_rect(self, x0, y0, width, height, *args, **kwargs):
        # Filled rectangle drawing function.  Will draw a single pixel wide
        # rectangle starting in the upper left x0, y0 position and width, height
        # pixels in size.
        if y0 &lt; -height or y0 > self.height or x0 &lt; -width or x0 > self.width:
            return
        for i in range(x0, x0+width):
            self.vline(i, y0, height, *args, **kwargs)
    def line(self, x0, y0, x1, y1, *args, **kwargs):
        # Line drawing function.  Will draw a single pixel wide line starting at
        # x0, y0 and ending at x1, y1.
        steep = abs(y1 - y0) > abs(x1 - x0)
        if steep:
            x0, y0 = y0, x0
            x1, y1 = y1, x1
        if x0 > x1:
            x0, x1 = x1, x0
            y0, y1 = y1, y0
        dx = x1 - x0
        dy = abs(y1 - y0)
        err = dx // 2
        ystep = 0
        if y0 &lt; y1:
            ystep = 1
        else:
            ystep = -1
        while x0 &lt;= x1:
            if steep:
                self._pixel(y0, x0, *args, **kwargs)
            else:
                self._pixel(x0, y0, *args, **kwargs)
            err -= dy
            if err &lt; 0:
                y0 += ystep
                err += dx
            x0 += 1
    def circle(self, x0, y0, radius, *args, **kwargs):
        # Circle drawing function.  Will draw a single pixel wide circle with
        # center at x0, y0 and the specified radius.
        f = 1 - radius
        ddF_x = 1
        ddF_y = -2 * radius
        x = 0
        y = radius
        self._pixel(x0, y0 + radius, *args, **kwargs)
        self._pixel(x0, y0 - radius, *args, **kwargs)
        self._pixel(x0 + radius, y0, *args, **kwargs)
        self._pixel(x0 - radius, y0, *args, **kwargs)
        while x &lt; y:
            if f >= 0:
                y -= 1
                ddF_y += 2
                f += ddF_y
            x += 1
            ddF_x += 2
            f += ddF_x
            self._pixel(x0 + x, y0 + y, *args, **kwargs)
            self._pixel(x0 - x, y0 + y, *args, **kwargs)
            self._pixel(x0 + x, y0 - y, *args, **kwargs)
            self._pixel(x0 - x, y0 - y, *args, **kwargs)
            self._pixel(x0 + y, y0 + x, *args, **kwargs)
            self._pixel(x0 - y, y0 + x, *args, **kwargs)
            self._pixel(x0 + y, y0 - x, *args, **kwargs)
            self._pixel(x0 - y, y0 - x, *args, **kwargs)
    def fill_circle(self, x0, y0, radius, *args, **kwargs):
        # Filled circle drawing function.  Will draw a filled circule with
        # center at x0, y0 and the specified radius.
        self.vline(x0, y0 - radius, 2*radius + 1, *args, **kwargs)
        f = 1 - radius
        ddF_x = 1
        ddF_y = -2 * radius
        x = 0
        y = radius
        while x &lt; y:
            if f >= 0:
                y -= 1
                ddF_y += 2
                f += ddF_y
            x += 1
            ddF_x += 2
            f += ddF_x
            self.vline(x0 + x, y0 - y, 2*y + 1, *args, **kwargs)
            self.vline(x0 + y, y0 - x, 2*x + 1, *args, **kwargs)
            self.vline(x0 - x, y0 - y, 2*y + 1, *args, **kwargs)
            self.vline(x0 - y, y0 - x, 2*x + 1, *args, **kwargs)
    def triangle(self, x0, y0, x1, y1, x2, y2, *args, **kwargs):
        # Triangle drawing function.  Will draw a single pixel wide triangle
        # around the points (x0, y0), (x1, y1), and (x2, y2).
        self.line(x0, y0, x1, y1, *args, **kwargs)
        self.line(x1, y1, x2, y2, *args, **kwargs)
        self.line(x2, y2, x0, y0, *args, **kwargs)
    def fill_triangle(self, x0, y0, x1, y1, x2, y2, *args, **kwargs):
        # Filled triangle drawing function.  Will draw a filled triangle around
        # the points (x0, y0), (x1, y1), and (x2, y2).
        if y0 > y1:
            y0, y1 = y1, y0
            x0, x1 = x1, x0
        if y1 > y2:
            y2, y1 = y1, y2
            x2, x1 = x1, x2
        if y0 > y1:
            y0, y1 = y1, y0
            x0, x1 = x1, x0
        a = 0
        b = 0
        y = 0
        last = 0
        if y0 == y2:
            a = x0
            b = x0
            if x1 &lt; a:
                a = x1
            elif x1 > b:
                b = x1
            if x2 &lt; a:
                a = x2
            elif x2 > b:
                b = x2
            self.hline(a, y0, b-a+1, *args, **kwargs)
            return
        dx01 = x1 - x0
        dy01 = y1 - y0
        dx02 = x2 - x0
        dy02 = y2 - y0
        dx12 = x2 - x1
        dy12 = y2 - y1
        if dy01 == 0:
            dy01 = 1
        if dy02 == 0:
            dy02 = 1
        if dy12 == 0:
            dy12 = 1
        sa = 0
        sb = 0
        if y1 == y2:
            last = y1
        else:
            last = y1-1
        for y in range(y0, last+1):
            a = x0 + sa // dy01
            b = x0 + sb // dy02
            sa += dx01
            sb += dx02
            if a > b:
                a, b = b, a
            self.hline(a, y, b-a+1, *args, **kwargs)
        sa = dx12 * (y - y1)
        sb = dx02 * (y - y0)
        while y &lt;= y2:
            a = x1 + sa // dy12
            b = x0 + sb // dy02
            sa += dx12
            sb += dx02
            if a > b:
                a, b = b, a
            self.hline(a, y, b-a+1, *args, **kwargs)
            y += 1</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP-MicroPython/oled/gfx.py" target="_blank">View raw code</a>
Follow the previous instructions on how to install a library, but for the GFX library. Save the GFX library file as <em>gfx.py</em>. Then, you can use the library functionalities by importing the library in your code.
In summary, here's how to draw shapes. First, you need to include the ssd1306 and gfx libraries as well as the Pin and SoftI2C modules.
<k>from machine import Pin, SoftI2C
import ssd1306
from time import sleep
import gfx</k>
Then, define the pins for the ESP32.
<k>i2c = SoftI2C(scl=Pin(22), sda=Pin(21))</k>
If you're using an ESP8266, use the following pins instead:
<k>i2c = SoftI2C(scl=Pin(5), sda=Pin(4))</k>
We're using a 12864 OLED display. If you're using an OLED display with different dimensions, change that on the following lines:
<k>oled_width = 128
oled_height = 64</k>
Create an ss1306 object called oled.
<k>oled = ssd1306.SSD1306_I2C(oled_width, oled_height, i2c)</k>
Then, we need to create a gfx object to draw shapes. In this case, it's called graphics. It takes as arguments, the width and height of the drawing area. In this case, we want to draw in the entire OLED, so we pass the OLED width and height. We should also pass as argument one function of our display that draws pixels, in our case is oled.pixel.
<k>graphics = gfx.GFX(oled_width, oled_height, oled.pixel)</k>
Then, you can use the drawing functions we'll show you next to display shapes.
<h3>Draw a Line</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/05/ESP32-ESP8266-Arduino-OLED-Display-Line.jpg">
Use the line(x0, y0, x1, y1, color) method on the gfx object to create a line. The (x0, y0) coordinates indicate the start of the line, and the (x1, y1) coordinates indicate where the line ends. You always need to call oled.show() to actually display the shapes on the OLED. Here's an example:
<k>graphics.line(0, 0, 127, 20, 1)
oled.show()</k>
<h3>Rectangle</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/05/ESP32-ESP8266-Arduino-OLED-Display-Rectangle.jpg">
To draw a rectangle, you can use the rect(x0, y0, width, height, color) method on the gfx object. The (x0, y0) coordinates indicate the top left corner of the rectangle. Then, you need to specify the width, height and color of the rectangle. For example:
<k>graphics.rect(10, 10, 50, 30, 1)
oled.show()</k>
<h3>Filled Rectangle</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/05/ESP32-ESP8266-Arduino-OLED-Display-Filled.jpg">
You can use the fill_rect(x0, y0, width, height, color) method to draw a filled rectangle. This method accepts the same arguments as drawRect().
<k>graphics.rect(10, 10, 50, 30, 1)
oled.show()</k>
<h3>Circle</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/05/ESP32-ESP8266-Arduino-OLED-Display-Circle.jpg">
Draw a circle using the circle(x0, y0, radius, color) method. The (x0, y0) coordinates indicate the center of the circle. Here's an example:
<k>graphics.circle(64, 32, 10, 1)
oled.show()</k>
<h3>Filled Circle</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/05/ESP32-ESP8266-Arduino-OLED-Display-Circle-Filled.jpg">
Draw a filled circle using the fill_circle(x0, y0, radius, color) method.
<k>graphics.fill_circle(64, 32, 10, 1)
oled.show()</k>
<h3>Triangle</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/05/ESP32-ESP8266-Arduino-OLED-Display-Triangle.jpg">
There's also a method to draw a triangle: triangle(x0, y0, x1, y1, x2, y2, color). This method accepts as arguments the coordinates of each corner and the color.
<k>graphics.triangle(10,10,55,20,5,40,1)
oled.show()</k>
<h3>Filled Triangle</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/05/ESP32-ESP8266-Arduino-OLED-Display-Triangle-Filled.jpg">
Use the fill_triangle(x0, y0, x1, y1, x2, y2, color) method to draw a filled triangle.
<k>graphics.fill_triangle(10,10,55,20,5,40,1)
oled.show()</k>
<h3>MicroPython Script  Draw Shapes</h3>
The following script implements all the drawing methods shown previously.
<k># Complete project details at https://RandomNerdTutorials.com/micropython-ssd1306-oled-scroll-shapes-esp32-esp8266/
from machine import Pin, SoftI2C
import ssd1306
from time import sleep
import gfx
# ESP32 Pin assignment
i2c = SoftI2C(scl=Pin(22), sda=Pin(21))
# ESP8266 Pin assignment
#i2c = SoftI2C(scl=Pin(5), sda=Pin(4))
oled_width = 128
oled_height = 64
oled = ssd1306.SSD1306_I2C(oled_width, oled_height, i2c)
graphics = gfx.GFX(oled_width, oled_height, oled.pixel)
while True:
  graphics.line(0, 0, 127, 20, 1)
  oled.show()
  sleep(1)
  oled.fill(0)
  graphics.rect(10, 10, 50, 30, 1)
  oled.show()
  sleep(1)
  oled.fill(0)
  graphics.fill_rect(10, 10, 50, 30, 1)
  oled.show()
  sleep(1)
  oled.fill(0)
  graphics.circle(64, 32, 10, 1)
  oled.show()
  sleep(1)
  oled.fill(0)
  graphics.fill_circle(64, 32, 10, 1)
  oled.show()
  sleep(1)
  oled.fill(0)
  graphics.triangle(10,10,55,20,5,40,1)
  oled.show()
  sleep(1)
  oled.fill(0)
  graphics.fill_triangle(10,10,55,20,5,40,1)
  oled.show()
  sleep(1)
  oled.fill(0)
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP-MicroPython/oled/draw_shapes.py" target="_blank">View raw code</a>
<h3>Wrapping Up</h3>
In this tutorial you've learned how to use more advanced functions to scroll the OLED screen and draw shapes using MicroPython with the ESP32 or ESP8266. To draw shapes you need to import the Adafruit GFX MicroPython library.
We hope you've found this tutorial useful. If this is your first time dealing with the OLED display using MicroPython, we recommend following the getting started guide first:
<a href="https://randomnerdtutorials.com/micropython-oled-display-esp32-esp8266/">MicroPython: OLED Display with ESP32 and ESP8266</a>
We have a similar tutorials, but using Arduino IDE: 
<a href="https://randomnerdtutorials.com/esp32-ssd1306-oled-display-arduino-ide/">ESP32 OLED Display with Arduino IDE</a>
<a href="https://randomnerdtutorials.com/esp8266-0-96-inch-oled-display-with-arduino-ide/">ESP8266 OLED Display with Arduino IDE</a>
<h2>ESP32 MQTT  Publish DHT11/DHT22 Temperature and Humidity Readings (Arduino IDE)</a8></h2>
Learn how to publish temperature and humidity readings from a DHT11 or DHT22 sensor via MQTT with the ESP32 to any platform that supports MQTT or any MQTT client. As an example, we'll publish sensor readings to Node-RED Dashboard and the ESP32 will be programmed using Arduino IDE.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-DHT11-DHT22-Temperature-Humidity-Sensor-MQTT-Publish-Arduino-IDE-Node-RED.jpg">
<k>Recommended reading:</k> <a href="https://randomnerdtutorials.com/what-is-mqtt-and-how-it-works/">What is MQTT and How It Works</a>
<h3>Project Overview</h3>
The following diagram shows a high-level overview of the project we'll build.
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-MQTT-DHT11-DHT22-Node-RED.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-MQTT-DHT11-DHT22-Node-RED.png"></a>
The ESP32 requests temperature and humidity readings from the DHT11 or DHT22 sensor;
Temperature readings are published in the <k>esp32/dht/temperature</k> topic;
Humidity readings are published in the <k>esp32/dht/humidity</k> topic;
Node-RED is subscribed those topics;
Node-RED receives the sensor readings and displays them on gauges;
You can receive the readings in any other platform that supports MQTT and handle the readings as you want.
<h3>Prerequisites</h3>
Before proceeding with this tutorial, make sure you check the following prerequisites.
<h3>Arduino IDE</h3>
We'll program the ESP32 using Arduino IDE, so make sure you have the ESP32 add-on installed.
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<h3>MQTT Broker</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/01/mosquitto-broker.png">
To use MQTT, you need a broker. We'll be using <a href="https://mosquitto.org/" target="_blank" aria-label=" (opens in a new tab)">Mosquitto broker</a> installed on a Raspberry Pi. Read <a href="https://randomnerdtutorials.com/how-to-install-mosquitto-broker-on-raspberry-pi/" target="_blank">How to Install Mosquitto Broker on Raspberry Pi</a>.
You can use any other MQTT broker, including a cloud MQTT broker. We'll show you how to do that in the code later on.
If you're not familiar with MQTT make sure you read our introductory tutorial: <a href="https://randomnerdtutorials.com/what-is-mqtt-and-how-it-works/" target="_blank">What is MQTT and How It Works</a>.
<h3>MQTT Libraries</h3>
To use MQTT with the ESP32 we'll use the <a href="https://github.com/marvinroger/async-mqtt-client" target="_blank" aria-label=" (opens in a new tab)">Async MQTT Client Library</a>.
<k>Installing the Async MQTT Client Library</k>
<ol>
<a href="https://github.com/marvinroger/async-mqtt-client/archive/master.zip" target="_blank" aria-label=" (opens in a new tab)">Click here to download the Async MQTT client library</a>. You should have a .zip folder in your Downloads folder
Unzip the .zip folder and you should get <k>async-mqtt-client-master</k> folder
Rename your folder from <del><k>async-mqtt-client-master</k></del> to <k>async_mqtt_client</k>
Move the <k>async_mqtt_client</k> folder to your Arduino IDE installation libraries folder
Finally, re-open your Arduino IDE
</ol>
Alternatively, you can go to <k>Sketch </k>> <k>Include Library</k> > <k>Add . ZIP</k> library and select the library you've just downloaded.
<k>Installing the Async TCP Library</k>
To use MQTT with the ESP, you also need the <a href="https://github.com/me-no-dev/AsyncTCP" target="_blank" aria-label=" (opens in a new tab)">Async TCP library</a>.
<ol>
<a href="https://github.com/me-no-dev/AsyncTCP/archive/master.zip" target="_blank" aria-label=" (opens in a new tab)">Click here to download the Async TCP client library</a>. You should have a .zip folder in your Downloads folder
Unzip the .zip folder and you should get <k>AsyncTCP-master</k> folder
Rename your folder from <del><k>AsyncTCP-master</k></del> to <k>AsyncTCP</k>
Move the <k>AsyncTCP </k>folder to your Arduino IDE installation libraries folder
Finally, re-open your Arduino IDE
</ol>
Alternatively, you can go to <k>Sketch </k>> <k>Include Library</k> > <k>Add . ZIP</k> library and select the library you've just downloaded. 
<h3>DHT Sensor Libraries</h3>
To read from the DHT sensor, we'll use the <a href="https://github.com/adafruit/DHT-sensor-library" target="_blank">DHT library from Adafruit</a>. To use this library you also need to install the <a href="https://github.com/adafruit/Adafruit_Sensor" target="_blank">Adafruit Unified Sensor library</a>. Follow the next steps to install those libraries.
1. Open your Arduino IDE and go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k>. The Library Manager should open.
2. Search for <k>DHT</k> on the Search box and install the DHT library from Adafruit.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/04/adafruit_dht_library.png">
3. After installing the DHT library from Adafruit, type <k>Adafruit Unified Sensor</k> in the search box. Scroll all the way down to find the library and install it.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/04/adafruit_unified_sensor_library.png">
After installing the libraries, restart your Arduino IDE.
To learn more about the DHT11 or DHT22 temperature sensor, read our guide: <a href="https://randomnerdtutorials.com/esp32-dht11-dht22-temperature-humidity-sensor-arduino-ide/">ESP32 with DHT11/DHT22 Temperature and Humidity Sensor using Arduino IDE</a>
<h3>Parts Required</h3>
For this tutorial you need the following parts:
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> (read <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">Best ESP32 development boards</a>)
<a aria-label="DHT11 (opens in a new tab)" href="https://makeradvisor.com/tools/dht11-temperature-humidity-sensor/" target="_blank">DHT11</a> or <a aria-label="DHT22 (opens in a new tab)" href="https://makeradvisor.com/tools/dht22-temperature-humidity-sensor/" target="_blank">DHT22</a>  <a href="https://randomnerdtutorials.com/esp32-dht11-dht22-temperature-humidity-sensor-arduino-ide/">DHT with ESP32 Guide</a>
<a aria-label="4.7k Ohm resistor (opens in a new tab)" href="https://makeradvisor.com/tools/resistors-kits/" target="_blank">4.7k Ohm resistor</a>
<a href="https://makeradvisor.com/raspberry-pi-board/" target="_blank">Raspberry Pi board</a> (read <a href="https://makeradvisor.com/best-raspberry-pi-starter-kits/" target="_blank">Best Raspberry Pi Starter Kits</a>)
<a href="https://makeradvisor.com/tools/microsd-card-raspberry-pi-16gb-class-10/" target="_blank">MicroSD Card  16GB Class10</a>
<a href="https://makeradvisor.com/tools/raspberry-pi-power-supply/" target="_blank">Raspberry Pi Power Supply (5V 2.5A)</a> 
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a>
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="lazy" fetchpriority="low"></a>
<h3>Schematic Diagram</h3>
Wire the DHT11 or DHT22 to the ESP32 as shown in the following schematic diagram with the data pin connected to GPIO 4.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/04/dht_esp32_bb.png">
<k>Note: </k> if you have a DHT sensor in a breakout board, it comes with only three pins and with an internal pull-up resistor on pin 2, so you don't need to connect the resistor. You just need to wire VCC, data and GND. 
In this example, we're connecting the DHT data pin to GPIO 4. However, you can use any other suitable digital pin.
Learn how to use the ESP32 GPIOs with our guide: <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">ESP32 Pinout Reference: Which GPIO pins should you use?</a>
<h3>Code</h3>
Copy the following code to your Arduino IDE. To make it work for you, you need to insert your network credentials as well as the MQTT broker details.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-mqtt-publish-dht11-dht22-arduino/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include "DHT.h"
#include &lt;WiFi.h>
extern "C" {
  #include "freertos/FreeRTOS.h"
  #include "freertos/timers.h"
}
#include &lt;AsyncMqttClient.h>
#define WIFI_SSID "REPLACE_WITH_YOUR_SSID"
#define WIFI_PASSWORD "REPLACE_WITH_YOUR_PASSWORD"
// Raspberry Pi Mosquitto MQTT Broker
#define MQTT_HOST IPAddress(192, 168, 1, XXX)
// For a cloud MQTT broker, type the domain name
//#define MQTT_HOST "example.com"
#define MQTT_PORT 1883
// Temperature MQTT Topics
#define MQTT_PUB_TEMP "esp32/dht/temperature"
#define MQTT_PUB_HUM  "esp32/dht/humidity"
// Digital pin connected to the DHT sensor
#define DHTPIN 4  
// Uncomment whatever DHT sensor type you're using
//#define DHTTYPE DHT11   // DHT 11
#define DHTTYPE DHT22   // DHT 22  (AM2302), AM2321
//#define DHTTYPE DHT21   // DHT 21 (AM2301)   
// Initialize DHT sensor
DHT dht(DHTPIN, DHTTYPE);
// Variables to hold sensor readings
float temp;
float hum;
AsyncMqttClient mqttClient;
TimerHandle_t mqttReconnectTimer;
TimerHandle_t wifiReconnectTimer;
unsigned long previousMillis = 0;   // Stores last time temperature was published
const long interval = 10000;        // Interval at which to publish sensor readings
void connectToWifi() {
  Serial.println("Connecting to Wi-Fi...");
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
}
void connectToMqtt() {
  Serial.println("Connecting to MQTT...");
  mqttClient.connect();
}
void WiFiEvent(WiFiEvent_t event) {
  Serial.printf("[WiFi-event] event: %d\n", event);
  switch(event) {
    case SYSTEM_EVENT_STA_GOT_IP:
      Serial.println("WiFi connected");
      Serial.println("IP address: ");
      Serial.println(WiFi.localIP());
      connectToMqtt();
      break;
    case SYSTEM_EVENT_STA_DISCONNECTED:
      Serial.println("WiFi lost connection");
      xTimerStop(mqttReconnectTimer, 0); // ensure we don't reconnect to MQTT while reconnecting to Wi-Fi
      xTimerStart(wifiReconnectTimer, 0);
      break;
  }
}
void onMqttConnect(bool sessionPresent) {
  Serial.println("Connected to MQTT.");
  Serial.print("Session present: ");
  Serial.println(sessionPresent);
}
void onMqttDisconnect(AsyncMqttClientDisconnectReason reason) {
  Serial.println("Disconnected from MQTT.");
  if (WiFi.isConnected()) {
    xTimerStart(mqttReconnectTimer, 0);
  }
}
/*void onMqttSubscribe(uint16_t packetId, uint8_t qos) {
  Serial.println("Subscribe acknowledged.");
  Serial.print("  packetId: ");
  Serial.println(packetId);
  Serial.print("  qos: ");
  Serial.println(qos);
}
void onMqttUnsubscribe(uint16_t packetId) {
  Serial.println("Unsubscribe acknowledged.");
  Serial.print("  packetId: ");
  Serial.println(packetId);
}*/
void onMqttPublish(uint16_t packetId) {
  Serial.print("Publish acknowledged.");
  Serial.print("  packetId: ");
  Serial.println(packetId);
}
void setup() {
  Serial.begin(115200);
  Serial.println();
  dht.begin();
  
  mqttReconnectTimer = xTimerCreate("mqttTimer", pdMS_TO_TICKS(2000), pdFALSE, (void*)0, reinterpret_cast&lt;TimerCallbackFunction_t>(connectToMqtt));
  wifiReconnectTimer = xTimerCreate("wifiTimer", pdMS_TO_TICKS(2000), pdFALSE, (void*)0, reinterpret_cast&lt;TimerCallbackFunction_t>(connectToWifi));
  WiFi.onEvent(WiFiEvent);
  mqttClient.onConnect(onMqttConnect);
  mqttClient.onDisconnect(onMqttDisconnect);
  //mqttClient.onSubscribe(onMqttSubscribe);
  //mqttClient.onUnsubscribe(onMqttUnsubscribe);
  mqttClient.onPublish(onMqttPublish);
  mqttClient.setServer(MQTT_HOST, MQTT_PORT);
  // If your broker requires authentication (username and password), set them below
  //mqttClient.setCredentials("REPlACE_WITH_YOUR_USER", "REPLACE_WITH_YOUR_PASSWORD");
  connectToWifi();
}
void loop() {
  unsigned long currentMillis = millis();
  // Every X number of seconds (interval = 10 seconds) 
  // it publishes a new MQTT message
  if (currentMillis - previousMillis >= interval) {
    // Save the last time a new reading was published
    previousMillis = currentMillis;
    // New DHT sensor readings
    hum = dht.readHumidity();
    // Read temperature as Celsius (the default)
    temp = dht.readTemperature();
    // Read temperature as Fahrenheit (isFahrenheit = true)
    //temp = dht.readTemperature(true);
    // Check if any reads failed and exit early (to try again).
    if (isnan(temp) || isnan(hum)) {
      Serial.println(F("Failed to read from DHT sensor!"));
      return;
    }
    
    // Publish an MQTT message on topic esp32/dht/temperature
    uint16_t packetIdPub1 = mqttClient.publish(MQTT_PUB_TEMP, 1, true, String(temp).c_str());                            
    Serial.printf("Publishing on topic %s at QoS 1, packetId: %i", MQTT_PUB_TEMP, packetIdPub1);
    Serial.printf("Message: %.2f \n", temp);
    // Publish an MQTT message on topic esp32/dht/humidity
    uint16_t packetIdPub2 = mqttClient.publish(MQTT_PUB_HUM, 1, true, String(hum).c_str());                            
    Serial.printf("Publishing on topic %s at QoS 1, packetId %i: ", MQTT_PUB_HUM, packetIdPub2);
    Serial.printf("Message: %.2f \n", hum);
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_MQTT/ESP32_DHT.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
The following section imports all the required libraries.
<k>#include "DHT.h"
#include &lt;WiFi.h>
extern "C" {
  #include "freertos/FreeRTOS.h"
  #include "freertos/timers.h"
}
#include &lt;AsyncMqttClient.h></k>
Include your network credentials on the following lines.
<k>#define WIFI_SSID "REPLACE_WITH_YOUR_SSID"
#define WIFI_PASSWORD "REPLACE_WITH_YOUR_PASSWORD"</k>
Insert the Raspberry Pi IP address, so that the ESP32 connects to your broker.
<k>#define MQTT_HOST IPAddress(192, 168, 1, 106)</k>
If you're using a cloud MQTT broker, insert the broker domain name, for example:
<k>#define MQTT_HOST "example.com"</k>
Define the MQTT port.
<k>#define MQTT_PORT 1883</k>
The temperature and humidity will be published on the following topics:
<k>#define MQTT_PUB_TEMP "esp32/dht/temperature"
#define MQTT_PUB_HUM  "esp32/dht/humidity"</k>
Define the GPIO that the DHT sensor data pin is connected to. In our case, it is connected to GPIO 4.
Uncomment the DHT sensor type you're using. In our example, we're using the DHT22.
<k>//#define DHTTYPE DHT11   // DHT 11
#define DHTTYPE DHT22     // DHT 22 (AM2302), AM2321
//#define DHTTYPE DHT21   // DHT 21 (AM2301)</k>
Initialize the DHT sensor on the pin and type defined earlier.
<k>DHT dht(DHTPIN, DHTTYPE);</k>
The temp and hum variables will hold the temperature and humidity values from the DHT22 sensor.
<k>float temp;
float hum;</k>
Create an AsyncMqttClient object called mqttClient to handle the MQTT client and timers to reconnect to your MQTT broker and router when it disconnects.
<k>AsyncMqttClient mqttClient;
TimerHandle_t mqttReconnectTimer;
TimerHandle_t wifiReconnectTimer;</k>
Then, create some auxiliary timer variables to publish the readings every 10 seconds. You can change the delay time on the interval variable.
<k>unsigned long previousMillis = 0;  // Stores last time temperature was published
const long interval = 10000;       // Interval at which to publish sensor readings</k>
<k>Note: </k> the DHT11 and DHT22 have a low sampling rate. You can only request DHT11 readings every second, or every two seconds for the DHT22.
<h3>MQTT functions: connect to Wi-Fi, connect to MQTT, and Wi-Fi events</h3>
We haven't added any comments to the functions defined in the next code section. Those functions come with the Async Mqtt Client library. The function's names are pretty self-explanatory.
For example, the connectToWifi() connects your ESP32 to your router:
<k>void connectToWifi() {
  Serial.println("Connecting to Wi-Fi...");
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
}</k>
The connectToMqtt() connects your ESP32 to your MQTT broker:
<k>void connectToMqtt() {
  Serial.println("Connecting to MQTT");
  mqttClient.connect();
 }</k>
The WiFiEvent() function is responsible for handling the Wi-Fi events. For example, after a successful connection with the router and MQTT broker, it prints the ESP32 IP address. On the other hand, if the connection is lost, it starts a timer and tries to reconnect.
<k>void WiFiEvent(WiFiEvent_t event) {
  Serial.printf("[WiFi-event] event: %d\n", event);
  switch(event) {
    case SYSTEM_EVENT_STA_GOT_IP:
      Serial.println("WiFi connected");
      Serial.println("IP address: ");
      Serial.println(WiFi.localIP());
      connectToMqtt();
      break;
    case SYSTEM_EVENT_STA_DISCONNECTED:
      Serial.println("WiFi lost connection");
      xTimerStop(mqttReconnectTimer, 0);
      xTimerStart(wifiReconnectTimer, 0);
      break;
  }
}</k>
The onMqttConnect() function runs after starting a session with the broker.
<k>void onMqttConnect(bool sessionPresent) {
  Serial.println("Connected to MQTT.");
  Serial.print("Session present: ");
  Serial.println(sessionPresent);
}</k>
<h3>MQTT functions: disconnect and publish</h3>
If the ESP32 loses connection with the MQTT broker, it calls the onMqttDisconnect function that prints that message in the serial monitor.
<k>void onMqttDisconnect(AsyncMqttClientDisconnectReason reason) {
  Serial.println("Disconnected from MQTT.");
  if (WiFi.isConnected()) { 
    xTimerStart(mqttReconnectTimer, 0);
  }
}</k>
When you publish a message to an MQTT topic, the onMqttPublish() function is called. It prints the packet id in the Serial Monitor.
<k>void onMqttPublish(uint16_t packetId) {
  Serial.println("Publish acknowledged.");
  Serial.print("  packetId: ");
  Serial.println(packetId);
}</k>
Basically, all these functions that we've just mentioned are callback functions. So, they are executed asynchronously.
<h3>setup()</h3>
Now, let's proceed to the setup(). Initialize the DHT sensor.
<k>dht.begin();</k>
The next two lines create timers that will allow both the MQTT broker and Wi-Fi connection to reconnect, in case the connection is lost.
<k>mqttReconnectTimer = xTimerCreate("mqttTimer", pdMS_TO_TICKS(2000), pdFALSE, (void*)0, reinterpret_cast&lt;TimerCallbackFunction_t>(connectToMqtt));
wifiReconnectTimer = xTimerCreate("wifiTimer", pdMS_TO_TICKS(2000), pdFALSE, (void*)0, reinterpret_cast&lt;TimerCallbackFunction_t>(connectToWifi));</k>
The following line assigns a callback function, so when the ESP32 connects to your Wi-Fi, it will execute the WiFiEvent() function to print the details described earlier.
<k>WiFi.onEvent(WiFiEvent);</k>
Finally, assign all the callback functions. This means that these functions will be executed automatically when needed. For example, when the ESP32 connects to the broker, it automatically calls the onMqttConnect() function, and so on.
<k>mqttClient.onConnect(onMqttConnect);
mqttClient.onDisconnect(onMqttDisconnect);
//mqttClient.onSubscribe(onMqttSubscribe);
//mqttClient.onUnsubscribe(onMqttUnsubscribe);
mqttClient.onPublish(onMqttPublish);
mqttClient.setServer(MQTT_HOST, MQTT_PORT);</k>
<h4>Broker Authentication</h4>
If your broker requires authentication, uncomment the following line and insert your credentials (username and password).
<k>mqttClient.setCredentials("REPlACE_WITH_YOUR_USER", "REPLACE_WITH_YOUR_PASSWORD");</k>
Finally, connect to Wi-Fi.
<k>connectToWifi();</k>
<h3>loop()</h3>
In the loop(), you create a timer that will allow you to get new temperature and humidity readings from the DHT sensor and publishing them on the corresponding topic every 10 seconds.
<k>unsigned long currentMillis = millis();
// Every X number of seconds (interval = 10 seconds) 
// it publishes a new MQTT message
if (currentMillis - previousMillis >= interval) {
  // Save the last time a new reading was published
  previousMillis = currentMillis;
  // New DHT sensor readings
  hum = dht.readHumidity();
  // Read temperature as Celsius (the default)
  temp = dht.readTemperature();
  // Read temperature as Fahrenheit (isFahrenheit = true)
  //temp = dht.readTemperature(true);</k>
Learn more about getting readings from the DHT11 or DHT22 sensors: <a href="https://randomnerdtutorials.com/esp32-dht11-dht22-temperature-humidity-sensor-arduino-ide/">ESP32 with DHT11/DHT22 Temperature and Humidity Sensor using Arduino IDE</a>.
<h3>Publishing to topics</h3>
To publish the readings on the corresponding MQTT topics, use the next lines:
<k>uint16_t packetIdPub1 = mqttClient.publish(MQTT_PUB_TEMP, 1, true, String(temp).c_str());
uint16_t packetIdPub2 = mqttClient.publish(MQTT_PUB_HUM, 1, true, String(hum).c_str());</k>
Basically, use the publish() method on the mqttClient object to publish data on a topic. The publish() method accepts the following arguments, in order:
MQTT topic (const char*)
QoS (uint8_t): quality of service  it can be 0, 1 or 2
retain flag (bool): retain flag
payload (const char*)  in this case, the payload corresponds to the sensor reading
The QoS (quality of service) is a way to guarantee that the message is delivered. It can be one of the following levels:
<k>0</k>: the message will be delivered once or not at all. The message is not acknowledged. There is no possibility of duplicated messages;
<k>1</k>: the message will be delivered at least once, but may be delivered more than once;
<k>2</k>: the message is always delivered exactly once;
<a href="https://www.ibm.com/support/knowledgecenter/en/SSFKSJ_8.0.0/com.ibm.mq.dev.doc/q029090_.htm" target="_blank" aria-label=" (opens in a new tab)">Learn about MQTT QoS.</a>
<h3>Uploading the code</h3>
With your Raspberry Pi powered on and running the Mosquitto MQTT broker, upload the code to your ESP32.
Open the Serial Monitor at a baud rate of 115200 and you'll see that the ESP32 starts publishing messages on the topics we've defined previously.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/ESP32-Publish-MQTT-DHT11-DHT22-Temperature-Serial-Monitor.png">
<h3>Preparing Node-RED Dashboard</h3>
The ESP32 is publishing temperature readings every 10 seconds on the <k>esp32/dht/temperature</k> and <k>esp32/dht/humidity</k> topics. Now, you can use any dashboard that supports MQTT or any other device that supports MQTT to subscribe to those topics and receive the readings.
As an example, we'll create a simple flow using Node-RED to subscribe to those topics and display the readings on gauges.
If you don't have Node-RED installed, follow the next tutorials:
<a href="https://randomnerdtutorials.com/getting-started-with-node-red-on-raspberry-pi/">Getting Started with Node-RED on Raspberry Pi</a>
<a href="https://randomnerdtutorials.com/getting-started-with-node-red-dashboard/">Installing and Getting Started with Node-RED Dashboard</a>
Having Node-RED running on your Raspberry Pi, go to your Raspberry Pi IP address followed by :1880.
<k>http://raspberry-pi-ip-address:1880</k>
The Node-RED interface should open. Drag two MQTT in nodes, and two gauge nodes to the flow.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/0-ESP32-DHT11-DHT22-Arduino-IDE.png">
Click the MQTT node and edit its properties.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/1-MQTT-In-Node-ESP32-Publish-Temperature-Humidity-Node-RED-Flow.png">
The Server field refers to the MQTT broker. In our case, the MQTT broker is the Raspberry Pi, so it is set to localhost:1883. If you're using a Cloud MQTT broker, you should change that field. 
Insert the topic you want to be subscribed to and the QoS. This previous MQTT node is subscribed to the <k>esp32/dht/temperature</k> topic. 
Click on the other MQTT in node and edit its properties with the same server, but for the other topic: <k>esp32/dht/humidity</k>. 
Click on the gauge nodes and edit its properties for each reading. The following node is set for the temperature readings. Edit the other chart node for the humidity readings.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/2-ESP32-Gauge-Temperature-Humidity-Node-RED-Flow.png">
Wire your nodes as shown below:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/3-ESP32-MQTT-Publish-Temperature-Humidity-Node-RED-Flow.png">
Finally, deploy your flow (press the button on the upper right corner).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/06/11_deploy_button.png">
Alternatively, you can go to <k>Menu </k>> <k>Import </k>and copy the following to your <k>Clipboard</k> to create your Node-RED flow.
<k>[{"id":"5a45b8da.52b0d8","type":"mqtt in","z":"b01416d3.f69f38","name":"","topic":"esp32/dht/temperature","qos":"1","datatype":"auto","broker":"8db3fac0.99dd48","x":300,"y":60,"wires":[["3042e15e.80a4ee"]]},{"id":"3042e15e.80a4ee","type":"ui_gauge","z":"b01416d3.f69f38","name":"","group":"37de8fe8.46846","order":2,"width":0,"height":0,"gtype":"gage","title":"Temperature","label":"oC","format":"{{value}}","min":0,"max":"40","colors":["#00b500","#f7df09","#ca3838"],"seg1":"","seg2":"","x":590,"y":60,"wires":[]},{"id":"8ff168f0.0c74a8","type":"mqtt in","z":"b01416d3.f69f38","name":"","topic":"esp32/dht/humidity","qos":"1","datatype":"auto","broker":"8db3fac0.99dd48","x":290,"y":140,"wires":[["29251f29.6687c"]]},{"id":"29251f29.6687c","type":"ui_gauge","z":"b01416d3.f69f38","name":"","group":"37de8fe8.46846","order":2,"width":0,"height":0,"gtype":"gage","title":"Humidity","label":"%","format":"{{value}}","min":"30","max":"100","colors":["#53a4e6","#1d78a9","#4e38c9"],"seg1":"","seg2":"","x":580,"y":140,"wires":[]},{"id":"8db3fac0.99dd48","type":"mqtt-broker","z":"","name":"","broker":"localhost","port":"1883","clientid":"","usetls":false,"compatmode":false,"keepalive":"60","cleansession":true,"birthTopic":"","birthQos":"0","birthPayload":"","closeTopic":"","closeQos":"0","closePayload":"","willTopic":"","willQos":"0","willPayload":""},{"id":"37de8fe8.46846","type":"ui_group","z":"","name":"DHT","tab":"53b8c8f9.cfbe48","order":1,"disp":true,"width":"6","collapse":false},{"id":"53b8c8f9.cfbe48","type":"ui_tab","z":"","name":"Home","icon":"dashboard","order":2,"disabled":false,"hidden":false}]
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_MQTT/ESP32_DHT_Flow.txt" target="_blank">View raw code</a>
<h3>Demonstration</h3>
Go to your Raspberry Pi IP address followed by <em>:1880/ui</em>.
<k>http://raspberry-pi-ip-address:1880/ui</k>
You should get access to the current DHT temperature and humidity readings on the Dashboard. You can use other dashboard-type nodes to display the readings on different ways.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/04/4-ESP32-MQTT-Publish-Temperature-Humidity-Node-RED-Dashboard.png">
That's it! You have your ESP32 board publishing DHT temperature and humidity readings to Node-RED via MQTT.
<h3>Wrapping Up</h3>
MQTT is a great communication protocol to exchange small amounts of data between devices. In this tutorial you've learned how to publish temperature and humidity readings from a DHT sensor with the ESP32 to different MQTT topics. Then, you can use any device or home automation platform to subscribe to those topics and receive the readings. 
Instead of a <a aria-label="DHT11 (opens in a new tab)" href="https://makeradvisor.com/tools/dht11-temperature-humidity-sensor/" target="_blank">DHT11</a> or <a aria-label="DHT22 (opens in a new tab)" href="https://makeradvisor.com/tools/dht22-temperature-humidity-sensor/" target="_blank">DHT22</a> sensor, you can use any other sensor like a <a aria-label="DS18B20 temperature sensor (opens in a new tab)" href="https://makeradvisor.com/tools/ds18b20-temperature-sensor-2/" target="_blank">DS18B20 temperature sensor</a> or <a aria-label="BME280 temperature, humidity and pressure sensor (opens in a new tab)" href="https://makeradvisor.com/tools/bme280-sensor-module/" target="_blank">BME280 sensor</a>:
<a href="https://randomnerdtutorials.com/esp32-mqtt-publish-ds18b20-temperature-arduino/">ESP32 MQTT  Publish DS18B20 Temperature Readings</a>
<a href="https://randomnerdtutorials.com/esp32-mqtt-publish-bme280-arduino/">ESP32 MQTT  Publish BME280 Temperature, Humidity and Pressure Readings</a>
We hope you've found this tutorial useful. If you want to learn more about the ESP32, take a look at our resources:
<a href="https://randomnerdtutorials.com/learn-esp32-with-arduino-ide/">Learn ESP32 with Arduino IDE</a>
<a href="https://randomnerdtutorials.com/micropython-programming-with-esp32-and-esp8266/">MicroPython Programming with ESP32 and ESP8266</a>
<a href="https://randomnerdtutorials.com/projects-esp32/">More ESP32 Projects</a>
Thanks for reading.
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h-p2lw6wwnkk9ystvwe9iof8zx6yt4x7uma3cqfup534.jpg" title="Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h" alt="Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h" loading="lazy" width="129" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/">[eBook] Build Web Servers with ESP32 and ESP8266 (2nd Edition)</a></h4>
Build Web Server projects with the ESP32 and ESP8266 boards to control outputs and monitor sensors remotely. Learn HTML, CSS, JavaScript and client-server communication protocols <k><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Build Web Server projects with the ESP32 and ESP8266 boards to control outputs and monitor sensors remotely. Learn HTML, CSS, JavaScript and client-server communication protocols <k><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>ESP32 MQTT  Publish BME280 Sensor Readings (Arduino IDE)</a8></h2>
Learn how to publish BME280 sensor readings (temperature, humidity and pressure) via MQTT with the ESP32 to any platform that supports MQTT or any MQTT client. As an example, we'll publish sensor readings to Node-RED Dashboard and the ESP32 will be programmed using Arduino IDE.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-BME280-Temperature-Humidity-Pressure-Sensor-MQTT-Publish-Arduino-IDE-Node-RED.jpg">
<k>Recommended reading:</k> <a href="https://randomnerdtutorials.com/what-is-mqtt-and-how-it-works/">What is MQTT and How It Works</a>
<h3>Project Overview</h3>
The following diagram shows a high-level overview of the project we'll build.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/BME280-publish-readings-node-red-mqtt.png">
The ESP32 requests temperature readings from the BME280 sensor.
The temperature readings are published in the <k>esp32/bme280/temperature</k> topic;
Humidity readings are published in the <k>esp32/bme280/humidity</k>topic;
Pressure readings are published in the <k>esp32/bme280/pressure</k> topic;
Node-RED is subscribed those topics;
Node-RED receives the sensor readings and displays them on gauges;
You can receive the readings in any other platform that supports MQTT and handle the readings as you want.
<h3>Prerequisites</h3>
Before proceeding with this tutorial, make sure you check the following prerequisites.
<h3>Arduino IDE</h3>
We'll program the ESP32 using Arduino IDE, so make sure you have the ESP32 add-on installed.
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<h3>MQTT Broker</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/01/mosquitto-broker.png">
To use MQTT, you need a broker. We'll be using <a href="https://mosquitto.org/" target="_blank" aria-label=" (opens in a new tab)">Mosquitto broker</a> installed on a Raspberry Pi. Read <a href="https://randomnerdtutorials.com/how-to-install-mosquitto-broker-on-raspberry-pi/" target="_blank">How to Install Mosquitto Broker on Raspberry Pi</a>.
You can use any other MQTT broker, including a cloud MQTT broker. We'll show you how to do that in the code later on.
If you're not familiar with MQTT make sure you read our introductory tutorial: <a href="https://randomnerdtutorials.com/what-is-mqtt-and-how-it-works/" target="_blank">What is MQTT and How It Works</a>.
<h3>MQTT Libraries</h3>
To use MQTT with the ESP32 we'll use the <a href="https://github.com/marvinroger/async-mqtt-client" target="_blank" aria-label=" (opens in a new tab)">Async MQTT Client Library</a>.
<k>Installing the Async MQTT Client Library</k>
<ol>
<a href="https://github.com/marvinroger/async-mqtt-client/archive/master.zip" target="_blank" aria-label=" (opens in a new tab)">Click here to download the Async MQTT client library</a>. You should have a .zip folder in your Downloads folder
Unzip the .zip folder and you should get <k>async-mqtt-client-master</k> folder
Rename your folder from <del><k>async-mqtt-client-master</k></del> to <k>async_mqtt_client</k>
Move the <k>async_mqtt_client</k> folder to your Arduino IDE installation libraries folder
Finally, re-open your Arduino IDE
</ol>
Alternatively, you can go to <k>Sketch </k>> <k>Include Library</k> > <k>Add . ZIP</k> library and select the library you've just downloaded.
<k>Installing the Async TCP Library</k>
To use MQTT with the ESP, you also need the <a href="https://github.com/me-no-dev/AsyncTCP" target="_blank" aria-label=" (opens in a new tab)">Async TCP library</a>.
<ol>
<a href="https://github.com/me-no-dev/AsyncTCP/archive/master.zip" target="_blank" aria-label=" (opens in a new tab)">Click here to download the Async TCP client library</a>. You should have a .zip folder in your Downloads folder
Unzip the .zip folder and you should get <k>AsyncTCP-master</k> folder
Rename your folder from <del><k>AsyncTCP-master</k></del> to <k>AsyncTCP</k>
Move the <k>AsyncTCP </k>folder to your Arduino IDE installation libraries folder
Finally, re-open your Arduino IDE
</ol>
Alternatively, you can go to <k>Sketch </k>> <k>Include Library</k> > <k>Add . ZIP</k> library and select the library you've just downloaded. 
<h3>BME280 Sensor Libraries</h3>
To get readings from the BME280 sensor module, we'll use the <a href="https://github.com/adafruit/Adafruit_BME280_Library" target="_blank">Adafruit_BME280 library</a>. You also need to install the <a href="https://github.com/adafruit/Adafruit_Sensor" target="_blank">Adafruit_Sensor library</a>. Follow the next steps to install the libraries in your Arduino IDE:
1. Open your Arduino IDE and go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k>. The Library Manager should open.
2. Search for <k>adafruit bme280</k>  on the Search box and install the library.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/08/install-bme280.png">
To use the BME280 library, you also need to install the <a href="https://github.com/adafruit/Adafruit_Sensor" target="_blank" aria-label="Adafruit Unified Sensor (opens in a new tab)">Adafruit Unified Sensor</a>. Follow the next steps to install the library in your Arduino IDE:
3. Search for <k>Adafruit Unified Sensor</k>in the search box. Scroll all the way down to find the library and install it.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/04/adafruit_unified_sensor_library.png">
After installing the libraries, restart your Arduino IDE.
To learn more about the BME280 sensor, read our guide: <a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/">ESP32 with BME280 Sensor using Arduino IDE (Pressure, Temperature, Humidity)</a>.
<h3>Parts Required</h3>
For this tutorial you need the following parts:
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> (read <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">Best ESP32 development boards</a>)
<a href="https://makeradvisor.com/tools/bme280-sensor-module/" target="_blank" aria-label=" (opens in a new tab)">BME280</a>  <a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/">BME280 with ESP32 Guide</a>
<a href="https://makeradvisor.com/raspberry-pi-board/" target="_blank">Raspberry Pi board</a> (read <a href="https://makeradvisor.com/best-raspberry-pi-starter-kits/" target="_blank">Best Raspberry Pi Starter Kits</a>)
<a href="https://makeradvisor.com/tools/microsd-card-raspberry-pi-16gb-class-10/" target="_blank">MicroSD Card  16GB Class10</a>
<a href="https://makeradvisor.com/tools/raspberry-pi-power-supply/" target="_blank">Raspberry Pi Power Supply (5V 2.5A)</a> 
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a> 
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="lazy" fetchpriority="low"></a>
<h3>Schematic Diagram</h3>
Wire the BME280 to the ESP32 as shown in the following schematic diagram with the SDA pin connected to GPIO 21 and the SCL pin connected to GPIO 22.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/06/ESP32-bme280_schematic.jpg">
<h3>Code</h3>
Copy the following code to your Arduino IDE. To make it work for you, you need to insert your network credentials as well as the MQTT broker details.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-mqtt-publish-bme280-arduino/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;Wire.h>
#include &lt;Adafruit_Sensor.h>
#include &lt;Adafruit_BME280.h>
#include &lt;WiFi.h>
extern "C" {
  #include "freertos/FreeRTOS.h"
  #include "freertos/timers.h"
}
#include &lt;AsyncMqttClient.h>
#define WIFI_SSID "REPLACE_WITH_YOUR_SSID"
#define WIFI_PASSWORD "REPLACE_WITH_YOUR_PASSWORD"
// Raspberry Pi Mosquitto MQTT Broker
#define MQTT_HOST IPAddress(192, 168, 1, XXX)
// For a cloud MQTT broker, type the domain name
//#define MQTT_HOST "example.com"
#define MQTT_PORT 1883
// Temperature MQTT Topics
#define MQTT_PUB_TEMP "esp32/bme280/temperature"
#define MQTT_PUB_HUM "esp32/bme280/humidity"
#define MQTT_PUB_PRES "esp32/bme280/pressure"
// BME280 I2C
Adafruit_BME280 bme;
// Variables to hold sensor readings
float temp;
float hum;
float pres;
AsyncMqttClient mqttClient;
TimerHandle_t mqttReconnectTimer;
TimerHandle_t wifiReconnectTimer;
unsigned long previousMillis = 0;   // Stores last time temperature was published
const long interval = 10000;        // Interval at which to publish sensor readings
void connectToWifi() {
  Serial.println("Connecting to Wi-Fi...");
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
}
void connectToMqtt() {
  Serial.println("Connecting to MQTT...");
  mqttClient.connect();
}
void WiFiEvent(WiFiEvent_t event) {
  Serial.printf("[WiFi-event] event: %d\n", event);
  switch(event) {
    case SYSTEM_EVENT_STA_GOT_IP:
      Serial.println("WiFi connected");
      Serial.println("IP address: ");
      Serial.println(WiFi.localIP());
      connectToMqtt();
      break;
    case SYSTEM_EVENT_STA_DISCONNECTED:
      Serial.println("WiFi lost connection");
      xTimerStop(mqttReconnectTimer, 0); // ensure we don't reconnect to MQTT while reconnecting to Wi-Fi
      xTimerStart(wifiReconnectTimer, 0);
      break;
  }
}
void onMqttConnect(bool sessionPresent) {
  Serial.println("Connected to MQTT.");
  Serial.print("Session present: ");
  Serial.println(sessionPresent);
}
void onMqttDisconnect(AsyncMqttClientDisconnectReason reason) {
  Serial.println("Disconnected from MQTT.");
  if (WiFi.isConnected()) {
    xTimerStart(mqttReconnectTimer, 0);
  }
}
/*void onMqttSubscribe(uint16_t packetId, uint8_t qos) {
  Serial.println("Subscribe acknowledged.");
  Serial.print("  packetId: ");
  Serial.println(packetId);
  Serial.print("  qos: ");
  Serial.println(qos);
}
void onMqttUnsubscribe(uint16_t packetId) {
  Serial.println("Unsubscribe acknowledged.");
  Serial.print("  packetId: ");
  Serial.println(packetId);
}*/
void onMqttPublish(uint16_t packetId) {
  Serial.print("Publish acknowledged.");
  Serial.print("  packetId: ");
  Serial.println(packetId);
}
void setup() {
  Serial.begin(115200);
  Serial.println();
  
  // Initialize BME280 sensor 
  if (!bme.begin(0x76)) {
    Serial.println("Could not find a valid BME280 sensor, check wiring!");
    while (1);
  }
  
  mqttReconnectTimer = xTimerCreate("mqttTimer", pdMS_TO_TICKS(2000), pdFALSE, (void*)0, reinterpret_cast&lt;TimerCallbackFunction_t>(connectToMqtt));
  wifiReconnectTimer = xTimerCreate("wifiTimer", pdMS_TO_TICKS(2000), pdFALSE, (void*)0, reinterpret_cast&lt;TimerCallbackFunction_t>(connectToWifi));
  WiFi.onEvent(WiFiEvent);
  mqttClient.onConnect(onMqttConnect);
  mqttClient.onDisconnect(onMqttDisconnect);
  //mqttClient.onSubscribe(onMqttSubscribe);
  //mqttClient.onUnsubscribe(onMqttUnsubscribe);
  mqttClient.onPublish(onMqttPublish);
  mqttClient.setServer(MQTT_HOST, MQTT_PORT);
  // If your broker requires authentication (username and password), set them below
  //mqttClient.setCredentials("REPlACE_WITH_YOUR_USER", "REPLACE_WITH_YOUR_PASSWORD");
  connectToWifi();
}
void loop() {
  unsigned long currentMillis = millis();
  // Every X number of seconds (interval = 10 seconds) 
  // it publishes a new MQTT message
  if (currentMillis - previousMillis >= interval) {
    // Save the last time a new reading was published
    previousMillis = currentMillis;
    // New BME280 sensor readings
    temp = bme.readTemperature();
    //temp = 1.8*bme.readTemperature() + 32;
    hum = bme.readHumidity();
    pres = bme.readPressure()/100.0F;
    
    // Publish an MQTT message on topic esp32/BME2800/temperature
    uint16_t packetIdPub1 = mqttClient.publish(MQTT_PUB_TEMP, 1, true, String(temp).c_str());                            
    Serial.printf("Publishing on topic %s at QoS 1, packetId: %i", MQTT_PUB_TEMP, packetIdPub1);
    Serial.printf("Message: %.2f \n", temp);
    // Publish an MQTT message on topic esp32/BME2800/humidity
    uint16_t packetIdPub2 = mqttClient.publish(MQTT_PUB_HUM, 1, true, String(hum).c_str());                            
    Serial.printf("Publishing on topic %s at QoS 1, packetId %i: ", MQTT_PUB_HUM, packetIdPub2);
    Serial.printf("Message: %.2f \n", hum);
    // Publish an MQTT message on topic esp32/BME2800/pressure
    uint16_t packetIdPub3 = mqttClient.publish(MQTT_PUB_PRES, 1, true, String(pres).c_str());                            
    Serial.printf("Publishing on topic %s at QoS 1, packetId: %i", MQTT_PUB_PRES, packetIdPub3);
    Serial.printf("Message: %.3f \n", pres);
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_MQTT/ESP32_BME280.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
The following section imports all the required libraries.
<k>#include &lt;Wire.h>
#include &lt;Adafruit_Sensor.h>
#include &lt;Adafruit_BME280.h>
#include &lt;WiFi.h>
extern "C" {
  #include "freertos/FreeRTOS.h"
  #include "freertos/timers.h"
}
#include &lt;AsyncMqttClient.h></k>
Include your network credentials on the following lines.
<k>#define WIFI_SSID "REPLACE_WITH_YOUR_SSID"
#define WIFI_PASSWORD "REPLACE_WITH_YOUR_PASSWORD"</k>
Insert the Raspberry Pi IP address, so that the ESP32 connects to your broker.
<k>#define MQTT_HOST IPAddress(192, 168, 1, 106)</k>
If you're using a cloud MQTT broker, insert the broker domain name, for example:
<k>#define MQTT_HOST "example.com"</k>
Define the MQTT port.
<k>#define MQTT_PORT 1883</k>
The temperature, humidity and pressure will be published on the following topics:
<k>#define MQTT_PUB_TEMP "esp32/bme280/temperature"
#define MQTT_PUB_HUM  "esp32/bme280/humidity"
#define MQTT_PUB_PRES "esp32/bme280/pressure"</k>
Initialize a Adafruit_BME280 object called bme.
<k>Adafruit_BME280 bme;</k>
The temp, hum and pres variables will hold the temperature, humidity and pressure values from the BME280 sensor.
<k>float temp;
float hum;
float pres;</k>
Create an AsyncMqttClient object called mqttClient to handle the MQTT client and timers to reconnect to your MQTT broker and router when it disconnects.
<k>AsyncMqttClient mqttClient;
TimerHandle_t mqttReconnectTimer;
TimerHandle_t wifiReconnectTimer;</k>
Then, create some auxiliary timer variables to publish the readings every 10 seconds. You can change the delay time on the interval variable.
<k>unsigned long previousMillis = 0;  // Stores last time temperature was published
const long interval = 10000;       // Interval at which to publish sensor readings</k>
<h3>MQTT functions: connect to Wi-Fi, connect to MQTT, and Wi-Fi events</h3>
We haven't added any comments to the functions defined in the next code section. Those functions come with the Async Mqtt Client library. The function's names are pretty self-explanatory.
For example, the connectToWifi() connects your ESP32 to your router:
<k>void connectToWifi() {
  Serial.println("Connecting to Wi-Fi...");
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
}</k>
The connectToMqtt() connects your ESP32 to your MQTT broker:
<k>void connectToMqtt() {
  Serial.println("Connecting to MQTT");
  mqttClient.connect();
 }</k>
The WiFiEvent() function is responsible for handling the Wi-Fi events. For example, after a successful connection with the router and MQTT broker, it prints the ESP32 IP address. On the other hand, if the connection is lost, it starts a timer and tries to reconnect.
<k>void WiFiEvent(WiFiEvent_t event) {
  Serial.printf("[WiFi-event] event: %d\n", event);
  switch(event) {
    case SYSTEM_EVENT_STA_GOT_IP:
      Serial.println("WiFi connected");
      Serial.println("IP address: ");
      Serial.println(WiFi.localIP());
      connectToMqtt();
      break;
    case SYSTEM_EVENT_STA_DISCONNECTED:
      Serial.println("WiFi lost connection");
      xTimerStop(mqttReconnectTimer, 0);
      xTimerStart(wifiReconnectTimer, 0);
      break;
  }
}</k>
The onMqttConnect() function runs after starting a session with the broker.
<k>void onMqttConnect(bool sessionPresent) {
  Serial.println("Connected to MQTT.");
  Serial.print("Session present: ");
  Serial.println(sessionPresent);
}</k>
<h3>MQTT functions: disconnect and publish</h3>
If the ESP32 loses connection with the MQTT broker, it calls the onMqttDisconnect function that prints that message in the serial monitor.
<k>void onMqttDisconnect(AsyncMqttClientDisconnectReason reason) {
  Serial.println("Disconnected from MQTT.");
  if (WiFi.isConnected()) { 
    xTimerStart(mqttReconnectTimer, 0);
  }
}</k>
When you publish a message to an MQTT topic, the onMqttPublish() function is called. It prints the packet id in the Serial Monitor.
<k>void onMqttPublish(uint16_t packetId) {
  Serial.println("Publish acknowledged.");
  Serial.print("  packetId: ");
  Serial.println(packetId);
}</k>
Basically, all these functions that we've just mentioned are callback functions. So, they are executed asynchronously.
<h3>setup()</h3>
Now, let's proceed to the setup(). Initialize the BME280 sensor.
<k>if (!bme.begin(0x76)) {
  Serial.println("Could not find a valid BME280 sensor, check wiring!");
  while (1);
}</k>
The next two lines create timers that will allow both the MQTT broker and Wi-Fi connection to reconnect, in case the connection is lost.
<k>mqttReconnectTimer = xTimerCreate("mqttTimer", pdMS_TO_TICKS(2000), pdFALSE, (void*)0, reinterpret_cast&lt;TimerCallbackFunction_t>(connectToMqtt));
wifiReconnectTimer = xTimerCreate("wifiTimer", pdMS_TO_TICKS(2000), pdFALSE, (void*)0, reinterpret_cast&lt;TimerCallbackFunction_t>(connectToWifi));</k>
The following line assigns a callback function, so when the ESP32 connects to your Wi-Fi, it will execute the WiFiEvent() function to print the details described earlier.
<k>WiFi.onEvent(WiFiEvent);</k>
Finally, assign all the callbacks functions. This means that these functions will be executed automatically when needed. For example, when the ESP32 connects to the broker, it automatically calls the onMqttConnect() function, and so on.
<k>mqttClient.onConnect(onMqttConnect);
mqttClient.onDisconnect(onMqttDisconnect);
//mqttClient.onSubscribe(onMqttSubscribe);
//mqttClient.onUnsubscribe(onMqttUnsubscribe);
mqttClient.onPublish(onMqttPublish);
mqttClient.setServer(MQTT_HOST, MQTT_PORT);</k>
<h4>Broker Authentication</h4>
If your broker requires authentication, uncomment the following line and insert your credentials (username and password).
<k>mqttClient.setCredentials("REPlACE_WITH_YOUR_USER", "REPLACE_WITH_YOUR_PASSWORD");</k>
Finally, connect to Wi-Fi.
<k>connectToWifi();</k>
<h3>loop()</h3>
In the loop(), you create a timer that will allow you to get new readings from the BME280 sensor and publishing them on the corresponding topic every 10 seconds.
<k>unsigned long currentMillis = millis();
// Every X number of seconds (interval = 10 seconds) 
// it publishes a new MQTT message
if (currentMillis - previousMillis >= interval) {
  // Save the last time a new reading was published
  previousMillis = currentMillis;
  // New BME280 sensor readings
  temp = bme.readTemperature();
  //temp = 1.8*bme.readTemperature() + 32;
  hum = bme.readHumidity();
  pres = bme.readPressure()/100.0F;</k>
Learn more about getting readings from the BME280 sensor: <a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/">ESP32 with BME280 Temperature, Humidity and Pressure Sensor Guide</a>.
<h3>Publishing to topics</h3>
To publish the readings on the corresponding MQTT topics, use the next lines:
<k>uint16_t packetIdPub1 = mqttClient.publish(MQTT_PUB_TEMP, 1, true, String(temp).c_str());
uint16_t packetIdPub2 = mqttClient.publish(MQTT_PUB_HUM, 1, true, String(hum).c_str());
uint16_t packetIdPub3 = mqttClient.publish(MQTT_PUB_PRES, 1, true, String(pres).c_str());</k>
Basically, use the publish() method on the mqttClient object to publish data on a topic. The publish() method accepts the following arguments, in order:
MQTT topic (const char*)
QoS (uint8_t): quality of service  it can be 0, 1 or 2
retain flag (bool): retain flag
payload (const char*)  in this case, the payload corresponds to the sensor reading
The QoS (quality of service) is a way to guarantee that the message is delivered. It can be one of the following levels:
<k>0</k>: the message will be delivered once or not at all. The message is not acknowledged. There is no possibility of duplicated messages;
<k>1</k>: the message will be delivered at least once, but may be delivered more than once;
<k>2</k>: the message is always delivered exactly once;
<a href="https://www.ibm.com/support/knowledgecenter/en/SSFKSJ_8.0.0/com.ibm.mq.dev.doc/q029090_.htm" target="_blank" aria-label=" (opens in a new tab)">Learn about MQTT QoS.</a>
<h3>Uploading the code</h3>
With your Raspberry Pi powered on and running the Mosquitto MQTT broker, upload the code to your ESP32.
Open the Serial Monitor at a baud rate of 115200 and you'll see that the ESP32 starts publishing messages on the topics we've defined previously.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-Publish-BME280-Readings-MQTT-Serial-Monitor-Arduino-IDE.png">
<h3>Preparing Node-RED Dashboard</h3>
The ESP32 is publishing temperature readings every 10 seconds on the <k>esp32/bme280/temperature</k>, <k>esp32/bme280/humidity</k>, and <k>esp32/bme280/pressure</k> topics. Now, you can use any dashboard that supports MQTT or any other device that supports MQTT to subscribe to those topics and receive the readings.
As an example, we'll create a simple flow using Node-RED to subscribe to those topics and display the readings on gauges.
If you don't have Node-RED installed, follow the next tutorials:
<a href="https://randomnerdtutorials.com/getting-started-with-node-red-on-raspberry-pi/">Getting Started with Node-RED on Raspberry Pi</a>
<a href="https://randomnerdtutorials.com/getting-started-with-node-red-dashboard/">Installing and Getting Started with Node-RED Dashboard</a>
Having Node-RED running on your Raspberry Pi, go to your Raspberry Pi IP address followed by :1880.
<k>http://raspberry-pi-ip-address:1880</k>
The Node-RED interface should open. Drag three MQTT in nodes, and three gauge nodes to the flow.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/0-Node-RED-Drag-6-Nodes-MQTT-In-Chart-Gauge.png">
Click the MQTT node and edit its properties.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/2-MQTT-In-Node-ESP32-Publish-Temperature-Node-RED-Flow.png">
The Server field refers to the MQTT broker. In our case, the MQTT broker is the Raspberry Pi, so it is set to localhost:1883. If you're using a Cloud MQTT broker, you should change that field. 
Insert the topic you want to be subscribed to and the QoS. This previous MQTT node is subscribed to the <k>esp32/bme280/temperature</k> topic. 
Click on the other MQTT in nodes and edit its properties with the same server, but for the other topics: <k>esp32/bme280/humidity</k> and <k>esp32/bme280/pressure</k>. 
Click on the gauge nodes and edit its properties for each reading. The following node is set for the temperature readings. Edit the other chart nodes for the other readings.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/1-ESP32-Gauge-Temperature-Node-RED-Flow.png">
Wire your nodes as shown below:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/3-ESP32-MQTT-Publish-Temperature-Humidity-Pressure-Node-RED-Flow.png">
Finally, deploy your flow (press the button on the upper right corner).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/06/11_deploy_button.png">
Alternatively, you can go to <k>Menu </k>> <k>Import </k>and copy the following to your <k>Clipboard</k> to create your Node-RED flow.
<k>[{"id":"5a45b8da.52b0d8","type":"mqtt in","z":"b01416d3.f69f38","name":"","topic":"esp32/bme280/temperature","qos":"1","datatype":"auto","broker":"8db3fac0.99dd48","x":340,"y":120,"wires":[["3042e15e.80a4ee"]]},{"id":"3042e15e.80a4ee","type":"ui_gauge","z":"b01416d3.f69f38","name":"","group":"37de8fe8.46846","order":2,"width":0,"height":0,"gtype":"gage","title":"Temperature","label":"oC","format":"{{value}}","min":0,"max":"40","colors":["#00b500","#f7df09","#ca3838"],"seg1":"","seg2":"","x":610,"y":120,"wires":[]},{"id":"8ff168f0.0c74a8","type":"mqtt in","z":"b01416d3.f69f38","name":"","topic":"esp32/bme280/humidity","qos":"1","datatype":"auto","broker":"8db3fac0.99dd48","x":320,"y":200,"wires":[["29251f29.6687c"]]},{"id":"29251f29.6687c","type":"ui_gauge","z":"b01416d3.f69f38","name":"","group":"37de8fe8.46846","order":2,"width":0,"height":0,"gtype":"gage","title":"Humidity","label":"%","format":"{{value}}","min":"30","max":"100","colors":["#53a4e6","#1d78a9","#4e38c9"],"seg1":"","seg2":"","x":600,"y":200,"wires":[]},{"id":"681a1588.8506fc","type":"mqtt in","z":"b01416d3.f69f38","name":"","topic":"esp32/bme280/pressure","qos":"1","datatype":"auto","broker":"8db3fac0.99dd48","x":330,"y":280,"wires":[["41164c6.e7b3cb4"]]},{"id":"41164c6.e7b3cb4","type":"ui_gauge","z":"b01416d3.f69f38","name":"","group":"37de8fe8.46846","order":2,"width":0,"height":0,"gtype":"gage","title":"Pressure","label":"hPa","format":"{{value}}","min":"900","max":"1100","colors":["#a346ff","#bd45cb","#7d007d"],"seg1":"","seg2":"","x":600,"y":280,"wires":[]},{"id":"8db3fac0.99dd48","type":"mqtt-broker","z":"","name":"","broker":"localhost","port":"1883","clientid":"","usetls":false,"compatmode":false,"keepalive":"60","cleansession":true,"birthTopic":"","birthQos":"0","birthPayload":"","closeTopic":"","closeQos":"0","closePayload":"","willTopic":"","willQos":"0","willPayload":""},{"id":"37de8fe8.46846","type":"ui_group","z":"","name":"BME280","tab":"53b8c8f9.cfbe48","order":1,"disp":true,"width":"6","collapse":false},{"id":"53b8c8f9.cfbe48","type":"ui_tab","z":"","name":"Home","icon":"dashboard","order":2,"disabled":false,"hidden":false}]
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_MQTT/ESP32_BME280_Flow.txt" target="_blank">View raw code</a>
<h3>Demonstration</h3>
Go to your Raspberry Pi IP address followed by <em>:1880/ui</em>.
<k>http://raspberry-pi-ip-address:1880/ui</k>
You should get access to the current BME280 sensor readings on the Dashboard. You can use other dashboard-type nodes to display the readings on different ways.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/5-ESP32-MQTT-Publish-Temperature-Humidity-Pressure-Node-RED-Dashboard.png">
That's it! You have your ESP32 board publishing BME280 temperature, humidity and pressure readings to Node-RED via MQTT.
<h3>Wrapping Up</h3>
MQTT is a great communication protocol to exchange small amounts of data between devices. In this tutorial you've learned how to publish temperature, humidity and pressure readings from a BME280 sensor with the ESP32 to different MQTT topics. Then, you can use any device or home automation platform to subscribe to those topics and receive the readings. 
Instead of a <a href="https://makeradvisor.com/tools/bme280-sensor-module/" target="_blank" aria-label=" (opens in a new tab)">BME280 sensor</a>, you can use any other sensor like a <a aria-label="DS18B20  (opens in a new tab)" href="https://makeradvisor.com/tools/ds18b20-temperature-sensor-2/" target="_blank">DS18B20 </a>temperature sensor (<a href="https://randomnerdtutorials.com/esp32-mqtt-publish-ds18b20-temperature-arduino/">ESP32 MQTT  Publish DS18B20 Temperature Readings</a>). 
We hope you've found this tutorial useful. If you want to learn more about the ESP32, take a look at our resources:
<a href="https://randomnerdtutorials.com/learn-esp32-with-arduino-ide/">Learn ESP32 with Arduino IDE</a>
<a href="https://randomnerdtutorials.com/micropython-programming-with-esp32-and-esp8266/">MicroPython Programming with ESP32 and ESP8266</a>
<a href="https://randomnerdtutorials.com/projects-esp32/">More ESP32 Projects</a>
Thanks for reading.
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h-p2lw6wwnkk9ystvwe9iof8zx6yt4x7uma3cqfup534.jpg" title="Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h" alt="Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h" loading="lazy" width="129" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/">[eBook] Build Web Servers with ESP32 and ESP8266 (2nd Edition)</a></h4>
Build Web Server projects with the ESP32 and ESP8266 boards to control outputs and monitor sensors remotely. Learn HTML, CSS, JavaScript and client-server communication protocols <k><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Build Web Server projects with the ESP32 and ESP8266 boards to control outputs and monitor sensors remotely. Learn HTML, CSS, JavaScript and client-server communication protocols <k><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>ESP32 Digital Inputs and Digital Outputs (Arduino IDE)</h2>
In this getting started guide you'll learn how to read digital inputs like a button switch and control digital outputs like an LED using the ESP32 with Arduino IDE.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-Read-Inputs-Control-Outputs-Arduino-IDE.jpg">
<h3>Prerequisites</h3>
We'll program the ESP32 using Arduino IDE. So, make sure you have the ESP32 boards add-on installed before proceeding:
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<h3>ESP32 Control Digital Outputs</h3>
First, you need set the GPIO you want to control as an OUTPUT. Use the pinMode() function as follows:
<k>pinMode(GPIO, OUTPUT);</k>
To control a digital output you just need to use the digitalWrite() function, that accepts as arguments, the GPIO (int number) you are referring to, and the state, either HIGH or LOW.
<k>digitalWrite(GPIO, STATE);</k>
All GPIOs can be used as outputs except GPIOs 6 to 11 (connected to the integrated SPI flash) and GPIOs 34, 35, 36 and 39 (input only GPIOs);
Learn more about the ESP32 GPIOs: <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">ESP32 GPIO Reference Guide</a> 
<h3>ESP32 Read Digital Inputs</h3>
First, set the GPIO you want to read as INPUT, using the pinMode() function as follows:
<k>pinMode(GPIO, INPUT);</k>
To read a digital input, like a button, you use the digitalRead() function, that accepts as argument, the GPIO (int number) you are referring to.
<k>digitalRead(GPIO);</k>
All ESP32 GPIOs can be used as inputs, except GPIOs 6 to 11 (connected to the integrated SPI flash).
Learn more about the ESP32 GPIOs: <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">ESP32 GPIO Reference Guide</a>
<h3>Project Example</h3>
To show you how to use digital inputs and digital outputs, we'll build a simple project example with a pushbutton and an LED. We'll read the state of the pushbutton and light up the LED accordingly as illustrated in the following figure.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/10/led_pushbutton.png"><h3>Schematic Diagram</h3>
Before proceeding, you need to assemble a circuit with an LED and a pushbutton. We'll connect the LED to GPIO 5 and the pushbutton to GPIO 4.
<h3>Parts Required</h3>
Here's a list of the parts to you need to build the circuit:
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> (read <a href="https://makeradvisor.com/esp32-development-boards-review-comparison/" target="_blank" aria-label=" (opens in a new tab)">Best ESP32 Dev Boards</a>)
<a href="https://makeradvisor.com/tools/3mm-5mm-leds-kit-storage-box/">5 mm LED</a>
<a href="https://makeradvisor.com/tools/resistors-kits/">330 Ohm resistor</a>
<a href="https://makeradvisor.com/tools/pushbuttons-kit/">Pushbutton</a>
<a href="https://makeradvisor.com/tools/resistors-kits/">10k Ohm resistor</a>
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a>
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank" aria-label=" (opens in a new tab)">Jumper wires</a>
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="eager" fetchpriority="high" decoding="async"></a>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/04/led_button_esp32_bb.png"><h3>Code</h3>
Copy the following code to your Arduino IDE.
<k>// Complete Instructions: https://RandomNerdTutorials.com/esp32-digital-inputs-outputs-arduino/
// set pin numbers
const int buttonPin = 4;  // the number of the pushbutton pin
const int ledPin =  5;    // the number of the LED pin
// variable for storing the pushbutton status 
int buttonState = 0;
void setup() {
  Serial.begin(115200);  
  // initialize the pushbutton pin as an input
  pinMode(buttonPin, INPUT);
  // initialize the LED pin as an output
  pinMode(ledPin, OUTPUT);
}
void loop() {
  // read the state of the pushbutton value
  buttonState = digitalRead(buttonPin);
  Serial.println(buttonState);
  // check if the pushbutton is pressed.
  // if it is, the buttonState is HIGH
  if (buttonState == HIGH) {
    // turn LED on
    digitalWrite(ledPin, HIGH);
  } else {
    // turn LED off
    digitalWrite(ledPin, LOW);
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Digital_Inputs_Outputs.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
In the following two lines, you create variables to assign pins:
<k>const int buttonPin = 4;
const int ledPin = 5;</k>
The button is connected to GPIO 4 and the LED is connected to GPIO 5. When using the Arduino IDE with the ESP32, 4 corresponds to GPIO 4 and 5 corresponds to GPIO 5.
Next, you create a variable to hold the button state. By default, it's 0 (not pressed).
<k>int buttonState = 0;</k>
In the setup(), you initialize the button as an INPUT, and the LED as an OUTPUT. For that, you use the pinMode() function that accepts the pin you are referring to, and the mode: INPUT or OUTPUT.
<k>pinMode(buttonPin, INPUT);
pinMode(ledPin, OUTPUT);</k>
In the loop() is where you read the button state and set the LED accordingly.
In the next line, you read the button state and save it in the buttonState variable. As we've seen previously, you use the digitalRead() function.
<k>buttonState = digitalRead(buttonPin);</k>
The following if statement, checks whether the button state is HIGH. If it is, it turns the LED on using the digitalWrite() function that accepts as argument the ledPin, and the state HIGH.
<k>if (buttonState == HIGH) {
  digitalWrite(ledPin, HIGH);
}</k>
If the button state is not HIGH, you set the LED off. Just set LOW as a second argument to in the digitalWrite() function.
<k>else {
  digitalWrite(ledPin, LOW);
}</k>
<h3>Uploading the Code</h3>
Before clicking the upload button, go to <k>Tools</k> > <k>Board</k>, and select the board you're using. In my case, it's the <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank" aria-label=" (opens in a new tab)">DOIT ESP32 DEVKIT V1 board</a>. 
Go to <k>Tools </k>> <k>Port </k>and select the COM port the ESP32 is connected to. Then, press the upload button and wait for the <k>Done uploading</k> message. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/upload-button-arduino-ide.png">
If you see a lot of dots (____) on the debugging window and the <a href="https://randomnerdtutorials.com/solved-failed-to-connect-to-esp32-timed-out-waiting-for-packet-header/">Failed to connect to ESP32: Timed out waiting for packet header</a> message, that means you need to press the ESP32 on-board BOOT button after the dots start appearing.
<h3>Demonstration</h3>
After uploading the code, test your circuit. Your LED should light up when you press the pushbutton:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-Input-Output-Button-Pressed-LED-On-Arduino-IDE.jpg">
And turn off when you release it:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-Input-Output-Button-Not-Pressed-Arduino-IDE.jpg">
<h3>Wrapping Up</h3>
With this getting started guide, you've learned how to read digital inputs and control digital outputs with the ESP32 using Arduino IDE.
If you want to learn how to read analog inputs, or output PWM signals, read the following guides:
<a href="https://randomnerdtutorials.com/esp32-adc-analog-read-arduino-ide/">ESP32 ADC  Read Analog Values with Arduino IDE</a>
<a href="https://randomnerdtutorials.com/esp32-pwm-arduino-ide/">ESP32 PWM with Arduino IDE (Analog Output)</a>
You may also find useful taking a look at the <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">ESP32 GPIO Reference</a> that shows how to use the ESP32 GPIOs and its functions.
Finally, if you want to learn more about the ESP32, take a look at our resources:
<a href="https://randomnerdtutorials.com/learn-esp32-with-arduino-ide/">Learn ESP32 with Arduino IDE</a>
<a href="https://randomnerdtutorials.com/micropython-programming-with-esp32-and-esp8266/">MicroPython Programming with ESP32/ESP8266</a>
<a href="https://randomnerdtutorials.com/projects-esp32/">More ESP32 Projects</a>
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/smart-home-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px-pupj8i6e7hlzpgwxe82jjd8skst9vmrjt9lpqb0v0g.jpg" title="Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px" alt="SMART HOME with Raspberry Pi ESP32 and ESP8266 Node-RED InfluxDB eBook" loading="lazy" width="117" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/smart-home-ebook/">SMART HOME with Raspberry Pi, ESP32, ESP8266 [eBook] </a></h4>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>ESP32 MQTT  Publish DS18B20 Temperature Readings (Arduino IDE)</a8></h2>
Learn how to publish DS18B20 temperature readings via MQTT with the ESP32 to any platform that supports MQTT or any other MQTT client. As an example, we'll publish sensor readings to Node-RED Dashboard and the ESP32 will be programmed using Arduino IDE.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-DS18B20-Temperature-Sensor-MQTT-Publish-Arduino-IDE-Node-RED.jpg">
<k>Recommended reading:</k> <a href="https://randomnerdtutorials.com/what-is-mqtt-and-how-it-works/">What is MQTT and How It Works</a>
<h3>Project Overview</h3>
The following diagram shows a high-level overview of the project we'll build.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-MQTT-DS18B20-Node-RED-f.png">
The ESP32 request temperature readings from the DS18B20 sensor. The readings are published in the <k>esp32/ds18b20/temperature</k> topic;
Node-RED is subscribed to the <k>esp32/ds18b20/temperature</k> topic. So, it receives the DS18B20 temperature readings and displays the readings in a gauge/chart;
You can receive the readings in any other platform that supports MQTT and handle the readings as you want.
<h3>Prerequisites</h3>
Before proceeding with this tutorial, make sure you check the following prerequisites.
<h3>Arduino IDE</h3>
We'll program the ESP32 using Arduino IDE, so make sure you have the ESP32 add-on installed.
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<h3>MQTT Broker</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/01/mosquitto-broker.png">
To use MQTT, you need a broker. We'll be using <a href="https://mosquitto.org/" target="_blank" aria-label=" (opens in a new tab)">Mosquitto broker</a> installed on a Raspberry Pi. Read <a href="https://randomnerdtutorials.com/how-to-install-mosquitto-broker-on-raspberry-pi/" target="_blank">How to Install Mosquitto Broker on Raspberry Pi</a>.
You can use any other MQTT broker, including a cloud MQTT broker. We'll show you how to do that in the code later on.
If you're not familiar with MQTT make sure you read our introductory tutorial: <a href="https://randomnerdtutorials.com/what-is-mqtt-and-how-it-works/" target="_blank">What is MQTT and How It Works</a>.
<h3>MQTT Libraries</h3>
To use MQTT with the ESP32 we'll use the <a href="https://github.com/marvinroger/async-mqtt-client" target="_blank" aria-label=" (opens in a new tab)">Async MQTT Client Library</a>.
<k>Installing the Async MQTT Client Library</k>
<ol>
<a href="https://github.com/marvinroger/async-mqtt-client/archive/master.zip" target="_blank" aria-label=" (opens in a new tab)">Click here to download the Async MQTT client library</a>. You should have a .zip folder in your Downloads folder
Unzip the .zip folder and you should get <k>async-mqtt-client-master</k> folder
Rename your folder from <del><k>async-mqtt-client-master</k></del> to <k>async_mqtt_client</k>
Move the <k>async_mqtt_client</k> folder to your Arduino IDE installation libraries folder
Finally, re-open your Arduino IDE
</ol>
Alternatively, you can go to <k>Sketch </k>> <k>Include Library</k> > <k>Add . ZIP</k> library and select the library you've just downloaded.
<k>Installing the Async TCP Library</k>
To use MQTT with the ESP, you also need the <a href="https://github.com/me-no-dev/AsyncTCP" target="_blank" aria-label=" (opens in a new tab)">Async TCP library</a>.
<ol>
<a href="https://github.com/me-no-dev/AsyncTCP/archive/master.zip" target="_blank" aria-label=" (opens in a new tab)">Click here to download the Async TCP client library</a>. You should have a .zip folder in your Downloads folder
Unzip the .zip folder and you should get <k>AsyncTCP-master</k> folder
Rename your folder from <del><k>AsyncTCP-master</k></del> to <k>AsyncTCP</k>
Move the <k>AsyncTCP </k>folder to your Arduino IDE installation libraries folder
Finally, re-open your Arduino IDE
</ol>
Alternatively, you can go to <k>Sketch </k>> <k>Include Library</k> > <k>Add . ZIP</k> library and select the library you've just downloaded. 
<h3>DS18B20 Temperature Sensor Libraries</h3>
To interface with the DS18B20 temperature sensor, you need to install the <a href="https://github.com/PaulStoffregen/OneWire" target="_blank" aria-label=" (opens in a new tab)">One Wire library by Paul Stoffregen</a> and the <a href="https://github.com/milesburton/Arduino-Temperature-Control-Library" target="_blank">Dallas Temperature library</a>. Follow the next steps to install those libraries.
1. Open your Arduino IDE and go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k>. The Library Manager should open.
2. Type <k>onewire</k> in the search box and install OneWire library by Paul Stoffregen.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/06/install-onewire-library.png">3. Then, search for <k>Dallas</k> and install DallasTemperature library by Miles Burton.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/06/install-dallas-temperature.png">After installing the libraries, restart your Arduino IDE.
To learn more about the DS18B20 temperature sensor, read our guide: <a href="https://randomnerdtutorials.com/esp32-ds18b20-temperature-arduino-ide/">ESP32 DS18B20 Temperature Sensor with Arduino IDE (Single, Multiple, Web Server)</a>.
<h3>Parts Required</h3>
For this tutorial you need the following parts:
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> (read <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">Best ESP32 development boards</a>)
<a aria-label="DS18B20 Temperature Sensor (opens in a new tab)" href="https://makeradvisor.com/tools/ds18b20-temperature-sensor-2/" target="_blank">DS18B20 Temperature Sensor</a>  <a href="https://randomnerdtutorials.com/esp32-ds18b20-temperature-arduino-ide/">DS18B20 with ESP32 Guide</a>
<a href="https://makeradvisor.com/tools/resistors-kits/" target="_blank" aria-label=" (opens in a new tab)">4.7k Ohm resistor</a>
<a href="https://makeradvisor.com/raspberry-pi-board/" target="_blank">Raspberry Pi board</a> (read <a href="https://makeradvisor.com/best-raspberry-pi-starter-kits/" target="_blank">Best Raspberry Pi Starter Kits</a>)
<a href="https://makeradvisor.com/tools/microsd-card-raspberry-pi-16gb-class-10/" target="_blank">MicroSD Card  16GB Class10</a>
<a href="https://makeradvisor.com/tools/raspberry-pi-power-supply/" target="_blank">Raspberry Pi Power Supply (5V 2.5A)</a> 
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a> 
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="lazy" fetchpriority="low"></a>
<h3>Schematic Diagram</h3>
Wire the DS18B20 to the ESP32 as shown in the following schematic diagram with the DS18B20 data pin connected to GPIO 4.
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/06/ds18b20_esp32_single_normal.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/06/ds18b20_esp32_single_normal.png"></a>
<h3>Code</h3>
Copy the following code to your Arduino IDE. To make it work for you, you need to insert your network credentials as well as the MQTT broker details.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-mqtt-publish-ds18b20-temperature-arduino/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;WiFi.h>
extern "C" {
  #include "freertos/FreeRTOS.h"
  #include "freertos/timers.h"
}
#include &lt;AsyncMqttClient.h>
#include &lt;OneWire.h>
#include &lt;DallasTemperature.h>
#define WIFI_SSID "REPLACE_WITH_YOUR_SSID"
#define WIFI_PASSWORD "REPLACE_WITH_YOUR_PASSWORD"
// Raspberry Pi Mosquitto MQTT Broker
#define MQTT_HOST IPAddress(192, 168, 1, XXX)
// For a cloud MQTT broker, type the domain name
//#define MQTT_HOST "example.com"
#define MQTT_PORT 1883
// Temperature MQTT Topic
#define MQTT_PUB_TEMP "esp32/ds18b20/temperature"
// GPIO where the DS18B20 is connected to
const int oneWireBus = 4;          
// Setup a oneWire instance to communicate with any OneWire devices
OneWire oneWire(oneWireBus);
// Pass our oneWire reference to Dallas Temperature sensor 
DallasTemperature sensors(&oneWire);
// Temperature value
float temp;
AsyncMqttClient mqttClient;
TimerHandle_t mqttReconnectTimer;
TimerHandle_t wifiReconnectTimer;
unsigned long previousMillis = 0;   // Stores last time temperature was published
const long interval = 10000;        // Interval at which to publish sensor readings
void connectToWifi() {
  Serial.println("Connecting to Wi-Fi...");
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
}
void connectToMqtt() {
  Serial.println("Connecting to MQTT...");
  mqttClient.connect();
}
void WiFiEvent(WiFiEvent_t event) {
  Serial.printf("[WiFi-event] event: %d\n", event);
  switch(event) {
    case SYSTEM_EVENT_STA_GOT_IP:
      Serial.println("WiFi connected");
      Serial.println("IP address: ");
      Serial.println(WiFi.localIP());
      connectToMqtt();
      break;
    case SYSTEM_EVENT_STA_DISCONNECTED:
      Serial.println("WiFi lost connection");
      xTimerStop(mqttReconnectTimer, 0); // ensure we don't reconnect to MQTT while reconnecting to Wi-Fi
      xTimerStart(wifiReconnectTimer, 0);
      break;
  }
}
void onMqttConnect(bool sessionPresent) {
  Serial.println("Connected to MQTT.");
  Serial.print("Session present: ");
  Serial.println(sessionPresent);
}
void onMqttDisconnect(AsyncMqttClientDisconnectReason reason) {
  Serial.println("Disconnected from MQTT.");
  if (WiFi.isConnected()) {
    xTimerStart(mqttReconnectTimer, 0);
  }
}
/*void onMqttSubscribe(uint16_t packetId, uint8_t qos) {
  Serial.println("Subscribe acknowledged.");
  Serial.print("  packetId: ");
  Serial.println(packetId);
  Serial.print("  qos: ");
  Serial.println(qos);
}
void onMqttUnsubscribe(uint16_t packetId) {
  Serial.println("Unsubscribe acknowledged.");
  Serial.print("  packetId: ");
  Serial.println(packetId);
}*/
void onMqttPublish(uint16_t packetId) {
  Serial.println("Publish acknowledged.");
  Serial.print("  packetId: ");
  Serial.println(packetId);
}
void setup() {
  // Start the DS18B20 sensor
  sensors.begin();
  
  Serial.begin(115200);
  Serial.println();
  Serial.println();
  mqttReconnectTimer = xTimerCreate("mqttTimer", pdMS_TO_TICKS(2000), pdFALSE, (void*)0, reinterpret_cast&lt;TimerCallbackFunction_t>(connectToMqtt));
  wifiReconnectTimer = xTimerCreate("wifiTimer", pdMS_TO_TICKS(2000), pdFALSE, (void*)0, reinterpret_cast&lt;TimerCallbackFunction_t>(connectToWifi));
  WiFi.onEvent(WiFiEvent);
  mqttClient.onConnect(onMqttConnect);
  mqttClient.onDisconnect(onMqttDisconnect);
  //mqttClient.onSubscribe(onMqttSubscribe);
  //mqttClient.onUnsubscribe(onMqttUnsubscribe);
  mqttClient.onPublish(onMqttPublish);
  mqttClient.setServer(MQTT_HOST, MQTT_PORT);
  // If your broker requires authentication (username and password), set them below
  //mqttClient.setCredentials("REPlACE_WITH_YOUR_USER", "REPLACE_WITH_YOUR_PASSWORD");
  connectToWifi();
}
void loop() {
  unsigned long currentMillis = millis();
  // Every X number of seconds (interval = 10 seconds) 
  // it publishes a new MQTT message
  if (currentMillis - previousMillis >= interval) {
    // Save the last time a new reading was published
    previousMillis = currentMillis;
    // New temperature readings
    sensors.requestTemperatures(); 
    // Temperature in Celsius degrees
    temp = sensors.getTempCByIndex(0);
    // Temperature in Fahrenheit degrees
    //temp = sensors.getTempFByIndex(0);
    
    // Publish an MQTT message on topic esp32/ds18b20/temperature
    uint16_t packetIdPub1 = mqttClient.publish(MQTT_PUB_TEMP, 1, true, String(temp).c_str());                            
    Serial.printf("Publishing on topic %s at QoS 1, packetId: ", MQTT_PUB_TEMP);
    Serial.println(packetIdPub1);
    Serial.printf("Message: %.2f /n", sensors.getTempCByIndex(0));
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_MQTT/ESP32_DS18B20.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
The following section imports all the required libraries.
<k>#include &lt;WiFi.h>
extern "C" {
  #include "freertos/FreeRTOS.h"
  #include "freertos/timers.h"
}
#include &lt;AsyncMqttClient.h>
#include &lt;OneWire.h>
#include &lt;DallasTemperature.h></k>
Include your network credentials on the following lines.
<k>#define WIFI_SSID "REPLACE_WITH_YOUR_SSID"
#define WIFI_PASSWORD "REPLACE_WITH_YOUR_PASSWORD"</k>
Insert the Raspberry Pi IP address, so that the ESP32 connects to your broker.
<k>#define MQTT_HOST IPAddress(192, 168, 1, 106)</k>
If you're using a cloud MQTT broker, insert the broker domain name, for example:
<k>#define MQTT_HOST "example.com"</k>
Define the MQTT port.
<k>#define MQTT_PORT 1883</k>
We'll publish the temperature on the <k>esp32/ds18b20/temperature</k> topic. If you want to change the topic, change it on the following line.
<k>#define MQTT_PUB_TEMP "esp32/ds18b20/temperature"</k>
You can create more topics if you want.
Setup your DS18B20 on the following lines. In our case, it is connected to GPIO 4. You can connect it to any other GPIO.
<k>// GPIO where the DS18B20 is connected to
const int oneWireBus = 4;
// Setup a oneWire instance to communicate with any OneWire devices
OneWire oneWire(oneWireBus);
// Pass our oneWire reference to Dallas Temperature sensor
DallasTemperature sensors(&oneWire);</k>
The temp variable will hold the temperature value from the DS18B20 temperature sensor.
<k>float temp;</k>
Create an AsyncMqttClient object called mqttClient to handle the MQTT client and timers to reconnect to your MQTT broker and router when it disconnects.
<k>AsyncMqttClient mqttClient;
TimerHandle_t mqttReconnectTimer;
TimerHandle_t wifiReconnectTimer;</k>
Then, create some auxiliary timer variables to publish the readings every 10 seconds. You can change the delay time on the interval variable.
<k>unsigned long previousMillis = 0;  // Stores last time temperature was published
const long interval = 10000;       // Interval at which to publish sensor readings</k>
<h3>MQTT functions: connect to Wi-Fi, connect to MQTT, and Wi-Fi events</h3>
We haven't added any comments to the functions defined in the next code section. Those functions come with the Async Mqtt Client library. The function's names are pretty self-explanatory.
For example, the connectToWifi() connects your ESP32 to your router:
<k>void connectToWifi() {
  Serial.println("Connecting to Wi-Fi...");
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
}</k>
The connectToMqtt() connects your ESP32 to your MQTT broker:
<k>void connectToMqtt() {
  Serial.println("Connecting to MQTT");
  mqttClient.connect();
 }</k>
The WiFiEvent() function is responsible for handling the Wi-Fi events. For example, after a successful connection with the router and MQTT broker, it prints the ESP32 IP address. On the other hand, if the connection is lost, it starts a timer and tries to reconnect.
<k>void WiFiEvent(WiFiEvent_t event) {
  Serial.printf("[WiFi-event] event: %d\n", event);
  switch(event) {
    case SYSTEM_EVENT_STA_GOT_IP:
      Serial.println("WiFi connected");
      Serial.println("IP address: ");
      Serial.println(WiFi.localIP());
      connectToMqtt();
      break;
    case SYSTEM_EVENT_STA_DISCONNECTED:
      Serial.println("WiFi lost connection");
      xTimerStop(mqttReconnectTimer, 0);
      xTimerStart(wifiReconnectTimer, 0);
      break;
  }
}</k>
The onMqttConnect() function runs after starting a session with the broker.
<k>void onMqttConnect(bool sessionPresent) {
  Serial.println("Connected to MQTT.");
  Serial.print("Session present: ");
  Serial.println(sessionPresent);
}</k>
<h3>MQTT functions: disconnect and publish</h3>
If the ESP32 loses connection with the MQTT broker, calls the onMqttDisconnect function that prints that message in the serial monitor.
<k>void onMqttDisconnect(AsyncMqttClientDisconnectReason reason) {
  Serial.println("Disconnected from MQTT.");
  if (WiFi.isConnected()) { 
    xTimerStart(mqttReconnectTimer, 0);
  }
}</k>
When you publish a message to an MQTT topic, the onMqttPublish() function is called. It prints the packet id in the Serial Monitor.
<k>void onMqttPublish(uint16_t packetId) {
  Serial.println("Publish acknowledged.");
  Serial.print("  packetId: ");
  Serial.println(packetId);
}</k>
Basically, all these functions that we've just mentioned are callback functions. So, they are executed asynchronously.
<h3>setup()</h3>
Now, let's proceed to the setup(). Initialize the DS18B20 sensor and start the serial communication.
<k>sensors.begin();
Serial.begin(115200);</k>
The next two lines create timers that will allow both the MQTT broker and Wi-Fi connection to reconnect, in case the connection is lost.
<k>mqttReconnectTimer = xTimerCreate("mqttTimer", pdMS_TO_TICKS(2000), pdFALSE, (void*)0, reinterpret_cast&lt;TimerCallbackFunction_t>(connectToMqtt));
wifiReconnectTimer = xTimerCreate("wifiTimer", pdMS_TO_TICKS(2000), pdFALSE, (void*)0, reinterpret_cast&lt;TimerCallbackFunction_t>(connectToWifi));</k>
The following line assigns a callback function, so when the ESP32 connects to your Wi-Fi, it will execute the WiFiEvent() function to print the details described earlier.
<k>WiFi.onEvent(WiFiEvent);</k>
Finally, assign all the callbacks functions. This means that these functions will be executed automatically when needed. For example, when the ESP32 connects to the broker, it automatically calls the onMqttConnect() function, and so on.
<k>mqttClient.onConnect(onMqttConnect);
mqttClient.onDisconnect(onMqttDisconnect);
//mqttClient.onSubscribe(onMqttSubscribe);
//mqttClient.onUnsubscribe(onMqttUnsubscribe);
mqttClient.onPublish(onMqttPublish);
mqttClient.setServer(MQTT_HOST, MQTT_PORT);</k>
<h4>Broker Authentication</h4>
If your broker requires authentication, uncomment the following line and insert your credentials (username and password).
<k>mqttClient.setCredentials("REPlACE_WITH_YOUR_USER", "REPLACE_WITH_YOUR_PASSWORD");</k>
Finally, connect to Wi-Fi.
<k>connectToWifi();</k>
<h3>loop()</h3>
In the loop(), you create a timer that will allow you to publish new temperature readings in the <k>esp32/d18b20/temperature</k> topic every 10 seconds.
<k>unsigned long currentMillis = millis();
// Every X number of seconds (interval = 10 seconds) 
// it publishes a new MQTT message
if (currentMillis - previousMillis >= interval) {
  // Save the last time a new reading was published
  previousMillis = currentMillis;
  // New temperature readings
  sensors.requestTemperatures(); 
  // Temperature in Celsius degrees
  temp = sensors.getTempCByIndex(0);</k>
If you prefer the temperature in Fahrenheit, uncomment the following line:
<k>//temp = sensors.getTempFByIndex(0);</k>
Learn more about the DS18B20 temperature sensor: <a href="https://randomnerdtutorials.com/esp32-ds18b20-temperature-arduino-ide/">ESP32 with DS18B20 Temperature Sensor Guide</a>.
<h3>Publishing to topics</h3>
To publish a message on an MQTT topic, use the next line:
<k>uint16_t packetIdPub1 = mqttClient.publish(MQTT_PUB_TEMP, 1, true, String(temp).c_str());</k>
If you would like to publish more readings on different topics, you can duplicate this previous line the loop().
Basically, use the publish() method on the mqttClient object to publish data on a topic. The publish() method accepts the following arguments, in order:
MQTT topic (const char*)
QoS (uint8_t): quality of service  it can be 0, 1 or 2
retain flag (bool): retain flag
payload (const char*)
The QoS (quality of service) is a way to guarantee that the message is delivered. It can be one of the following levels:
<k>0</k>: the message will be delivered once or not at all. The message is not acknowledged. There is no possibility of duplicated messages;
<k>1</k>: the message will be delivered at least once, but may be delivered more than once;
<k>2</k>: the message is always delivered exactly once;
<a href="https://www.ibm.com/support/knowledgecenter/en/SSFKSJ_8.0.0/com.ibm.mq.dev.doc/q029090_.htm" target="_blank" aria-label=" (opens in a new tab)">Learn about MQTT QoS.</a>
<h3>Uploading the code</h3>
With your Raspberry Pi powered on and running the Mosquitto MQTT broker, upload the code to your ESP32.
Open the Serial Monitor at a baud rate of 115200 and you'll see that the ESP32 starts publishing messages.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-Publish-MQTT-DS18B20-Temperature-Serial-Monitor.png">
<h3>Preparing Node-RED Dashboard</h3>
The ESP32 is publishing temperature readings every 10 seconds on the <k>esp32/ds18b20/temperature</k> topic. Now, you can use any dashboard that supports MQTT or any other device that supports MQTT to subscribe to that topic and receive the readings.
As an example, we'll create a simple flow using Node-RED to subscribe to that topic and display the readings on a gauge or chart.
If you don't have Node-RED installed, follow the next tutorials:
<a href="https://randomnerdtutorials.com/getting-started-with-node-red-on-raspberry-pi/">Getting Started with Node-RED on Raspberry Pi</a>
<a href="https://randomnerdtutorials.com/getting-started-with-node-red-dashboard/">Installing and Getting Started with Node-RED Dashboard</a>
Having Node-RED running on your Raspberry Pi, go to your Raspberry Pi IP address followed by :1880.
<k>http://raspberry-pi-ip-address:1880</k>
The Node-RED interface should open. Drag an MQTT in node, a chart node and a gauge node to the flow.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/0-Node-RED-Drag-Nodes-MQTT-In-Chart-Gauge.png">
Click the MQTT node and edit its properties as follows:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/1-MQTT-In-Node-ESP32-Publish-Temperature-Node-RED-Flow.png">
The Server field refers to the MQTT broker. In our case, the MQTT broker is the Raspberry Pi, so it is set to localhost:1883. If you're using a Cloud MQTT broker, you should change that field. Insert the topic you want to be subscribed to and the QoS.
Set the following properties for the gauge node.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/2-Gauge-ESP32-Publish-Temperature-Node-RED-Flow.png">
Edit the chart node as follows:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/3-Chart-ESP32-Publish-Temperature-Node-RED-Flow.png">
Wire your nodes as shown below:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/4-ESP32-MQTT-Publish-Temperature-Node-RED-Flow.png">
Finally, deploy your flow (press the button on the upper right corner).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/06/11_deploy_button.png">
Alternatively, you can go to <k>Menu </k>> <k>Import </k>and copy the following to your <k>Clipboard</k> to create your Node-RED flow.
<k>[{"id":"5a45b8da.52b0d8","type":"mqtt in","z":"b01416d3.f69f38","name":"","topic":"esp32/ds18b20/temperature","qos":"1","datatype":"auto","broker":"8db3fac0.99dd48","x":380,"y":280,"wires":[["3042e15e.80a4ee","4c53cb0f.3e6084"]]},{"id":"3042e15e.80a4ee","type":"ui_gauge","z":"b01416d3.f69f38","name":"","group":"2b7ac01b.fc984","order":0,"width":0,"height":0,"gtype":"gage","title":"Temperature","label":"oC","format":"{{value}}","min":0,"max":"40","colors":["#00b500","#e6e600","#ca3838"],"seg1":"","seg2":"","x":650,"y":240,"wires":[]},{"id":"4c53cb0f.3e6084","type":"ui_chart","z":"b01416d3.f69f38","name":"","group":"2b7ac01b.fc984","order":1,"width":0,"height":0,"label":"Temperature","chartType":"line","legend":"false","xformat":"HH:mm:ss","interpolate":"linear","nodata":"","dot":false,"ymin":"","ymax":"","removeOlder":1,"removeOlderPoints":"","removeOlderUnit":"3600","cutout":0,"useOneColor":false,"colors":["#1f77b4","#aec7e8","#ff7f0e","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5"],"useOldStyle":false,"outputs":1,"x":650,"y":320,"wires":[[]]},{"id":"8db3fac0.99dd48","type":"mqtt-broker","z":"","name":"","broker":"localhost","port":"1883","clientid":"","usetls":false,"compatmode":false,"keepalive":"60","cleansession":true,"birthTopic":"","birthQos":"0","birthPayload":"","closeTopic":"","closeQos":"0","closePayload":"","willTopic":"","willQos":"0","willPayload":""},{"id":"2b7ac01b.fc984","type":"ui_group","z":"","name":"DS18B20 Temperature Sensor","tab":"99ab8dc5.f435c","disp":true,"width":"6","collapse":false},{"id":"99ab8dc5.f435c","type":"ui_tab","z":"","name":"Home","icon":"dashboard","disabled":false,"hidden":false}]
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_MQTT/ESP32_DS18B20_Flow.txt" target="_blank">View raw code</a>
<h3>Demonstration</h3>
Go to your Raspberry Pi IP address followed by <em>:1880/ui</em>.
<k>http://raspberry-pi-ip-address:1880/ui</k>
You should get access to the current sensor readings on the Dashboard (gauge and chart).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/5-ESP32-MQTT-Publish-Temperature-Node-RED-Dashboard-Gauge-Chart.png">
That's it! You have your ESP32 board publishing sensor readings to Node-RED via MQTT.
<h3>Wrapping Up</h3>
MQTT is a great communication protocol to exchange small amounts of data between devices. In this tutorial you've learned how to publish DS18B20 temperature readings with the ESP32 on an MQTT topic. Then, you can use any device or home automation platform to subscribe to that topic and receive the readings. 
Instead of a <a href="https://makeradvisor.com/tools/ds18b20-temperature-sensor-2/" target="_blank" aria-label="DS18B20 temperature sensor (opens in a new tab)">DS18B20 temperature sensor</a>, you can use any other sensor and you can also publish on multiple topics at the same time.
We hope you've found this tutorial useful. If you want to learn more about the ESP32, take a look at our resources:
<a href="https://randomnerdtutorials.com/learn-esp32-with-arduino-ide/">Learn ESP32 with Arduino IDE</a>
<a href="https://randomnerdtutorials.com/micropython-programming-with-esp32-and-esp8266/">MicroPython Programming with ESP32 and ESP8266</a>
<a href="https://randomnerdtutorials.com/projects-esp32/">More ESP32 Projects</a>
Thanks for reading.
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/smart-home-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px-pupj8i6e7hlzpgwxe82jjd8skst9vmrjt9lpqb0v0g.jpg" title="Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px" alt="SMART HOME with Raspberry Pi ESP32 and ESP8266 Node-RED InfluxDB eBook" loading="lazy" width="117" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/smart-home-ebook/">SMART HOME with Raspberry Pi, ESP32, ESP8266 [eBook] </a></h4>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>ESP32 NTP Client-Server: Get Date and Time (Arduino IDE)</h2>
Learn how to request date and time from an NTP Server using the ESP32 with Arduino IDE. Getting date and time is useful in data logging projects to timestamp readings. To get time from an NTP Server, the <a aria-label="ESP32 (opens in a new tab)" href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> needs to have an Internet connection and you don't need additional hardware (like an RTC clock).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-Get-Date-Day-Time-Hour-Minute-Arduino-IDE-NTP-Client-Server.jpg">
Before proceeding with this tutorial you need to have the ESP32 add-on installed in your Arduino IDE:
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<k>Recommended:</k> <a href="https://randomnerdtutorials.com/esp8266-nodemcu-date-time-ntp-client-server-arduino/">Get Date and Time with ESP8266 NodeMCU NTP Client-Server</a>
<h3>NTP (Network Time Protocol)</h3>
NTP stands for Network Time Protocol and it is a networking protocol for clock synchronization between computer systems. In other words, it is used to synchronize computer clock times in a network.
There are NTP servers like <em>pool.ntp.org</em> that anyone can use to request time as a client. In this case, the ESP32 is an NTP Client that requests time from an NTP Server (<em>pool.ntp.org</em>).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-NTP-Client-Server-Arduino-IDE-How-NTP-works.png">
<h3>Getting Date and Time from NTP Server</h3>
To get date and time with the ESP32, you don't need to install any libraries. You simply need to include the time.h library in your code.
The following code gets date and time from the NTP Server and prints the results on the Serial Monitor. It was based on the example provided by the time.h library.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-date-time-ntp-client-server-arduino/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;WiFi.h>
#include "time.h"
const char* ssid     = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
const char* ntpServer = "pool.ntp.org";
const long  gmtOffset_sec = 0;
const int   daylightOffset_sec = 3600;
void setup(){
  Serial.begin(115200);
  // Connect to Wi-Fi
  Serial.print("Connecting to ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.println("WiFi connected.");
  
  // Init and get the time
  configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
  printLocalTime();
  //disconnect WiFi as it's no longer needed
  WiFi.disconnect(true);
  WiFi.mode(WIFI_OFF);
}
void loop(){
  delay(1000);
  printLocalTime();
}
void printLocalTime(){
  struct tm timeinfo;
  if(!getLocalTime(&timeinfo)){
    Serial.println("Failed to obtain time");
    return;
  }
  Serial.println(&timeinfo, "%A, %B %d %Y %H:%M:%S");
  Serial.print("Day of week: ");
  Serial.println(&timeinfo, "%A");
  Serial.print("Month: ");
  Serial.println(&timeinfo, "%B");
  Serial.print("Day of Month: ");
  Serial.println(&timeinfo, "%d");
  Serial.print("Year: ");
  Serial.println(&timeinfo, "%Y");
  Serial.print("Hour: ");
  Serial.println(&timeinfo, "%H");
  Serial.print("Hour (12 hour format): ");
  Serial.println(&timeinfo, "%I");
  Serial.print("Minute: ");
  Serial.println(&timeinfo, "%M");
  Serial.print("Second: ");
  Serial.println(&timeinfo, "%S");
  Serial.println("Time variables");
  char timeHour[3];
  strftime(timeHour,3, "%H", &timeinfo);
  Serial.println(timeHour);
  char timeWeekDay[10];
  strftime(timeWeekDay,10, "%A", &timeinfo);
  Serial.println(timeWeekDay);
  Serial.println();
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Date_Time.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
Let's take a quick look at the code to see how it works. First, include the libraries to connect to Wi-Fi and get time.
<k>#include &lt;WiFi.h>
#include "time.h"</k>
<h3>Setting SSID and Password</h3>
Type your network credentials in the following variables, so that the ESP32 is able to establish an Internet connection and get date and time from the NTP server.
<k>// Replace with your network credentials
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h3>NTP Server and Time Settings</h3>
Then, you need to define the following variables to configure and get time from an NTP server: ntpServer, gmtOffset_sec and daylightOffset_sec.
<k>NTP Server</k>
We'll request the time from <em>pool.ntp.org</em>, which is a cluster of timeservers that anyone can use to request the time.
<k>const char* ntpServer = "pool.ntp.org";</k>
<k>GMT Offset</k>
The gmtOffset_sec variable defines the offset in seconds between your time zone and GMT. We live in Portugal, so the time offset is 0. Change the time gmtOffset_sec variable to match your time zone.
<k>const long gmtOffset_sec = 0;</k>
<k>Daylight Offset</k>
The daylightOffset_sec variable defines the offset in seconds for daylight saving time. It is generally one hour, that corresponds to 3600 seconds
<k>const int daylightOffset_sec = 3600;</k>
<h3>setup()</h3>
In the setup() you initialize the Serial communication at baud rate 115200 to print the results:
<k>Serial.begin(115200);</k>
These next lines connect the ESP32 to your router.
<k>// Connect to Wi-Fi
Serial.print("Connecting to ");
Serial.println(ssid);
WiFi.begin(ssid, password);
while (WiFi.status() != WL_CONNECTED) {
  delay(500);
  Serial.print(".");
}
Serial.println("");
Serial.println("WiFi connected.");</k>
Configure the time with the settings you've defined earlier:
<k>configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);</k>
<h3>printLocalTime()</h3>
After configuring the time, call the printLocalTime() function to print the time in the Serial Monitor.
In that function, create a time structure (struct tm) called timeinfo that contains all the details about the time (min, sec, hour, etc).
<k>struct tm timeinfo;</k>
The tm structure contains a calendar date and time broken down into its components:
tm_sec: seconds after the minute;
tm_min: minutes after the hour;
tm_hour: hours since midnight;
tm_mday: day of the month;
tm_year: years since 1900;
tm_wday: days since Sunday;
tm_yday: days since January 1;
tm_isdst: Daylight Saving Time flag;
<a href="http://www.cplusplus.com/reference/ctime/tm/" target="_blank">tm structure documentation</a>.
Get all the details about date and time and save them on the timeinfo structure.
<k>if(!getLocalTime(&timeinfo)){
  Serial.println("Failed to obtain time");
  return;
}</k>
Then, print all details about the time in the Serial Monitor. 
<k>Serial.println(&timeinfo, "%A, %B %d %Y %H:%M:%S");
Serial.print("Day of week: ");
Serial.println(&timeinfo, "%A");
Serial.print("Month: ");
Serial.println(&timeinfo, "%B");
Serial.print("Day of Month: ");
Serial.println(&timeinfo, "%d");
Serial.print("Year: ");
Serial.println(&timeinfo, "%Y");
Serial.print("Hour: ");
Serial.println(&timeinfo, "%H");
Serial.print("Hour (12 hour format): ");
Serial.println(&timeinfo, "%I");
Serial.print("Minute: ");
Serial.println(&timeinfo, "%M");
Serial.print("Second: ");
Serial.println(&timeinfo, "%S");</k>
To access the members of the date and time structure you can use the following specifiers:
<table><tbody>
<tr>
<td>%A</td>
<td>Full weekday name</td>
</tr>
<tr>
<td>%B</td>
<td>Full month name</td>
</tr>
<tr>
<td>%d</td>
<td>Day of the month</td>
</tr>
<tr>
<td>%Y</td>
<td>Year</td>
</tr>
<tr>
<td>%H</td>
<td>Hour in 24h format</td>
</tr>
<tr>
<td>%I</td>
<td>Hour in 12h format</td>
</tr>
<tr>
<td>%M</td>
<td>Minute</td>
</tr>
<tr>
<td>%S</td>
<td>Second</td>
</tr>
</tbody></table>There are other specifiers you can use to get information in other format, for example: abbreviated month name (%b), abbreviated weekday name (%a), week number with the first Sunday as the first day of week one (%U), and others (<a href="http://www.cplusplus.com/reference/ctime/strftime/" target="_blank">read more</a>).
We also show you an example, if you want to save information about time in variables. For example, if you want to save the hour into a variable called timeHour, create a char variable with a length of 3 characters (it must save the hour characters plus the terminating character). Then, copy the information about the hour that is on the timeinfo structure into the timeHour variable using the <a href="http://www.cplusplus.com/reference/ctime/strftime/" target="_blank" aria-label=" (opens in a new tab)">strftime()</a> function.
<k>Serial.println("Time variables");
char timeHour[3];
strftime(timeHour,3, "%H", &timeinfo);
Serial.println(timeHour);</k>
To get other variables, use a similar process. For example, for the week day, we need to create a char variable with a length of 10 characters because the longest day of the week contains 9 characters (saturday).
<k>char timeWeekDay[10];
strftime(timeWeekDay,10, "%A", &timeinfo);
Serial.println(timeWeekDay);
Serial.println();</k>
<h3>Demonstration</h3>
After inserting your network credentials and modifying the variables to change your timezone and daylight saving time, you can test the example.
Upload the code your ESP32 board. Make sure you have the right board and COM port selected. After uploading the code, press the ESP32 Enable button, and you should get the date and time every second as shown in the following figure.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-Request-Time-NRP-Server-Serial-Monitor.png">
<h3>Wrapping Up</h3>
In this tutorial you've learned how to get date and time from an NTP server using the ESP32 programmed with Arduino IDE. Now, you can use what you've learned here to timestamp the sensor readings in your own projects. 
This method only works if the ESP32 is connected to the Internet. If your project doesn't have access to the internet, you need to use other method. You can use an <a href="https://makeradvisor.com/tools/real-time-clock-module-ds1307/" target="_blank" aria-label=" (opens in a new tab)">RTC module like the DS1307</a>.
<h2>ESP32-CAM Camera Boards: Pin and GPIOs Assignment Guide</h2>
ESP32 development boards with camera are becoming popular with the maker community. There are different models of ESP32 Camera boards with different features. Each ESP32 Camera dev board uses different GPIOs to connect to the camera. In this guide we'll show you the pin definition to include in your code for each board.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-Camera-Boards-Pin-GPIO-Assignment-Guide.jpg">
This guide covers the pin/GPIOs assignment for the following ESP32 Camera Development boards:
ESP32-CAM AI-Thinker
Freenove ESP32-Wrover CAM
TTGO T-Journal
M5-Camera Model A
M5-Camera Model B
M5 ESP32-Camera (without PSRAM)
ESP-EYE
TTGO T-Camera Plus
TTGO T-Camera (with PIR sensor)
For a detailed comparison of the different ESP32 Camera Boards, read:
<a href="https://makeradvisor.com/esp32-camera-cam-boards-review-comparison/" target="_blank" aria-label=" (opens in a new tab)">ESP32 Camera Dev Boards Review and Comparison (Best ESP32-CAM)</a>
<h3>ESP32-CAM AI-Thinker Pin Assignment</h3>
The following image shows the pinout diagram for the ESP32-CAM AI-Thinker.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-pinout-new.png">
This is the OV2640 camera pin assignment for the ESP32-CAM AI-Thinker board:
<k>#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22</k>
The ESP32-CAM AI-Thinker comes with 10 exposed GPIOs. Learn how to use those GPIOs with this <a href="https://randomnerdtutorials.com/esp32-cam-ai-thinker-pinout/">ESP32-CAM Pinout Reference Guide</a>.
<k>Review:</k> <a href="https://makeradvisor.com/esp32-cam-ov2640-camera/" target="_blank" aria-label=" (opens in a new tab)">ESP32-CAM with OV2640 Camera</a>
<h3>Freenove ESP32-Wrover CAM Board</h3>
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/01/Freenove-ESP32.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/01/Freenove-ESP32.png"></a>
Pin definition for the ESP32-Wrover CAM board (Freenove brand). In some of the examples, this pin definition is under the CAMERA_MODEL_WROVER_KIT.
<k>#define PWDN_GPIO_NUM    -1
#define RESET_GPIO_NUM   -1
#define XCLK_GPIO_NUM    21
#define SIOD_GPIO_NUM    26
#define SIOC_GPIO_NUM    27
#define Y9_GPIO_NUM      35
#define Y8_GPIO_NUM      34
#define Y7_GPIO_NUM      39
#define Y6_GPIO_NUM      36
#define Y5_GPIO_NUM      19
#define Y4_GPIO_NUM      18
#define Y3_GPIO_NUM       5
#define Y2_GPIO_NUM       4
#define VSYNC_GPIO_NUM   25
#define HREF_GPIO_NUM    23
#define PCLK_GPIO_NUM    22
</k>
<h3>TTGO T-Journal Pin Assignment</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/TTGO-T-Journal.jpg">
Pin assignment for the TTGO T-Journal board.
<k>#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM     27
#define SIOD_GPIO_NUM     25
#define SIOC_GPIO_NUM     23
#define Y9_GPIO_NUM       19
#define Y8_GPIO_NUM       36
#define Y7_GPIO_NUM       18
#define Y6_GPIO_NUM       39
#define Y5_GPIO_NUM       5
#define Y4_GPIO_NUM       34
#define Y3_GPIO_NUM       35
#define Y2_GPIO_NUM       17
#define VSYNC_GPIO_NUM    22
#define HREF_GPIO_NUM     26
#define PCLK_GPIO_NUM     21</k>
<k>Review:</k> <a href="https://makeradvisor.com/ttgo-t-journal-esp32-camera-board-review/" target="_blank" aria-label=" (opens in a new tab)">TTGO T-Journal ESP32 Camera Development Board</a>
<h3>M5-Camera Model A Pin Assignment</h3>
There are two similar models: M5-Camera Model A and M5-Camera Model B. The model A looks as shown in the following figure.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/M5-Stack-ESP32-Camera-PSRAM-model-A.png">
Pin assignment for the M5-Camera Model A.
<k>#define PWDN_GPIO_NUM     -1
#define RESET_GPIO_NUM    15
#define XCLK_GPIO_NUM     27
#define SIOD_GPIO_NUM     25
#define SIOC_GPIO_NUM     23
#define Y9_GPIO_NUM       19
#define Y8_GPIO_NUM       36
#define Y7_GPIO_NUM       18
#define Y6_GPIO_NUM       39
#define Y5_GPIO_NUM        5
#define Y4_GPIO_NUM       34
#define Y3_GPIO_NUM       35
#define Y2_GPIO_NUM       32
#define VSYNC_GPIO_NUM    22
#define HREF_GPIO_NUM     26
#define PCLK_GPIO_NUM     21</k>
<h3>M5-Camera Model B Pin Assignment</h3>
The M5-Camera Model B looks as follows:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/M5-Stack-ESP32-Camera-PSRAM-model-B.png">
 Pin assignment for the M5-Camera Model B.
<k>#define PWDN_GPIO_NUM     -1
#define RESET_GPIO_NUM    15
#define XCLK_GPIO_NUM     27
#define SIOD_GPIO_NUM     22
#define SIOC_GPIO_NUM     23
#define Y9_GPIO_NUM       19
#define Y8_GPIO_NUM       36
#define Y7_GPIO_NUM       18
#define Y6_GPIO_NUM       39
#define Y5_GPIO_NUM        5
#define Y4_GPIO_NUM       34
#define Y3_GPIO_NUM       35
#define Y2_GPIO_NUM       32
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     26
#define PCLK_GPIO_NUM     21</k>
<h3>M5-Stack ESP32-Camera (without PSRAM) Pin Assignment</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/M5-stack-ESP32-camera-no-PSRAM.jpg">
Pin assignment for the M5-stack ESP32 camera without PSRAM.
<k>#define PWDN_GPIO_NUM     -1
#define RESET_GPIO_NUM    15
#define XCLK_GPIO_NUM     27
#define SIOD_GPIO_NUM     25
#define SIOC_GPIO_NUM     23
#define Y9_GPIO_NUM       19
#define Y8_GPIO_NUM       36
#define Y7_GPIO_NUM       18
#define Y6_GPIO_NUM       39
#define Y5_GPIO_NUM        5
#define Y4_GPIO_NUM       34
#define Y3_GPIO_NUM       35
#define Y2_GPIO_NUM       17
#define VSYNC_GPIO_NUM    22
#define HREF_GPIO_NUM     26
#define PCLK_GPIO_NUM     21</k>
<h3>ESP-EYE Pin Assignment</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP-EYE.jpg">
Pin assignment for the ESP-EYE camera.
<k>#define PWDN_GPIO_NUM    -1
#define RESET_GPIO_NUM   -1
#define XCLK_GPIO_NUM    4
#define SIOD_GPIO_NUM    18
#define SIOC_GPIO_NUM    23
#define Y9_GPIO_NUM      36
#define Y8_GPIO_NUM      37
#define Y7_GPIO_NUM      38
#define Y6_GPIO_NUM      39
#define Y5_GPIO_NUM      35
#define Y4_GPIO_NUM      14
#define Y3_GPIO_NUM      13
#define Y2_GPIO_NUM      34
#define VSYNC_GPIO_NUM   5
#define HREF_GPIO_NUM    27
#define PCLK_GPIO_NUM    25</k>
<k>Review:</k> <a href="https://makeradvisor.com/esp-eye-new-esp32-based-board/" target="_blank" aria-label=" (opens in a new tab)">ESP-EYE: ESP32-based board for AI</a>
<h3>TTGO T-Camera Plus Pin Assignment</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/TTGO-T-Camera-Plus.jpg">
Pin assignment for the TTGO T-Camera Plus.
<k>#define PWDN_GPIO_NUM    -1
#define RESET_GPIO_NUM   -1
#define XCLK_GPIO_NUM    4
#define SIOD_GPIO_NUM    18
#define SIOC_GPIO_NUM    23
#define Y9_GPIO_NUM      36
#define Y8_GPIO_NUM      37
#define Y7_GPIO_NUM      38
#define Y6_GPIO_NUM      39
#define Y5_GPIO_NUM      35
#define Y4_GPIO_NUM      26
#define Y3_GPIO_NUM      13
#define Y2_GPIO_NUM      34
#define VSYNC_GPIO_NUM   5
#define HREF_GPIO_NUM    27
#define PCLK_GPIO_NUM    25</k>
<k>Review:</k> <a href="https://makeradvisor.com/ttgo-t-camera-plus-esp32-review-pinout/" target="_blank" aria-label=" (opens in a new tab)">TTGO T-Camera Plus ESP32 Development Board</a>
<h3>TTGO T-Camera with PIR Sensor Pin Assignment</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/TTGO-Camera-with-PIT.jpg">
Pin definition for the T-Camera with PIR sensor (without microphone and without BME280):
<k>#define PWDN_GPIO_NUM -1
#define RESET_GPIO_NUM -1
#define XCLK_GPIO_NUM 32
#define SIOD_GPIO_NUM 13
#define SIOC_GPIO_NUM 12
#define Y9_GPIO_NUM 39
#define Y8_GPIO_NUM 36
#define Y7_GPIO_NUM 23
#define Y6_GPIO_NUM 18
#define Y5_GPIO_NUM 15
#define Y4_GPIO_NUM 4
#define Y3_GPIO_NUM 14
#define Y2_GPIO_NUM 5
#define VSYNC_GPIO_NUM 27
#define HREF_GPIO_NUM 25
#define PCLK_GPIO_NUM 19</k>
<a href="https://randomnerdtutorials.com/esp32-cam-projects-ebook/">
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-eBook-334.jpg?fit=334%2C334&quality=100&strip=all&ssl=1" alt="" srcset="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-eBook-334.jpg?w=334&quality=100&strip=all&ssl=1 334w, https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-eBook-334.jpg"></a>

<h3>Wrapping Up</h3>
Having the right pin definition for your ESP32 camera board is very important. Otherwise, your code won't work or your board will <a href="https://randomnerdtutorials.com/esp32-cam-troubleshooting-guide/">not initialize the camera</a>.
We have several tutorials for the ESP32-CAM that may also be compatible with other ESP32 camera boards as long as you use the right pin definition in your code.
<a aria-label="ESP32-CAM Take Photo and Save to MicroSD Card (opens in a new tab)" href="https://randomnerdtutorials.com/esp32-cam-take-photo-save-microsd-card/" target="_blank">ESP32-CAM Take Photo and Save to MicroSD Card</a>
<a aria-label="ESP32-CAM PIR Motion Detector with Photo Capture (saves to microSD card) (opens in a new tab)" href="https://randomnerdtutorials.com/esp32-cam-pir-motion-detector-photo-capture/" target="_blank">ESP32-CAM PIR Motion Detector with Photo Capture</a>
<a href="https://randomnerdtutorials.com/esp32-cam-video-streaming-face-recognition-arduino-ide/">ESP32-CAM Video Streaming and Face Recognition with Arduino IDE</a>
<a href="https://randomnerdtutorials.com/esp32-cam-projects-ebook/"><k>Build ESP32-CAM Projects (eBook)</k></a>
<a href="https://randomnerdtutorials.com/projects-esp32-cam/"><k>Read all our ESP32-CAM Projects, Tutorials and Guides</k></a>
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h-p2lw6wwnkk9ystvwe9iof8zx6yt4x7uma3cqfup534.jpg" title="Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h" alt="Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h" loading="lazy" width="129" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/">[eBook] Build Web Servers with ESP32 and ESP8266 (2nd Edition)</a></h4>
Build Web Server projects with the ESP32 and ESP8266 boards to control outputs and monitor sensors remotely. Learn HTML, CSS, JavaScript and client-server communication protocols <k><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Build Web Server projects with the ESP32 and ESP8266 boards to control outputs and monitor sensors remotely. Learn HTML, CSS, JavaScript and client-server communication protocols <k><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>ESP32-CAM Connect External Antenna (Extend Wi-Fi Coverage)</h2>
The ESP32-CAM comes with an on-board Wi-Fi antenna, but it also has an IPEX connector if you want to use an external antenna. Using an external antenna can solve problems related with slow <a href="https://randomnerdtutorials.com/esp32-cam-video-streaming-web-server-camera-home-assistant/">video streaming</a> web servers and other connectivity problems. This tutorial shows how to use an external antenna with the <a href="https://makeradvisor.com/esp32-cam-ov2640-camera/" target="_blank">ESP32-CAM</a>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-External-Antenna-connected.jpg">
<h3>How to connect an External Antenna to the ESP32-CAM</h3>
The ESP32-CAM has the option to use either the built-in PCB antenna or an external antenna as the one shown in the following figure.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-External-Antenna.jpg">
Next to the IPEX connector there are three little white squares laid out like a <k>&lt;</k> with the middle position being common. There is a resistor selecting the desired antenna. Here's the two configurations:
To use the IPEX connector with an <k>external antenna</k>, the resistor must be on the bottom position, like this <k>\</k>. See illustration below;
To use the PCB antenna (<k>on-board antenna</k>), the resistor must be on the top position, like this <k>/</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-Antenna-external-on-board-restitor-placement.jpg">
Take a look at your board to see if it is set to use the on-board antenna or the IPEX connector. Using the on-board antenna works well if you are close to your router. We recommend using the IPEX connector with an external antenna for better results.
Projects with video streaming crash frequently when you don't use an external antenna due to poor connectivity. So, make sure you <a href="https://makeradvisor.com/tools/esp32-cam-external-antenna/" target="_blank" aria-label=" (opens in a new tab)">get one</a> to have your projects working reliably.
To enable or disable the on-board antenna, you just need to unsolder that resistor and solder it in the desired configuration. You can also drop some solder to connect those points (you don't necessarily need to add the resistor as long as the pads are connected).
<k>Note: </k> You can't use the two antennas at the same time, so you can only have one connection for the antenna.
When getting an ESP32-CAM, there are stores that offer the package with an external antenna:
<a href="https://makeradvisor.com/tools/esp32-cam-external-antenna/" target="_blank" aria-label="ESP32-CAM with External Antenna (opens in a new tab)">ESP32-CAM with External Antenna</a>
<h3>Testing the ESP32-CAM Wi-Fi Signal Strength</h3>
You can <a href="https://randomnerdtutorials.com/program-upload-code-esp32-cam/">upload the following code to your ESP32-CAM boards</a> to check the signal strength of the connection to the router (RSSI  Received Signal Strength Indication).
<k>#include "WiFi.h"
const char* ssid     = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
void setup(){
  Serial.begin(115200);
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.println("WiFi connected.");
  delay(100);
}
void loop(){
  Serial.print("RSSI: ");
  Serial.println(WiFi.RSSI());
  delay(2000);
}</k>
When testing the signal strength, the closer the value to 0, the stronger the signal is.
In our case, with a distance of approximately 5 meters (16.4 feet) to the router with obstacles in between (walls), we got the following results:
ESP32-CAM <em>without antenna</em>: RSSI of approximately -60
ESP32-CAM <em>with antenna</em>: RSSI of approximately -36
<a href="https://randomnerdtutorials.com/esp32-cam-projects-ebook/">
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-eBook-334.jpg?fit=334%2C334&quality=100&strip=all&ssl=1" alt="" srcset="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-eBook-334.jpg?w=334&quality=100&strip=all&ssl=1 334w, https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-eBook-334.jpg"></a>

<h3>Wrapping Up</h3>
If you're having issues with your video streaming projects with the ESP32-CAM: constant lag and very slow web servers, adding an external antenna might solve those problems. If you connect an external antenna, take a look at your board to see if it has the right connection to actually use the external antenna.
If you're having other problems/errors with your ESP32-CAM projects, take a look at our troubleshooting guide  <a href="https://randomnerdtutorials.com/esp32-cam-troubleshooting-guide/">ESP32-CAM Troubleshooting Guide</a>.
We hope you've found these tips about the <a href="https://makeradvisor.com/tools/esp32-cam-external-antenna/" target="_blank">ESP32-CAM antenna</a> useful. We have more projects and tutorials about the ESP32-CAM that you may like:
<a href="https://randomnerdtutorials.com/esp32-cam-ai-thinker-pinout/">ESP32-CAM AI-Thinker Pinout Guide: GPIOs Usage Explained</a>
<a style="font-size: inherit; background-color: initial;" href="https://randomnerdtutorials.com/esp32-cam-video-streaming-face-recognition-arduino-ide/" target="_blank">Video Streaming, Face Detection and Face Recognition</a>
<a href="https://randomnerdtutorials.com/esp32-cam-pir-motion-detector-photo-capture/" target="_blank">PIR Motion Detector with Photo Capture</a>
<a href="https://makeradvisor.com/esp32-camera-cam-boards-review-comparison/" target="_blank">Best ESP32 Camera Development Board</a>
<a href="https://randomnerdtutorials.com/esp32-cam-projects-ebook/"><k>Build ESP32-CAM Projects (eBook)</k></a>
<a href="https://randomnerdtutorials.com/projects-esp32-cam/"><k>Read all our ESP32-CAM Projects, Tutorials and Guides</k></a>
Thanks for reading.
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/smart-home-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px-pupj8i6e7hlzpgwxe82jjd8skst9vmrjt9lpqb0v0g.jpg" title="Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px" alt="SMART HOME with Raspberry Pi ESP32 and ESP8266 Node-RED InfluxDB eBook" loading="lazy" width="117" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/smart-home-ebook/">SMART HOME with Raspberry Pi, ESP32, ESP8266 [eBook] </a></h4>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>ESP32-CAM AI-Thinker Pinout Guide: GPIOs Usage Explained</h2>
The ESP32-CAM is a development board with an ESP32-S chip, an OV2640 camera, microSD card slot and several GPIOs to connect peripherals. In this guide, we'll take a look at the ESP32-CAM GPIOs and how to use them.
<h3>Pinout Diagram</h3>
The following image shows the pinout diagram for the <a href="https://makeradvisor.com/tools/esp32-cam-external-antenna/" target="_blank" aria-label=" (opens in a new tab)">ESP32-CAM AI-Thinker</a>.
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-pinout-new.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-pinout-new.png"></a>
<h3>Schematic Diagram</h3>
The following figure shows the schematic diagram for the ESP32-CAM.
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-AI-Thinker-schematic-diagram.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-AI-Thinker-schematic-diagram.png"></a><center><figcaption><a href="https://github.com/SeeedDocument/forum_doc/blob/master/reg/ESP32_CAM_V1.6.pdf" target="_blank" aria-label="Image Source (opens in a new tab)">Image Source</a></figcaption></center>You can download a PDF file with better resolution on <a aria-label="this GitHub repository (opens in a new tab)" href="https://github.com/SeeedDocument/forum_doc/blob/master/reg/ESP32_CAM_V1.6.pdf" target="_blank">this GitHub repository</a>.
<h3>Power Pins</h3>
The ESP32-CAM comes with three GND pins (colored in black color) and two power pins (colored with red color): 3.3V and 5V.
You can power the ESP32-CAM through the 3.3V or 5V pins. However, many people reported errors when powering the ESP32-CAM with 3.3V, so we always advise to <k>power the ESP32-CAM through the 5V pin</k>.
<h3>Power output pin</h3>
There's also the pin labeled on the silkscreen as <k>VCC</k> (colored with a yellow rectangle). You should not use that pin to power the ESP32-CAM. That is an output power pin. It can either output 5V or 3.3V. 
In our case, the ESP32-CAM outputs 3.3V whether it is powered with 5V or 3.3V. Next to the VCC pin, there are two pads. One labeled as 3.3V and other as 5V. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-Camera-AI-Think-Module-VCC-Power-Pins.jpg">
If you look closely, you should have a jumper on the 3.3V pads. If you want to have an output of 5V on the VCC pin, you need to unsolder that connection and solder the 5V pads.
<h3>Serial Pins</h3>
GPIO 1 and GPIO 3 are the serial pins (TX and RX, respectively). Because the ESP32-CAM doesn't have a built-in programmer, you need to use these pins to communicate with the board and upload code. 
The best way to upload code to the ESP32-CAM is using an <a href="https://makeradvisor.com/tools/ftdi-programmer-board/" target="_blank" aria-label=" (opens in a new tab)">FTDI programmer</a>.
<a href="https://randomnerdtutorials.com/program-upload-code-esp32-cam/">Learn how to upload code to the ESP32-CAM AI-Thinker.</a>
You can use GPIO 1 and GPIO 3 to connect other peripherals like outputs or sensors after uploading the code. However, you won't be able to open the Serial Monitor and see if everything is going well with your setup.
<h3>GPIO 0</h3>
GPIO 0 determines whether the ESP32 is in flashing mode or not. This GPIO is internally connected to a pull-up 10k Ohm resistor.
When GPIO 0 is connected to GND, the ESP32 goes into flashing mode and you can upload code to the board.
GPIO 0 connected to GND <U+00BB> ESP32-CAM in flashing mode
To make the ESP32 run normally, you just need to disconnect GPIO 0 from GND.
<h3>MicroSD Card Connections</h3>
The following pins are used to interface with the microSD card when it is on operation.
<table><tbody>
<tr>
<td><k>MicroSD card</k></td>
<td><k>ESP32</k></td>
</tr>
<tr>
<td>CLK</td>
<td>GPIO 14</td>
</tr>
<tr>
<td>CMD</td>
<td>GPIO 15</td>
</tr>
<tr>
<td>DATA0</td>
<td>GPIO 2</td>
</tr>
<tr>
<td>DATA1 / flashlight</td>
<td>GPIO 4</td>
</tr>
<tr>
<td>DATA2</td>
<td>GPIO 12</td>
</tr>
<tr>
<td>DATA3</td>
<td>GPIO 13</td>
</tr>
</tbody></table>If you're not using the microSD card, you can use these pins as regular inputs/outputs. You can take a look at the <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">ESP32 pinout guide</a> to see the features of these pins.
All these GPIOs are RTC and support ADC: GPIOs 2, 4, 12, 13, 14, and 15.
<h3>Flashlight (GPIO 4)</h3>
The ESP32-CAM has a very bright built-in LED that can work as a flash when taking
 photos. That LED is internally connected to GPIO 4. 
That GPIO is also connected to the microSD card slot, so you may have troubles when trying to use both at the same time  the flashlight will light up when using the microSD card.
<k>Note:</k> one of our readers shared that if you initialize the microSD card as follows, you won't have this problem because the microSD card won't use that data line.*
<k>SD_MMC.begin("/sdcard", true)</k>
* we found that this works and that the LED will not make that flash effect. However, the LED remains on with low brightness  we're not sure if we are missing something.
<h3>GPIO 33  Built-in Red LED</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-AI-Thinker-Module-Red-LED-built-in.jpg">Next to the RST button, there's an on-board red LED. That LED is internally connected to GPIO 33. You can use this LED to indicate that something is happening. For example, if the Wi-Fi is connected, the LED is red or vice-versa.
That LED works with inverted logic, so you send a LOW signal to turn it on and a HIGH signal to turn it off.
You can experiment uploading the following snippet and see if you get that LED glowing.
<k>void setup() {
  pinMode(33, OUTPUT);
}
void loop() {
  digitalWrite(33, LOW);
}</k>
<h3>Camera Connections</h3>
The connections between the camera and the ESP32-CAM AI-Thinker are shown in the following table.
<table><tbody>
<tr>
<td><k>OV2640 CAMERA</k></td>
<td><k>ESP32</k></td>
<td><k>Variable name in code</k></td>
</tr>
<tr>
<td>D0</td>
<td>GPIO 5</td>
<td>Y2_GPIO_NUM</td>
</tr>
<tr>
<td>D1</td>
<td>GPIO 18</td>
<td>Y3_GPIO_NUM</td>
</tr>
<tr>
<td>D2</td>
<td>GPIO 19</td>
<td>Y4_GPIO_NUM</td>
</tr>
<tr>
<td>D3</td>
<td>GPIO 21</td>
<td>Y5_GPIO_NUM</td>
</tr>
<tr>
<td>D4</td>
<td>GPIO 36</td>
<td>Y6_GPIO_NUM</td>
</tr>
<tr>
<td>D5</td>
<td>GPIO 39</td>
<td>Y7_GPIO_NUM</td>
</tr>
<tr>
<td>D6</td>
<td>GPIO 34</td>
<td>Y8_GPIO_NUM</td>
</tr>
<tr>
<td>D7</td>
<td>GPIO 35</td>
<td>Y9_GPIO_NUM</td>
</tr>
<tr>
<td>XCLK</td>
<td>GPIO 0</td>
<td>XCLK_GPIO_NUM</td>
</tr>
<tr>
<td>PCLK</td>
<td>GPIO 22</td>
<td>PCLK_GPIO_NUM</td>
</tr>
<tr>
<td>VSYNC</td>
<td>GPIO 25</td>
<td>VSYNC_GPIO_NUM</td>
</tr>
<tr>
<td>HREF</td>
<td>GPIO 23</td>
<td>HREF_GPIO_NUM</td>
</tr>
<tr>
<td>SDA</td>
<td>GPIO 26</td>
<td>SIOD_GPIO_NUM</td>
</tr>
<tr>
<td>SCL</td>
<td>GPIO 27</td>
<td>SIOC_GPIO_NUM</td>
</tr>
<tr>
<td>POWER PIN</td>
<td>GPIO 32</td>
<td>PWDN_GPIO_NUM</td>
</tr>
</tbody></table>So, the pin definition for the ESP32-CAM AI-Thinker on the Arduino IDE should be as follows:
<k>#define PWDN_GPIO_NUM  32
#define RESET_GPIO_NUM -1
#define XCLK_GPIO_NUM  0
#define SIOD_GPIO_NUM  26
#define SIOC_GPIO_NUM  27
#define Y9_GPIO_NUM    35
#define Y8_GPIO_NUM    34
#define Y7_GPIO_NUM    39
#define Y6_GPIO_NUM    36
#define Y5_GPIO_NUM    21
#define Y4_GPIO_NUM    19
#define Y3_GPIO_NUM    18
#define Y2_GPIO_NUM    5
#define VSYNC_GPIO_NUM 25
#define HREF_GPIO_NUM  23
#define PCLK_GPIO_NUM  22</k>
<a href="https://randomnerdtutorials.com/esp32-cam-projects-ebook/">
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-eBook-334.jpg?fit=334%2C334&quality=100&strip=all&ssl=1" alt="" srcset="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-eBook-334.jpg?w=334&quality=100&strip=all&ssl=1 334w, https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-eBook-334.jpg"></a>
<h3>Wrapping Up</h3>
We hope you've found this guide for the ESP32-CAM GPIOs useful. If you have any tips or more info about the ESP32-CAM GPIOs, write a comment below.
We have several projects with the ESP32-CAM that you may like:
<a href="https://randomnerdtutorials.com/esp32-cam-video-streaming-face-recognition-arduino-ide/" target="_blank">Video Streaming, Face Detection and Face Recognition</a>
<a href="https://randomnerdtutorials.com/esp32-cam-video-streaming-web-server-camera-home-assistant/" target="_blank">ESP32 IP CAM  Video Streaming (Home Assistant and Node-RED)</a>
<a style="font-size: inherit; background-color: initial;" href="https://randomnerdtutorials.com/esp32-cam-pir-motion-detector-photo-capture/" target="_blank">PIR Motion Detector with Photo Capture</a>
<a href="https://randomnerdtutorials.com/esp32-cam-take-photo-display-web-server/" target="_blank">Take Photo, Save to SPIFFS and Display in Web Server</a>
<a href="https://makeradvisor.com/esp32-camera-cam-boards-review-comparison/" target="_blank">Best ESP32 Camera Development Board</a>
<a href="https://randomnerdtutorials.com/esp32-cam-projects-ebook/"><k>Build ESP32-CAM Projects (eBook)</k></a>
<a href="https://randomnerdtutorials.com/projects-esp32-cam/"><k>Read all our ESP32-CAM Projects, Tutorials and Guides</k></a>
Thanks for reading.
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/smart-home-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px-pupj8i6e7hlzpgwxe82jjd8skst9vmrjt9lpqb0v0g.jpg" title="Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px" alt="SMART HOME with Raspberry Pi ESP32 and ESP8266 Node-RED InfluxDB eBook" loading="lazy" width="117" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/smart-home-ebook/">SMART HOME with Raspberry Pi, ESP32, ESP8266 [eBook] </a></h4>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>Change ESP32-CAM OV2640 Camera Settings: Brightness, Resolution, Quality, Contrast, and More</h2>
This guide shows how to change the <a aria-label="ESP32-CAM OV2640 (opens in a new tab)" href="https://makeradvisor.com/tools/esp32-cam/" target="_blank">ESP32-CAM OV2640</a> camera settings such as contrast, brightness, resolution, quality, saturation and more using Arduino IDE.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-Settings.jpg">
The instructions in this tutorial work for any ESP32 camera development board as long as it comes with the OV2640 camera.
<k>You may like reading:</k> <a href="https://makeradvisor.com/esp32-camera-cam-boards-review-comparison/" target="_blank">Best ESP32 Camera Development Board</a>
<h3>Installing the ESP32 add-on</h3>
We'll program the ESP32 board using Arduino IDE. So, you need the Arduino IDE installed as well as the ESP32 add-on:
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<h3>OV2640 Camera Settings</h3>
In the <a href="https://randomnerdtutorials.com/esp32-cam-video-streaming-face-recognition-arduino-ide/">ESP32 Camera Web Server project</a>, the web server provided a lot of options to change the image settings. Take a look at the following screenshot  there are sliders that you can move to change the image settings. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/03/ESP32-CAM-video-streaming-example.jpg">
In this tutorial we'll show you how to implement those changes on your code regardless of the project you're building: taking photos or streaming video.
We recommend that you follow the <a href="https://randomnerdtutorials.com/esp32-cam-video-streaming-face-recognition-arduino-ide/">Camera Web Server project</a> first and play with the image settings to see what each setting does:
<a href="https://randomnerdtutorials.com/esp32-cam-video-streaming-face-recognition-arduino-ide/">ESP32-CAM Video Streaming and Face Recognition with Arduino IDE</a>
Depending on where your camera is located, you may want to change some settings to get a better picture. Playing with that web server gives you an idea of what you need to change and what values you need to set to get a better picture. Once you know the best settings for your camera, you may want to apply them in your other projects.
<h3>Changing ESP32-CAM Camera Settings Arduino Sketch</h3>
 To change the image settings, after initializing the camera, use the following lines:
<k>sensor_t * s = esp_camera_sensor_get()
s->set_brightness(s, 0);     // -2 to 2
s->set_contrast(s, 0);       // -2 to 2
s->set_saturation(s, 0);     // -2 to 2
s->set_special_effect(s, 0); // 0 to 6 (0 - No Effect, 1 - Negative, 2 - Grayscale, 3 - Red Tint, 4 - Green Tint, 5 - Blue Tint, 6 - Sepia)
s->set_whitebal(s, 1);       // 0 = disable , 1 = enable
s->set_awb_gain(s, 1);       // 0 = disable , 1 = enable
s->set_wb_mode(s, 0);        // 0 to 4 - if awb_gain enabled (0 - Auto, 1 - Sunny, 2 - Cloudy, 3 - Office, 4 - Home)
s->set_exposure_ctrl(s, 1);  // 0 = disable , 1 = enable
s->set_aec2(s, 0);           // 0 = disable , 1 = enable
s->set_ae_level(s, 0);       // -2 to 2
s->set_aec_value(s, 300);    // 0 to 1200
s->set_gain_ctrl(s, 1);      // 0 = disable , 1 = enable
s->set_agc_gain(s, 0);       // 0 to 30
s->set_gainceiling(s, (gainceiling_t)0);  // 0 to 6
s->set_bpc(s, 0);            // 0 = disable , 1 = enable
s->set_wpc(s, 1);            // 0 = disable , 1 = enable
s->set_raw_gma(s, 1);        // 0 = disable , 1 = enable
s->set_lenc(s, 1);           // 0 = disable , 1 = enable
s->set_hmirror(s, 0);        // 0 = disable , 1 = enable
s->set_vflip(s, 0);          // 0 = disable , 1 = enable
s->set_dcw(s, 1);            // 0 = disable , 1 = enable
s->set_colorbar(s, 0);       // 0 = disable , 1 = enable</k>
The following table shows each function and the values accepted:
<table><tbody>
<tr>
<td><k>Function</k></td>
<td><k>Meaning</k></td>
<td><k>Values</k></td>
</tr>
<tr>
<td>set_brightness()</td>
<td>Set brightness</td>
<td>-2 to 2</td>
</tr>
<tr>
<td>set_contrast()</td>
<td>Set contrast</td>
<td>-2 to 2 </td>
</tr>
<tr>
<td>set_saturation()</td>
<td>Set saturation</td>
<td>-2 to 2 </td>
</tr>
<tr>
<td>set_special_effect()</td>
<td>Set a special effect</td>
<td>0  No Effect
1  Negative
2  Grayscale
3  Red Tint
4  Green Tint
5  Blue Tint
6  Sepia</td>
</tr>
<tr>
<td>set_whitebal()</td>
<td>Set white balance</td>
<td>0  disable
1  enable</td>
</tr>
<tr>
<td>set_awb_gain()</td>
<td>Set white balance gain</td>
<td>0  disable
1  enable </td>
</tr>
<tr>
<td>set_wb_mode()</td>
<td>Set white balance mode</td>
<td>0  Auto
1  Sunny
2  Cloudy
3  Office
4  Home</td>
</tr>
<tr>
<td>set_exposure_ctrl()</td>
<td>Set exposure control</td>
<td>0  disable
1  enable</td>
</tr>
<tr>
<td>set_aec2()</td>
<td></td>
<td>0  disable
1  enable</td>
</tr>
<tr>
<td>set_ae_level()</td>
<td></td>
<td>-2 to 2</td>
</tr>
<tr>
<td>set_aec_value()</td>
<td></td>
<td>0 to 1200</td>
</tr>
<tr>
<td>set_gain_ctrl()</td>
<td></td>
<td>0  disable
1  enable</td>
</tr>
<tr>
<td>set_agc_gain()</td>
<td></td>
<td>0 to 30</td>
</tr>
<tr>
<td>set_gainceiling()</td>
<td></td>
<td>0 to 6</td>
</tr>
<tr>
<td>set_bpc()</td>
<td></td>
<td>0  disable
1  enable</td>
</tr>
<tr>
<td>set_wpc()</td>
<td></td>
<td>0  disable
1  enable</td>
</tr>
<tr>
<td>set_raw_gma()</td>
<td></td>
<td>0  disable
1  enable</td>
</tr>
<tr>
<td>set_lenc()</td>
<td>Set lens correction</td>
<td>0  disable
1  enable</td>
</tr>
<tr>
<td>set_hmirror()</td>
<td>Horizontal mirror</td>
<td>0  disable
1  enable</td>
</tr>
<tr>
<td>set_vflip()</td>
<td>Vertical flip</td>
<td>0  disable
1  enable</td>
</tr>
<tr>
<td>set_dcw()</td>
<td></td>
<td>0  disable
1  enable </td>
</tr>
<tr>
<td>set_colorbar()</td>
<td>Set a colorbar</td>
<td>0  disable
1  enable</td>
</tr>
</tbody></table>As you can see, changing the camera settings is pretty straightforward. You just need to use those lines of code after initializing the camera. After that, you can use the usual functions and code to control the camera. To better understand how to use them, you can follow the next example.
The functions in the table appear in the same order as in the <a href="https://randomnerdtutorials.com/esp32-cam-video-streaming-face-recognition-arduino-ide/">Camera Web Server example</a> so that it is easier to identify which functions and values you should use to get a better image in your scenario.
<h3>Changing ESP32-CAM Camera Settings Example</h3>
To show you how to apply the image settings in your code, we've built a simple example. The following code takes a photo every 10 seconds and saves it in the microSD card. There's a section in the code that allows you to change the camera settings.
<k>/*********
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-cam-ov2640-camera-settings/
*********/
#include "esp_camera.h"
#include "FS.h"                // SD Card ESP32
#include "SD_MMC.h"            // SD Card ESP32
#include "soc/soc.h"           // Disable brownout problems
#include "soc/rtc_cntl_reg.h"  // Disable brownout problems
#include "driver/rtc_io.h"
// Pin definition for CAMERA_MODEL_AI_THINKER
// Change pin definition if you're using another ESP32 with camera module
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22
// Keep track of number of pictures
unsigned int pictureNumber = 0;
//Stores the camera configuration parameters
camera_config_t config;
void setup() {
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0); //disable brownout detector
 
  Serial.begin(115200);
  
  //Initialize the camera  
  Serial.print("Initializing the camera module...");
  configInitCamera();
  Serial.println("Ok!");
 
  //Initialize MicroSD
  Serial.print("Initializing the MicroSD card module... ");
  initMicroSDCard();
}
void loop() {
  //Path where new picture will be saved in SD Card
  String path = "/picture" + String(pictureNumber) +".jpg";  
  Serial.printf("Picture file name: %s\n", path.c_str());
  //Take and Save Photo
  takeSavePhoto(path);
  pictureNumber++;
  delay(10000); 
}
void configInitCamera(){
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM;
  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;
  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;
  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;
  config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk = XCLK_GPIO_NUM;
  config.pin_pclk = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM;
  config.pin_href = HREF_GPIO_NUM;
  config.pin_sscb_sda = SIOD_GPIO_NUM;
  config.pin_sscb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn = PWDN_GPIO_NUM;
  config.pin_reset = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG; //YUV422,GRAYSCALE,RGB565,JPEG
  // Select lower framesize if the camera doesn't support PSRAM
  if(psramFound()){
    config.frame_size = FRAMESIZE_UXGA; // FRAMESIZE_ + QVGA|CIF|VGA|SVGA|XGA|SXGA|UXGA
    config.jpeg_quality = 10; //10-63 lower number means higher quality
    config.fb_count = 2;
  } else {
    config.frame_size = FRAMESIZE_SVGA;
    config.jpeg_quality = 12;
    config.fb_count = 1;
  }
  
  // Initialize the Camera
  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed with error 0x%x", err);
    return;
  }
  sensor_t * s = esp_camera_sensor_get();
  s->set_brightness(s, 0);     // -2 to 2
  s->set_contrast(s, 0);       // -2 to 2
  s->set_saturation(s, 0);     // -2 to 2
  s->set_special_effect(s, 0); // 0 to 6 (0 - No Effect, 1 - Negative, 2 - Grayscale, 3 - Red Tint, 4 - Green Tint, 5 - Blue Tint, 6 - Sepia)
  s->set_whitebal(s, 1);       // 0 = disable , 1 = enable
  s->set_awb_gain(s, 1);       // 0 = disable , 1 = enable
  s->set_wb_mode(s, 0);        // 0 to 4 - if awb_gain enabled (0 - Auto, 1 - Sunny, 2 - Cloudy, 3 - Office, 4 - Home)
  s->set_exposure_ctrl(s, 1);  // 0 = disable , 1 = enable
  s->set_aec2(s, 0);           // 0 = disable , 1 = enable
  s->set_ae_level(s, 0);       // -2 to 2
  s->set_aec_value(s, 300);    // 0 to 1200
  s->set_gain_ctrl(s, 1);      // 0 = disable , 1 = enable
  s->set_agc_gain(s, 0);       // 0 to 30
  s->set_gainceiling(s, (gainceiling_t)0);  // 0 to 6
  s->set_bpc(s, 0);            // 0 = disable , 1 = enable
  s->set_wpc(s, 1);            // 0 = disable , 1 = enable
  s->set_raw_gma(s, 1);        // 0 = disable , 1 = enable
  s->set_lenc(s, 1);           // 0 = disable , 1 = enable
  s->set_hmirror(s, 0);        // 0 = disable , 1 = enable
  s->set_vflip(s, 0);          // 0 = disable , 1 = enable
  s->set_dcw(s, 1);            // 0 = disable , 1 = enable
  s->set_colorbar(s, 0);       // 0 = disable , 1 = enable
}
void initMicroSDCard(){
  // Start Micro SD card
  Serial.println("Starting SD Card");
  if(!SD_MMC.begin()){
    Serial.println("SD Card Mount Failed");
    return;
  }
  uint8_t cardType = SD_MMC.cardType();
  if(cardType == CARD_NONE){
    Serial.println("No SD Card attached");
    return;
  }
}
void takeSavePhoto(String path){
  // Take Picture with Camera
  camera_fb_t  * fb = esp_camera_fb_get();
  
  
  if(!fb) {
    Serial.println("Camera capture failed");
    return;
  }
  // Save picture to microSD card
  fs::FS &fs = SD_MMC; 
  File file = fs.open(path.c_str(), FILE_WRITE);
  if(!file){
    Serial.println("Failed to open file in writing mode");
  } 
  else {
    file.write(fb->buf, fb->len); // payload (image), payload length
    Serial.printf("Saved file to path: %s\n", path.c_str());
  }
  file.close();
  
  //return the frame buffer back to the driver for reuse
  esp_camera_fb_return(fb); 
}
</k>
<a href="https://github.com/RuiSantosdotme/ESP32-CAM-Arduino-IDE/raw/master/ESP32-CAM-Change-Settings/ESP32-CAM-Change-Settings.ino" target="_blank">View raw code</a>
To makes things simpler, we've created a function called configInitCamera() that contains all the commands to initialize the camera.
<h3>Assigning OV2640 GPIOs</h3>
First, it starts by assigning the GPIOs.
<k>config.ledc_channel = LEDC_CHANNEL_0;
config.ledc_timer = LEDC_TIMER_0;
config.pin_d0 = Y2_GPIO_NUM;
config.pin_d1 = Y3_GPIO_NUM;
config.pin_d2 = Y4_GPIO_NUM;
config.pin_d3 = Y5_GPIO_NUM;
config.pin_d4 = Y6_GPIO_NUM;
config.pin_d5 = Y7_GPIO_NUM;
config.pin_d6 = Y8_GPIO_NUM;
config.pin_d7 = Y9_GPIO_NUM;
config.pin_xclk = XCLK_GPIO_NUM;
config.pin_pclk = PCLK_GPIO_NUM;
config.pin_vsync = VSYNC_GPIO_NUM;
config.pin_href = HREF_GPIO_NUM;
config.pin_sscb_sda = SIOD_GPIO_NUM;
config.pin_sscb_scl = SIOC_GPIO_NUM;
config.pin_pwdn = PWDN_GPIO_NUM;
config.pin_reset = RESET_GPIO_NUM;</k>
The camera frequency:
<k>config.xclk_freq_hz = 20000000;</k>
<h3>OV2640 image format, quality, and frame size</h3>
The image format:
<k>config.pixel_format = PIXFORMAT_JPEG; //YUV422,GRAYSCALE,RGB565,JPEG</k>
The image format can be one of the following options:
PIXFORMAT_YUV422
PIXFORMAT_GRAYSCALE
PIXFORMAT_RGB565
PIXFORMAT_JPEG
Then, set the frame size, jpeg quality and framebuffer count. We select different settings depending if you're using a camera with PSRAM or without PSRAM.
<k>// Select lower framesize if the camera doesn't support PSRAM
if(psramFound()){
  config.frame_size = FRAMESIZE_UXGA; // FRAMESIZE_ + QVGA|CIF|VGA|SVGA|XGA|SXGA|UXGA
  config.jpeg_quality = 10; //10-63 lower number means higher quality
  config.fb_count = 2;
} else {
  config.frame_size = FRAMESIZE_SVGA;
  config.jpeg_quality = 12;
  config.fb_count = 1;
}</k>
The frame size can be set to one of these options:
FRAMESIZE_UXGA (1600 x 1200)
FRAMESIZE_QVGA (320 x 240)
FRAMESIZE_CIF (352 x 288)
FRAMESIZE_VGA (640 x 480)
FRAMESIZE_SVGA (800 x 600)
FRAMESIZE_XGA (1024 x 768)
FRAMESIZE_SXGA (1280 x 1024)
The image quality (jpeg_quality) can be a number between 0 and 63. A lower number means a higher quality. However, very low numbers for image quality, specially at higher resolution can make the ESP32-CAM to crash or it may not be able to take the photos properly.
So, if you notice that the images taken with the ESP32-CAM are cut in half, or with strange colors, that's probably a sign that you need to lower the quality (select a higher number).
<h3>Initialize OV2640 camera</h3>
The following lines initialize the camera:
<k>// Initialize the Camera
esp_err_t err = esp_camera_init(&config);
if (err != ESP_OK) {
  Serial.printf("Camera init failed with error 0x%x", err);
  return;
}</k>
After this, you can add the lines of code we've shown you previously to change the image settings.
<h3>OV2640 settings: brightness, contrast, saturation, white balance, exposure, and more</h3>
The values set on the following lines are the default values, you can change them to change the image settings.
<k>sensor_t * s = esp_camera_sensor_get();
s->set_brightness(s, 0);     // -2 to 2
s->set_contrast(s, 0);       // -2 to 2
s->set_saturation(s, 0);     // -2 to 2
s->set_special_effect(s, 0); // 0 to 6 (0 - No Effect, 1 - Negative, 2 - Grayscale, 3 - Red Tint, 4 - Green Tint, 5 - Blue Tint, 6 - Sepia)
s->set_whitebal(s, 1);       // 0 = disable , 1 = enable
s->set_awb_gain(s, 1);       // 0 = disable , 1 = enable
s->set_wb_mode(s, 0);        // 0 to 4 - if awb_gain enabled (0 - Auto, 1 - Sunny, 2 - Cloudy, 3 - Office, 4 - Home)
s->set_exposure_ctrl(s, 1);  // 0 = disable , 1 = enable
s->set_aec2(s, 0);           // 0 = disable , 1 = enable
s->set_ae_level(s, 0);       // -2 to 2
s->set_aec_value(s, 300);    // 0 to 1200
s->set_gain_ctrl(s, 1);      // 0 = disable , 1 = enable
s->set_agc_gain(s, 0);       // 0 to 30
s->set_gainceiling(s, (gainceiling_t)0);  // 0 to 6
s->set_bpc(s, 0);            // 0 = disable , 1 = enable
s->set_wpc(s, 1);            // 0 = disable , 1 = enable
s->set_raw_gma(s, 1);        // 0 = disable , 1 = enable
s->set_lenc(s, 1);           // 0 = disable , 1 = enable
s->set_hmirror(s, 0);        // 0 = disable , 1 = enable
s->set_vflip(s, 0);          // 0 = disable , 1 = enable
s->set_dcw(s, 1);            // 0 = disable , 1 = enable
s->set_colorbar(s, 0);       // 0 = disable , 1 = enable</k>
<h3>Demonstration</h3>
Change the camera settings in the code to adjust the image. Then, <a href="https://randomnerdtutorials.com/program-upload-code-esp32-cam/">upload the code to your ESP32-CAM</a>.
Press the ESP32-CAM RST button, and it will start taking photos. Then, grab the microSD card to see the photos.
Below you can see several images taken with different settings. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-camera-change-grayscale.jpg"><figcaption> ESP32-CAM Photo with Grayscale effect enabled</figcaption>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-camera-change-brightness2.jpg"><figcaption>ESP32-CAM Photo with Brightness set to 2</figcaption>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-camera-change-contrast-saturation.jpg"><figcaption>ESP32-CAM with Contrast set to 2 and Saturation to -2</figcaption>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-camera-change-settings.jpg"><figcaption>ESP32-CAM Photo with Default Settings</figcaption>
In my opinion, in these conditions, the best settings for a better picture are: contrast set to 2 and saturation set to -2.
<a href="https://randomnerdtutorials.com/esp32-cam-projects-ebook/">
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-eBook-334.jpg?fit=334%2C334&quality=100&strip=all&ssl=1" alt="" srcset="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-eBook-334.jpg?w=334&quality=100&strip=all&ssl=1 334w, https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-eBook-334.jpg"></a>
<h3>Wrapping Up</h3>
In this tutorial, you've learned how to change the camera settings to adjust the image you get with the OV2640 camera. 
This can be useful because depending on where you place your camera you may need to change the settings to get a better image. 
You can use the functions we've shown you here in any of your projects with the ESP32-CAM to adjust the settings. We have several projects with the ESP32-CAM that you may like:
<a href="https://randomnerdtutorials.com/esp32-cam-video-streaming-face-recognition-arduino-ide/" target="_blank">Video Streaming, Face Detection and Face Recognition</a>
<a href="https://randomnerdtutorials.com/esp32-cam-video-streaming-web-server-camera-home-assistant/" target="_blank">ESP32 IP CAM  Video Streaming (Home Assistant and Node-RED)</a>
<a href="https://randomnerdtutorials.com/esp32-cam-take-photo-save-microsd-card/" target="_blank">Take Photo and Save to MicroSD Card</a>
<a href="https://randomnerdtutorials.com/esp32-cam-pir-motion-detector-photo-capture/" target="_blank">PIR Motion Detector with Photo Capture</a>
<a href="https://randomnerdtutorials.com/esp32-cam-take-photo-display-web-server/" target="_blank">Take Photo, Save to SPIFFS and Display in Web Server</a>
<a href="https://randomnerdtutorials.com/esp32-cam-projects-ebook/"><k>Build ESP32-CAM Projects (eBook)</k></a>
<a href="https://randomnerdtutorials.com/projects-esp32-cam/"><k>Read all our ESP32-CAM Projects, Tutorials and Guides</k></a>
Thanks for reading.
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/smart-home-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px-pupj8i6e7hlzpgwxe82jjd8skst9vmrjt9lpqb0v0g.jpg" title="Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px" alt="SMART HOME with Raspberry Pi ESP32 and ESP8266 Node-RED InfluxDB eBook" loading="lazy" width="117" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/smart-home-ebook/">SMART HOME with Raspberry Pi, ESP32, ESP8266 [eBook] </a></h4>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>ESP32 Email Alert Based on Temperature Threshold (change values on web server)</h2>
Learn how to send an email alert with the ESP32 based on a temperature threshold. The ESP32 also hosts a Web Server that shows the latest sensor readings and <a href="https://randomnerdtutorials.com/esp32-esp8266-input-data-html-form/">input fields</a> to change the threshold value, email's recipient, and the option to arm or disarm the system.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/ESP32-Email-Alert-Based-on-Temperature-Threshold-web-server.jpg">
We'll <a href="https://randomnerdtutorials.com/esp32-ds18b20-temperature-arduino-ide/">read the temperature using a DS18B20 sensor</a> and <a href="https://randomnerdtutorials.com/esp32-send-email-smtp-server-arduino-ide/">send emails using an SMTP Server</a>. The <a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">ESP32 will be programmed using Arduino IDE</a>.
To better understand how this project works, we recommend taking a look at the following tutorials:
<a href="https://randomnerdtutorials.com/esp32-send-email-smtp-server-arduino-ide/">ESP32 Send Emails using an SMTP Server: HTML, Text and Attachments (Arduino IDE)</a>
<a href="https://randomnerdtutorials.com/esp32-esp8266-input-data-html-form/">Input Data on HTML Form ESP32/ESP8266 Web Server (Arduino IDE)</a>
<a href="https://randomnerdtutorials.com/esp32-esp8266-thermostat-web-server/">ESP32/ESP8266 Thermostat Web Server  Control Output Based on Temperature</a>
<h3>Watch the Video Demonstration</h3>
To see how the project works, you can watch the following video demonstration:

<h3>Project Overview</h3>
The following image shows a high-level overview of the project we'll build. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/ESP32-Email-notification-with-temperature-threshold.png">
The ESP32 hosts a web server that shows the latest temperature readings from a DS18B20 temperature sensor.
There's an input field to set up a threshold. When the temperature goes above or below the threshold value, you'll receive an email.
You can also set up the recipient's email address on the web page.
The system can be activated or deactivated through the web server. If you choose to deactivate the system, you won't receive email notifications when the temperature crosses the threshold value.
The following image shows an overview of the web server page.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/ESP32-Web-Server-Set-Temperature-Threshold-Email.png">
<h3>Prerequisites</h3>
Make sure you check each of the following prerequisites before proceeding with this project.
<h3>1. ESP32 add-on Arduino IDE</h3>
We'll program the ESP32 using Arduino IDE. So, you need to have the ESP32 add-on installed in your Arduino IDE. Follow the next tutorial, if you haven't already.
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<h3>2. ESP32 Mail Client Library</h3>
To send emails with the <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a>, we'll use the <a href="https://github.com/mobizt/ESP32-Mail-Client" target="_blank">ESP32 Mail Client library</a> (<a href="https://randomnerdtutorials.com/esp32-send-email-smtp-server-arduino-ide/">how to use the library to send emails</a>). Follow the next steps to install the library.
In your Arduino IDE go to <k>Sketch</k> > <k>Include Library</k> > <k>Manage Libraries</k>
The Library Manager should open. Search for <k>ESP32 Mail Client</k> by Mobizt and install the library as shown below.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/Install-library-ESP32-Send-Email-SMTP-Server.png">
<h3>3. Create a Sender Email (New Account)</h3>
We recommend creating a new email account to send the emails to your main personal email address. <k>Do not use your main personal email to send emails via ESP32</k>. If something goes wrong in your code or if by mistake you make too many requests, you can be banned or have your account temporary disabled.
We'll use a newly created Gmail.com account to send the emails, but you can use any other email provider. The receiver email can be your personal email without any problem.
Create a new email account for sending emails with the ESP32. If you want to use a Gmail account, <a href="https://www.google.com/gmail/about/" target="_blank">go to this link</a> to create a new one.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/GMAIL-create-a-new-account.png">
<h3>Create an App Password</h3>
You need to create an app password so that the ESP32 is able to send emails using your Gmail account. An App Password is a 16-digit passcode that gives a less secure app or device permission to access your Google Account. <a href="https://support.google.com/accounts/answer/185833" target="_blank">Learn more about sign-in with app passwords here</a>.
An app password can only be used with accounts that have <k><a href="https://support.google.com/accounts/answer/185839">2-step verification turned on</a></k>. 
<ol>
Open your <a href="https://myaccount.google.com/">Google Account</a>.
In the navigation panel, select <k>Security</k>.
Under Signing in to Google, select <k>2-Step Verification</k> > <k>Get started</k>.
Follow the on-screen steps.
</ol>
After enabling 2-step verification, you can create an app password.
<ol>
Open your <a href="https://myaccount.google.com/">Google Account</a>.
In the navigation panel, select <k>Security</k>.
Under Signing in to Google, select <k>App Passwords</k>.
</ol>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/06/create-app-password-gmail.png">
<ol start="4">In the Select app field, choose <k>mail</k>. For the device, select <k>Other</k> and give it a name, for example <em>ESP32.</em> Then, click on <k>Generate</k>. It will pop-up a window with a password that you'll use with the ESP32 or ESP8266 to send emails. Save that password (even though it says you won't need to remmeber it) because you'll need it later.</ol>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/06/generated-app-password-gmail.png">
Now, you should have an app password that you'll use on the ESP32 code to send the emails.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/06/Gmail-app-password-created-for-esp32-send-emails.png">
If you're using another email provider, check how to create an app password. You should be able to find the instructions with a quick google search <k>your_email_provider</k> + create app password.
<h3>4. SMTP Server Settings</h3>
Before proceeding you need to know the SMTP server settings of the sender email. 
<h4>Gmail SMTP Server Settings</h4>
If you're using a Gmail account, these are the SMTP Server details:
SMTP Server: <k>smtp.gmail.com</k>
SMTP username: Complete Gmail address
SMTP password: Your Gmail password
SMTP port (TLS): <k>587</k>
SMTP port (SSL): <k>465</k>
SMTP TLS/SSL required: <k>yes</k>
<h4>Outlook SMTP Server Settings</h4>
For Outlook accounts, these are the SMTP Server settings:
SMTP Server: <k>smtp.office365.com</k>
SMTP Username: Complete Outlook email address
SMTP Password: Your Outlook password
SMTP Port: <k>587</k>
SMTP TLS/SSL Required: <k>Yes</k>
<h4>Live or Hotmail SMTP Server Settings</h4>
For Live or Hotmail accounts, these are the SMTP Server settings:
SMTP Server: <k>smtp.live.com</k>
SMTP Username: Complete Live/Hotmail email address
SMTP Password: Your Windows Live Hotmail password
SMTP Port: <k>587</k>
SMTP TLS/SSL Required: <k>Yes</k>
If you're using another email provider, you need to search for its SMTP Server settings.
<h3>5. Async Web Server and DS18B20 Libraries</h3>
In this project, we'll build an asynchronous web server using the next libraries:
<a href="https://github.com/me-no-dev/ESPAsyncWebServer" target="_blank">ESPAsyncWebServer</a> 
<a href="https://github.com/me-no-dev/AsyncTCP" target="_blank">AsyncTCP</a>
These two libraries aren't available to install through the Arduino Library Manager, so you need to copy the library files to the Arduino Installation folder. Alternatively, in your Arduino IDE, you can go to <k>Sketch </k>> <k>Include Library</k> > <k>Add .zip Library</k> and select the libraries you've just downloaded.
Open your Arduino IDE and go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k>. The Library Manager should open and you can install these libraries:
<a aria-label="One Wire library by Paul Stoffregen<U+2028> (opens in a new tab)" href="https://github.com/PaulStoffregen/OneWire" target="_blank">One Wire by Paul Stoffregen</a> (<a href="https://randomnerdtutorials.com/esp32-ds18b20-temperature-arduino-ide/">DS18B20 Guide</a>)
<a aria-label="Dallas Temperature library (opens in a new tab)" href="https://github.com/milesburton/Arduino-Temperature-Control-Library" target="_blank">Dallas Temperature</a> (<a href="https://randomnerdtutorials.com/esp32-ds18b20-temperature-arduino-ide/">DS18B20 Guide</a>) 
<h3>6. Parts Required</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/07/ESP32-DS18B20.jpg">
To follow this tutorial you need the following parts:
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> (read <a style="font-size: inherit; background-color: initial;" href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">Best ESP32 development boards</a>)
<a href="https://makeradvisor.com/tools/ds18b20-temperature-sensor-2/" target="_blank">DS18B20 temperature sensor</a> (<a href="https://makeradvisor.com/tools/ds18b20-digital-temperature-sensor/" target="_blank">waterproof version</a>)  <a href="https://randomnerdtutorials.com/esp32-ds18b20-temperature-arduino-ide/">complete Guide</a>
<a href="https://makeradvisor.com/tools/ds18b20-temperature-sensor-2/" target="_blank">4.7k Ohm resistor</a>
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a>
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="lazy" fetchpriority="low"></a>
<h3>Schematic Diagram</h3>
Wire the DS18B20 temperature sensor to the ESP32 as shown in the following schematic diagram, with the data pin connected to GPIO 4
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/06/ds18b20_esp32_single_normal.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/06/ds18b20_esp32_single_normal.png"></a>
<h3>ESP32 Code  Email Web Server</h3>
Copy the following code to your Arduino IDE, but don't upload it yet. You need to make some changes to make it work for you. You need to insert the sender's email address, the recipient's email address, your default threshold input and your network credentials.
<k>/*********
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-email-alert-temperature-threshold/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*********/
#include &lt;WiFi.h>
#include &lt;AsyncTCP.h>
#include &lt;ESPAsyncWebServer.h>
#include &lt;OneWire.h>
#include &lt;DallasTemperature.h>
#include "ESP32_MailClient.h"
// REPLACE WITH YOUR NETWORK CREDENTIALS
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
// To send Emails using Gmail on port 465 (SSL), you need to create an app password: https://support.google.com/accounts/answer/185833
#define emailSenderAccount    "<a href="/cdn-cgi/l/email-protection" data-cfemail="0e6b766f637e626b517d6b606a6b7c516f6d6d617b607a4e69636f6762206d6163">[email protected]</a>"
#define emailSenderPassword   "email_sender_password"
#define smtpServer            "smtp.gmail.com"
#define smtpServerPort        465
#define emailSubject          "[ALERT] ESP32 Temperature"
// Default Recipient Email Address
String inputMessage = "<a href="/cdn-cgi/l/email-protection" data-cfemail="4a33253f38152f272b232615382f29233a232f243e0a2d272b232664292527">[email protected]</a>";
String enableEmailChecked = "checked";
String inputMessage2 = "true";
// Default Threshold Temperature Value
String inputMessage3 = "25.0";
String lastTemperature;
// HTML web page to handle 3 input fields (email_input, enable_email_input, threshold_input)
const char index_html[] PROGMEM = R"rawliteral(
&lt;!DOCTYPE HTML>&lt;html>&lt;head>
  &lt;title>Email Notification with Temperature&lt;/title>
  &lt;meta name="viewport" content="width=device-width, initial-scale=1">
  &lt;/head>&lt;body>
  &lt;h2>DS18B20 Temperature&lt;/h2>
  &lt;h3>%TEMPERATURE% &deg;C&lt;/h3>
  &lt;h2>ESP Email Notification&lt;/h2>
  &lt;form action="/get">
    Email Address &lt;input type="email" name="email_input" value="%EMAIL_INPUT%" required>&lt;br>
    Enable Email Notification &lt;input type="checkbox" name="enable_email_input" value="true" %ENABLE_EMAIL%>&lt;br>
    Temperature Threshold &lt;input type="number" step="0.1" name="threshold_input" value="%THRESHOLD%" required>&lt;br>
    &lt;input type="submit" value="Submit">
  &lt;/form>
&lt;/body>&lt;/html>)rawliteral";
void notFound(AsyncWebServerRequest *request) {
  request->send(404, "text/plain", "Not found");
}
AsyncWebServer server(80);
// Replaces placeholder with DS18B20 values
String processor(const String& var){
  //Serial.println(var);
  if(var == "TEMPERATURE"){
    return lastTemperature;
  }
  else if(var == "EMAIL_INPUT"){
    return inputMessage;
  }
  else if(var == "ENABLE_EMAIL"){
    return enableEmailChecked;
  }
  else if(var == "THRESHOLD"){
    return inputMessage3;
  }
  return String();
}
// Flag variable to keep track if email notification was sent or not
bool emailSent = false;
const char* PARAM_INPUT_1 = "email_input";
const char* PARAM_INPUT_2 = "enable_email_input";
const char* PARAM_INPUT_3 = "threshold_input";
// Interval between sensor readings. Learn more about timers: https://RandomNerdTutorials.com/esp32-pir-motion-sensor-interrupts-timers/
unsigned long previousMillis = 0;     
const long interval = 5000;    
// GPIO where the DS18B20 is connected to
const int oneWireBus = 4;     
// Setup a oneWire instance to communicate with any OneWire devices
OneWire oneWire(oneWireBus);
// Pass our oneWire reference to Dallas Temperature sensor 
DallasTemperature sensors(&oneWire);
// The Email Sending data object contains config and data to send
SMTPData smtpData;
void setup() {
  Serial.begin(115200);
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  if (WiFi.waitForConnectResult() != WL_CONNECTED) {
    Serial.println("WiFi Failed!");
    return;
  }
  Serial.println();
  Serial.print("ESP IP Address: http://");
  Serial.println(WiFi.localIP());
  
  // Start the DS18B20 sensor
  sensors.begin();
  // Send web page to client
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send_P(200, "text/html", index_html, processor);
  });
  // Receive an HTTP GET request at &lt;ESP_IP>/get?email_input=&lt;inputMessage>&enable_email_input=&lt;inputMessage2>&threshold_input=&lt;inputMessage3>
  server.on("/get", HTTP_GET, [] (AsyncWebServerRequest *request) {
    // GET email_input value on &lt;ESP_IP>/get?email_input=&lt;inputMessage>
    if (request->hasParam(PARAM_INPUT_1)) {
      inputMessage = request->getParam(PARAM_INPUT_1)->value();
      // GET enable_email_input value on &lt;ESP_IP>/get?enable_email_input=&lt;inputMessage2>
      if (request->hasParam(PARAM_INPUT_2)) {
        inputMessage2 = request->getParam(PARAM_INPUT_2)->value();
        enableEmailChecked = "checked";
      }
      else {
        inputMessage2 = "false";
        enableEmailChecked = "";
      }
      // GET threshold_input value on &lt;ESP_IP>/get?threshold_input=&lt;inputMessage3>
      if (request->hasParam(PARAM_INPUT_3)) {
        inputMessage3 = request->getParam(PARAM_INPUT_3)->value();
      }
    }
    else {
      inputMessage = "No message sent";
    }
    Serial.println(inputMessage);
    Serial.println(inputMessage2);
    Serial.println(inputMessage3);
    request->send(200, "text/html", "HTTP GET request sent to your ESP.&lt;br>&lt;a href=\"/\">Return to Home Page&lt;/a>");
  });
  server.onNotFound(notFound);
  server.begin();
}
void loop() {
  unsigned long currentMillis = millis();
  if (currentMillis - previousMillis >= interval) {
    previousMillis = currentMillis;
    sensors.requestTemperatures();
    // Temperature in Celsius degrees 
    float temperature = sensors.getTempCByIndex(0);
    Serial.print(temperature);
    Serial.println(" *C");
    
    // Temperature in Fahrenheit degrees
    /*float temperature = sensors.getTempFByIndex(0);
    SerialMon.print(temperature);
    SerialMon.println(" *F");*/
    
    lastTemperature = String(temperature);
    
    // Check if temperature is above threshold and if it needs to send the Email alert
    if(temperature > inputMessage3.toFloat() && inputMessage2 == "true" && !emailSent){
      String emailMessage = String("Temperature above threshold. Current temperature: ") + 
                            String(temperature) + String("C");
      if(sendEmailNotification(emailMessage)) {
        Serial.println(emailMessage);
        emailSent = true;
      }
      else {
        Serial.println("Email failed to send");
      }    
    }
    // Check if temperature is below threshold and if it needs to send the Email alert
    else if((temperature &lt; inputMessage3.toFloat()) && inputMessage2 == "true" && emailSent) {
      String emailMessage = String("Temperature below threshold. Current temperature: ") + 
                            String(temperature) + String(" C");
      if(sendEmailNotification(emailMessage)) {
        Serial.println(emailMessage);
        emailSent = false;
      }
      else {
        Serial.println("Email failed to send");
      }
    }
  }
}
bool sendEmailNotification(String emailMessage){
  // Set the SMTP Server Email host, port, account and password
  smtpData.setLogin(smtpServer, smtpServerPort, emailSenderAccount, emailSenderPassword);
  // For library version 1.2.0 and later which STARTTLS protocol was supported,the STARTTLS will be 
  // enabled automatically when port 587 was used, or enable it manually using setSTARTTLS function.
  //smtpData.setSTARTTLS(true);
  // Set the sender name and Email
  smtpData.setSender("ESP32", emailSenderAccount);
  // Set Email priority or importance High, Normal, Low or 1 to 5 (1 is highest)
  smtpData.setPriority("High");
  // Set the subject
  smtpData.setSubject(emailSubject);
  // Set the message with HTML format
  smtpData.setMessage(emailMessage, true);
  // Add recipients
  smtpData.addRecipient(inputMessage);
  smtpData.setSendCallback(sendCallback);
  // Start sending Email, can be set callback function to track the status
  if (!MailClient.sendMail(smtpData)) {
    Serial.println("Error sending Email, " + MailClient.smtpErrorReason());
    return false;
  }
  // Clear all data from Email object to free memory
  smtpData.empty();
  return true;
}
// Callback function to get the Email sending status
void sendCallback(SendStatus msg) {
  // Print the current status
  Serial.println(msg.info());
  // Do something when complete
  if (msg.success()) {
    Serial.println("----------------");
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Email/ESP32_Email_Threshold_Web_Server.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
Continue reading to learn how the code works, or skip to the demonstration section.
<h3>Libraries</h3>
Start by importing the required libraries. The WiFi, AsyncTCP and ESPAsyncWebServer are required to build the web server. The OneWire and DallasTemperature are required to interface with the DS18B20 and the ESP32_MailClient is required to send emails with the ESP32 via SMTP server.
<k>#include &lt;WiFi.h>
#include &lt;AsyncTCP.h>
#include &lt;ESPAsyncWebServer.h>
#include &lt;OneWire.h>
#include &lt;DallasTemperature.h>
#include "ESP32_MailClient.h"</k>
<h3>Network Credentials</h3>
Insert your network credentials in the following lines:
<k>// REPLACE WITH YOUR NETWORK CREDENTIALS
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h3>Email Settings</h3>
Insert the sender email  this is the email that will be used to send emails by the ESP32.
<k>#define emailSenderAccount "<a href="/cdn-cgi/l/email-protection" data-cfemail="56332e373b263a3309253338323324093735353923382216313b373f3a7835393b">[email protected]</a>"</k>
Type the email sender password:
<k>#define emailSenderPassword "email_sender_password"</k>
In the next lines, insert the email sender SMTP server settings. We're using a Gmail account. If you're using another email provider you need to insert the right server settings.
<k>#define smtpServer      "smtp.gmail.com"
#define smtpServerPort  465</k>
Insert the email subject on the following line:
<k>#define emailSubject "[ALERT] ESP32 Temperature"</k>
<h3>Auxiliar Variables</h3>
Next, we have some auxiliar variables to save the values submitted through the form. The inputMessage variable holds the recipient's email. You can insert the default's recipient's email. You can change the recipient's email later on the form.
<k>String inputMessage = "<a href="/cdn-cgi/l/email-protection" data-cfemail="c2bbadb7b09da7afa3abae9db0a7a1abb2aba7acb682a5afa3abaeeca1adaf">[email protected]</a>";</k>
The enableEmailChecked variable will tell us whether the checkbox to send an email is checked or not.
<k>String enableEmailChecked = "checked";</k>
In case it's checked, the value saved on the inputMessage2 should be set to true.
<k>String inputMessage2 = "true";</k>
The inputMessage3 holds the temperature threshold value. By default is set to 25.0oC, but you can set it to any other default value that makes more sense to you. You can also change it later in the HTML form.
<k>String inputMessage3 = "25.0";</k>
The lastTemperature variable saves the last temperature value to compare with the current value.
<k>String lastTemperature;</k>
<h3>HTML Text</h3>
Then, we have some basic HTML text to build a page with three input fields: the recipient's email, a checkbox to enable or disable email notifications and the temperature threshold input field. The web page also displays the latest temperature reading from the DS18B20 temperature sensor.
The following lines display the temperature:
<k>&lt;h2>DS18B20 Temperature&lt;/h2>
&lt;h3>%TEMPERATURE% &deg;C&lt;/h3></k>
The %TEMPERATURE% is placeholder that will be replaced by the actual temperature value when the ESP32 serves the page.
Then, we have a form with three input fields and a Submit button. When the user types some data and clicks the Submit button, those values are sent to the ESP32 to update the variables.
<k>&lt;form action="/get">
  Email Address &lt;input type="email" name="email_input" value="%EMAIL_INPUT%" required>&lt;br>
  Enable Email Notification &lt;input type="checkbox" name="enable_email_input" value="true" %ENABLE_EMAIL%>&lt;br>
  Temperature Threshold &lt;input type="number" step="0.1" name="threshold_input" value="%THRESHOLD%" required>&lt;br>
  &lt;input type="submit" value="Submit">
&lt;/form></k>
The first input field is of type email, the second input field is a checkbox and the last input field is of type number. To learn more about input fields, we recommend taking a look at following resources of the w3schools website:
<a rel="noreferrer noopener nofollow" aria-label="HTML &lt;Input> Tag<U+2028> (opens in a new tab) href=https://www.w3schools.com/tags/tag_input.asp target=_blank>HTML Input Tag&lt;/a>&lt;/li>&lt;li>&lt;a rel=" noreferrer noopener nofollow href="https://www.w3schools.com/html/html_form_input_types.asp" target="_blank">HTML Input Types</a>
The action attribute of the form specifies where to send the data inserted on the form after pressing submit. In this case, it makes an HTTP GET request to:
<k>/get?email_input=value&enable_email_input=value&threshold_input=value</k>
The value refers to the text you enter in each of the input fields. To learn more about handling input fields with the ESP32, read: <a href="https://randomnerdtutorials.com/esp32-esp8266-input-data-html-form/">Input Data on HTML Form ESP32 Web Server using Arduino IDE</a>.
<h3>processor()</h3>
The processor() function replaces all placeholders in the HTML text with the actual values.
%TEMPERATURE% <U+00BB> lastTemperature
%EMAIL_INPUT% <U+00BB> inputMessage
%ENABLE_EMAIL% <U+00BB> enableEmailChecked
%THRESHOLD% <U+00BB> inputMessage3
<k>String processor(const String& var){
  //Serial.println(var);
  if(var == "TEMPERATURE"){
    return lastTemperature;
  }
  else if(var == "EMAIL_INPUT"){
    return inputMessage;
  }
  else if(var == "ENABLE_EMAIL"){
    return enableEmailChecked;
  }
  else if(var == "THRESHOLD"){
    return inputMessage3;
  }
  return String();
}</k>
<h3>Input Field Parameters</h3>
The following variables will be used to check whether we've received an HTTP GET request from those input fields and save the values into variables accordingly.
<k>const char* PARAM_INPUT_1 = "email_input";
const char* PARAM_INPUT_2 = "enable_email_input";
const char* PARAM_INPUT_3 = "threshold_input";</k>
<h3>DS18B20 Temperature Sensor Init</h3>
Initialize the DS18B20 temperature sensor.
<k>// GPIO where the DS18B20 is connected to
const int oneWireBus = 4;
// Setup a oneWire instance to communicate with any OneWire devices
OneWire oneWire(oneWireBus);
// Pass our oneWire reference to Dallas Temperature sensor 
DallasTemperature sensors(&oneWire);</k>
To learn more about interfacing the DS18B20 temperature sensor with the ESP32, read: <a href="https://randomnerdtutorials.com/esp32-ds18b20-temperature-arduino-ide/">ESP32 DS18B20 Temperature Sensor with Arduino IDE</a>.
<h3>SMTPData Object</h3>
The smtpData object contains configurations and data to be sent via email. These configurations are set later on the sendEmailNotification() function.
<k>SMTPData smtpData;</k>
<h3>setup()</h3>
In the setup(), connect to Wi-Fi in station mode and print the ESP32 IP address:
<k>Serial.begin(115200);
WiFi.mode(WIFI_STA);
WiFi.begin(ssid, password);
if (WiFi.waitForConnectResult() != WL_CONNECTED) {
  Serial.println("WiFi Failed!");
  return;
}
Serial.println();
Serial.print("ESP IP Address: http://");
Serial.println(WiFi.localIP());</k>
Initialize the DS18B20 temperature sensor:
<k>sensors.begin();</k>
<h3>Handle Web Server</h3>
Then, define what happens when the ESP32 receives HTTP requests. When we get a request on the root / url, send the HTML text with the processor (so that the placeholders are replaced with the latest values).
<k>server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
  request->send_P(200, "text/html", index_html, processor);
});</k>
When a form is submitted, the ESP32 receives a request on the following URL:
<k>&lt;ESP_IP>/get?email_input=&lt;inputMessage>&enable_email_input=&lt;inputMessage2>&threshold_input=&lt;inputMessage3></k>
So, we check whether the request contains input parameters, and save those parameters into variables:
<k>server.on("/get", HTTP_GET, [] (AsyncWebServerRequest *request) {
  // GET email_input value on &lt;ESP_IP>/get?email_input=&lt;inputMessage>
  if (request->hasParam(PARAM_INPUT_1)) {
    inputMessage = request->getParam(PARAM_INPUT_1)->value();
    // GET enable_email_input value on &lt;ESP_IP>/get?enable_email_input=&lt;inputMessage2>
    if (request->hasParam(PARAM_INPUT_2)) {
      inputMessage2 = request->getParam(PARAM_INPUT_2)->value();
      enableEmailChecked = "checked";
    }
    else {
      inputMessage2 = "false";
      enableEmailChecked = "";
    }
    // GET threshold_input value on &lt;ESP_IP>/get?threshold_input=&lt;inputMessage3>
    if (request->hasParam(PARAM_INPUT_3)) {
      inputMessage3 = request->getParam(PARAM_INPUT_3)->value();
    }
  }
  else {
    inputMessage = "No message sent";
  }</k>
This is the part of the code where the variables will be replaced with the values submitted on the form. The inputMessage variable saves the recipient's email address, the inputMessage2 saves whether the email notification system is enabled or not and the inputMessage3 saves the temperature threshold.
After submitting the values on the form, it displays a new page saying the request was successfully sent to the ESP32 with a link to return to the homepage.
<k>request->send(200, "text/html", "HTTP GET request sent to your ESP.&lt;br>&lt;a href=\"/\">Return to Home Page&lt;/a>");
});</k>
Finally, start the server:
<k>server.begin();</k>
<h3>loop()</h3>
In the loop(), we use <a href="https://randomnerdtutorials.com/esp32-pir-motion-sensor-interrupts-timers/">timers</a> to get new temperature readings every 5 seconds.
<k>unsigned long currentMillis = millis();
if (currentMillis - previousMillis >= interval) {
  previousMillis = currentMillis;
  sensors.requestTemperatures();
  // Temperature in Celsius degrees 
  float temperature = sensors.getTempCByIndex(0);
  Serial.print(temperature);
  Serial.println(" *C");
    
  // Temperature in Fahrenheit degrees
  /*float temperature = sensors.getTempFByIndex(0);
  SerialMon.print(temperature);
  SerialMon.println(" *F");*/
    
  lastTemperature = String(temperature);</k>
After getting a new temperature reading, we check whether it is above or below the threshold and send an email if necessary.
You'll send an email alert, if all these conditions are met:
The current temperature is above the threshold;
Email notifications are enabled (the checkbox is ticked on the web page);
If an email hasn't been sent yet.
<k>if(temperature > inputMessage3.toFloat() && inputMessage2 == "true" && !emailSent){
  String emailMessage = String("Temperature above threshold. Current temperature: ") + 
                        String(temperature) + String("C");
  if(sendEmailNotification(emailMessage)) {
    Serial.println(emailMessage);
    emailSent = true;
  }
  else {
    Serial.println("Email failed to send");
  }    
}</k>
The email contains a message saying the temperature is above the threshold and the current temperature.
Then, if the temperature goes below the threshold, send another email.
<k>else if((temperature &lt; inputMessage3.toFloat()) && inputMessage2 == "true" && emailSent) {
  String emailMessage = String("Temperature below threshold. Current temperature: ") 
                        + String(temperature) + String(" C");
  if(sendEmailNotification(emailMessage)) {
    Serial.println(emailMessage);
    emailSent = false;
  }
  else {
    Serial.println("Email failed to send");
  }
}</k>
To send emails, we've created the sendEmailNotification function that contains all the details to send the email. This function returns true if the email was successfully sent, or false if it failed. To learn more about sending emails via SMTP Server with the ESP32, read: <a href="https://randomnerdtutorials.com/esp32-send-email-smtp-server-arduino-ide/">ESP32 Send Emails using an SMTP Server</a>.
<h3>Demonstration</h3>
Upload the code to your ESP32 board (with the DS18B20 wired to your ESP32 board).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/ESP32-Web-Server-Set-Temperature-Threshold-Receive-Email-Alert-1.jpg">
Open the Serial Monitor at a baud rate of 115200 and press the on-board RST button. The ESP32 will print its IP address and it will start displaying new temperature values every 5 seconds.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/ESP32-Email-Web-Server-Arduino-IDE-Serial-Monitor-Temperature.png">Open a browser and type the ESP32 IP address. A similar web page should load with the default values (defined in your code):
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/ESP32-Web-Server-Set-Temperature-Threshold-Email.png">
If the email notifications are enabled (checkbox checked) and if the temperature goes above the threshold, you'll receive an email notification.
After that, when the temperature goes below the threshold, you'll receive another email.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/ESP32-Email-Alert-Notification-Temperature-Reached-above-below-threshold.png">
You can use the web page input fields to set up a different recipient's email address, to enable or disable email notifications, and to change the threshold value. For any change to take effect, you just need to press the Submit button.
At the same time, you should get the new input fields in the Serial Monitor.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/ESP32-Web-Server-Arduino-IDE-Serial-Monitor-change-values-temperature-email.png">
<h3>Wrapping Up</h3>
In this project you've learn how to set a threshold value and send an email notification when the temperature crosses that value. We hope you've found this project interesting. Now, feel free to modify the project to meet your own needs. For, example, when the temperature crosses the threshold, you may also want to trigger an output to <a href="https://randomnerdtutorials.com/esp32-relay-module-ac-web-server/">control a relay</a>.
In this project, we've used raw HTML text, to make the project easier to follow. We suggest adding some CSS to style your web page to make it look nicer.
Instead of using a DS18B20, you might consider using a different temperature sensor: <a href="https://randomnerdtutorials.com/dht11-vs-dht22-vs-lm35-vs-ds18b20-vs-bme280-vs-bmp180/">DHT vs LM35 vs DS18B20 vs BME280 vs BMP180</a>.
<h2>ESP32/ESP8266 Thermostat Web Server  Control Output Based on Temperature</a8></h2>
In this project, you'll build an ESP32 / ESP8266 Thermostat Web Server with an <a href="https://randomnerdtutorials.com/esp32-esp8266-input-data-html-form/">input field</a> to set a temperature threshold value. This allows you to automatically control an output based on the current temperature reading. The output will be set to on if the temperature is above or set to off if it's below the threshold  this can be used to build a simple thermostat project.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/ESP32-ESP8266-Web-Server-Temperature-Threshold-Trigger-Control-Output-Arduino-IDE.jpg">
As an example, we'll read the temperature using a DS18B20 temperature sensor. You can use any other temperature sensor like <a href="https://randomnerdtutorials.com/dht11-vs-dht22-vs-lm35-vs-ds18b20-vs-bme280-vs-bmp180/">DHT11/DHT22, BME280 or LM35</a>.
To better understand how this project works, we recommend reading these tutorials:
<a href="https://randomnerdtutorials.com/esp32-esp8266-input-data-html-form/">Input Data on HTML Form ESP32/ESP8266 Web Server (Arduino IDE)</a>
<a href="https://randomnerdtutorials.com/esp32-ds18b20-temperature-arduino-ide/">ESP32 with DS18B20 (one sensor, multiple sensors, web server)</a>
<a href="https://randomnerdtutorials.com/esp8266-ds18b20-temperature-sensor-web-server-with-arduino-ide/">ESP8266 NodeMCU with DS18B20 (one sensor, multiple sensors, web server)</a>
<a href="https://randomnerdtutorials.com/esp32-dht11-dht22-temperature-humidity-web-server-arduino-ide/">ESP32 Web Server</a> or <a href="https://randomnerdtutorials.com/esp8266-dht11dht22-temperature-and-humidity-web-server-with-arduino-ide/">ESP8266 NodeMCU Web Server</a>
<h3>Project Overview</h3>
The following image shows a high-level overview of the project we'll build. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/ESP32-ESP8266-Web-Server-threshold-project-overview.png">
The ESP32/ESP8266 hosts a web server that shows the latest temperature readings from a DS18B20 temperature sensor.
There's an input field to set up a temperature threshold value. When the temperature goes above the threshold, an output will be automatically turned on. You can invert this logic depending on your project application.
When the temperature goes below the threshold, the output will be turned off.
The system can be activated or deactivated through the web server. If you choose to deactivate the system, the output will keep its state, no matter the temperature value.
The following image shows how the web server page looks like.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/ESP32-ESP8266-Temperature-threshold-trigger-web-server-Arduino-IDE.png">
<h3>Prerequisites</h3>
Make sure you check each of the following prerequisites before proceeding with this project.
<h3>1. ESP32 or ESP8266 Add-on Arduino IDE</h3>
This project is compatible with both the ESP32 and ESP8266 boards. We'll program these boards using Arduino IDE, so make sure you have the necessary add-ons installed:
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Install ESP32 Board in Arduino IDE</a>
<a href="https://randomnerdtutorials.com/how-to-install-esp8266-board-arduino-ide/">Install ESP8266 Board in Arduino IDE</a>
<h3>2. Async Web Server Libraries</h3>
To build the asynchronous web server, you need to install these libraries.
<k>ESP32:</k> install the <a href="https://github.com/me-no-dev/ESPAsyncWebServer" target="_blank">ESPAsyncWebServer</a> and the <a href="https://github.com/me-no-dev/AsyncTCP" target="_blank">AsyncTCP</a> libraries.
<k>ESP8266:</k> install the <a href="https://github.com/me-no-dev/ESPAsyncWebServer" target="_blank">ESPAsyncWebServer</a> and the <a href="https://github.com/me-no-dev/ESPAsyncTCP" target="_blank">ESPAsyncTCP</a> libraries.
These libraries aren't available to install through the Arduino Library Manager, so you need to copy the library files to the Arduino Installation Libraries folder. Alternatively, in your Arduino IDE, you can go to <k>Sketch </k>> <k>Include Library</k> > <k>Add .zip Library</k> and select the libraries you've just downloaded.
<h3>3. Parts Required</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/esp32-vs-esp8266-devlopment-boards.jpg">
To follow this tutorial you need the following parts:
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> (read <a style="font-size: inherit; background-color: initial;" href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">Best ESP32 boards</a>) or <a aria-label="ESP8266  (opens in a new tab)" href="https://makeradvisor.com/tools/esp8266-esp-12e-nodemcu-wi-fi-development-board/" target="_blank">ESP8266 </a>(read <a aria-label="Best ESP8266 development boards (opens in a new tab)" href="https://makeradvisor.com/best-esp8266-wi-fi-development-board/" target="_blank">Best ESP8266 boards</a>)
<a aria-label="LED (opens in a new tab)" href="https://makeradvisor.com/tools/3mm-5mm-leds-kit-storage-box/" target="_blank">LED</a>
<a aria-label="220 Ohm resistor<U+2028> (opens in a new tab)" href="https://makeradvisor.com/tools/resistors-kits/" target="_blank">220 Ohm resistor</a>
<a href="https://makeradvisor.com/tools/ds18b20-temperature-sensor-2/" target="_blank">DS18B20 temperature sensor</a> (<a href="https://makeradvisor.com/tools/ds18b20-digital-temperature-sensor/" target="_blank">waterproof version</a>)
<a href="https://makeradvisor.com/tools/ds18b20-temperature-sensor-2/" target="_blank">4.7k Ohm resistor</a>
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a>
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="lazy" fetchpriority="low"></a>
<h3>Schematic Diagram</h3>
Before proceeding, wire the DS18B20 temperature sensor to your board.
<h3>ESP32 with DS18B20 and LED</h3>
If you're using an ESP32, <a href="https://randomnerdtutorials.com/esp32-ds18b20-temperature-arduino-ide/">wire the DS18B20</a> temperature sensor as shown in the following schematic diagram, with the data pin connected to GPIO 4.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/ESP32-ds18b20-led-schematic-diagram.png">
<h3>ESP8266 with DS18B20 and LED</h3>
If you're using an ESP8266, <a href="https://randomnerdtutorials.com/esp8266-ds18b20-temperature-sensor-web-server-with-arduino-ide/">wire the DS18B20</a> temperature sensor as shown in the following schematic diagram, with the data pin connected to GPIO 4 (D2).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/ESP8266-ds18b20-led-schematic-diagram.png">
<h3>Code  Thermostat Web Server with Threshold Input</h3>
Copy the following code to your Arduino IDE, but don't upload it yet. You need to make some changes to make it work for you. You need to insert your network credentials and your default threshold value.
<k>/*********
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-esp8266-thermostat-web-server/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*********/
#ifdef ESP32
  #include &lt;WiFi.h>
  #include &lt;AsyncTCP.h>
#else
  #include &lt;ESP8266WiFi.h>
  #include &lt;ESPAsyncTCP.h>
#endif
#include &lt;ESPAsyncWebServer.h>
#include &lt;Wire.h>
#include &lt;OneWire.h>
#include &lt;DallasTemperature.h>
// REPLACE WITH YOUR NETWORK CREDENTIALS
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
// Default Threshold Temperature Value
String inputMessage = "25.0";
String lastTemperature;
String enableArmChecked = "checked";
String inputMessage2 = "true";
// HTML web page to handle 2 input fields (threshold_input, enable_arm_input)
const char index_html[] PROGMEM = R"rawliteral(
&lt;!DOCTYPE HTML>&lt;html>&lt;head>
  &lt;title>Temperature Threshold Output Control&lt;/title>
  &lt;meta name="viewport" content="width=device-width, initial-scale=1">
  &lt;/head>&lt;body>
  &lt;h2>DS18B20 Temperature&lt;/h2>
  &lt;h3>%TEMPERATURE% &deg;C&lt;/h3>
  &lt;h2>ESP Arm Trigger&lt;/h2>
  &lt;form action="/get">
    Temperature Threshold &lt;input type="number" step="0.1" name="threshold_input" value="%THRESHOLD%" required>&lt;br>
    Arm Trigger &lt;input type="checkbox" name="enable_arm_input" value="true" %ENABLE_ARM_INPUT%>&lt;br>&lt;br>
    &lt;input type="submit" value="Submit">
  &lt;/form>
&lt;/body>&lt;/html>)rawliteral";
void notFound(AsyncWebServerRequest *request) {
  request->send(404, "text/plain", "Not found");
}
AsyncWebServer server(80);
// Replaces placeholder with DS18B20 values
String processor(const String& var){
  //Serial.println(var);
  if(var == "TEMPERATURE"){
    return lastTemperature;
  }
  else if(var == "THRESHOLD"){
    return inputMessage;
  }
  else if(var == "ENABLE_ARM_INPUT"){
    return enableArmChecked;
  }
  return String();
}
// Flag variable to keep track if triggers was activated or not
bool triggerActive = false;
const char* PARAM_INPUT_1 = "threshold_input";
const char* PARAM_INPUT_2 = "enable_arm_input";
// Interval between sensor readings. Learn more about ESP32 timers: https://RandomNerdTutorials.com/esp32-pir-motion-sensor-interrupts-timers/
unsigned long previousMillis = 0;     
const long interval = 5000;    
// GPIO where the output is connected to
const int output = 2;
// GPIO where the DS18B20 is connected to
const int oneWireBus = 4;     
// Setup a oneWire instance to communicate with any OneWire devices
OneWire oneWire(oneWireBus);
// Pass our oneWire reference to Dallas Temperature sensor 
DallasTemperature sensors(&oneWire);
void setup() {
  Serial.begin(115200);
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  if (WiFi.waitForConnectResult() != WL_CONNECTED) {
    Serial.println("WiFi Failed!");
    return;
  }
  Serial.println();
  Serial.print("ESP IP Address: http://");
  Serial.println(WiFi.localIP());
  
  pinMode(output, OUTPUT);
  digitalWrite(output, LOW);
  
  // Start the DS18B20 sensor
  sensors.begin();
  
  // Send web page to client
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send_P(200, "text/html", index_html, processor);
  });
  // Receive an HTTP GET request at &lt;ESP_IP>/get?threshold_input=&lt;inputMessage>&enable_arm_input=&lt;inputMessage2>
  server.on("/get", HTTP_GET, [] (AsyncWebServerRequest *request) {
    // GET threshold_input value on &lt;ESP_IP>/get?threshold_input=&lt;inputMessage>
    if (request->hasParam(PARAM_INPUT_1)) {
      inputMessage = request->getParam(PARAM_INPUT_1)->value();
      // GET enable_arm_input value on &lt;ESP_IP>/get?enable_arm_input=&lt;inputMessage2>
      if (request->hasParam(PARAM_INPUT_2)) {
        inputMessage2 = request->getParam(PARAM_INPUT_2)->value();
        enableArmChecked = "checked";
      }
      else {
        inputMessage2 = "false";
        enableArmChecked = "";
      }
    }
    Serial.println(inputMessage);
    Serial.println(inputMessage2);
    request->send(200, "text/html", "HTTP GET request sent to your ESP.&lt;br>&lt;a href=\"/\">Return to Home Page&lt;/a>");
  });
  server.onNotFound(notFound);
  server.begin();
}
void loop() {
  unsigned long currentMillis = millis();
  if (currentMillis - previousMillis >= interval) {
    previousMillis = currentMillis;
    sensors.requestTemperatures();
    // Temperature in Celsius degrees 
    float temperature = sensors.getTempCByIndex(0);
    Serial.print(temperature);
    Serial.println(" *C");
    
    // Temperature in Fahrenheit degrees
    /*float temperature = sensors.getTempFByIndex(0);
    Serial.print(temperature);
    Serial.println(" *F");*/
    
    lastTemperature = String(temperature);
    
    // Check if temperature is above threshold and if it needs to trigger output
    if(temperature > inputMessage.toFloat() && inputMessage2 == "true" && !triggerActive){
      String message = String("Temperature above threshold. Current temperature: ") + 
                            String(temperature) + String("C");
      Serial.println(message);
      triggerActive = true;
      digitalWrite(output, HIGH);
    }
    // Check if temperature is below threshold and if it needs to trigger output
    else if((temperature &lt; inputMessage.toFloat()) && inputMessage2 == "true" && triggerActive) {
      String message = String("Temperature below threshold. Current temperature: ") + 
                            String(temperature) + String(" C");
      Serial.println(message);
      triggerActive = false;
      digitalWrite(output, LOW);
    }
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_Thermostat_Web_Server.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
Continue reading to learn how the code works, or skip to the Demonstration section.
<h3>Libraries</h3>
Start by importing the required libraries. The WiFi (or ESP8266WiFi), AsyncTCP (or ESPAsyncTCP) and ESPAsyncWebServer are required to build the web server. 
The OneWire and DallasTemperature are required to interface with the DS18B20.
The code automatically imports the right libraries accordingly to the selected board (ESP32 or ESP8266).
<k>#ifdef ESP32
  #include &lt;WiFi.h>
  #include &lt;AsyncTCP.h>
#else
  #include &lt;ESP8266WiFi.h>
  #include &lt;ESPAsyncTCP.h>
#endif
#include &lt;ESPAsyncWebServer.h>
#include &lt;Wire.h>
#include &lt;OneWire.h>
#include &lt;DallasTemperature.h></k>
<h3>Network Credentials</h3>
Insert your network credentials in the following lines:
<k>// REPLACE WITH YOUR NETWORK CREDENTIALS
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h3>Default Temperature Threshold Value</h3>
In the inputMessage variable insert your default temperature threshold value. We're setting it to 25.0, but you can set it yo any other value.
<k>String inputMessage = "25.0";</k>
<h3>Auxiliar Variables</h3>
The lastTemperature variable will hold the latest temperature reading to be compared with the threshold value.
<k>String lastTemperature;</k>
The enableArmChecked variable will tell us whether the checkbox to automatically control the output is checked or not.
<k>String enableArmChecked = "checked";</k>
In case it's checked, the value saved on the inputMessage2 should be set to true.
<k>String inputMessage2 = "true";</k>
<h3>HTML Text</h3>
Then, we have some basic HTML text to build a page with two input fields: a temperature threshold input field and a checkbox to enable or disable automatically controlling the output. 
The web page also displays the latest temperature reading from the DS18B20 temperature sensor.
The following lines display the temperature:
<k>&lt;h2>DS18B20 Temperature&lt;/h2>
&lt;h3>%TEMPERATURE% &deg;C&lt;/h3></k>
The %TEMPERATURE% is a placeholder that will be replaced by the actual temperature value when the ESP32/ESP8266 serves the page.
Then, we have a form with two input fields and a Submit button. When the user types some data and clicks the Submit button, those values are sent to the ESP to update the variables.
<k>&lt;form action="/get">
  Temperature Threshold &lt;input type="number" step="0.1" name="threshold_input" value="%THRESHOLD%" required>&lt;br>
  Arm Trigger &lt;input type="checkbox" name="enable_arm_input" value="true" %ENABLE_ARM_INPUT%>&lt;br>&lt;br>
  &lt;input type="submit" value="Submit">
&lt;/form></k>
The first input field is of type number and the second input field is a checkbox. To learn more about input fields, we recommend taking a look at following resources of the w3schools website:
<a rel="noreferrer noopener nofollow" aria-label="HTML Input Tags (opens in a new tab)" href="https://www.w3schools.com/tags/tag_input.asp" target="_blank">HTML Input Tag</a>
<a rel="noreferrer noopener nofollow" aria-label="HTML Input Types (opens in a new tab)" href="https://www.w3schools.com/html/html_form_input_types.asp" target="_blank">HTML Input Types</a>
The action attribute of the form specifies where to send the data inserted on the form after pressing submit. In this case, it makes an HTTP GET request to:
<k>/get?threshold_input=value&enable_arm_input=value</k>
The value refers to the text you enter in each of the input fields. To learn more about handling input fields with the ESP32/ESP8266, read: <a href="https://randomnerdtutorials.com/esp32-esp8266-input-data-html-form/">Input Data on HTML Form ESP32/ESP8266 Web Server using Arduino IDE</a>.
<h3>processor()</h3>
The processor() function replaces all placeholders in the HTML text with the actual values.
%TEMPERATURE% <U+00BB> lastTemperature
%THRESHOLD% <U+00BB> inputMessage
<k>String processor(const String& var){
  //Serial.println(var);
  if(var == "TEMPERATURE"){
    return lastTemperature;
  }
  else if(var == "THRESHOLD"){
    return inputMessage;
  }
  else if(var == "ENABLE_ARM_INPUT"){
    return enableArmChecked;
  }
  return String();
}</k>
<h3>Input Field Parameters</h3>
The following variables will be used to check whether we've received an HTTP GET request from those input fields and save the values into variables accordingly.
<k>const char* PARAM_INPUT_1 = "threshold_input";
const char* PARAM_INPUT_2 = "enable_arm_input";</k>
<h3>Interval Between Readings</h3>
Every 5000 milliseconds (5 seconds), we'll get a new temperature reading from the DS18B20 temperature sensor and compare it with the threshold value. To keep track of the time, we use <a href="https://randomnerdtutorials.com/esp32-pir-motion-sensor-interrupts-timers/">timers</a>. 
Change the interval variable if you want to change the time between each sensor reading.
<k>unsigned long previousMillis = 0;
const long interval = 5000;</k>
<h3>GPIO Output</h3>
In this example, we'll control GPIO 2. This GPIO is connected to the ESP32 and ESP8266 built-in LED, so it allows us to easily check if the project is working as expected. You can control any other output and for many applications you'll want to <a href="https://randomnerdtutorials.com/esp32-relay-module-ac-web-server/">control a relay module</a>. 
<k>// GPIO where the output is connected to
const int output = 2;</k>
<h3>DS18B20 Temperature Sensor Init</h3>
Initialize the DS18B20 temperature sensor.
<k>// GPIO where the DS18B20 is connected to
const int oneWireBus = 4;
// Setup a oneWire instance to communicate with any OneWire devices
OneWire oneWire(oneWireBus);
// Pass our oneWire reference to Dallas Temperature sensor 
DallasTemperature sensors(&oneWire);</k>
To learn more about interfacing the DS18B20 temperature sensor with the ESP board, read: 
<a href="https://randomnerdtutorials.com/esp32-ds18b20-temperature-arduino-ide/">ESP32 DS18B20 Temperature Sensor</a>
<a href="https://randomnerdtutorials.com/esp8266-ds18b20-temperature-sensor-web-server-with-arduino-ide/">ESP8266 NodeMCU DS18B20 Temperature Sensor</a>
<h3>setup()</h3>
In the setup(), connect to Wi-Fi in station mode and print the ESP IP address:
<k>Serial.begin(115200);
WiFi.mode(WIFI_STA);
WiFi.begin(ssid, password);
if (WiFi.waitForConnectResult() != WL_CONNECTED) {
  Serial.println("WiFi Failed!");
  return;
}
Serial.println();
Serial.print("ESP IP Address: http://");
Serial.println(WiFi.localIP());</k>
Set GPIO 2 as an output and set it to LOW when the ESP first starts.
<k>pinMode(output, OUTPUT);
digitalWrite(output, LOW);</k>
Initialize the DS18B20 temperature sensor:
<k>sensors.begin();</k>
<h3>Handle Web Server</h3>
Then, define what happens when the ESP32 or ESP8266 receives HTTP requests. When we get a request on the root / url, send the HTML text with the processor (so that the placeholders are replaced with the latest values).
<k>server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
  request->send_P(200, "text/html", index_html, processor);
});</k>
When, a form is submitted, the ESP receives a request on the following URL:
<k>&lt;ESP_IP>/get?threshold_input=&lt;inputMessage>&enable_arm_input=&lt;inputMessage2></k>
So, we check whether the request contains input parameters, and save those parameters into variables:
<k>server.on("/get", HTTP_GET, [] (AsyncWebServerRequest *request) {
  // GET threshold_input value on &lt;ESP_IP>/get?threshold_input=&lt;inputMessage>
  if (request->hasParam(PARAM_INPUT_1)) {
    inputMessage = request->getParam(PARAM_INPUT_1)->value();
    // GET enable_arm_input value on &lt;ESP_IP>/get?enable_arm_input=&lt;inputMessage2>
    if (request->hasParam(PARAM_INPUT_2)) {
      inputMessage2 = request->getParam(PARAM_INPUT_2)->value();
      enableArmChecked = "checked";
    }
    else {
      inputMessage2 = "false";
      enableArmChecked = "";
    }
  }</k>
This is the part of the code where the variables will be replaced with the values submitted on the form. The inputMessage variable saves the temperature threshold value and the inputMessage2 saves whether the checkbox is ticked or not (if we should control the GPIO or not).
After submitting the values on the form, it displays a new page saying the request was successfully sent to your board an with a link to return to the homepage.
<k>request->send(200, "text/html", "HTTP GET request sent to your ESP.&lt;br>&lt;a href=\"/\">Return to Home Page&lt;/a>");
});</k>
Finally, start the server:
<k>server.begin();</k>
<h3>loop()</h3>
In the loop(), we use <a href="https://randomnerdtutorials.com/esp32-pir-motion-sensor-interrupts-timers/">timers</a> to get new temperature readings every 5 seconds.
<k>unsigned long currentMillis = millis();
if (currentMillis - previousMillis >= interval) {
  previousMillis = currentMillis;
  sensors.requestTemperatures();
  // Temperature in Celsius degrees 
  float temperature = sensors.getTempCByIndex(0);
  Serial.print(temperature);
  Serial.println(" *C");
    
  // Temperature in Fahrenheit degrees
  /*float temperature = sensors.getTempFByIndex(0);
  Serial.print(temperature);
  Serial.println(" *F");*/
  
  lastTemperature = String(temperature);</k>
After getting a new temperature reading, we check whether it is above or below the threshold and turn the output on or off accordingly.
In this example, we set the output state to HIGH, if all these conditions are met:
The current temperature is above the threshold;
Automatic output control is enabled (the checkbox is ticked on the web page);
If the output hasn't been triggered yet.
<k>// Check if temperature is above threshold and if it needs to trigger output
if(temperature > inputMessage.toFloat() && inputMessage2 == "true" && !triggerActive){
  String message = String("Temperature above threshold. Current temperature: ") 
                   + String(temperature) + String("C");
  Serial.println(message);
  triggerActive = true;
  digitalWrite(output, HIGH);
}</k>
Then, if the temperature goes below the threshold, set the output to LOW.
<k>else if((temperature &lt; inputMessage.toFloat()) && inputMessage2 == "true" && triggerActive) {
  String message = String("Temperature below threshold. Current temperature: ") 
                   + String(temperature) + String(" C");
  Serial.println(message);
  triggerActive = false;
  digitalWrite(output, LOW);
}</k>
Depending on your application, you may want to change the output to LOW, when the temperature is above the threshold and to HIGH when the output is below the threshold.
<h3>Demonstration  ESP Thermostat</h3>
Upload the code to your ESP board (with the DS18B20 wired to your ESP32 or ESP8266 board).
Open the Serial Monitor at a baud rate of 115200 and press the on-board RST/EN button. The ESP will print its IP address and it will start displaying new temperature values every 5 seconds.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/ESP32-ESP8266-Control-Output-when-Temperature-above-threshold-Arduino-IDE-Serial-Monitor.png">
Open a browser and type the ESP IP address. A similar web page should load with the default values (defined in your code):
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/ESP32-ESP8266-Temperature-threshold-trigger-web-server-Arduino-IDE.png">
If the arm trigger is enabled (checkbox ticked) and if the temperature goes above the threshold, the LED should turn on (output is set to HIGH).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/ESP32-ESP8266-Control-Output-triggered-Temperature-above-threshold.jpg">
After that, if the temperature goes below the threshold, the output will turn off.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/ESP32-ESP8266-Output-Temperature-threshold-web-server.jpg">
You can use the web page input fields to change the threshold value or to arm and disarm controlling the output. For any change to take effect, you just need to press the Submit button.
At the same time, you should get the new input fields in the Serial Monitor.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/ESP32-ESP8266-Control-Output-when-Temperature-above-threshold-Arduino-IDE.png">
<h3>Wrapping Up</h3>
In this project you've learn how to create a web server with a threshold value to automatically control an output accordingly to the current temperature reading thermostat web server). As an example, we've controlled an LED. For real world applications, you'll probably want to control a relay module. You can read the following guides to learn how to control a relay with the ESP:
<a href="https://randomnerdtutorials.com/esp32-relay-module-ac-web-server/">ESP32 Relay Module  Control AC Appliances (Web Server)</a>
<a href="https://randomnerdtutorials.com/esp8266-relay-module-ac-web-server/">ESP8266 NodeMCU Relay Module  Control AC Appliances (Web Server)</a>
We've used raw HTML text, to make the project easier to follow. We suggest adding some CSS to style your web page to make it look nicer. You may also want to <a href="https://randomnerdtutorials.com/esp32-send-email-smtp-server-arduino-ide/">add email notifications</a> to this project.
<h2>How to Program / Upload Code to ESP32-CAM AI-Thinker (Arduino IDE)</h2>
The ESP32-CAM AI-Thinker development board can be programmed using Arduino IDE. This guide shows how to program and upload code to the ESP32-CAM (AI-Thinker) development board using Arduino IDE.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/how-to-program-upload-code-firmware-ESP32-CAM-board-Arduino-IDE-FTDI.jpg">
The <a aria-label="ESP32-CAM AI-Thinker (opens in a new tab)" href="https://makeradvisor.com/esp32-cam-ov2640-camera/" target="_blank">ESP32-CAM AI-Thinker</a> module is an ESP32 development board with an OV2640 camera, microSD card support, on-board flash lamp and several GPIOs to connect peripherals. However, it doesn't have a built-in programmer. You need an FTDI programmer to connect it to your computer and upload code.
<a href="https://makeradvisor.com/tools/ftdi-programmer-board/" target="_blank">Buy an FTDI Programmer</a>
<a aria-label="Buy an ESP32-CAM AI-Thinker with OV2640 Camera (opens in a new tab)" href="https://makeradvisor.com/tools/esp32-cam/" target="_blank">Buy an ESP32-CAM AI-Thinker with OV2640 Camera</a>
<h3>Install the ESP32 Add-on</h3>
To program the ESP32-CAM board with Arduino IDE, you need to have Arduino IDE installed as well as the ESP32 add-on. Follow the next tutorial to install the ESP32 add-on, if you haven't already:
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing the ESP32 Board in Arduino IDE</a>
<h3>Program ESP32-CAM (Upload Code with Arduino IDE)</h3>
To upload code to the ESP32-CAM (AI-Thinker) using Arduino IDE, follow the next exact steps.
Connect the ESP32-CAM board to your computer using an <a href="https://makeradvisor.com/tools/ftdi-programmer-board/" target="_blank" aria-label=" (opens in a new tab)">FTDI programmer</a>. Follow the next schematic diagram:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/ESP32-CAM-FTDI-programmer-5V-supply.png">
<k>Note: </k> the order of the FTDI pins on the diagram may not match yours. Make sure you check the silkscreen label next to each pin.
Many FTDI programmers have a jumper that allows you to select 3.3V or 5V. Make sure the jumper is in the right place to select 5V.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/FTDI-Programmer-select-jumper-to-5V-cap.jpg">
<k>Important: </k> GPIO 0 needs to be connected to GND so that you're able to upload code.
<table><tbody>
<tr>
<td><k>ESP32-CAM</k></td>
<td><k>FTDI Programmer</k></td>
</tr>
<tr>
<td>GND</td>
<td>GND</td>
</tr>
<tr>
<td>5V</td>
<td>VCC (5V)</td>
</tr>
<tr>
<td>U0R</td>
<td>TX</td>
</tr>
<tr>
<td>U0T</td>
<td>RX</td>
</tr>
<tr>
<td>GPIO 0</td>
<td>GND</td>
</tr>
</tbody></table>To upload code to the ESP32-CAM using Arduino IDE, follow the next steps:
1) Go to <k>Tools </k>> <k>Board </k>and select <k>AI-Thinker ESP32-CAM</k>. You must have the <a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">ESP32 add-on installed</a>. Otherwise, this board won't show up on the Boards menu.
2) Go to <k>Tools </k>> <k>Port </k>and select the COM port the ESP32-CAM is connected to.
3) For demonstration purposes, you can upload a blank sketch to your board:
<k>void setup() {
  // put your setup code here, to run once:
}
void loop() {
  // put your main code here, to run repeatedly:
}</k>
4) Then, click the <k>Upload </k>button in your Arduino IDE.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/upload-button-arduino-ide.png">
5) When you start to see some dots on the debugging window, press the ESP32-CAM on-board RST button.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/dots-uploading-code.png">
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/ESP32-CAM-Press-Click-RESET-RST-button-on-board-restart.jpg">
After a few seconds, the code should be successfully uploaded to your board.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/ESP32-CAM-AI-Thinker-Arduino-IDE-Done-Uploading.png">
6) When you see the <k>Done uploading</k> message, you need to remove GPIO 0 from GND and press the RST button to run your new code.
<h3>Common Errors and How to Fix Them</h3>
If you don't follow the previous instructions exactly, you may get the following errors:
<h3>Failed to connect to ESP32: Timed out waiting for packet header</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/06/fatal-error-occurred-failed-to-connect-to-esp32-timed-out-waiting-for-packet-header.png">
This error means that the ESP32-CAM is not in flashing mode or it is not connected properly to the FTDI programmer.
<h3>Brownout detector or Guru meditation error</h3>
When you open your Arduino IDE Serial Monitor and the error message Brownout detector was triggered is constantly being printed over and over again. It means that there's some sort of hardware problem.
It's often related to one of the following issues:
Poor quality USB cable;
USB cable is too long;
Board with some defect (bad solder joints);
Bad computer USB port;
Or not enough power provided by the computer USB port.
<k>Solution:</k> 
Try a different shorter USB cable (with data wires);
Use a different computer USB port or use a USB hub with an external power supply;
Some readers were using 3.3V and reported that when powering the ESP32-CAM with 5V, the issue was fixed.
<h3>Board at COMX is not available  COM Port not selected</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/06/no-com-port-selected.png">If you get the following error or similar:
<k>serial.serialutil.SerialException: could not open port 'COM8': WindowsError(2, 'The system cannot find the file specified.')
Failed to execute script esptool
the selected serial port Failed to execute script esptool
 does not exist or your board is not connected
Board at COM8 is not available</k>
It means that you haven't selected the COM port in the Tools menu. In your Arduino IDE, go to <k>Tools </k>> <k>Port </k>and select the COM port the ESP32 is connected to.
It might also mean that the ESP32-CAM is not establishing a serial connection with your computer or it is not properly connected to the USB connector.
<h3>Other errors</h3>
For a more extensive list of the most common problems with the ESP32-CAM and how to fix them, read our <a href="https://randomnerdtutorials.com/esp32-cam-troubleshooting-guide/">ESP32-CAM Troubleshooting Guide</a>.
<a href="https://randomnerdtutorials.com/esp32-cam-projects-ebook/">
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-eBook-334.jpg?fit=334%2C334&quality=100&strip=all&ssl=1" alt="" srcset="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-eBook-334.jpg?w=334&quality=100&strip=all&ssl=1 334w, https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-eBook-334.jpg"></a>
<h3>Wrapping Up</h3>
We hope this guide helps you get started programming your ESP32-CAM AI-Thinker using Arduino IDE. 
Check all our projects with the ESP32-CAM:
<a href="https://randomnerdtutorials.com/esp32-cam-video-streaming-face-recognition-arduino-ide/" target="_blank">Video Streaming, Face Detection and Face Recognition</a>
<a href="https://randomnerdtutorials.com/esp32-cam-video-streaming-web-server-camera-home-assistant/" target="_blank">ESP32 IP CAM  Video Streaming (Home Assistant and Node-RED)</a>
<a href="https://randomnerdtutorials.com/esp32-cam-take-photo-save-microsd-card/" target="_blank">Take Photo and Save to MicroSD Card</a>
<a href="https://randomnerdtutorials.com/esp32-cam-pir-motion-detector-photo-capture/" target="_blank">PIR Motion Detector with Photo Capture</a>
<a href="https://randomnerdtutorials.com/esp32-cam-take-photo-display-web-server/" target="_blank">Take Photo, Save to SPIFFS and Display in Web Server</a>
<a href="https://randomnerdtutorials.com/esp32-cam-projects-ebook/"><k>Build ESP32-CAM Projects (eBook)</k></a>
<a href="https://randomnerdtutorials.com/projects-esp32-cam/"><k>Read all our ESP32-CAM Projects, Tutorials and Guides</k></a>
There are different models of ESP32 camera development boards that might be more suitable for your projects. So, you might also like reading:
<a href="https://makeradvisor.com/esp32-camera-cam-boards-review-comparison/" target="_blank" aria-label="ESP32 Camera Dev Boards Review and Comparison (opens in a new tab)">ESP32 Camera Dev Boards Review and Comparison</a>
Thanks for reading.
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/smart-home-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px-pupj8i6e7hlzpgwxe82jjd8skst9vmrjt9lpqb0v0g.jpg" title="Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px" alt="SMART HOME with Raspberry Pi ESP32 and ESP8266 Node-RED InfluxDB eBook" loading="lazy" width="117" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/smart-home-ebook/">SMART HOME with Raspberry Pi, ESP32, ESP8266 [eBook] </a></h4>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>ESP-NOW Two-Way Communication Between ESP32 Boards</h2>
In this guide, we'll show you how to establish a two-way communication between two ESP32 boards using ESP-NOW communication protocol. As an example, two ESP32 boards will exchange sensor readings (with a range in open field up to 220 meters ~ 722 feet).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP-NOW-Two-Way-Communication-Between-ESP32-Boards-Arduino-IDE.jpg">
<h3>Watch the Video Introduction</h3>
For an introduction to ESP-NOW protocol, you can watch the following video:

<h2>Get ESP32/ESP8266 MAC Address and Change It (Arduino IDE)</h2>
This guide shows how to get the ESP32 or ESP8266 boards MAC Address using Arduino IDE. We also show how to change your board's MAC Address.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/How-to-get-ESP32-ESP8266-Physical-MAC-Address-Arduino-IDE.jpg">
<h3>What's a MAC Address?</h3>
MAC Address stands for <k>M</k>edia <k>A</k>ccess <k>C</k>ontrol Address and it is a hardware unique identifier that identifies each device on a network.
MAC Addresses are made up of six groups of two hexadecimal digits, separated by colons, for example: 30:AE:A4:07:0D:64. 
MAC Addresses are assigned by manufacturers, but you can also give a custom MAC Address to your board. However, every time the board resets, it will return to its original MAC Address. So, you need to include the code to set a custom MAC Address in every sketch.
<h3>Get ESP32 or ESP8266 MAC Address</h3>
To get your board MAC Address, simply upload the following code to the ESP32 or ESP8266. The code is compatible with both boards.
<k>// Complete Instructions to Get and Change ESP MAC Address: https://RandomNerdTutorials.com/get-change-esp32-esp8266-mac-address-arduino/
#ifdef ESP32
  #include &lt;WiFi.h>
#else
  #include &lt;ESP8266WiFi.h>
#endif
void setup(){
  Serial.begin(115200);
  Serial.println();
  Serial.print("ESP Board MAC Address:  ");
  Serial.println(WiFi.macAddress());
}
 
void loop(){
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_Get_MAC_Address.ino" target="_blank">View raw code</a>
<h3>Demonstration</h3>
After uploading the code, open the Serial Monitor at a baud rate of 115200. Press the on-board RESET or EN button.
The MAC Address should be printed in the Serial Monitor as shown in the following figure.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP32-ESP8266-Get-Board-Physical-MAC-Address-with-Arduino-IDE.png">
That's it! Now, you know how to get your ESP32 or ESP8266 board MAC Address.
<h3>Set a Custom MAC Address for ESP32 and ESP8266</h3>
In some applications, it might be useful to give your boards a custom MAC Address. However, as explained previously, <k>this doesn't overwrite the MAC Address set by the manufacturer</k>. So, every time you reset the board, or upload a new code, it will get back to its default MAC Address.
<h3>Change ESP32 MAC Address (Arduino IDE)</h3>
The following code sets a custom MAC Address for the ESP32 board.
<k>// Complete Instructions: https://RandomNerdTutorials.com/get-change-esp32-esp8266-mac-address-arduino/
#include &lt;WiFi.h>
#include &lt;esp_wifi.h>
// Set your new MAC Address
uint8_t newMACAddress[] = {0x32, 0xAE, 0xA4, 0x07, 0x0D, 0x66};
void setup(){
  Serial.begin(115200);
  Serial.println();
  
  WiFi.mode(WIFI_STA);
  
  Serial.print("[OLD] ESP32 Board MAC Address:  ");
  Serial.println(WiFi.macAddress());
  
  // ESP32 Board add-on before version &lt; 1.0.5
  //esp_wifi_set_mac(ESP_IF_WIFI_STA, &newMACAddress[0]);
  
  // ESP32 Board add-on after version > 1.0.5
  esp_wifi_set_mac(WIFI_IF_STA, &newMACAddress[0]);
  
  Serial.print("[NEW] ESP32 Board MAC Address:  ");
  Serial.println(WiFi.macAddress());
}
 
void loop(){
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Change_MAC_Address.ino" target="_blank">View raw code</a>
You can set a custom MAC Address in the following line:
<k>uint8_t newMACAddress[] = {0x32, 0xAE, 0xA4, 0x07, 0x0D, 0x66};</k>
After uploading the code, open the Serial Monitor at a baud rate of 115200. Restart the ESP32 and you should get its old and new MAC Address.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/Change-ESP32-Board-MAC-Address-Arduino-IDE-fixed.png"><h3>Change ESP8266 MAC Address (Arduino IDE) </h3>
 The following code sets a custom MAC Address for the ESP8266 board. 
<k>// Complete Instructions: https://RandomNerdTutorials.com/get-change-esp32-esp8266-mac-address-arduino/
#include &lt;ESP8266WiFi.h>
// Set your new MAC Address
uint8_t newMACAddress[] = {0x32, 0xAE, 0xA4, 0x07, 0x0D, 0x66};
void setup(){
  Serial.begin(115200);
  Serial.println();
  
  WiFi.mode(WIFI_STA);
  
  Serial.print("[OLD] ESP8266 Board MAC Address:  ");
  Serial.println(WiFi.macAddress());
  // For Soft Access Point (AP) Mode
  //wifi_set_macaddr(SOFTAP_IF, &newMACAddress[0]);
  // For Station Mode
  wifi_set_macaddr(STATION_IF, &newMACAddress[0]);
  
  Serial.print("[NEW] ESP8266 Board MAC Address:  ");
  Serial.println(WiFi.macAddress());
}
 
void loop(){
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP8266/ESP8266_Change_MAC_Address.ino" target="_blank">View raw code</a>
Set your custom MAC Address on the following line:
<k>uint8_t newMACAddress[] = {0x32, 0xAE, 0xA4, 0x07, 0x0D, 0x66};</k>
After uploading the code, open the Serial Monitor at a baud rate of 115200. Restart the ESP8266 and you should get its old and new MAC Address. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/Change-ESP8266-Board-MAC-Address-Arduino-IDE-fixed.png"><h3>Wrapping Up</h3>
In this quick guide, we've shown you how to get your ESP32 and ESP8266 manufacturer MAC Address with Arduino IDE. You've also learned how to set a custom MAC Address for your boards.
Learn more about the ESP32 and ESP8266 boards:
<a href="https://randomnerdtutorials.com/learn-esp32-with-arduino-ide/">Learn ESP32 with Arduino IDE (eBook + Video Course)</a>
<a href="https://randomnerdtutorials.com/projects-esp32/">More ESP32 resources</a>
<a href="https://randomnerdtutorials.com/home-automation-using-esp8266/">Home Automation using ESP8266 (eBook)</a>
<a href="https://randomnerdtutorials.com/projects-esp8266/">More ESP8266 resources</a>
Thanks for reading. 
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h-p2lw6wwnkk9ystvwe9iof8zx6yt4x7uma3cqfup534.jpg" title="Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h" alt="Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h" loading="lazy" width="129" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/">[eBook] Build Web Servers with ESP32 and ESP8266 (2nd Edition)</a></h4>
Build Web Server projects with the ESP32 and ESP8266 boards to control outputs and monitor sensors remotely. Learn HTML, CSS, JavaScript and client-server communication protocols <k><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Build Web Server projects with the ESP32 and ESP8266 boards to control outputs and monitor sensors remotely. Learn HTML, CSS, JavaScript and client-server communication protocols <k><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>Getting Started with ESP-NOW (ESP32 with Arduino IDE)</h2>
Learn how to use ESP-NOW to exchange data between ESP32 boards programmed with Arduino IDE. ESP-NOW is a connectionless communication protocol developed by Espressif that features short packet transmission. This protocol enables multiple devices to talk to each other in an easy way.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/Getting-Started-with-ESP-NOW-ESP32-Arduino-IDE.jpg">
We have other tutorials for ESP-NOW with the ESP32:
<a href="https://randomnerdtutorials.com/esp-now-two-way-communication-esp32/">ESP-NOW Two-Way Communication Between ESP32 Boards</a>
<a href="https://randomnerdtutorials.com/esp-now-one-to-many-esp32-esp8266/">ESP-NOW with ESP32: Send Data to Multiple Boards (one-to-many)</a>
<a href="https://randomnerdtutorials.com/esp-now-many-to-one-esp32/">ESP-NOW with ESP32: Receive Data from Multiple Boards (many-to-one)</a>
<a href="https://randomnerdtutorials.com/esp32-esp-now-wi-fi-web-server/">ESP32: ESP-NOW Web Server Sensor Dashboard (ESP-NOW + Wi-Fi)</a>
<h3>Arduino IDE</h3>
We'll program the <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank" aria-label="ESP32 board (opens in a new tab)">ESP32 board</a> using Arduino IDE, so before proceeding with this tutorial you should have the ESP32 add-on installed in your Arduino IDE. Follow the next guide:
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, and Linux instructions)</a>
<k>Note: </k>we have a similar guide for the ESP8266 NodeMCU Board: <a href="https://randomnerdtutorials.com/esp-now-esp8266-nodemcu-arduino-ide/">Getting Started with ESP-NOW (ESP8266 NodeMCU with Arduino IDE)</a>
<h3>Introducing ESP-NOW</h3>
For a video introduction to ESP-NOW protocol, watch the following (<a href="https://randomnerdtutorials.com/esp-now-two-way-communication-esp32/">try the project featured in this video</a>):

Stating the Espressif website, ESP-NOW is a <em>protocol developed by Espressif, which enables multiple devices to communicate with one another without using Wi-Fi. The protocol is similar to the low-power 2.4GHz wireless connectivity () . The pairing between devices is needed prior to their communication. After the pairing is done, the connection is safe and peer-to-peer, with no handshake being required</em>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/esp-now-logo.png">
This means that after pairing a device with each other, the connection is persistent. In other words, if suddenly one of your boards loses power or resets, when it restarts, it will automatically connect to its peer to continue the communication.
ESP-NOW supports the following features:
Encrypted and unencrypted unicast communication;
Mixed encrypted and unencrypted peer devices;
<k>Up to 250-byte</k> payload can be carried;
Sending callback function that can be set to inform the application layer of transmission success or failure.
ESP-NOW technology also has the following limitations:
Limited encrypted peers. 10 encrypted peers at the most are supported in Station mode; 6 at the most in SoftAP or SoftAP + Station mode;
Multiple unencrypted peers are supported, however, their total number should be less than 20, including encrypted peers;
<k>Payload is limited to 250 bytes</k>. 
<k>In simple words, ESP-NOW is a fast communication protocol that can be used to exchange small messages (up to 250 bytes) between ESP32 boards.</k>
ESP-NOW is very versatile and you can have one-way or two-way communication in different setups.
<h3>ESP-NOW One-Way Communication</h3>
For example, in one-way communication, you can have scenarios like this:
<k>One ESP32 board sending data to another ESP32 board</k>
This configuration is very easy to implement and it is great to send data from one board to the other like sensor readings or ON and OFF commands to control GPIOs.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP_NOW_one_way_communication_two_boards.png">
<k><a href="https://randomnerdtutorials.com/esp-now-one-to-many-esp32-esp8266/">A master ESP32 sending data to multiple ESP32 slaves</a></k>
One ESP32 board sending the same or different commands to different ESP32 boards. This configuration is ideal to build something like a remote control. You can have several ESP32 boards around the house that are controlled by one main ESP32 board.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP_NOW_one_master_multiple_slaves.png">
<k><a href="https://randomnerdtutorials.com/esp-now-many-to-one-esp32/">One ESP32 slave receiving data from multiple masters</a></k>
This configuration is ideal if you want to collect data from several sensors nodes into one ESP32 board. This can be configured as a web server to display data from all the other boards, for example.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP_NOW_one_slave_multiple_masters.png">
<k>Note: </k> in the ESP-NOW documentation there isn't such thing as sender/master and receiver/slave. Every board can be a sender or receiver. However, to keep things clear we'll use the terms sender and receiver or master and slave. 
<h3>ESP-NOW Two-Way Communication</h3>
With ESP-NOW, each board can be a sender and a receiver at the same time. So, you can establish <a href="https://randomnerdtutorials.com/esp-now-two-way-communication-esp32/">two-way communication between boards</a>.
For example, you can have two boards communicating with each other. 
<a href="https://randomnerdtutorials.com/esp-now-two-way-communication-esp32/"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP_NOW_two_way_communication_two_boards.png"></a>
<k>Learn how to:</k> <a href="https://randomnerdtutorials.com/esp-now-two-way-communication-esp32/">Exchange Sensor Readings with ESP-NOW Two-Way Communication</a>.
You can add more boards to this configuration and have something that looks like a network (all ESP32 boards communicate with each other).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP_NOW_multiple_boards_two_way_communication.png">
In summary, ESP-NOW is ideal to build a network in which you can have several ESP32 boards exchanging data with each other. 
<h3>ESP32: Getting Board MAC Address</h3>
To communicate via ESP-NOW, you need to know the MAC Address of the <a aria-label="ESP32 receiver (opens in a new tab)" href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32 receiver</a>. That's how you know to which device you'll send the data to.
Each ESP32 has a <a href="https://randomnerdtutorials.com/get-change-esp32-esp8266-mac-address-arduino/">unique MAC Address</a> and that's how we identify each board to send data to it using ESP-NOW (learn how to <a href="https://randomnerdtutorials.com/get-change-esp32-esp8266-mac-address-arduino/">Get and Change the ESP32 MAC Address</a>).
To get your board's MAC Address, upload the following code.
<k>// Complete Instructions to Get and Change ESP MAC Address: https://RandomNerdTutorials.com/get-change-esp32-esp8266-mac-address-arduino/
#include "WiFi.h"
 
void setup(){
  Serial.begin(115200);
  WiFi.mode(WIFI_MODE_STA);
  Serial.println(WiFi.macAddress());
}
 
void loop(){
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Get_MAC_Address.ino" target="_blank">View raw code</a>
After uploading the code, open the Serial Monitor at a baud rate of 115200 and press the ESP32 RST/EN button. The MAC address should be printed as follows:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP32_MAC_Address_Serial_monitor.jpg">
Save your board MAC address because you'll need it to send data to the right board via ESP-NOW.
<h3>ESP-NOW One-way Point to Point Communication</h3>
To get you started with ESP-NOW wireless communication, we'll build a simple project that shows how to send a message from one ESP32 to another. One ESP32 will be the sender and the other ESP32 will be the receiver.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP_NOW_one_way_communication_two_boards.png">
We'll send a structure that contains a variable of type <em>char</em>, <em>int</em>, <em>float</em>, and <em>boolean</em>. Then, you can modify the structure to send whichever variable types are suitable for your project (like sensor readings, or boolean variables to turn something on or off).
For better understanding, we'll call sender to ESP32 #1 and receiver to ESP32 #2.
Here's what we should include in the sender sketch:
<ol>
Initialize ESP-NOW;
Register a callback function upon sending data  the OnDataSent function will be executed when a message is sent. This can tell us if the message was successfully delivered or not;
Add a peer device (the receiver). For this, you need to know the receiver MAC address;
Send a message to the peer device.
</ol>
On the receiver side, the sketch should include:
<ol>
Initialize ESP-NOW;
Register for a receive callback function (OnDataRecv). This is a function that will be executed when a message is received.
Inside that callback function, save the message into a variable to execute any task with that information.
</ol>
ESP-NOW works with callback functions that are called when a device receives a message or when a message is sent (you get if the message was successfully delivered or if it failed).
<h3>ESP-NOW Useful Functions</h3>
Here's a summary of the most essential ESP-NOW functions:
<table><tbody>
<tr><td><k>Function Name and Description</k></td></tr>
<tr><td>
esp_now_init() Initializes ESP-NOW. You must initialize Wi-Fi before initializing ESP-NOW. </td></tr>
<tr><td>
esp_now_add_peer() Call this function to pair a device and pass as an argument the peer MAC address. </td></tr>
<tr><td>
esp_now_send() Send data with ESP-NOW. </td></tr>
<tr><td>
esp_now_register_send_cb() Register a callback function that is triggered upon sending data. When a message is sent, a function is called  this function returns whether the delivery was successful or not. </td></tr>
<tr><td>
esp_now_register_rcv_cb() Register a callback function that is triggered upon receiving data. When data is received via ESP-NOW, a function is called. </td></tr>
</tbody></table>For more information about these functions read the <a href="https://demo-dijiudu.readthedocs.io/en/latest/api-reference/wifi/esp_now.html" target="_blank" aria-label=" (opens in a new tab)">ESP-NOW documentation at Read the Docs</a>.
<h3>ESP32 Sender Sketch (ESP-NOW)</h3>
Here's the code for the <a aria-label="ESP32 Sender (opens in a new tab)" href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32 Sender board</a>. Copy the code to your Arduino IDE, but don't upload it yet. You need to make a few modifications to make it work for you.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp-now-esp32-arduino-ide/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;esp_now.h>
#include &lt;WiFi.h>
// REPLACE WITH YOUR RECEIVER MAC Address
uint8_t broadcastAddress[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
// Structure example to send data
// Must match the receiver structure
typedef struct struct_message {
  char a[32];
  int b;
  float c;
  bool d;
} struct_message;
// Create a struct_message called myData
struct_message myData;
esp_now_peer_info_t peerInfo;
// callback when data is sent
void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
  Serial.print("\r\nLast Packet Send Status:\t");
  Serial.println(status == ESP_NOW_SEND_SUCCESS ? "Delivery Success" : "Delivery Fail");
}
 
void setup() {
  // Init Serial Monitor
  Serial.begin(115200);
 
  // Set device as a Wi-Fi Station
  WiFi.mode(WIFI_STA);
  // Init ESP-NOW
  if (esp_now_init() != ESP_OK) {
    Serial.println("Error initializing ESP-NOW");
    return;
  }
  // Once ESPNow is successfully Init, we will register for Send CB to
  // get the status of Trasnmitted packet
  esp_now_register_send_cb(OnDataSent);
  
  // Register peer
  memcpy(peerInfo.peer_addr, broadcastAddress, 6);
  peerInfo.channel = 0;  
  peerInfo.encrypt = false;
  
  // Add peer        
  if (esp_now_add_peer(&peerInfo) != ESP_OK){
    Serial.println("Failed to add peer");
    return;
  }
}
 
void loop() {
  // Set values to send
  strcpy(myData.a, "THIS IS A CHAR");
  myData.b = random(1,20);
  myData.c = 1.2;
  myData.d = false;
  
  // Send message via ESP-NOW
  esp_err_t result = esp_now_send(broadcastAddress, (uint8_t *) &myData, sizeof(myData));
   
  if (result == ESP_OK) {
    Serial.println("Sent with success");
  }
  else {
    Serial.println("Error sending the data");
  }
  delay(2000);
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP_NOW/ESP_NOW_Sender.ino" target="_blank">View raw code</a>
<h3>How the code works</h3>
First, include the esp_now.h and WiFi.h libraries.
<k>#include &lt;esp_now.h>
#include &lt;WiFi.h></k>
In the next line, you should insert the ESP32 receiver MAC address.
<k>uint8_t broadcastAddress[] = {0x30, 0xAE, 0xA4, 0x07, 0x0D, 0x64};</k>
In our case, the receiver MAC address is: 30:AE:A4:07:0D:64, but you need to replace that variable with your own MAC address.
Then, create a structure that contains the type of data we want to send. We called this structure struct_message and it contains 4 different variable types. You can change this to send other variable types.
<k>typedef struct struct_message {
  char a[32];
  int b;
  float c;
  bool d;
} struct_message;</k>
Then, create a new variable of type struct_message that is called myData that will store the variables' values.
<k>struct_message myData;</k>
Create a variable of type esp_now_peer_info_t to store information about the peer.
<k>esp_now_peer_info_t peerInfo;</k>
Next, define the OnDataSent() function. This is a callback function that will be executed when a message is sent. In this case, this function simply prints if the message was successfully delivered or not.
<k>void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
  Serial.print("\r\nLast Packet Send Status:\t");
  Serial.println(status == ESP_NOW_SEND_SUCCESS ? "Delivery Success" : "Delivery Fail");
}</k>
In the setup(), initialize the serial monitor for debugging purposes:
<k>Serial.begin(115200);</k>
Set the device as a Wi-Fi station:
<k>WiFi.mode(WIFI_STA);</k>
Initialize ESP-NOW:
<k>if (esp_now_init() != ESP_OK) {
  Serial.println("Error initializing ESP-NOW");
  return;
}</k>
After successfully initializing ESP-NOW, register the callback function that will be called when a message is sent. In this case, we register for the OnDataSent() function created previously.
<k>esp_now_register_send_cb(OnDataSent);</k>
After that, we need to pair with another ESP-NOW device to send data. That's what we do in the next lines:
<k>//Register peer
memcpy(peerInfo.peer_addr, broadcastAddress, 6);
peerInfo.channel = 0;
peerInfo.encrypt = false;
//Add peer
if (esp_now_add_peer(&peerInfo) != ESP_OK){
  Serial.println("Failed to add peer");
  return;
}</k>
In the loop(), we'll send a message via ESP-NOW every 2 seconds (you can change this delay time).
First, we set the variables values as follows:
<k>strcpy(myData.a, "THIS IS A CHAR");
myData.b = random(1,20);
myData.c = 1.2;
myData.d = false;</k>
Remember that myData is a structure. Here we assign the values we want to send inside the structure. For example, the first line assigns a char, the second line assigns a random Int number, a Float, and a Boolean variable. 
We create this kind of structure to show you how to send the most common variable types. You can change the structure to send other data types.
Finally, send the message as follows:
<k>esp_err_t result = esp_now_send(broadcastAddress, (uint8_t *) &myData, sizeof(myData));</k>
Check if the message was successfully sent:
<k>if (result == ESP_OK) {
  Serial.println("Sent with success");
}
else {
  Serial.println("Error sending the data");
}</k>
The loop() is executed every 2000 milliseconds (2 seconds).
<k>delay(2000);</k>
<h3>ESP32 Receiver Sketch (ESP-NOW)</h3>
Upload the following code to your <a aria-label="ESP32 receiver (opens in a new tab)" href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32 receiver board</a>.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp-now-esp32-arduino-ide/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;esp_now.h>
#include &lt;WiFi.h>
// Structure example to receive data
// Must match the sender structure
typedef struct struct_message {
    char a[32];
    int b;
    float c;
    bool d;
} struct_message;
// Create a struct_message called myData
struct_message myData;
// callback function that will be executed when data is received
void OnDataRecv(const uint8_t * mac, const uint8_t *incomingData, int len) {
  memcpy(&myData, incomingData, sizeof(myData));
  Serial.print("Bytes received: ");
  Serial.println(len);
  Serial.print("Char: ");
  Serial.println(myData.a);
  Serial.print("Int: ");
  Serial.println(myData.b);
  Serial.print("Float: ");
  Serial.println(myData.c);
  Serial.print("Bool: ");
  Serial.println(myData.d);
  Serial.println();
}
 
void setup() {
  // Initialize Serial Monitor
  Serial.begin(115200);
  
  // Set device as a Wi-Fi Station
  WiFi.mode(WIFI_STA);
  // Init ESP-NOW
  if (esp_now_init() != ESP_OK) {
    Serial.println("Error initializing ESP-NOW");
    return;
  }
  
  // Once ESPNow is successfully Init, we will register for recv CB to
  // get recv packer info
  esp_now_register_recv_cb(OnDataRecv);
}
 
void loop() {
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP_NOW/ESP_NOW_Receiver.ino" target="_blank">View raw code</a>
<h3>How the code works</h3>
Similarly to the sender, start by including the libraries:
<k>#include &lt;esp_now.h>
#include &lt;WiFi.h></k>
Create a structure to receive the data. This structure should be the same defined in the sender sketch.
<k>typedef struct struct_message {
  char a[32];
  int b;
  float c;
  bool d;
} struct_message;</k>
Create a struct_message variable called myData.
<k>struct_message myData;</k>
Create a callback function that will be called when the ESP32 receives the data via ESP-NOW. The function is called onDataRecv() and should accept several parameters as follows:
<k>void OnDataRecv(const uint8_t * mac, const uint8_t *incomingData, int len) {</k>
We copy the content of the incomingData data variable into the myData variable. 
<k>memcpy(&myData, incomingData, sizeof(myData));</k>
Now, the myData structure contains several variables inside with the values sent by the ESP32 sender. To access variable a, for example, we just need to call myData.a.
In this example, we simply print the received data, but in a practical application you can print the data on a display, for example.
<k>Serial.print("Bytes received: ");
Serial.println(len);
Serial.print("Char: ");
Serial.println(myData.a);
Serial.print("Int: ");
Serial.println(myData.b);
Serial.print("Float: ");
Serial.println(myData.c);
Serial.print("Bool: ");
Serial.println(myData.d);
Serial.println();</k>
In the setup(), intialize the Serial Monitor.
<k>Serial.begin(115200);</k>
Set the device as a Wi-Fi Station.
<k>WiFi.mode(WIFI_STA);</k>
Initialize ESP-NOW:
<k>if (esp_now_init() != ESP_OK) {
  Serial.println("Error initializing ESP-NOW");
  return;
}</k>
Register for a callback function that will be called when data is received. In this case, we register for the OnDataRecv() function that was created previously.
<k>esp_now_register_recv_cb(OnDataRecv);</k>
<h3>Testing ESP-NOW Communication</h3>
Upload the sender sketch to the sender ESP32 board and the receiver sketch to the receiver ESP32 board. 
Now, open two Arduino IDE windows. One for the receiver, and another for the sender. Open the Serial Monitor for each board. It should be a different COM port for each board.
This is what you should get on the sender side.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP_NOW_Sender_Serial_Monitor.jpg">
And this is what you should get on the receiver side. Note that the Int variable changes between each reading received (because we set it to a random number on the sender side).
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP_NOW_Receiver_Serial_Monitor_.jpg?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP_NOW_Receiver_Serial_Monitor_.jpg"></a>
We tested the communication range between the two boards, and we are able to get a stable communication up to 220 meters (approximately 722 feet) in open field. In this experiment both ESP32 on-board antennas were pointing to each other.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP_NOW_ESP32_testing_range.png">
<h3>Wrapping Up</h3>
We tried to keep our examples as simple as possible so that you better understand how everything works. There are more ESP-NOW-related functions that can be useful in your projects, like: managing peers, deleting peers, scanning for slave devices, etc For a complete example, in your Arduino IDE, you can go to <k>File </k>> <k>Examples </k>> <k>ESP32 </k>> <k>ESPNow </k>and choose one of the example sketches.
We hope you've found this introduction to ESP-NOW useful. As a simple getting started example, we've shown you how to send data as a structure from one ESP32 to another. The idea is to replace the structure values with sensor readings or GPIO states, for example.
Additionally, with ESP-NOW, each board can simultaneously be a sender and receiver. One board can <a href="https://randomnerdtutorials.com/esp-now-one-to-many-esp32-esp8266/">send data to multiple boards</a> and also <a href="https://randomnerdtutorials.com/esp-now-many-to-one-esp32/">receive data from multiple boards</a>.
We also have a tutorial about ESP-NOW with the ESP8266: <a href="https://randomnerdtutorials.com/esp-now-esp8266-nodemcu-arduino-ide/">Getting Started with ESP-NOW (ESP8266 NodeMCU with Arduino IDE)</a>.
To learn more about the ESP32 board, make sure you take a look at our resources:
<a href="https://randomnerdtutorials.com/esp-now-two-way-communication-esp32/">ESP-NOW Two-Way Communication Between ESP32 Boards</a>
<k><a href="https://randomnerdtutorials.com/learn-esp32-with-arduino-ide/">Learn ESP32 with Arduino IDE (video course + eBook);</a></k>
<a href="https://randomnerdtutorials.com/micropython-programming-with-esp32-and-esp8266/">MicroPython Programming with ESP32 and ESP8266</a>
<a href="https://randomnerdtutorials.com/projects-esp32/">More ESP32 resources</a>
Thanks for reading.
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/smart-home-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px-pupj8i6e7hlzpgwxe82jjd8skst9vmrjt9lpqb0v0g.jpg" title="Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px" alt="SMART HOME with Raspberry Pi ESP32 and ESP8266 Node-RED InfluxDB eBook" loading="lazy" width="117" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/smart-home-ebook/">SMART HOME with Raspberry Pi, ESP32, ESP8266 [eBook] </a></h4>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>TTGO T-Journal ESP32 Camera: Built-in Programmer, OLED, Antenna and Project Examples</h2>
This is a getting started guide for the TTGO T-Journal ESP32 Camera Development Board. The TTGO T-Journal features an OV2640 camera, an OLED display, several GPIOs to connect peripherals and a built-in programmer, which makes it easy to upload code. We'll take a quick look at the camera dev board and learn how to program it using Arduino IDE.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP32-TTGO-T-Journal-Board-Project-Examples-1024x576.jpg"><h3>Where to Buy?</h3>
You can go to the<a href="https://makeradvisor.com/tools/ttgo-t-journal-esp32-camera/" target="_blank" aria-label=" TTGO T-Journal page on Maker Advisor (opens in a new tab)"> TTGO T-Journal page on Maker Advisor</a> to compare the board on different stores.
<a aria-label="TTGO T-Journal ESP32 Camera + OLED  (opens in a new tab)" href="https://makeradvisor.com/tools/ttgo-t-journal-esp32-camera/" target="_blank">TTGO T-Journal ESP32 Camera + OLED +Antenna + Built-in Programmer</a>
<a href="https://makeradvisor.com/tools/ttgo-t-journal-esp32-camera/" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/TTGO-T-Journal-ESP32-Camera-Dev-Board-750.jpg"></a>
<h3>Introducing the TTGO T-Journal ESP32 Camera</h3>
The <a aria-label="TTGO T-Journal (opens in a new tab)" href="https://makeradvisor.com/tools/ttgo-t-journal-esp32-camera/" target="_blank">TTGO T-Journal</a> is a $12-$15 ESP32 Camera Development Board with an OV2640 camera, an antenna, an I2C SSD1306 0.91 inch OLED display, some exposed GPIOs, and a micro-USB interface that makes it easy and quick to upload code to the board.
For a complete overview of this board you can watch the following video or read this article: <a href="https://makeradvisor.com/ttgo-t-journal-esp32-camera-board-review/" target="_blank" aria-label="TTGO T-Journal ESP32 Camera Dev Board Review (opens in a new tab)">TTGO T-Journal ESP32 Camera Dev Board Review</a>.

<h3>TTGO T-Journal ESP32 Features</h3>
Here's a summary of the TTGO T-Journal features:
Chipset ESPRESSIF-ESP32-PCIO-D4 240MHz Xtensa<U+00AE> single-/dual-core 32-bit LX6 microprocessor
FLASH QSPI flash/SRAM, up to 4 x 16 MBSRAM 520 kB SRAM
Reset button and button on GPIO 32
0.91 inch SSD1306 OLED display
Power indicator red LED
USB to TTL CP2104 (you can upload code via USB cable);
Camera OV2640  2 Megapixel
Steering engine analog servo (comes with two sets of pins ideal to connect servos)
Working voltage: 2.3V-3.6V
Working current: about 160mA
Size: 64.57mm x 23.98mm
<k>Power supply specifications:</k> 
Power Supply USB 5V/1A
Charging current 1A
Battery 3.7V lithium battery
<k>Read our in-depth review: </k><a href="https://makeradvisor.com/ttgo-t-journal-esp32-camera-board-review/" target="_blank" aria-label="TTGO T-Journal ESP32 Camera Development Board (opens in a new tab)">TTGO T-Journal ESP32 Camera Development Board</a>
<h3>TTGO T-Journal ESP32 Board Pinout</h3>
Having the right pinout for your camera board is very important. If you don't assign the right camera pins in your code, the camera will not work. The following image shows the TTGO T-Journal ESP32 board pinout.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/TTGOcam-pinout.jpg"><figcaption><center><a href="https://github.com/LilyGO/ESP32-Camera" target="_blank" aria-label="Image Source (opens in a new tab)">Image Source</a></center></figcaption>
<h3> TTGO T-Journal ESP32 Camera Connections</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/TTGO-T-Journal-Camera-OV2640.jpg">
Here's a table with the connections between the ESP32 and the camera:
<table><tbody>
<tr>
<td><k>OV2640 Camera</k></td>
<td><k>ESP32</k></td>
</tr>
<tr>
<td>D2</td>
<td>GPIO 17</td>
</tr>
<tr>
<td>D3</td>
<td>GPIO 35</td>
</tr>
<tr>
<td>D4</td>
<td>GPIO 34</td>
</tr>
<tr>
<td>D5</td>
<td>GPIO 5</td>
</tr>
<tr>
<td>D6</td>
<td>GPIO 39</td>
</tr>
<tr>
<td>D7</td>
<td>GPIO 18</td>
</tr>
<tr>
<td>D8</td>
<td>GPIO 36</td>
</tr>
<tr>
<td>D9</td>
<td>GPIO 19</td>
</tr>
<tr>
<td>SIOC</td>
<td>GPIO 23</td>
</tr>
<tr>
<td>SIOD</td>
<td>GPIO 25</td>
</tr>
<tr>
<td>XCLK</td>
<td>GPIO 27</td>
</tr>
<tr>
<td>VSYNC</td>
<td>GPIO 22</td>
</tr>
<tr>
<td>HREF</td>
<td>GPIO 26</td>
</tr>
<tr>
<td>PCLK</td>
<td>GPIO 21</td>
</tr>
<tr>
<td>RST</td>
<td>GPIO 15</td>
</tr>
<tr>
<td>PWDN</td>
<td>GPIO 0</td>
</tr>
</tbody></table>So, the pin assignment in your Arduino sketch should be as follows:
<k>#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM     27
#define SIOD_GPIO_NUM     25
#define SIOC_GPIO_NUM     23
#define Y9_GPIO_NUM       19
#define Y8_GPIO_NUM       36
#define Y7_GPIO_NUM       18
#define Y6_GPIO_NUM       39
#define Y5_GPIO_NUM       5
#define Y4_GPIO_NUM       34
#define Y3_GPIO_NUM       35
#define Y2_GPIO_NUM       17
#define VSYNC_GPIO_NUM    22
#define HREF_GPIO_NUM     26
#define PCLK_GPIO_NUM     21</k>
Because this board uses the same camera used in the <a href="https://randomnerdtutorials.com/esp32-cam-video-streaming-face-recognition-arduino-ide/">ESP32-CAM board</a>, the <a href="https://randomnerdtutorials.com/category/ESP32-CAM/">examples for the ESP32-CAM </a>(that don't use microSD card) should also work with the TTGO T-Journal by changing the pin definition. We'll show you a couple of examples in a moment.
<h3>TTGO T-Journal ESP32 Board OLED Connections</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/TTGO-T-Journal-ESP32-CAM-OLED-display.jpg">
This board comes with an I2C SSD1306 0.91 inch OLED display. To interact with the display you can use the <a aria-label="Adafruit SSD1306 (opens in a new tab)" href="https://github.com/adafruit/Adafruit_SSD1306" target="_blank">Adafruit SSD1306</a>, the <a aria-label="oled-ssd1306 (opens in a new tab)" href="https://github.com/ThingPulse/esp8266-oled-ssd1306" target="_blank">oled-ssd1306</a> or other compatible libraries. We usually use the Adafruit SSD1306 along with the <a aria-label="Adafruit_GFX (opens in a new tab)" href="https://github.com/adafruit/Adafruit-GFX-Library" target="_blank">Adafruit_GFX</a> to interact with OLED displays. 
The OLED communicates with the ESP32 using the following pins:
<table><tbody>
<tr>
<td><k>OLED</k></td>
<td><k>ESP32</k></td>
</tr>
<tr>
<td>SDA</td>
<td>GPIO 14</td>
</tr>
<tr>
<td>SCL</td>
<td>GPIO 13</td>
</tr>
</tbody></table><h3>TTGO T-Journal ESP32 Board Control OLED Display</h3>
In this section, well show you quick tips on how to control the OLED display of the TTGO T-Journal ESP32 board.
<h3>Installing Libraries</h3>
To control the OLED display, we'll use the <a aria-label="Adafruit SSD1306 (opens in a new tab)" href="https://github.com/adafruit/Adafruit_SSD1306" target="_blank">Adafruit SSD1306</a> and <a aria-label="Adafruit GFX (opens in a new tab)" href="https://github.com/adafruit/Adafruit-GFX-Library" target="_blank">Adafruit GFX</a> libraries. These libraries can be installed through the Arduino IDE Library Manager.
In your Arduino IDE, go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k>. Then, search for the library name and install it.
<h3>OLED I2C Pins and Display Size</h3>
Controlling this OLED display is similar to control a regular 0.96 OLED display connected to an ESP32. The only difference is the way you initialize the display.
You need to take into account the I2C pins used by this display (because it doesn't use the default I2C pins), and the size of the display.
<k>I2C pins:</k>
SDA (GPIO 14)
SCL (GPIO 13)
<k>Display size:</k>
Width: 128 px
Height: 32 px
<h3>Arduino Sketch</h3>
To control the OLED display, first, you need to import the required libraries:
<k>#include &lt;Wire.h>
#include &lt;Adafruit_GFX.h>
#include &lt;Adafruit_SSD1306.h></k>
 Define the OLED size:
<k>#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 32</k>
Define the I2C pins:
<k>#define I2C_SDA 14
#define I2C_SCL 13</k>
Next create an Adafruit_SSD1306 object called display as follows:
<k>Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);</k>
In the setup(), you need to initialize an I2C communication on the I2C pins you've defined earlier as follows:
<k>Wire.begin(I2C_SDA, I2C_SCL);</k>
Then, initialize the OLED display as follows:
<k>if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C, false, false)) {
  Serial.println(F("SSD1306 allocation failed"));
  for(;;);
}</k>
After properly initializing the display, you can use the usual functions to write text and display shapes on the OLED. Read our <a href="https://randomnerdtutorials.com/esp32-ssd1306-oled-display-arduino-ide/">OLED tutorial with the ESP32</a> to learn more on how to interact with the OLED display.
For testing purposes, you can upload the following code to your board. It simply displays Hello World.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/ttgo-t-journal-esp32-camera-getting-started/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;Wire.h>
#include &lt;Adafruit_GFX.h>
#include &lt;Adafruit_SSD1306.h>
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 32
#define I2C_SDA 14
#define I2C_SCL 13
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);
void setup() {
  
  Wire.begin(I2C_SDA, I2C_SCL);
  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C, false, false)) {
    Serial.println(F("SSD1306 allocation failed"));
    for(;;);
  }
  
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(WHITE);
  display.setCursor(0, 0);
  display.print("Hello World!");;
  display.display();
}
void loop() {
  // put your main code here, to run repeatedly:
}
</k>
<a href="https://github.com/RuiSantosdotme/ESP32-CAM-Arduino-IDE/raw/master/TTGO-T-Journal-ESP32-Camera/TTGO-T-Journal-ESP32-Camera-OLED-Hello-World.ino" target="_blank">View raw code</a>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP32-TTGO-T-Journal-Hello-World-OLED.jpg">
<h3>TTGO T-Journal ESP32 Camera Projects</h3>
We've modified some of our existing <a href="https://randomnerdtutorials.com/category/ESP32-CAM/">ESP32-CAM projects</a> to be compatible with the TTGO T-Journal. 
<h3>Video Streaming Web Server</h3>
The following code creates a video streaming web server on the camera IP address. So, you can create an IP CAM that can be integrated in Home Automation platforms like Home Assistant or Node-RED.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/ttgo-t-journal-esp32-camera-getting-started/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include "esp_camera.h"
#include &lt;WiFi.h>
#include "esp_timer.h"
#include "img_converters.h"
#include "Arduino.h"
#include "fb_gfx.h"
#include "soc/soc.h" //disable brownout problems
#include "soc/rtc_cntl_reg.h"  //disable brownout problems
#include "esp_http_server.h"
#include &lt;Wire.h>
#include &lt;Adafruit_GFX.h>
#include &lt;Adafruit_SSD1306.h>
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 32
#define I2C_SDA 14
#define I2C_SCL 13
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);
//Replace with your network credentials
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
#define PART_BOUNDARY "123456789000000000000987654321"
// OV2640 camera module pins (CAMERA_MODEL_TTGO-T-Journal)
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM     27
#define SIOD_GPIO_NUM     25
#define SIOC_GPIO_NUM     23
#define Y9_GPIO_NUM       19
#define Y8_GPIO_NUM       36
#define Y7_GPIO_NUM       18
#define Y6_GPIO_NUM       39
#define Y5_GPIO_NUM       5
#define Y4_GPIO_NUM       34
#define Y3_GPIO_NUM       35
#define Y2_GPIO_NUM       17
#define VSYNC_GPIO_NUM    22
#define HREF_GPIO_NUM     26
#define PCLK_GPIO_NUM     21
static const char* _STREAM_CONTENT_TYPE = "multipart/x-mixed-replace;boundary=" PART_BOUNDARY;
static const char* _STREAM_BOUNDARY = "\r\n--" PART_BOUNDARY "\r\n";
static const char* _STREAM_PART = "Content-Type: image/jpeg\r\nContent-Length: %u\r\n\r\n";
httpd_handle_t stream_httpd = NULL;
static esp_err_t stream_handler(httpd_req_t *req){
  camera_fb_t * fb = NULL;
  esp_err_t res = ESP_OK;
  size_t _jpg_buf_len = 0;
  uint8_t * _jpg_buf = NULL;
  char * part_buf[64];
  res = httpd_resp_set_type(req, _STREAM_CONTENT_TYPE);
  if(res != ESP_OK){
    return res;
  }
  while(true){
    fb = esp_camera_fb_get();
    if (!fb) {
      Serial.println("Camera capture failed");
      res = ESP_FAIL;
    } else {
      if(fb->width > 400){
        if(fb->format != PIXFORMAT_JPEG){
          bool jpeg_converted = frame2jpg(fb, 80, &_jpg_buf, &_jpg_buf_len);
          esp_camera_fb_return(fb);
          fb = NULL;
          if(!jpeg_converted){
            Serial.println("JPEG compression failed");
            res = ESP_FAIL;
          }
        } else {
          _jpg_buf_len = fb->len;
          _jpg_buf = fb->buf;
        }
      }
    }
    if(res == ESP_OK){
      size_t hlen = snprintf((char *)part_buf, 64, _STREAM_PART, _jpg_buf_len);
      res = httpd_resp_send_chunk(req, (const char *)part_buf, hlen);
    }
    if(res == ESP_OK){
      res = httpd_resp_send_chunk(req, (const char *)_jpg_buf, _jpg_buf_len);
    }
    if(res == ESP_OK){
      res = httpd_resp_send_chunk(req, _STREAM_BOUNDARY, strlen(_STREAM_BOUNDARY));
    }
    if(fb){
      esp_camera_fb_return(fb);
      fb = NULL;
      _jpg_buf = NULL;
    } else if(_jpg_buf){
      free(_jpg_buf);
      _jpg_buf = NULL;
    }
    if(res != ESP_OK){
      break;
    }
    //Serial.printf("MJPG: %uB\n",(uint32_t)(_jpg_buf_len));
  }
  return res;
}
void startCameraServer(){
  httpd_config_t config = HTTPD_DEFAULT_CONFIG();
  config.server_port = 80;
  httpd_uri_t index_uri = {
    .uri       = "/",
    .method    = HTTP_GET,
    .handler   = stream_handler,
    .user_ctx  = NULL
  };
  
  //Serial.printf("Starting web server on port: '%d'\n", config.server_port);
  if (httpd_start(&stream_httpd, &config) == ESP_OK) {
    httpd_register_uri_handler(stream_httpd, &index_uri);
  }
}
void setup() {
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0); //disable brownout detector
 
  Serial.begin(115200);
  Serial.setDebugOutput(false);
  
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM;
  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;
  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;
  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;
  config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk = XCLK_GPIO_NUM;
  config.pin_pclk = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM;
  config.pin_href = HREF_GPIO_NUM;
  config.pin_sscb_sda = SIOD_GPIO_NUM;
  config.pin_sscb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn = PWDN_GPIO_NUM;
  config.pin_reset = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG; 
  
  if(psramFound()){
    config.frame_size = FRAMESIZE_UXGA;
    config.jpeg_quality = 10;
    config.fb_count = 2;
  } else {
    config.frame_size = FRAMESIZE_SVGA;
    config.jpeg_quality = 12;
    config.fb_count = 1;
  }
  
  // Camera init
  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed with error 0x%x", err);
    return;
  }
  // Wi-Fi connection
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.println("WiFi connected");
  
  Serial.print("Camera Stream Ready! Go to: http://");
  Serial.print(WiFi.localIP());
  // Init OLED
  Wire.begin(I2C_SDA, I2C_SCL);
  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C, false, false)) {
    Serial.println(F("SSD1306 allocation failed"));
    for(;;);
  }
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(WHITE);
  display.setCursor(5, 5);
  display.print(WiFi.localIP());;
  display.display();
  
  // Start streaming web server
  startCameraServer();
}
void loop() {
  delay(1);
}
</k>
<a href="https://github.com/RuiSantosdotme/ESP32-CAM-Arduino-IDE/raw/master/TTGO-T-Journal-ESP32-Camera/TTGO-T-Journal-ESP32-Camera-Video-Streaming-Web-Server.ino" target="_blank">View raw code</a>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/03/main-entrance-home-assistant-esp32-cam.jpg">
Learn more about this project: <a href="https://randomnerdtutorials.com/esp32-cam-video-streaming-web-server-camera-home-assistant/">ESP32-CAM Video Streaming Web Server </a>
<h3>Take Photo and Display in Web Server</h3>
The following code creates a web server that you can access to take and display photos. The web server IP address is displayed on the OLED.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/ttgo-t-journal-esp32-camera-getting-started/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include "WiFi.h"
#include "esp_camera.h"
#include "esp_timer.h"
#include "img_converters.h"
#include "Arduino.h"
#include "soc/soc.h"           // Disable brownour problems
#include "soc/rtc_cntl_reg.h"  // Disable brownour problems
#include "driver/rtc_io.h"
#include &lt;ESPAsyncWebServer.h>
#include &lt;StringArray.h>
#include &lt;SPIFFS.h>
#include &lt;FS.h>
#include &lt;Wire.h>
#include &lt;Adafruit_GFX.h>
#include &lt;Adafruit_SSD1306.h>
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 32
#define I2C_SDA 14
#define I2C_SCL 13
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);
// Replace with your network credentials
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
// Create AsyncWebServer object on port 80
AsyncWebServer server(80);
boolean takeNewPhoto = false;
// Photo File Name to save in SPIFFS
#define FILE_PHOTO "/photo.jpg"
// OV2640 camera module pins (CAMERA_MODEL_TTGO-T-Journal)
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM     27
#define SIOD_GPIO_NUM     25
#define SIOC_GPIO_NUM     23
#define Y9_GPIO_NUM       19
#define Y8_GPIO_NUM       36
#define Y7_GPIO_NUM       18
#define Y6_GPIO_NUM       39
#define Y5_GPIO_NUM       5
#define Y4_GPIO_NUM       34
#define Y3_GPIO_NUM       35
#define Y2_GPIO_NUM       17
#define VSYNC_GPIO_NUM    22
#define HREF_GPIO_NUM     26
#define PCLK_GPIO_NUM     21
const char index_html[] PROGMEM = R"rawliteral(
&lt;!DOCTYPE HTML>&lt;html>
&lt;head>
  &lt;meta name="viewport" content="width=device-width, initial-scale=1">
  &lt;style>
    body { text-align:center; }
    .vert { margin-bottom: 10%; }
    .hori{ margin-bottom: 0%; }
  &lt;/style>
&lt;/head>
&lt;body>
  &lt;div>
    &lt;h2>ESP32-CAM Last Photo&lt;/h2>
    &lt;p>It might take more than 5 seconds to capture a photo.&lt;/p>
    &lt;p>
      &lt;button onclick="rotatePhoto();">ROTATE&lt;/button>
      &lt;button onclick="capturePhoto()">CAPTURE PHOTO&lt;/button>
      &lt;button onclick="location.reload();">REFRESH PAGE&lt;/button>
    &lt;/p>
  &lt;/div>
  &lt;div>&lt;img src="saved-photo" width="70%">&lt;/div>
&lt;/body>
&lt;script>
  var deg = 0;
  function capturePhoto() {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', "/capture", true);
    xhr.send();
  }
  function rotatePhoto() {
    var img = document.getElementById("photo");
    deg += 90;
    if(isOdd(deg/90)){ document.getElementById("container").className = "vert"; }
    else{ document.getElementById("container").className = "hori"; }
    img.style.transform = "rotate(" + deg + "deg)";
  }
  function isOdd(n) { return Math.abs(n % 2) == 1; }
&lt;/script>
&lt;/html>)rawliteral";
void setup() {
  // Serial port for debugging purposes
  Serial.begin(115200);
  // Connect to Wi-Fi
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi...");
  }
  if (!SPIFFS.begin(true)) {
    Serial.println("An Error has occurred while mounting SPIFFS");
    ESP.restart();
  }
  else {
    delay(500);
    Serial.println("SPIFFS mounted successfully");
  }
  // Print ESP32 Local IP Address
  Serial.print("IP Address: http://");
  Serial.println(WiFi.localIP());
  // Init OLED
  Wire.begin(I2C_SDA, I2C_SCL);
  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C, false, false)) {
    Serial.println(F("SSD1306 allocation failed"));
    for(;;);
  }
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(WHITE);
  display.setCursor(5, 5);
  display.print(WiFi.localIP());;
  display.display();
  // Turn-off the 'brownout detector'
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0);
  // OV2640 camera module
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM;
  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;
  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;
  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;
  config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk = XCLK_GPIO_NUM;
  config.pin_pclk = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM;
  config.pin_href = HREF_GPIO_NUM;
  config.pin_sscb_sda = SIOD_GPIO_NUM;
  config.pin_sscb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn = PWDN_GPIO_NUM;
  config.pin_reset = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG;
  if (psramFound()) {
    config.frame_size = FRAMESIZE_UXGA;
    config.jpeg_quality = 10;
    config.fb_count = 2;
  } else {
    config.frame_size = FRAMESIZE_SVGA;
    config.jpeg_quality = 12;
    config.fb_count = 1;
  }
  // Camera init
  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed with error 0x%x", err);
    ESP.restart();
  }
  // Route for root / web page
  server.on("/", HTTP_GET, [](AsyncWebServerRequest * request) {
    request->send_P(200, "text/html", index_html);
  });
  server.on("/capture", HTTP_GET, [](AsyncWebServerRequest * request) {
    takeNewPhoto = true;
    request->send_P(200, "text/plain", "Taking Photo");
  });
  server.on("/saved-photo", HTTP_GET, [](AsyncWebServerRequest * request) {
    request->send(SPIFFS, FILE_PHOTO, "image/jpg", false);
  });
  // Start server
  server.begin();
}
void loop() {
  if (takeNewPhoto) {
    capturePhotoSaveSpiffs();
    takeNewPhoto = false;
  }
  delay(1);
}
// Check if photo capture was successful
bool checkPhoto( fs::FS &fs ) {
  File f_pic = fs.open( FILE_PHOTO );
  unsigned int pic_sz = f_pic.size();
  return ( pic_sz > 100 );
}
// Capture Photo and Save it to SPIFFS
void capturePhotoSaveSpiffs( void ) {
  camera_fb_t * fb = NULL; // pointer
  bool ok = 0; // Boolean indicating if the picture has been taken correctly
  do {
    // Take a photo with the camera
    Serial.println("Taking a photo...");
    fb = esp_camera_fb_get();
    if (!fb) {
      Serial.println("Camera capture failed");
      return;
    }
    // Photo file name
    Serial.printf("Picture file name: %s\n", FILE_PHOTO);
    File file = SPIFFS.open(FILE_PHOTO, FILE_WRITE);
    // Insert the data in the photo file
    if (!file) {
      Serial.println("Failed to open file in writing mode");
    }
    else {
      file.write(fb->buf, fb->len); // payload (image), payload length
      Serial.print("The picture has been saved in ");
      Serial.print(FILE_PHOTO);
      Serial.print(" - Size: ");
      Serial.print(file.size());
      Serial.println(" bytes");
    }
    // Close the file
    file.close();
    esp_camera_fb_return(fb);
    // check if file has been correctly saved in SPIFFS
    ok = checkPhoto(SPIFFS);
  } while ( !ok );
}
</k>
<a href="https://github.com/RuiSantosdotme/ESP32-CAM-Arduino-IDE/raw/master/TTGO-T-Journal-ESP32-Camera/TTGO-T-Journal-ESP32-Camera-Take-Photo-Web-Server.ino" target="_blank">View raw code</a>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/10/ESP32-CAM-Web-Server-Display-Last-Photo-Captured.jpg">
Learn more about this project: <a href="https://randomnerdtutorials.com/esp32-cam-take-photo-display-web-server/">ESP32-CAM Take Photo and Display in Web Server</a>
<h3>CameraWebServer Example</h3>
You can also run the default CameraWebServer example that comes with the Arduino IDE.  In your Arduino IDE, go to <k>File </k>> <k>Examples </k>> <k>ESP32 </k>> <k>Camera </k>and open the <k>CameraWebServer</k> example.
You can click the next link to download the .zip with the final code:
<a href="https://github.com/RuiSantosdotme/ESP32-CAM-Arduino-IDE/raw/master/TTGO-T-Journal-ESP32-Camera/CameraWebServer.zip" target="_blank" aria-label=" (opens in a new tab)"><k>Download our CameraWebServer Example for the TTGO T-Journal Board </k></a>
Otherwise, you need to add the TTGO T-Journal pinout to the <em>camera_pins.h</em> tab. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/Add-T-Journal-Camera-pins.jpg">
Copy the following to the camera_pins.h file.
<k>#if defined(CAMERA_MODEL_T_JOURNAL)
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM     27
#define SIOD_GPIO_NUM     25
#define SIOC_GPIO_NUM     23
#define Y9_GPIO_NUM       19
#define Y8_GPIO_NUM       36
#define Y7_GPIO_NUM       18
#define Y6_GPIO_NUM       39
#define Y5_GPIO_NUM       5
#define Y4_GPIO_NUM       34
#define Y3_GPIO_NUM       35
#define Y2_GPIO_NUM       17
#define VSYNC_GPIO_NUM    22
#define HREF_GPIO_NUM     26
#define PCLK_GPIO_NUM     21</k>
Then, in the CameraWebServer tab, comment all the existing camera models, and add your camera, as follows:
<k>// Select camera model
#define CAMERA_MODEL_T_JOURNAL
//#define CAMERA_MODEL_WROVER_KIT
//#define CAMERA_MODEL_ESP_EYE
//#define CAMERA_MODEL_M5STACK_PSRAM
//#define CAMERA_MODEL_M5STACK_WIDE
//#define CAMERA_MODEL_AI_THINKER</k>
Because this camera doesn't have PSRAM, the face recognition and detection features of this project don't work with this camera. All the other functionalities work well. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/03/ESP32-CAM-video-streaming-example.jpg">
<h3>Upload Code to the TTGO T-Journal ESP32 Camera</h3>
To upload code, you just need to connect the board to your computer, then in the Arduino IDE, go to <k>Tools </k>> <k>Port </k>and select the COM port it is connected to.
Then, you also need to select a Board model. The TTGO T-Journal is not available on the ESP32 models. So, select the following settings:
<k>Board:</k> ESP32 Wrover Module
<k>Partition Scheme:</k> Huge APP (3MB No OTA)
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/03/upload-code-esp32-cam.png">
Then, simply click the Arduino IDE upload button and it is done!
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/upload-button-arduino-ide.png">
<a href="https://randomnerdtutorials.com/esp32-cam-projects-ebook/">
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-eBook-334.jpg?fit=334%2C334&quality=100&strip=all&ssl=1" alt="" srcset="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-eBook-334.jpg?w=334&quality=100&strip=all&ssl=1 334w, https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/ESP32-CAM-eBook-334.jpg"></a>
<h3>Wrapping Up</h3>
This tutorial was a quick getting started guide for the TTGO T-Journal ESP32 Camera Development board. You've learned how to control the OLED display and how to adapt existing ESP32 camera projects to your board.
We hope you've found this tutorial useful. To learn more about this board, you can read our complete overview on Maker Advisor as well as our ESP32-CAM development boards comparison post:
<a href="https://makeradvisor.com/ttgo-t-journal-esp32-camera-board-review/" target="_blank">TTGO T-Journal ESP32 Camera Board Review and Documentation (Pinout, Features, etc)</a>
<a href="https://makeradvisor.com/esp32-camera-cam-boards-review-comparison/" target="_blank" aria-label="ESP32 Camera Dev Boards Review and Comparison (Best ESP32-CAM) (opens in a new tab)">ESP32 Camera Dev Boards Review and Comparison (Best ESP32-CAM)</a>
You may also be interested in other ESP32 development boards:
<a aria-label="$7 ESP32-CAM with OV2640 Camera (Review)<U+2028> (opens in a new tab)" href="https://makeradvisor.com/esp32-cam-ov2640-camera/" target="_blank">$7 ESP32-CAM with OV2640 Camera (Review)</a>
<a aria-label="ESP32 with Built-in SX1276 LoRa and SSD1306 OLED Display (Review)<U+2028> (opens in a new tab)" href="https://makeradvisor.com/esp32-sx1276-lora-ssd1306-oled/" target="_blank">ESP32 with Built-in SX1276 LoRa and SSD1306 OLED Display (Review)</a>
<a aria-label="$11 TTGO T-Call ESP32 with SIM800L GSM/GPRS (Overview) (opens in a new tab)" href="https://makeradvisor.com/ttgo-t-call-esp32-with-sim800l-gsm-gprs/" target="_blank">$11 TTGO T-Call ESP32 with SIM800L GSM/GPRS (Overview)</a>
<a aria-label="10 IoT Development Boards You Need to Get (opens in a new tab)" href="https://makeradvisor.com/10-iot-development-boards/" target="_blank">10 IoT Development Boards You Need to Get</a>
<a aria-label="Best ESP32 Development Boards (opens in a new tab)" href="https://makeradvisor.com/esp32-development-boards-review-comparison/" target="_blank">Best ESP32 Development Boards</a>
<a href="https://randomnerdtutorials.com/esp32-cam-projects-ebook/"><k>Build ESP32-CAM Projects (eBook)</k></a>
<a href="https://randomnerdtutorials.com/projects-esp32-cam/"><k>Read all our ESP32-CAM Projects, Tutorials and Guides</k></a>
Thanks for reading.
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h-p2lw6wwnkk9ystvwe9iof8zx6yt4x7uma3cqfup534.jpg" title="Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h" alt="Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h" loading="lazy" width="129" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/">[eBook] Build Web Servers with ESP32 and ESP8266 (2nd Edition)</a></h4>
Build Web Server projects with the ESP32 and ESP8266 boards to control outputs and monitor sensors remotely. Learn HTML, CSS, JavaScript and client-server communication protocols <k><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Build Web Server projects with the ESP32 and ESP8266 boards to control outputs and monitor sensors remotely. Learn HTML, CSS, JavaScript and client-server communication protocols <k><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>ESP32 Client-Server Wi-Fi Communication Between Two Boards</h2>
This guide shows how to setup an HTTP communication between two ESP32 boards to exchange data via Wi-Fi without an internet connection (router). In simple words, you'll learn how to send data from one board to the other using HTTP requests. The ESP32 boards will be programmed using Arduino IDE.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP32-Client-Server-Wi-Fi-Communication-Between-Two-Boards.jpg">
For demonstration purposes, we'll send <a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/">BME280 sensor readings</a> from one board to the other. The receiver will <a href="https://randomnerdtutorials.com/esp32-esp8266-dht-temperature-and-humidity-oled-display/">display the readings on an OLED display</a>.
If you have an ESP8266 board, you can read this dedicated guide: <a href="https://randomnerdtutorials.com/esp8266-nodemcu-client-server-wi-fi/">ESP8266 NodeMCU Client-Server Wi-Fi Communication</a>.
<h3>Watch the Video Demonstration</h3>
To see how the project works, you can watch the following video demonstration:

<h3>Project Overview</h3>
One ESP32 board will act as a server and the other ESP32 board will act as a client. The following diagram shows an overview of how everything works.
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP32-Server-Client-HTTP-GET-Communication.jpg?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP32-Server-Client-HTTP-GET-Communication.jpg"></a>
The ESP32 server creates its own wireless network (<a href="https://randomnerdtutorials.com/esp32-access-point-ap-web-server/">ESP32 Soft-Access Point</a>). So, other Wi-Fi devices can connect to that network (<k>SSID:</k> ESP32-Access-Point, <k>Password:</k> 123456789).
The ESP32 client is set as a station. So, it can connect to the ESP32 server wireless network.
The client can make HTTP GET requests to the server to request sensor data or any other information. It just needs to use the IP address of the server to make a request on a certain route: /temperature, /humidity or /pressure.
The server listens for incoming requests and sends an appropriate response with the readings.
The client receives the readings and displays them on the OLED display.
As an example, the ESP32 client requests temperature, humidity and pressure to the server by making requests on the server IP address followed by /temperature, /humidity and /pressure, respectively. 
The ESP32 server is listening on those routes and when a request is made, it sends the corresponding sensor readings via HTTP response.
<h3>Parts Required</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP32-Client-Server-Interaction-Sensor-Readings.jpg">
For this tutorial, you need the following parts:
<a aria-label="ESP32 Development boards (opens in a new tab)" href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">2x ESP32 Development boards</a>  read <a aria-label="Best ESP32 Boards Review (opens in a new tab)" href="https://makeradvisor.com/esp32-development-boards-review-comparison/" target="_blank">Best ESP32 Boards Review</a>
<a aria-label="BME280 sensor<U+2028> (opens in a new tab)" href="https://makeradvisor.com/tools/bme280-sensor-module/" target="_blank">BME280 sensor</a>
<a aria-label="I2C SSD1306 OLED display<U+2028> (opens in a new tab)" href="https://makeradvisor.com/tools/oled-display-128x64-0-96-inch/" target="_blank">I2C SSD1306 OLED display</a>
<a aria-label="Jumper Wires<U+2028> (opens in a new tab)" href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper Wires</a>
<a aria-label="Breaboard (opens in a new tab)" href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breaboard</a>
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="eager" fetchpriority="high" decoding="async"></a>
<h3>Installing Libraries</h3>
For this tutorial you need to install the following libraries:
<h3>Asynchronous Web Server Libraries</h3>
We'll use the following libraries to handle HTTP request:
<a href="https://github.com/me-no-dev/ESPAsyncWebServer" target="_blank">ESPAsyncWebServer </a>library (<a href="https://github.com/me-no-dev/ESPAsyncWebServer/archive/master.zip" target="_blank">download ESPAsyncWebServer library</a>)
<a href="https://github.com/me-no-dev/AsyncTCP" target="_blank">Async TCP</a> library (<a href="https://github.com/me-no-dev/AsyncTCP/archive/master.zip" target="_blank">download AsyncTCP library</a>)
These libraries are not available to install through the Library Manager. So, you need to unzip the libraries and move them to the Arduino IDE installation libraries folder.
Alternatively, you can go to <k>Sketch </k>> <k>Include Library</k> > <k>Add .ZIP library</k> and select the libraries you've just downloaded.
You may also like: <a aria-label="Build an Asynchronous Web Server with the ESP32 (opens in a new tab)" href="https://randomnerdtutorials.com/esp32-dht11-dht22-temperature-humidity-web-server-arduino-ide/" target="_blank">Build an Asynchronous Web Server with the ESP32</a>
<h3>BME280 Libraries</h3>
The following libraries can be installed through the Arduino Library Manager. Go to <k>Sketch </k>> <k>Include Library</k>> <k>Manage Libraries</k> and search for the library name.
<a href="https://github.com/adafruit/Adafruit_BME280_Library" target="_blank">Adafruit_BME280 library</a>
<a href="https://github.com/adafruit/Adafruit_Sensor" target="_blank">Adafruit unified sensor library</a>
You may also like: <a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/">Interface BME280 with ESP32 (Guide)</a>
<h3>I2C SSD1306 OLED Libraries</h3>
To interface with the OLED display you need the following libraries. These can be installed through the Arduino Library Manager. Go to <k>Sketch </k>> <k>Include Library</k>> <k>Manage Libraries</k> and search for the library name.
<a href="https://github.com/adafruit/Adafruit_SSD1306" target="_blank" aria-label="Adafruit SSD1306<U+2028> (opens in a new tab)">Adafruit SSD1306</a>
<a href="https://github.com/adafruit/Adafruit-GFX-Library" target="_blank" aria-label=" (opens in a new tab)">Adafruit GFX Library</a>
You may also like: <a href="https://randomnerdtutorials.com/esp32-ssd1306-oled-display-arduino-ide/">I2C SSD1306 OLED Display with ESP32 (Guide)</a>
<h3>#1 ESP32 Server (Access Point)</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP32-Server-BME-280.jpg">
The ESP32 server is an <a href="https://randomnerdtutorials.com/esp32-access-point-ap-web-server/">Access Point (AP)</a>, that listens for requests on the /temperature, /humidity and /pressure URLs. When it gets requests on those URLs, it sends the latest BME280 sensor readings. 
For demonstration purposes, we're using a BME280 sensor, but you can use any other sensor by modifying a few lines of code.
<h3>Schematic Diagram</h3>
Wire the <a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/">ESP32 to the BME280 sensor</a> as shown in the following schematic diagram. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/06/ESP32-bme280_schematic.jpg">
<table><tbody>
<tr>
<td><k>BME280</k></td>
<td><k>ESP32</k></td>
</tr>
<tr>
<td>VIN/VCC</td>
<td>3.3V</td>
</tr>
<tr>
<td>GND</td>
<td>GND</td>
</tr>
<tr>
<td>SCL</td>
<td>GPIO 22</td>
</tr>
<tr>
<td>SDA</td>
<td>GPIO 21</td>
</tr>
</tbody></table><h3>Arduino Sketch for #1 ESP32 Server</h3>
Upload the following code to your board.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-client-server-wi-fi/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
// Import required libraries
#include "WiFi.h"
#include "ESPAsyncWebServer.h"
#include &lt;Wire.h>
#include &lt;Adafruit_Sensor.h>
#include &lt;Adafruit_BME280.h>
// Set your access point network credentials
const char* ssid = "ESP32-Access-Point";
const char* password = "123456789";
/*#include &lt;SPI.h>
#define BME_SCK 18
#define BME_MISO 19
#define BME_MOSI 23
#define BME_CS 5*/
Adafruit_BME280 bme; // I2C
//Adafruit_BME280 bme(BME_CS); // hardware SPI
//Adafruit_BME280 bme(BME_CS, BME_MOSI, BME_MISO, BME_SCK); // software SPI
// Create AsyncWebServer object on port 80
AsyncWebServer server(80);
String readTemp() {
  return String(bme.readTemperature());
  //return String(1.8 * bme.readTemperature() + 32);
}
String readHumi() {
  return String(bme.readHumidity());
}
String readPres() {
  return String(bme.readPressure() / 100.0F);
}
void setup(){
  // Serial port for debugging purposes
  Serial.begin(115200);
  Serial.println();
  
  // Setting the ESP as an access point
  Serial.print("Setting AP (Access Point)");
  // Remove the password parameter, if you want the AP (Access Point) to be open
  WiFi.softAP(ssid, password);
  IPAddress IP = WiFi.softAPIP();
  Serial.print("AP IP address: ");
  Serial.println(IP);
  server.on("/temperature", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send_P(200, "text/plain", readTemp().c_str());
  });
  server.on("/humidity", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send_P(200, "text/plain", readHumi().c_str());
  });
  server.on("/pressure", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send_P(200, "text/plain", readPres().c_str());
  });
  
  bool status;
  // default settings
  // (you can also pass in a Wire library object like &Wire2)
  status = bme.begin(0x76);  
  if (!status) {
    Serial.println("Could not find a valid BME280 sensor, check wiring!");
    while (1);
  }
  
  // Start server
  server.begin();
}
 
void loop(){
  
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_Client_Server/ESP_Server_Access_Point_AP_BME280.ino" target="_blank">View raw code</a>
<h3>How the code works</h3>
Start by including the necessary libraries. Include the WiFi.h library and the ESPAsyncWebServer.h library to handle incoming HTTP requests.
<k>#include "WiFi.h"
#include "ESPAsyncWebServer.h"</k>
Include the following libraries to interface with the BME280 sensor.
<k>#include &lt;Wire.h>
#include &lt;Adafruit_Sensor.h>
#include &lt;Adafruit_BME280.h></k>
In the following variables, define your access point network credentials:
<k>const char* ssid = "ESP32-Access-Point";
const char* password = "123456789";</k>
We're setting the SSID to ESP32-Access-Point, but you can give it any other name. You can also change the password. By default, its set to 123456789.
Create an instance for the BME280 sensor called bme.
<k>Adafruit_BME280 bme;</k>
Create an asynchronous web server on port 80.
<k>AsyncWebServer server(80);</k>
Then, create three functions that return the temperature, humidity, and pressure as String variables.
<k>String readTemp() {
  return String(bme.readTemperature());
  //return String(1.8 * bme.readTemperature() + 32);
}
String readHumi() {
  return String(bme.readHumidity());
}
String readPres() {
  return String(bme.readPressure() / 100.0F);
}</k>
In the setup(), initialize the Serial Monitor for demonstration purposes.
<k>Serial.begin(115200);</k>
Set your ESP32 as an access point with the SSID name and password defined earlier.
<k>WiFi.softAP(ssid, password);</k>
Then, handle the routes where the ESP32 will be listening for incoming requests.
For example, when the ESP32 server receives a request on the /temperature URL, it sends the temperature returned by the readTemp() function as a char (that's why we use the c_str() method.
<k>server.on("/temperature", HTTP_GET, [](AsyncWebServerRequest *request){
  request->send_P(200, "text/plain", readTemp().c_str());
});</k>
The same happens when the ESP receives a request on the /humidity and /pressure URLs.
<k>server.on("/humidity", HTTP_GET, [](AsyncWebServerRequest *request){
  request->send_P(200, "text/plain", readHumi().c_str());
});
server.on("/pressure", HTTP_GET, [](AsyncWebServerRequest *request){
  request->send_P(200, "text/plain", readPres().c_str());
});</k>
The following lines initialize the BME280 sensor.
<k>bool status;
// default settings
// (you can also pass in a Wire library object like &Wire2)
status = bme.begin(0x76);
if (!status) {
  Serial.println("Could not find a valid BME280 sensor, check wiring!");
  while (1);
}</k>
Finally, start the server.
<k>server.begin();</k>
Because this is an asynchronous web server, there's nothing in the loop().
<k>void loop(){
}</k>
<h3>Testing the ESP32 Server</h3>
Upload the code to your board and open the Serial Monitor. You should get something as follows:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/access-point-ip-address-esp32-server.jpg">
This means that the access point was set successfully. 
Now, to make sure it is listening for temperature, humidity and pressure requests, you need to connect to its network.
In your smartphone, go to the Wi-Fi settings and connect to the <k>ESP32-Access-Point</k>. The password is <k>123456789</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/connect-to-esp32-access-point-smartphone.png">
While connected to the access point, open your browser and type 192.168.4.1/temperature
You should get the temperature value in your browser:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/temperature-request-browser-esp32.png">
Try this URL path for the humidity 192.168.4.1/humidity:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/humidity-request-browser-esp32.png">
Finally, go to 192.168.4.1/pressure URL:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/pressure-request-browser-esp32.png">
If you're getting valid readings, it means that everything is working properly. Now, you need to prepare the other ESP32 board (client) to make those requests for you and display them on the OLED display.
<h3> #2 ESP32 Client (Station)</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP32-Client-Display-Sensor-Readings-OLED.jpg">
The ESP32 Client is a Wi-Fi station that is connected to the ESP32 Server. The client requests the temperature, humidity and pressure from the server by making HTTP GET requests on the /temperature, /humidity, and /pressure URL routes. Then, it displays the readings on an OLED display.
<h3>Schematic Diagram</h3>
Wire the <a href="https://randomnerdtutorials.com/esp32-ssd1306-oled-display-arduino-ide/">ESP32 to the OLED display</a> as shown in the following schematic diagram.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/05/ESP32_OLED.png">
<table><tbody>
<tr>
<td><k>OLED</k></td>
<td><k>ESP32</k></td>
</tr>
<tr>
<td>VIN/VCC</td>
<td>VIN</td>
</tr>
<tr>
<td>GND</td>
<td>GND</td>
</tr>
<tr>
<td>SCL</td>
<td>GPIO 22</td>
</tr>
<tr>
<td>SDA</td>
<td>GPIO 21</td>
</tr>
</tbody></table><h3>Arduino Sketch for #2 ESP32 Client</h3>
Upload the following code to the other ESP32:
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-client-server-wi-fi/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;WiFi.h>
#include &lt;HTTPClient.h>
const char* ssid = "ESP32-Access-Point";
const char* password = "123456789";
//Your IP address or domain name with URL path
const char* serverNameTemp = "http://192.168.4.1/temperature";
const char* serverNameHumi = "http://192.168.4.1/humidity";
const char* serverNamePres = "http://192.168.4.1/pressure";
#include &lt;Wire.h>
#include &lt;Adafruit_GFX.h>
#include &lt;Adafruit_SSD1306.h>
#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels
// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
#define OLED_RESET     4 // Reset pin # (or -1 if sharing Arduino reset pin)
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);
String temperature;
String humidity;
String pressure;
unsigned long previousMillis = 0;
const long interval = 5000; 
void setup() {
  Serial.begin(115200);
  
  // Address 0x3C for 128x64, you might need to change this value (use an I2C scanner)
  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("SSD1306 allocation failed"));
    for(;;); // Don't proceed, loop forever
  }
  display.clearDisplay();
  display.setTextColor(WHITE);
  
  WiFi.begin(ssid, password);
  Serial.println("Connecting");
  while(WiFi.status() != WL_CONNECTED) { 
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected to WiFi network with IP Address: ");
  Serial.println(WiFi.localIP());
}
void loop() {
  unsigned long currentMillis = millis();
  
  if(currentMillis - previousMillis >= interval) {
     // Check WiFi connection status
    if(WiFi.status()== WL_CONNECTED ){ 
      temperature = httpGETRequest(serverNameTemp);
      humidity = httpGETRequest(serverNameHumi);
      pressure = httpGETRequest(serverNamePres);
      Serial.println("Temperature: " + temperature + " *C - Humidity: " + humidity + " % - Pressure: " + pressure + " hPa");
      
      display.clearDisplay();
      
      // display temperature
      display.setTextSize(2);
      display.setTextColor(WHITE);
      display.setCursor(0,0);
      display.print("T: ");
      display.print(temperature);
      display.print(" ");
      display.setTextSize(1);
      display.cp437(true);
      display.write(248);
      display.setTextSize(2);
      display.print("C");
      
      // display humidity
      display.setTextSize(2);
      display.setCursor(0, 25);
      display.print("H: ");
      display.print(humidity);
      display.print(" %"); 
      
      // display pressure
      display.setTextSize(2);
      display.setCursor(0, 50);
      display.print("P:");
      display.print(pressure);
      display.setTextSize(1);
      display.setCursor(110, 56);
      display.print("hPa");
           
      display.display();
      
      // save the last HTTP GET Request
      previousMillis = currentMillis;
    }
    else {
      Serial.println("WiFi Disconnected");
    }
  }
}
String httpGETRequest(const char* serverName) {
  WiFiClient client;
  HTTPClient http;
    
  // Your Domain name with URL path or IP address with path
  http.begin(client, serverName);
  
  // Send HTTP POST request
  int httpResponseCode = http.GET();
  
  String payload = "--"; 
  
  if (httpResponseCode>0) {
    Serial.print("HTTP Response code: ");
    Serial.println(httpResponseCode);
    payload = http.getString();
  }
  else {
    Serial.print("Error code: ");
    Serial.println(httpResponseCode);
  }
  // Free resources
  http.end();
  return payload;
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_Client_Server/ESP_Client_OLED_Display.ino" target="_blank">View raw code</a>
<h3>How the code works</h3>
Include the necessary libraries for the Wi-Fi connection and for making HTTP requests:
<k>#include &lt;WiFi.h>
#include &lt;HTTPClient.h></k>
Insert the ESP32 server network credentials. If you've changed the default network credentials in the ESP32 server, you should change them here to match.
<k>const char* ssid = "ESP32-Access-Point";
const char* password = "123456789";</k>
Then, save the URLs where the client will be making HTTP requests. The ESP32 server has the 192.168.4.1 IP address, and we'll be making requests on the /temperature, /humidity and /pressure URLs.
<k>const char* serverNameTemp = "http://192.168.4.1/temperature";
const char* serverNameHumi = "http://192.168.4.1/humidity";
const char* serverNamePres = "http://192.168.4.1/pressure";</k>
Include the libraries to interface with the OLED display:
<k>#include &lt;SPI.h>
#include &lt;Wire.h>
#include &lt;Adafruit_GFX.h>
#include &lt;Adafruit_SSD1306.h></k>
Set the OLED display size:
<k>#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels</k>
Create a display object with the size you've defined earlier and with I2C communication protocol.
<k>Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);</k>
Initialize string variables that will hold the temperature, humidity and pressure readings retrieved by the server.
<k>String temperature;
String humidity;
String pressure;</k>
Set the time interval between each request. By default, it's set to 5 seconds, but you can change it to any other interval.
<k>const long interval = 5000; </k>
In the setup(), initialize the OLED display:
<k>// Address 0x3C for 128x64, you might need to change this value (use an I2C scanner)
if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
  Serial.println(F("SSD1306 allocation failed"));
  for(;;); // Don't proceed, loop forever
}
display.clearDisplay();
display.setTextColor(WHITE);</k>
<k>Note: </k> if your OLED display is not working, check its I2C address using an <a href="https://raw.githubusercontent.com/RuiSantosdotme/Random-Nerd-Tutorials/master/Projects/LCD_I2C/I2C_Scanner.ino" target="_blank" aria-label="I2C scanner sketch (opens in a new tab)">I2C scanner sketch</a> and change the code accordingly. 
Connect the ESP32 client to the ESP32 server network.
<k>WiFi.begin(ssid, password);
Serial.println("Connecting");
while(WiFi.status() != WL_CONNECTED) { 
  delay(500);
  Serial.print(".");
}
Serial.println("");
Serial.print("Connected to WiFi network with IP Address: ");</k>
In the loop() is where we make the HTTP GET requests. We've created a function called httpGETRequest() that accepts as argument the URL path where we want to make the request and returns the response as a String.
You can use the next function in your projects to simplify your code:
<k>String httpGETRequest(const char* serverName) {
  HTTPClient http;
    
  // Your IP address with path or Domain name with URL path 
  http.begin(serverName);
  
  // Send HTTP POST request
  int httpResponseCode = http.GET();
  
  String payload = "--"; 
  
  if (httpResponseCode>0) {
    Serial.print("HTTP Response code: ");
    Serial.println(httpResponseCode);
    payload = http.getString();
  }
  else {
    Serial.print("Error code: ");
    Serial.println(httpResponseCode);
  }
  // Free resources
  http.end();
  return payload;
}</k>
We use that function to get the temperature, humidity and pressure readings from the server.
<k>temperature = httpGETRequest(serverNameTemp);
humidity = httpGETRequest(serverNameHumi);
pressure = httpGETRequest(serverNamePres);</k>
Print those readings in the Serial Monitor for debugging.
<k>Serial.println("Temperature: " + temperature + " *C - Humidity: " + humidity + " % - Pressure: " + pressure + " hPa");</k>
Then, display the temperature in the OLED display:
<k>display.setTextSize(2);
display.setTextColor(WHITE);
display.setCursor(0,0);
display.print("T: ");
display.print(temperature);
display.print(" ");
display.setTextSize(1);
display.cp437(true);
display.write(248);
display.setTextSize(2);
display.print("C");</k>
The humidity:
<k>display.setTextSize(2);
display.setCursor(0, 25);
display.print("H: ");
display.print(humidity);
display.print(" %"); </k>
Finally, the pressure reading:
<k>display.setTextSize(2);
display.setCursor(0, 50);
display.print("P:");
display.print(pressure);
display.setTextSize(1);
display.setCursor(110, 56);
display.print("hPa");
display.display();</k>
We use timers instead of delays to make a request every x number of seconds. That's why we have the previousMillis, currentMillis variables and use the millis() function. We have an article that shows the <a href="https://randomnerdtutorials.com/why-you-shouldnt-always-use-the-arduino-delay-function/">difference between timers and delays</a> that you might find useful (or read <a href="https://randomnerdtutorials.com/esp32-pir-motion-sensor-interrupts-timers/">ESP32 Timers</a>).
Upload the sketch to #2 ESP32 (client) to test if everything is working properly.
<h3>Testing the ESP32 Client</h3>
Having both boards fairly close and powered, you'll see that ESP #2 is receiving new temperature, humidity and pressure readings every 5 seconds from ESP #1.
This is what you should see on the ESP32 Client Serial Monitor.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/esp32-client-receive-sensor-readings.jpg">
The sensor readings are also displayed in the OLED.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/Display-Readings-OLED-ESP32-Client.jpg">
That's it! Your two boards are talking with each other.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP32-to-ESP32-Client-Server-HTTP-Communication.jpg">
<h3>Wrapping Up</h3>
In this tutorial you've learned how to send data from one ESP32 to another ESP32 board via Wi-Fi using HTTP requests without the need to connect to the internet. For demonstration purposes, we've shown how to send BME280 sensor readings, but you can use any other sensor or send any other data. Other recommended sensors:
<a href="https://randomnerdtutorials.com/esp32-dht11-dht22-temperature-humidity-web-server-arduino-ide/">ESP32 DHT11 or DHT22 (Guide)</a>
<a href="https://randomnerdtutorials.com/esp32-ds18b20-temperature-arduino-ide/">ESP32 DS18B20 (Guide)</a>
<a href="https://randomnerdtutorials.com/dht11-vs-dht22-vs-lm35-vs-ds18b20-vs-bme280-vs-bmp180/">DHT11 vs DHT22 vs DS18B20 vs BME280</a>
We have a similar tutorial for the ESP8266 that you might find useful:
<a href="https://RandomNerdTutorials.com/esp8266-nodemcu-client-server-wi-fi/">ESP8266 NodeMCU Client-Server Wi-Fi Communication Between Two Boards</a>
We hope you've found this tutorial useful. We're preparing more tutorials like these. So, stay tuned and <a href="https://randomnerdtutorials.com/download">subscribe to our blog</a>!
Thanks for reading.
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/smart-home-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px-pupj8i6e7hlzpgwxe82jjd8skst9vmrjt9lpqb0v0g.jpg" title="Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px" alt="SMART HOME with Raspberry Pi ESP32 and ESP8266 Node-RED InfluxDB eBook" loading="lazy" width="117" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/smart-home-ebook/">SMART HOME with Raspberry Pi, ESP32, ESP8266 [eBook] </a></h4>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>MicroPython: Relay Module with ESP32/ESP8266 (Guide + Web Server)</h2>
Using a relay with the ESP32 or ESP8266 is a great way to control AC household appliances remotely. This tutorial explains how to control a relay module with the ESP32 or ESP8266 using <a href="https://randomnerdtutorials.com/getting-started-micropython-esp32-esp8266/">MicroPython firmware</a>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/MicroPython-firmware-ESP32-ESP8266-control-relay-web-server-ac-voltage.jpg">
We'll take a look at how a relay module works, how to connect the relay to the ESP32 or ESP8266 boards and build a web server to control a relay remotely.

<h3>Prerequisites</h3>
To follow this tutorial you need MicroPython firmware installed in your ESP32 or ESP8266 boards. You also need an IDE to write and upload the code to your board. We suggest using Thonny IDE or uPyCraft IDE:
Thonny IDE:
<a href="https://randomnerdtutorials.com/getting-started-thonny-micropython-python-ide-esp32-esp8266/">Installing and getting started with Thonny IDE</a>
<a href="https://randomnerdtutorials.com/flashing-micropython-firmware-esptool-py-esp32-esp8266/">Flashing MicroPython Firmware with esptool.py</a>
uPyCraft IDE:
<a href="https://randomnerdtutorials.com/getting-started-micropython-esp32-esp8266/">Getting Started with uPyCraft IDE</a>
Install uPyCraft IDE (<a href="https://randomnerdtutorials.com/install-upycraft-ide-windows-pc-instructions/">Windows</a>, <a href="https://randomnerdtutorials.com/install-upycraft-ide-mac-os-x-instructions/">Mac OS X</a>, <a href="https://randomnerdtutorials.com/install-upycraft-ide-linux-ubuntu-instructions/">Linux</a>)
<a href="https://randomnerdtutorials.com/flash-upload-micropython-firmware-esp32-esp8266/">Flash/Upload MicroPython Firmware to ESP32 and ESP8266</a>
Learn more about MicroPython: <a href="https://randomnerdtutorials.com/micropython-programming-with-esp32-and-esp8266/">MicroPython Programming with ESP32 and ESP8266 eBook</a>.
<h3>Introducing Relays</h3>
A relay is an electrically operated switch and like any other switch, it that can be turned on or off, letting the current go through or not. It can be controlled with low voltages, like the 3.3V provided by the ESP32/ESP8266 GPIOs and allows us to control high voltages like 12V, 24V or mains voltage (230V in Europe and 120V in the US).
<h3>1, 2, 4, 8, 16 Channels Relay Modules</h3>
There are different relay modules with a different number of channels. You can find relay modules with one, two, four, eight and even sixteen channels. The number of channels determines the number of outputs we'll be able to control.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/Relay-1-2-4-8-ch-channel-modules.jpg">
There are relay modules whose electromagnet can be powered by 5V and with 3.3V. Both can be used with the ESP32 or ESP8266  you can either use the VIN pin (that provides 5V) or the 3.3V pin.
Additionally, some come with built-in optocoupler that add an extra layer of protection, optically isolating the ESP boards from the relay circuit.
<k>Get a relay module</k>:
<a rel="noreferrer noopener nofollow" href="https://makeradvisor.com/tools/5v-2-channel-relay-module-optocoupler/" target="_blank">5V 2-channel relay module</a> (with optocoupler)
<a rel="noreferrer noopener nofollow" href="https://www.banggood.com/2Pcs-5V-1-Channel-Level-Trigger-Optocoupler-Relay-Module-For-Arduino-p-1366337.html?p=MA240439985285201910" target="_blank">5V 1-channel relay module</a> (with optocoupler) 
<a rel="noreferrer noopener nofollow" href="https://www.banggood.com/5V-8-Channel-Relay-Module-Board-For-Arduino-PIC-AVR-DSP-ARM-p-74110.html?p=MA240439985285201910" target="_blank">5V 8-channel relay module</a> (with optocoupler) 
<a href="https://www.banggood.com/BESTEP-16-Channel-5V-Relay-Module-LM2596-With-Optocoupler-Protection-Low-Level-Trigger-For-Auduino-p-1390338.html?p=MA240439985285201910&cur_warehouse=CN" target="_blank" rel="noreferrer noopener nofollow" aria-label="5V 16-channel relay module (opens in a new tab)">5V 16-channel relay module</a> (with optocoupler)
<a rel="noreferrer noopener nofollow" href="https://www.banggood.com/BESTEP-1-Channel-3_3V-Low-Level-Trigger-Relay-Module-Optocoupler-Isolation-Terminal-For-Arduino-p-1355736.html?p=MA240439985285201910" target="_blank">3.3V 1-channel relay module</a> (with optocoupler) 
<h3>Relay Pinout</h3>
For demonstration purposes, let's take a look at the pinout of a 2-channel relay module. Using a relay module with a different number of channels is similar.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/11/Relay-pinout.png">
On the left side, there are two sets of three sockets to connect high voltages, and the pins on the right side (low-voltage) connect to the ESP GPIOs.
<h3>Mains Voltage Connections</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/Relay-2-ch-channel-module-output-pins-pinout.jpg">
The relay module shown in the previous photo has two connectors, each with three sockets: common (COM), Normally Closed (NC), and Normally Open (NO).
<k>COM:</k> connect the current you want to control (mains voltage).
<k>NC (Normally Closed):</k> the normally closed configuration is used when you want the relay to be closed by default. The NC are COM pins are connected, meaning the current is flowing unless you send a signal from the ESP to the relay module to open the circuit and stop the current flow.
<k>NO (Normally Open):</k> the normally open configuration works the other way around: there is no connection between the NO and COM pins, so the circuit is broken unless you send a signal from the ESP to close the circuit.
<h3>Control Pins</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/Relay-2-ch-channel-module-with-optocoupler-top-view.jpg">
The low-voltage side has a set of four pins and a set of three pins. The first set consists of VCC and GND to power up the module, and input 1 (IN1) and input 2 (IN2) to control the bottom and top relays, respectively. 
If your relay module only has one channel, you'll have just one IN pin. If you have four channels, you'll have four IN pins, and so on.
The signal you send to the IN pins, determines whether the relay is active or not. The relay is triggered when the input goes below about 2V. This means that you'll have the following scenarios:
<k>Normally Closed configuration (NC)</k>:
HIGH signal  current is flowing
LOW signal  current is <k>not </k>flowing
<k>Normally Open configuration (NO)</k>:
HIGH signal  current is <k>not </k>flowing
LOW signal  current in flowing
You should use a normally closed configuration when the current should be flowing most of the times, and you only want to stop it occasionally. 
Use a normally open configuration when you want the current to flow occasionally (for example, turn on a lamp occasionally). 
<h3>Power Supply Selection</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/Relay-2-ch-channel-module-input-pins-pinout.jpg">
The second set of pins consists of GND, VCC, and JD-VCC pins. The JD-VCC pin powers the electromagnet of the relay. Notice that the module has a jumper cap connecting the VCC and JD-VCC pins; the one shown here is yellow, but yours may be a different color.
With the jumper cap on, the VCC and JD-VCC pins are connected. That means the relay electromagnet is directly powered from the ESP power pin, so the relay module and the ESP circuits are not physically isolated from each other. 
Without the jumper cap, you need to provide an independent power source to power up the relay's electromagnet through the JD-VCC pin. That configuration physically isolates the relays from the ESP with the module's built-in optocoupler, which prevents damage to the ESP in case of electrical spikes.
<h3>Wiring a Relay Module to the ESP32/ESP8266</h3>
<k>Warning: </k> in this example, we're dealing with mains voltage. Misuse can result in serious injuries. If you're not familiar with mains voltage ask someone who is to help you out. While programming the ESP or wiring your circuit make sure everything is disconnected from mains voltage.
Alternatively, you can use a 12V power source to control 12V appliances.
<h3>ESP32 Schematic Diagram</h3>
Connect the relay module to the ESP32 as shown in the following diagram. The diagram shows wiring for a 2-channel relay module, wiring a different number of channels is similar. 
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/relay-esp32-wiring.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/relay-esp32-wiring.png"></a>
In this example, we're controlling a lamp. We just want to light up the lamp occasionally, so it is better to use a normally open configuration.
We're connecting the IN1 pin to GPIO 26, you can use any other suitable GPIO. See <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">ESP32 GPIO Reference Guide</a>.
<h3>ESP8266 Schematic Diagram</h3>
Follow the next schematic diagram if you're using an ESP8266.
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/relay-esp8266-wiring.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/relay-esp8266-wiring.png"></a>
We're connecting the IN1 pin to GPIO 5, you can use any other suitable GPIO. See <a href="https://randomnerdtutorials.com/esp8266-pinout-reference-gpios/">ESP8266 GPIO Reference Guide</a>. 
The best ESP8266 pins to use with relays are: GPIO 5, GPIO 4, GPIO 14, GPIO 12 and GPIO 13. 
<h3>Controlling a Relay Module  MicroPython Code (Script)</h3>
The code to control a relay with the ESP32 or ESP8266 is as simple as controlling an LED or any other output. In this example, as we're using a normally open configuration, we need to send a LOW signal to let the current flow, and a HIGH signal to stop the current flow.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/ESP32-Relay-Module-Tutorial-project-example-off.jpg">
Copy the following code to the <em>main.py</em> file and upload it to your board. It lights up your lamp for 10 seconds and turn it off for another 10 seconds.
<k># Complete project details at https://RandomNerdTutorials.com
from machine import Pin
from time import sleep
# ESP32 GPIO 26
relay = Pin(26, Pin.OUT)
# ESP8266 GPIO 5
#relay = Pin(5, Pin.OUT)
while True:
  # RELAY ON
  relay.value(0)
  sleep(10)
  # RELAY OFF
  relay.value(1)
  sleep(10)
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP-MicroPython/esp_blink_relay.py" target="_blank">View raw code</a>
<h3>How the code works</h3>
Import the Pin class from the machine module to interact with the GPIOs. We also import the sleep() method from the time module to add delays.
<k>from machine import Pin
from time import sleep</k>
Then, we define a Pin object called relay on 26 (if you're using an ESP32) and define it as an output.
<k># ESP32 GPIO 26
relay = Pin(26, Pin.OUT)</k>
In case you're using an ESP8266, use GPIO 5 instead. Comment the previous line and uncomment the following.
<k># ESP8266 GPIO 5
#relay = Pin(5, Pin.OUT)</k>
In the while loop, send a LOW signal to light up the lamp for 10 seconds.
<k># RELAY ON
relay.value(0)
sleep(10)</k>
If you're using a normally closed configuration, send a HIGH signal to light up the lamp.
Stop the current flow by sending a HIGH signal to the relay pin. If you're using a normally closed configuration, send a LOW signal to stop the current flow.
<k># RELAY OFF
relay.value(1)
sleep(10)</k>
<h3>Control Relay Module with MicroPython Web Server</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/MicroPython-ESP32-ESP8266-control-relay-web-server.png">
In this section, we've created a web server example that allows you to control a relay remotely via web server.
<h3>boot.py</h3>
Copy the following code to your <em>boot.py</em> file.
<k># Complete project details at https://RandomNerdTutorials.com
try:
  import usocket as socket
except:
  import socket
from machine import Pin
import network
import esp
esp.osdebug(None)
import gc
gc.collect()
ssid = 'REPLACE_WITH_YOUR_SSID'
password = 'REPLACE_WITH_YOUR_PASSWORD'
station = network.WLAN(network.STA_IF)
station.active(True)
station.connect(ssid, password)
while station.isconnected() == False:
  pass
print('Connection successful')
print(station.ifconfig())
# ESP32 GPIO 26
relay = Pin(26, Pin.OUT)
# ESP8266 GPIO 5
#relay = Pin(5, Pin.OUT)
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP-MicroPython/esp_relay_web_server_boot.py" target="_blank">View raw code</a>
Insert your network credentials in the following variables:
<k>ssid = 'REPLACE_WITH_YOUR_SSID'
password = 'REPLACE_WITH_YOUR_PASSWORD'</k>
Uncomment one of the following lines accordingly to the board you're using. By default, it's set to use the ESP32 GPIO.
<k># ESP32 GPIO 26
relay = Pin(26, Pin.OUT)
# ESP8266 GPIO 5
#relay = Pin(5, Pin.OUT)</k>
<h3>main.py</h3>
Copy the following to your <em>main.py</em> file.
<k># Complete project details at https://RandomNerdTutorials.com
def web_page():
  if relay.value() == 1:
    relay_state = ''
  else:
    relay_state = 'checked'
  html = """&lt;html>&lt;head>&lt;meta name="viewport" content="width=device-width, initial-scale=1">&lt;style>
  body{font-family:Arial; text-align: center; margin: 0px auto; padding-top:30px;}
  .switch{position:relative;display:inline-block;width:120px;height:68px}.switch input{display:none}
  .slider{position:absolute;top:0;left:0;right:0;bottom:0;background-color:#ccc;border-radius:34px}
  .slider:before{position:absolute;content:"";height:52px;width:52px;left:8px;bottom:8px;background-color:#fff;-webkit-transition:.4s;transition:.4s;border-radius:68px}
  input:checked+.slider{background-color:#2196F3}
  input:checked+.slider:before{-webkit-transform:translateX(52px);-ms-transform:translateX(52px);transform:translateX(52px)}
  &lt;/style>&lt;script>function toggleCheckbox(element) { var xhr = new XMLHttpRequest(); if(element.checked){ xhr.open("GET", "/?relay=on", true); }
  else { xhr.open("GET", "/?relay=off", true); } xhr.send(); }&lt;/script>&lt;/head>&lt;body>
  &lt;h1>ESP Relay Web Server&lt;/h2>&lt;label>&lt;input type="checkbox" onchange="toggleCheckbox(this)" %s>&lt;span>
  &lt;/span>&lt;/label>&lt;/body>&lt;/html>""" % (relay_state)
  return html
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind(('', 80))
s.listen(5)
while True:
  try:
    if gc.mem_free() &lt; 102000:
      gc.collect()
    conn, addr = s.accept()
    conn.settimeout(3.0)
    print('Got a connection from %s' % str(addr))
    request = conn.recv(1024)
    conn.settimeout(None)
    request = str(request)
    print('Content = %s' % request)
    relay_on = request.find('/?relay=on')
    relay_off = request.find('/?relay=off')
    if relay_on == 6:
      print('RELAY ON')
      relay.value(0)
    if relay_off == 6:
      print('RELAY OFF')
      relay.value(1)
    response = web_page()
    conn.send('HTTP/1.1 200 OK\n')
    conn.send('Content-Type: text/html\n')
    conn.send('Connection: close\n\n')
    conn.sendall(response)
    conn.close()
  except OSError as e:
    conn.close()
    print('Connection closed')
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP-MicroPython/esp_relay_web_server_main.py" target="_blank">View raw code</a>
We won't explain how this code works because we already have a very similar tutorial with detailed explanation of each line of code. Read the next project:
<a href="https://randomnerdtutorials.com/esp32-esp8266-micropython-web-server/">ESP32/ESP8266 MicroPython Web Server  Control Outputs</a>
<h3>Demonstration</h3>
After making the necessary changes, upload the <em>boot.py</em> and <em>main.py</em> files to your board. Press the EN/RST button and in the Shell you should get the ESP IP address.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/esp32-esp8266-relay-web-server-ip-address.png">
Then, open a browser in your local network and type the ESP IP address to get access to the web server.
You should get a web page with a toggle button that allows you to control your relay remotely using your smartphone or your computer.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/MicroPython-ESP32-ESP8266-control-relay-web-server-ac-device.jpg"><h3>Enclosure for Safety</h3>
For a final project, make sure you place your relay module and ESP inside an enclosure to avoid any AC pins exposed.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/enclosure-for-relay-module.jpg">
<h3>Wrapping Up</h3>
In this tutorial you've learned how to control relays with the ESP32 or ESP8266 using MicroPython.

Controlling a relay with the ESP32 or ESP8266 is as easy controlling any other output, you just need to send HIGH and LOW signals as you would do to control an LED.
You can use our web server examples that control outputs to control relays. You just need to pay attention to the configuration you're using. In case you're using a normally open configuration, the relay works with inverted logic. You can use the following web server examples to control your relay:
<a href="https://randomnerdtutorials.com/esp32-web-server-arduino-ide/">ESP32 Web Server  Arduino IDE</a>
<a href="https://randomnerdtutorials.com/esp32-web-server-spiffs-spi-flash-file-system/">ESP32 Web Server using SPIFFS (control outputs)</a>
<a href="https://randomnerdtutorials.com/esp32-esp8266-micropython-web-server/">ESP32/ESP8266 MicroPython Web Server  Control Outputs</a>
Learn more about MicroPython with the ESP32 and ESP8266 with our resources:
<k><a href="https://randomnerdtutorials.com/micropython-programming-with-esp32-and-esp8266/">MicroPython Programming with the ESP32 and ESP8266 (eBook)</a> </k>
<a href="https://randomnerdtutorials.com/projects-esp32-esp8266-micropython/">More MicroPython Projects and Tutorials</a>
Thanks for reading.
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h-p2lw6wwnkk9ystvwe9iof8zx6yt4x7uma3cqfup534.jpg" title="Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h" alt="Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h" loading="lazy" width="129" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/">[eBook] Build Web Servers with ESP32 and ESP8266 (2nd Edition)</a></h4>
Build Web Server projects with the ESP32 and ESP8266 boards to control outputs and monitor sensors remotely. Learn HTML, CSS, JavaScript and client-server communication protocols <k><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Build Web Server projects with the ESP32 and ESP8266 boards to control outputs and monitor sensors remotely. Learn HTML, CSS, JavaScript and client-server communication protocols <k><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>ESP32 Relay Module  Control AC Appliances (Web Server)</a8></h2>
Using a relay with the ESP32 is a great way to control AC household appliances remotely. This tutorial explains how to control a relay module with the ESP32. We'll take a look at how a relay module works, how to connect the relay to the ESP32 and build a web server to control a relay remotely (or as many relays as you want).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/ESP32-Relay-Module-Tutorial-project-web-server-featured.jpg">
Learn how to control a relay module with ESP8266 board: <a href="https://randomnerdtutorials.com/esp8266-relay-module-ac-web-server/"><k>Guide for ESP8266 Relay Module</k>  Control AC Appliances + Web Server Example</a>.
<h3>Watch the Video Tutorial</h3>
Watch the following video tutorial or keep reading this page for the written instructions and all the resources. 

<h3>Introducing Relays</h3>
A relay is an electrically operated switch and like any other switch, it that can be turned on or off, letting the current go through or not. It can be controlled with low voltages, like the 3.3V provided by the ESP32 GPIOs and allows us to control high voltages like 12V, 24V or mains voltage (230V in Europe and 120V in the US).
<h3>1, 2, 4, 8, 16 Channels Relay Modules</h3>
There are different relay modules with a different number of channels. You can find relay modules with one, two, four, eight and even sixteen channels. The number of channels determines the number of outputs we'll be able to control.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/Relay-1-2-4-8-ch-channel-modules.jpg">
There are relay modules whose electromagnet can be powered by 5V and with 3.3V. Both can be used with the ESP32  you can either use the VIN pin (that provides 5V) or the 3.3V pin.
Additionally, some come with built-in optocoupler that add an extra layer of protection, optically isolating the ESP32 from the relay circuit.
<k>Get a relay module</k>:
<a rel="noreferrer noopener nofollow" href="https://makeradvisor.com/tools/5v-2-channel-relay-module-optocoupler/" target="_blank">5V 2-channel relay module</a> (with optocoupler)
<a rel="noreferrer noopener nofollow" href="https://www.banggood.com/2Pcs-5V-1-Channel-Level-Trigger-Optocoupler-Relay-Module-For-Arduino-p-1366337.html?p=MA240439985285201910" target="_blank">5V 1-channel relay module</a> (with optocoupler) 
<a rel="noreferrer noopener nofollow" href="https://www.banggood.com/5V-8-Channel-Relay-Module-Board-For-Arduino-PIC-AVR-DSP-ARM-p-74110.html?p=MA240439985285201910" target="_blank">5V 8-channel relay module</a> (with optocoupler) 
<a href="https://www.banggood.com/BESTEP-16-Channel-5V-Relay-Module-LM2596-With-Optocoupler-Protection-Low-Level-Trigger-For-Auduino-p-1390338.html?p=MA240439985285201910&cur_warehouse=CN" target="_blank" rel="noreferrer noopener nofollow" aria-label="5V 16-channel relay module (opens in a new tab)">5V 16-channel relay module</a> (with optocoupler)
<a rel="noreferrer noopener nofollow" href="https://www.banggood.com/BESTEP-1-Channel-3_3V-Low-Level-Trigger-Relay-Module-Optocoupler-Isolation-Terminal-For-Arduino-p-1355736.html?p=MA240439985285201910" target="_blank">3.3V 1-channel relay module</a> (with optocoupler) 
<h3>Relay Pinout</h3>
For demonstration purposes, let's take a look at the pinout of a 2-channel relay module. Using a relay module with a different number of channels is similar.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/11/Relay-pinout.png">
On the left side, there are two sets of three sockets to connect high voltages, and the pins on the right side (low-voltage) connect to the ESP32 GPIOs.
<h3>Mains Voltage Connections</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/Relay-2-ch-channel-module-output-pins-pinout.jpg">
The relay module shown in the previous photo has two connectors, each with three sockets: common (COM), Normally Closed (NC), and Normally Open (NO).
<k>COM:</k> connect the current you want to control (mains voltage).
<k>NC (Normally Closed):</k> the normally closed configuration is used when you want the relay to be closed by default. The NC are COM pins are connected, meaning the current is flowing unless you send a signal from the ESP32 to the relay module to open the circuit and stop the current flow.
<k>NO (Normally Open):</k> the normally open configuration works the other way around: there is no connection between the NO and COM pins, so the circuit is broken unless you send a signal from the ESP32 to close the circuit.
<h3>Control Pins</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/Relay-2-ch-channel-module-with-optocoupler-top-view.jpg">
The low-voltage side has a set of four pins and a set of three pins. The first set consists of VCC and GND to power up the module, and input 1 (IN1) and input 2 (IN2) to control the bottom and top relays, respectively. 
If your relay module only has one channel, you'll have just one IN pin. If you have four channels, you'll have four IN pins, and so on.
The signal you send to the IN pins, determines whether the relay is active or not. The relay is triggered when the input goes below about 2V. This means that you'll have the following scenarios:
<k>Normally Closed configuration (NC)</k>:
HIGH signal  current is flowing
LOW signal  current is <k>not </k>flowing
<k>Normally Open configuration (NO)</k>:
HIGH signal  current is <k>not </k>flowing
LOW signal  current in flowing
You should use a normally closed configuration when the current should be flowing most of the times, and you only want to stop it occasionally. 
Use a normally open configuration when you want the current to flow occasionally (for example, turn on a lamp occasionally). 
<h3>Power Supply Selection</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/Relay-2-ch-channel-module-input-pins-pinout.jpg">
The second set of pins consists of GND, VCC, and JD-VCC pins. The JD-VCC pin powers the electromagnet of the relay. Notice that the module has a jumper cap connecting the VCC and JD-VCC pins; the one shown here is yellow, but yours may be a different color.
With the jumper cap on, the VCC and JD-VCC pins are connected. That means the relay electromagnet is directly powered from the ESP32 power pin, so the relay module and the ESP32 circuits are not physically isolated from each other. 
Without the jumper cap, you need to provide an independent power source to power up the relay's electromagnet through the JD-VCC pin. That configuration physically isolates the relays from the ESP32 with the module's built-in optocoupler, which prevents damage to the ESP32 in case of electrical spikes.
<h3>Wiring a Relay Module to the ESP32</h3>
Connect the relay module to the ESP32 as shown in the following diagram. The diagram shows wiring for a 2-channel relay module, wiring a different number of channels is similar.
<k>Warning: </k> in this example, we're dealing with mains voltage. Misuse can result in serious injuries. If you're not familiar with mains voltage ask someone who is to help you out. While programming the ESP or wiring your circuit make sure everything is disconnected from mains voltage.
Alternatively, you can use a 12V power source to control 12V appliances.
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/relay-esp32-wiring.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/relay-esp32-wiring.png"></a>
In this example, we're controlling a lamp. We just want to light up the lamp occasionally, so it is better to use a normally open configuration.
We're connecting the IN1 pin to GPIO 26, you can use any other suitable GPIO. See <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">ESP32 GPIO Reference Guide</a>.
<h3>Controlling a Relay Module with the ESP32  Arduino Sketch</h3>
The code to control a relay with the ESP32 is as simple as controlling an LED or any other output. In this example, as we're using a normally open configuration, we need to send a LOW signal to let the current flow, and a HIGH signal to stop the current flow.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/ESP32-Relay-Module-Tutorial-project-example-off.jpg">
The following code will light up your lamp for 10 seconds and turn it off for another 10 seconds.
<k>/*********
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-relay-module-ac-web-server/
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*********/
const int relay = 26;
void setup() {
  Serial.begin(115200);
  pinMode(relay, OUTPUT);
}
void loop() {
  // Normally Open configuration, send LOW signal to let current flow
  // (if you're usong Normally Closed configuration send HIGH signal)
  digitalWrite(relay, LOW);
  Serial.println("Current Flowing");
  delay(5000); 
  
  // Normally Open configuration, send HIGH signal stop current flow
  // (if you're usong Normally Closed configuration send LOW signal)
  digitalWrite(relay, HIGH);
  Serial.println("Current not Flowing");
  delay(5000);
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Relay_Control.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
Define the pin the relay IN pin is connected to.
<k>const int relay = 26;</k>
In the setup(), define the relay as an output.
<k>pinMode(relay, OUTPUT);</k>
In the loop(), send a LOW signal to let the current flow and light up the lamp.
<k>digitalWrite(relay, LOW);</k>
If you're using a normally closed configuration, send a HIGH signal to light up the lamp. Then, wait 5 seconds.
<k>delay(5000);</k>
Stop the current flow by sending a HIGH signal to the relay pin. If you're using a normally closed configuration, send a LOW signal to stop the current flow.
<k>digitalWrite(relay, HIGH);</k>
<h3>Control Multiple Relays with ESP32 Web Server</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/ESP32-web-serve-relays.png">
In this section, we've created a web server example that allows you to control as many relays as you want via web server whether they are configured as normally opened or as normally closed. You just need to change a few lines of code to define the number of relays you want to control and the pin assignment.
To build this web server, we use the <a href="https://github.com/me-no-dev/ESPAsyncWebServer" target="_blank" aria-label=" (opens in a new tab)">ESPAsyncWebServer library</a>.
<k>Installing the ESPAsyncWebServer library</k>
Follow the next steps to install the <a href="https://github.com/me-no-dev/ESPAsyncWebServer" target="_blank" aria-label=" (opens in a new tab)">ESPAsyncWebServer</a> library:
<ol>
<a href="https://github.com/me-no-dev/ESPAsyncWebServer/archive/master.zip" target="_blank" aria-label=" (opens in a new tab)">Click here to download the ESPAsyncWebServer library</a>. You should have a .zip folder in your Downloads folder
Unzip the .zip folder and you should get <em>ESPAsyncWebServer-master</em> folder
Rename your folder from <del>ESPAsyncWebServer-master</del> to <em>ESPAsyncWebServer</em>
Move the <em>ESPAsyncWebServer </em>folder to your Arduino IDE installation libraries folder
</ol>
Alternatively, in your Arduino IDE, you can go to <k>Sketch </k>> <k>Include Library</k> > <k>Add .ZIP library</k> and select the library you've just downloaded.
<k>Installing the Async TCP Library for ESP32</k>
The <a href="https://github.com/me-no-dev/ESPAsyncWebServer" target="_blank" aria-label=" (opens in a new tab)">ESPAsyncWebServer</a> library requires the <a href="https://github.com/me-no-dev/AsyncTCP" target="_blank" aria-label=" (opens in a new tab)">AsyncTCP</a> library to work. Follow the next steps to install that library:
<ol>
<a href="https://github.com/me-no-dev/AsyncTCP/archive/master.zip" target="_blank" aria-label=" (opens in a new tab)">Click here to download the AsyncTCP library</a>. You should have a .zip folder in your Downloads folder
Unzip the .zip folder and you should get <em>AsyncTCP-master</em> folder
Rename your folder from <del>AsyncTCP-master </del>to <em>AsyncTCP</em>
Move the <em>AsyncTCP </em>folder to your Arduino IDE installation libraries folder
Finally, re-open your Arduino IDE
</ol>
Alternatively, in your Arduino IDE, you can go to <k>Sketch </k>> <k>Include Library</k> > <k>Add .ZIP library</k> and select the library you've just downloaded. 
After installing the required libraries, copy the following code to your Arduino IDE.
<k>/*********
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-relay-module-ac-web-server/
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*********/
// Import required libraries
#include "WiFi.h"
#include "ESPAsyncWebServer.h"
// Set to true to define Relay as Normally Open (NO)
#define RELAY_NO    true
// Set number of relays
#define NUM_RELAYS  5
// Assign each GPIO to a relay
int relayGPIOs[NUM_RELAYS] = {2, 26, 27, 25, 33};
// Replace with your network credentials
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
const char* PARAM_INPUT_1 = "relay";  
const char* PARAM_INPUT_2 = "state";
// Create AsyncWebServer object on port 80
AsyncWebServer server(80);
const char index_html[] PROGMEM = R"rawliteral(
&lt;!DOCTYPE HTML>&lt;html>
&lt;head>
  &lt;meta name="viewport" content="width=device-width, initial-scale=1">
  &lt;style>
    html {font-family: Arial; display: inline-block; text-align: center;}
    h2 {font-size: 3.0rem;}
    p {font-size: 3.0rem;}
    body {max-width: 600px; margin:0px auto; padding-bottom: 25px;}
    .switch {position: relative; display: inline-block; width: 120px; height: 68px} 
    .switch input {display: none}
    .slider {position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; border-radius: 34px}
    .slider:before {position: absolute; content: ""; height: 52px; width: 52px; left: 8px; bottom: 8px; background-color: #fff; -webkit-transition: .4s; transition: .4s; border-radius: 68px}
    input:checked+.slider {background-color: #2196F3}
    input:checked+.slider:before {-webkit-transform: translateX(52px); -ms-transform: translateX(52px); transform: translateX(52px)}
  &lt;/style>
&lt;/head>
&lt;body>
  &lt;h2>ESP Web Server&lt;/h2>
  %BUTTONPLACEHOLDER%
&lt;script>function toggleCheckbox(element) {
  var xhr = new XMLHttpRequest();
  if(element.checked){ xhr.open("GET", "/update?relay="+element.id+"&state=1", true); }
  else { xhr.open("GET", "/update?relay="+element.id+"&state=0", true); }
  xhr.send();
}&lt;/script>
&lt;/body>
&lt;/html>
)rawliteral";
// Replaces placeholder with button section in your web page
String processor(const String& var){
  //Serial.println(var);
  if(var == "BUTTONPLACEHOLDER"){
    String buttons ="";
    for(int i=1; i&lt;=NUM_RELAYS; i++){
      String relayStateValue = relayState(i);
      buttons+= "&lt;h4>Relay #" + String(i) + " - GPIO " + relayGPIOs[i-1] + "&lt;/h4>&lt;label class=\"switch\">&lt;input type=\"checkbox\" onchange=\"toggleCheckbox(this)\" id=\"" + String(i) + "\" "+ relayStateValue +">&lt;span class=\"slider\">&lt;/span>&lt;/label>";
    }
    return buttons;
  }
  return String();
}
String relayState(int numRelay){
  if(RELAY_NO){
    if(digitalRead(relayGPIOs[numRelay-1])){
      return "";
    }
    else {
      return "checked";
    }
  }
  else {
    if(digitalRead(relayGPIOs[numRelay-1])){
      return "checked";
    }
    else {
      return "";
    }
  }
  return "";
}
void setup(){
  // Serial port for debugging purposes
  Serial.begin(115200);
  // Set all relays to off when the program starts - if set to Normally Open (NO), the relay is off when you set the relay to HIGH
  for(int i=1; i&lt;=NUM_RELAYS; i++){
    pinMode(relayGPIOs[i-1], OUTPUT);
    if(RELAY_NO){
      digitalWrite(relayGPIOs[i-1], HIGH);
    }
    else{
      digitalWrite(relayGPIOs[i-1], LOW);
    }
  }
  
  // Connect to Wi-Fi
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi..");
  }
  // Print ESP32 Local IP Address
  Serial.println(WiFi.localIP());
  // Route for root / web page
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send_P(200, "text/html", index_html, processor);
  });
  // Send a GET request to &lt;ESP_IP>/update?relay=&lt;inputMessage>&state=&lt;inputMessage2>
  server.on("/update", HTTP_GET, [] (AsyncWebServerRequest *request) {
    String inputMessage;
    String inputParam;
    String inputMessage2;
    String inputParam2;
    // GET input1 value on &lt;ESP_IP>/update?relay=&lt;inputMessage>
    if (request->hasParam(PARAM_INPUT_1) & request->hasParam(PARAM_INPUT_2)) {
      inputMessage = request->getParam(PARAM_INPUT_1)->value();
      inputParam = PARAM_INPUT_1;
      inputMessage2 = request->getParam(PARAM_INPUT_2)->value();
      inputParam2 = PARAM_INPUT_2;
      if(RELAY_NO){
        Serial.print("NO ");
        digitalWrite(relayGPIOs[inputMessage.toInt()-1], !inputMessage2.toInt());
      }
      else{
        Serial.print("NC ");
        digitalWrite(relayGPIOs[inputMessage.toInt()-1], inputMessage2.toInt());
      }
    }
    else {
      inputMessage = "No message sent";
      inputParam = "none";
    }
    Serial.println(inputMessage + inputMessage2);
    request->send(200, "text/plain", "OK");
  });
  // Start server
  server.begin();
}
  
void loop() {
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Relay_Module_Web_Server.ino" target="_blank">View raw code</a>
<h3>Define Relay Configuration</h3>
Modify the following variable to indicate whether you're using your relays in normally open (NO) or normally closed (NC) configuration. Set the RELAY_NO variable to true for normally open os set to false for normally closed.
<k>#define RELAY_NO true</k>
<h3>Define Number of Relays (Channels)</h3>
You can define the number of relays you want to control on the NUM_RELAYS variable. For demonstration purposes, we're setting it to 5.
<k>#define NUM_RELAYS 5</k>
<h3>Define Relays Pin Assignment</h3>
In the following array variable you can define the ESP32 GPIOs that will control the relays:
<k>int relayGPIOs[NUM_RELAYS] = {2, 26, 27, 25, 33};</k>
The number of relays set on the NUM_RELAYS variable needs to match the number of GPIOs assigned in the relayGPIOs array.
<h3>Network Credentials</h3>
Insert your network credentials in the following variables.
<k>const char* ssid     = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h3>Wiring 8 Channel Relay to ESP32</h3>
For demonstration purposes, we're controlling 5 relay channels. Wire the ESP32 to the relay module as shown in the next schematic diagram.
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/Relay-pinout-8channels-esp32.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/Relay-pinout-8channels-esp32.png"></a>
<h3>Demonstration</h3>
After making the necessary changes, upload the code to your ESP32.
Open the Serial Monitor at a baud rate of 115200 and press the ESP32 EN button to get its IP address.
Then, open a browser in your local network and type the ESP32 IP address to get access to the web server.
You should get something as follows with as many buttons as the number of relays you've defined in your code.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/ESP32-Relay-Module-Tutorial-project-web-server-example-demo.jpg">
Now, you can use the buttons to control your relays remotely using your smartphone.
<h3>Enclosure for Safety</h3>
For a final project, make sure you place your relay module and ESP inside an enclosure to avoid any AC pins exposed.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/enclosure-for-relay-module.jpg"><h3>Wrapping Up</h3>
Using relays with the ESP32 is a great way to control AC household appliances remotely. You can also read our other <a href="https://randomnerdtutorials.com/esp8266-relay-module-ac-web-server/">Guide to control a Relay Module with <k>ESP8266</k></a>.
Controlling a relay with the ESP32 is as easy controlling any other output, you just need to send HIGH and LOW signals as you would do to control an LED.
You can use our web server examples that control outputs to control relays. You just need to pay attention to the configuration you're using. In case you're using a normally open configuration, the relay works with inverted logic. You can use the following web server examples to control your relay:
<a href="https://randomnerdtutorials.com/esp32-web-server-arduino-ide/">ESP32 Web Server  Arduino IDE</a>
<a href="https://randomnerdtutorials.com/esp32-web-server-spiffs-spi-flash-file-system/">ESP32 Web Server using SPIFFS (control outputs)</a>
<a href="https://randomnerdtutorials.com/esp32-esp8266-micropython-web-server/">ESP32/ESP8266 MicroPython Web Server  Control Outputs</a>


<script src='https://williamkpchan.github.io/LibDocs/readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
 elements_selector: ".lazy"
});
</script>

</body></html>
