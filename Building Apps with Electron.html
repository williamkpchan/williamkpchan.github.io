
<base target="_blank">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<style type="text/css">

body {
 font-size: 24px;
 margin: 10%;
 background-color: #000000;
 color: #109030;
}
a { text-decoration: none;
  color: #28B8B8;}
a:visited { color: #389898;}
A:hover { color: yellow;}
A:focus { color: red;}
code { color: gray; background-color: #001800}
pre { color: gray; background-color: #001010}
#newtype { color: pink}
#redpink { color: #cc0099}
#redword { color: red}
#yellowword { color: yellow}
#greenword { color: lightgreen}
#limeword { color: #00ff00}
#orangeword { color: orange}
#cyanword { color: cyan}
#whiteword { color: white}
#grayword { color: gray}
#brownword { color: #ff8000}
#yellowgreen { color: #bfff00}
#palered { color: #ffcccc}
#blueword { color: dodgerblue}
#purpleword { color: darkorchid}
#goldword { color: GoldenRod}
#silverword { color: silver}
#blackword { color: black}
.left {
    position: absolute;
    left: 100px;
    color: GoldenRod;
    border: 1px solid GoldenRod;
    padding: 2px;
    font-size: 60%;
}
.aquacolor {
    color: Aqua;
}
.bord {
    color: redpink;
    border: 1px solid GoldenRod;
    padding: 1px;
    font-size: 90%;
}
.bordsub {
    color: #F07070;
    margin: 3px 90px 3px 90px;
    border: 1px solid darkcyan;
    padding: 1px;
    font-size: 90%;
}
.highlight { 
    color: white;
    background-color: #002030
  }
.redpink { color: .cc0099}
.redword { color: red}
.yellowword { color: yellow}
.greenword { color: lightgreen}
.limeword { color: .00ff00}
.orangeword { color: orange}
.cyanword { color: cyan}
.whiteword { color: white}
.grayword { color: gray}
.brownword { color: #ff8000}
.yellowgreen { color: #bfff00}
.palered { color: #ffcccc}
.blueword { color: dodgerblue}
.purpleword { color: darkorchid}
.goldword { color: GoldenRod}
.silverword { color: silver}
.blackword { color: black}

</STYLE>
</head>

<body>

<div>
<h1>Building Apps with Electron</h1>

  <p>
  Earlier this year, Github released Atom-Shell, the core of its famous open-source editor 
  <a href="https://atom.io">
Atom
</a>
, and renamed it to 
<strong>
Electron
</strong>
 for the special occasion.
</p>
 


<p>
  Electron, unlike other competitors in the category of Node.js-based desktop applications, brings its own twist to this already well-established market by combining the power of Node.js (
  <a href="https://iojs.org/">
io.js
</a>
 until recent releases) with the 
 <a href="http://www.chromium.org/Home">
 Chromium Engine
</a>
 to bring us the best of both server and client-side JavaScript.
</p>
 


<p>
  Imagine a world where we could build performant, data-driven, cross-platform desktop applications powered by not only the ever-growing repository of NPM modules, but also the entire Bower registry to fulfill all our client-side needs.
</p>



<p>
  Enter 
  <a href="http://electron.atom.io/">
Electron
</a>
.
</p>



<p>
  
  <img src="https://assets.toptal.io/uploads/blog/image/91759/toptal-blog-image-1444912203611-6e3035926a5def9e7a0d42427430ede0.jpg" alt="Building Cross-platform Desktop Apps with Electron" />

</p>



<div class="pop_out_box is-full_width is-big" style="text-align: center;">
  Building Cross-platform Desktop Apps with Electron
</div>



<div class="tweet_this">
  

<a href="https://twitter.com/share" class="twitter-share-button" data-url="https://www.toptal.com/javascript/electron-cross-platform-desktop-apps-easy" data-text="Building Cross-platform Desktop Apps with Electron" data-via="toptal">
  Tweet
</a>


</div>



<p>
  In this tutorial, we will build a simple password keychain application using Electron, Angular.js and 
  <a href="http://lokijs.org/#/">
Loki.js
</a>
, a lightweight and in-memory database with a familiar syntax for 
<a href="https://www.toptal.com/mongodb">
MongoDB developers
</a>
.
</p>



<blockquote>
  
  
  <p>
    The full source code for this application is available 
    <a href="https://github.com/stephanepericat/toptal-electron-loki-demo">
  here
</a>
  .
</p>
  

</blockquote>



<p>
  This tutorial assumes that:
</p>



<ul>
  
  
  <li>
    The reader has Node.js and Bower installed on their machine.
  </li>
  
  
  <li>
    They are familiar with Node.js, Angular.js and MongoDB-like query syntax.
  </li>
  

</ul>



<h2 id="getting-the-goods">
  Getting the Goods
</h2>



<p>
  First things first, we will need to get the Electron binaries in order to test our app locally. We can install it globally and use it as a CLI, or install it locally in our application’s path. I recommend installing it globally, so that way we do not have to do it over and over again for every app we develop.
</p>



<blockquote>
  
  
  <p>
    We will learn later how to package our application for distribution using Gulp. This process involves copying the Electron binaries, and therefore it makes little to no sense to manually install it in our application’s path.
  </p>
  

</blockquote>



<p>
  To install the Electron CLI, we can type the following command in our terminal:
</p>



<pre>
  
  <code class="language-shell">
  $ npm install -g electron-prebuilt

</code>

</pre>



<p>
  To test the installation, type 
  <code>
electron -h
</code>
 and it should display the version of the Electron CLI.
</p>
 


<p>
  
  <em>
  At the time this article was written, the version of Electron was 
  <code>
0.31.2
</code>
.
</em>

</p>



<h2 id="setting-up-the-project">
  Setting up the Project
</h2>



<p>
  Let’s assume the following basic folder structure:
</p>



<pre>
  
  <code>
  my-app
|- cache/
|- dist/
|- src/
|-- app.js
| gulpfile.js

</code>

</pre>



<p>
  … where:
 - 
 <strong>
 cache/
</strong>
  will be used to download the Electron binaries when building the app.
 - 
 <strong>
 dist/
</strong>
  will contain the generated distribution files.
 - 
 <strong>
 src/
</strong>
  will contain our source code.
 - 
 <strong>
 src/app.js
</strong>
  will be the entry point of our application.
</p>
  


<p>
  Next, we will navigate to the 
  <code>
src/
</code>
 folder in our terminal and create the 
 <code>
 package.json
</code>
 and 
 <code>
 bower.json
</code>
 files for our app:
</p>
 


<pre>
  
  <code class="language-shell">
  $ npm init
$ bower init

</code>

</pre>



<p>
  We will install the necessary packages later on in this tutorial.
</p>



<h2 id="understanding-electron-processes">
  Understanding Electron Processes
</h2>



<p>
  Electron distinguishes between two types of processes:
</p>



<ul>
  
  
  <li>
    
    <strong>
    The Main Process
  </strong>
  : The entry point of our application, the file that will be executed whenever we run the app. Typically, this file declares the various windows of the app, and can optionally be used to define global event listeners using Electron’s IPC module.
</li>
  
  
  <li>
    
    <strong>
    The Renderer Process
  </strong>
  : The controller for a given window in our application. Each window creates its own Renderer Process.
</li>
  

</ul>



<blockquote>
  
  
  <p>
    For code clarity, a separate file should be used for each Renderer Process.
To define the Main Process for our app, we will open 
<code>
src/app.js
</code>
 and include the 
 <code>
 app
</code>
 module to start the app, and the 
 <code>
 browser-window
</code>
 module to create the various windows of our app (both part of the Electron core), as such:
</p>
 

</blockquote>



<pre>
  
  <code class="language-js">
  var app = require('app'),
    BrowserWindow = require('browser-window');

</code>

</pre>



<p>
  When the app is actually started, it fires a 
  <code>
ready
</code>
 event, which we can bind to. At this point, we can instantiate the main window of our app:
</p>
 


<pre>
  
  <code class="language-js">
  var mainWindow = null;

app.on('ready', function() {
    mainWindow = new BrowserWindow({
        width: 1024,
        height: 768
    });
    
    mainWindow.loadUrl('file://' + __dirname + '/windows/main/main.html');
    mainWindow.openDevTools();
});

</code>

</pre>



<p>
  
  <strong>
  Key points:
</strong>

</p>



<ul>
  
  
  <li>
    We create a new window by creating a new instance of the 
    <code>
  BrowserWindow
</code>
   object.
 </li>
   
  
  <li>
    It takes an object as a single argument, allowing us to define 
    <a href="http://electron.atom.io/docs/v0.31.0/api/browser-window/#class-browserwindow">
  various settings
</a>
  , amongst which the default 
  <em>
  width
</em>
   and 
   <em>
   height
 </em>
   of the window.
 </li>
   
  
  <li>
    The window instance has a 
    <code>
  loadUrl()
</code>
   method, allowing us to load the contents of an actual HTML file in the current window. The HTML file can either be 
   <em>
   local
 </em>
   or 
   <em>
   remote
 </em>
  .
</li>
  
  
  <li>
    The window instance has an optional 
    <code>
  openDevTools()
</code>
   method, allowing us to open an instance of the Chrome Dev Tools in the current window for debugging purposes.
 </li>
   

</ul>



<p>
  Next, we should organize our code a little. I recommend creating a 
  <code>
windows/
</code>
 folder in our 
 <code>
 src/
</code>
 folder, and where we can create a subfolder for each window, as such:
</p>
 


<pre>
  
  <code>
  my-app
|- src/
|-- windows/
|--- main/
|---- main.controller.js
|---- main.html
|---- main.view.js

</code>

</pre>



<p>
  … where 
  <code>
main.controller.js
</code>
 will contain the “server-side” logic of our application, and 
 <code>
 main.view.js
</code>
 will contain the “client-side” logic of our application.
</p>
 


<p>
  The 
  <code>
main.html
</code>
 file is simply an HTML5 webpage, so we can simply start it like this:
</p>
 


<pre>
  
  <code class="language-html">
  &lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Password Keychain&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Password Keychain&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;

</code>

</pre>



<p>
  At this point, our app should be ready to run. To test it, we can simply type the following in our terminal, at the root of the 
  <code>
src
</code>
 folder:
</p>
 


<pre>
  
  <code class="language-shell">
  $ electron .

</code>

</pre>



<blockquote>
  
  
  <p>
    We can automate this process by defining the 
    <code>
  start
</code>
   script of the package.son file.
 </p>
   

</blockquote>



<p>
  
  <img src="https://assets.toptal.io/uploads/blog/image/91760/toptal-blog-image-1444917323527.3-4d6db134197f81cfa4f7f9a3c0edb02b.jpg" alt="" />

</p>



<h2 id="building-a-password-keychain-desktop-app">
  Building a Password Keychain Desktop App
</h2>



<p>
  To build a password keychain application, we need:
- A way to add, generate and save passwords.
- A convenient way to copy and remove passwords.
</p>



<h3 id="generating-and-saving-passwords">
  Generating and Saving Passwords
</h3>



<p>
  A simple form will suffice to insert new passwords. For the sake of demonstrating communication between multiple windows in Electron, start by adding a second window in our application, which will display the “insert” form. Since we will open and close this window multiple times, we should wrap up the logic in a method so that we can simply call it when needed:
</p>



<pre>
  
  <code class="language-js">
  function createInsertWindow() {
    insertWindow = new BrowserWindow({
        width: 640,
        height: 480,
        show: false
    });
    
    insertWindow.loadUrl('file://' + __dirname + '/windows/insert/insert.html');
    
    insertWindow.on('closed',function() {
        insertWindow = null;
    });
}

</code>

</pre>



<p>
  
  <strong>
  Key points:
</strong>

</p>



<ul>
  
  
  <li>
    We will need to set the 
    <strong>
  show
</strong>
   property to 
   <strong>
   false
 </strong>
   in the options object of the BrowserWindow constructor, in order to prevent the window from being open by default when the applications starts.
 </li>
   
  
  <li>
    We will need to destroy the BrowserWindow instance whenever the window is firing a 
    <strong>
  closed
</strong>
   event.
 </li>
   

</ul>



<h4 id="opening-and-closing-the-insert-window">
  Opening and Closing the “Insert” Window
</h4>



<p>
  The idea is to be able to trigger the “insert” window when the end user clicks a button in the “main” window. In order to do this, we will need to send a message from the main window to the Main Process to instruct it to open the insert window. We can achieve this using Electron’s IPC module. There are actually two variants of the IPC module:
</p>



<ul>
  
  
  <li>
    One for the 
    <a href="http://electron.atom.io/docs/api/ipc-main/">
  Main Process
</a>
  , allowing the app to subscribe to messages sent from windows.
</li>
  
  
  <li>
    One for the 
    <a href="http://electron.atom.io/docs/api/ipc-renderer/">
  Renderer Process
</a>
  , allowing the app to send messages to the main process.
</li>
  

</ul>



<blockquote>
  
  
  <p>
    Although Electron’s communication channel is mostly uni-directional, it is possible to access the Main Process’ IPC module in a Renderer Process by making use of the 
    <strong>
  
  <a href="http://electron.atom.io/docs/v0.31.0/api/remote/">
    remote
  </a>

</strong>
   module. Also, the Main Process can send a message back to the Renderer Process from which the event originated by using the 
   <a href="http://electron.atom.io/docs/api/ipc-main/">
   Event.sender.send()
 </a>
   method.
 </p>
   

</blockquote>



<p>
  To use the IPC module, we just require it like any other NPM module in our Main Process script:
</p>



<pre>
  
  <code class="language-js">
  var ipc = require('ipc');

</code>

</pre>



<p>
  … and then bind to events with the 
  <code>
on()
</code>
 method:
</p>
 


<pre>
  
  <code class="language-js">
  ipc.on('toggle-insert-view', function() {
    if(!insertWindow) {
        createInsertWindow();
    }
    return (!insertWindow.isClosed() &amp;&amp; insertWindow.isVisible()) ? insertWindow.hide() : insertWindow.show();
});

</code>

</pre>



<p>
  
  <strong>
  Key Points:
</strong>

</p>



<ul>
  
  
  <li>
    We can name the event however we want, the example is just arbitrary.
  </li>
  
  
  <li>
    Do not forget to check if the BrowserWindow instance is already created, if not then instantiate it.
  </li>
  
  
  <li>
    The BrowserWindow instance has some useful methods:
    
    <ul>
      
      
      <li>
        
        <strong>
        isClosed()
      </strong>
       returns a boolean, whether or not the window is currently in a 
       <code>
       closed
     </code>
       state.
     </li>
       
      
      <li>
        
        <strong>
        isVisible()
      </strong>
      : returns a boolean, whether or not the window is currently visible.
    </li>
      
      
      <li>
        
        <strong>
        show() / hide()
      </strong>
      : convenience methods to show and hide the window.
    </li>
      
    
    </ul>
    
  
  </li>
  

</ul>



<p>
  Now we actually need to fire that event from the Renderer Process. We will create a new script file called 
  <code>
main.view.js
</code>
, and add it to our HTML page like we would with any normal script:
</p>



<pre>
  
  <code class="language-html">
  &lt;script src="./main.view.js"&gt;&lt;/script&gt;

</code>

</pre>



<blockquote>
  
  
  <p>
    Loading the script file via the HTML 
    <code>
  script
</code>
   tag loads this file in a 
   <em>
   client-side
 </em>
   context. This means that, for example, global variables are available via 
   <code>
   window.&lt;var_name&gt;
 </code>
  . To load a script in a 
  <em>
  server-side
</em>
   context, we can use the 
   <code>
   require()
 </code>
   method directly in our HTML page: 
   <code>
   require('./main.controller.js');
 </code>
  .
</p>
  

</blockquote>



<p>
  Even though the script is loaded in 
  <em>
client-side
</em>
 context, we can still access the IPC module for the Renderer Process in the same way that we can for the Main Process, and then send our event as such:
</p>
 


<pre>
  
  <code class="language-js">
  var ipc = require('ipc');

angular
    .module('Utils', [])
    .directive('toggleInsertView', function() {
        return function(scope, el) {
            el.bind('click', function(e) {
                e.preventDefault();
                ipc.send('toggle-insert-view');
            });
        };
    });

</code>

</pre>



<blockquote>
  
  
  <p>
    There is also a sendSync() method available, in case we need to send our events synchronously.
  </p>
  

</blockquote>



<p>
  Now, all we have left to do to open the “insert” window is to create an HTML button with the matching Angular directive on it:
</p>



<pre>
  
  <code class="language-html">
  &lt;div ng-controller="MainCtrl as vm"&gt;
    &lt;button toggle-insert-view class="mdl-button"&gt;
        &lt;i class="material-icons"&gt;add&lt;/i&gt;
    &lt;/button&gt;
&lt;/div&gt;

</code>

</pre>



<p>
  And add that directive as a dependency of the main window’s Angular controller:
</p>



<pre>
  
  <code class="language-js">
  angular
    .module('MainWindow', ['Utils'])
    .controller('MainCtrl', function() {
        var vm = this;
    });

</code>

</pre>



<p>
  
  <img src="https://assets.toptal.io/uploads/blog/image/91761/toptal-blog-image-1444917358694.1-5e6be8783f5eacd2a8f9f2e8c6ab2950.jpg" alt="" />

</p>



<h4 id="generating-passwords">
  Generating Passwords
</h4>



<p>
  To keep things simple, we can just use the NPM 
  <code>
uuid
</code>
 module to generate unique ID’s that will act as passwords for the purpose of this tutorial. We can install it like any other NPM module, require it in our ‘Utils’ script and then create a simple factory that will return a unique ID:
</p>
 


<pre>
  
  <code class="language-js">
  var uuid = require('uuid');

angular
    .module('Utils', [])
    
    ...
    
    .factory('Generator', function() {
        return {
            create: function() {
                return uuid.v4();
            }
        };
    })

</code>

</pre>



<p>
  Now, all we have left to do is create a button in the insert view, and attach a directive to it that will listen to click events on the button and call the create() method:
</p>



<pre>
  
  <code class="language-html">
  &lt;!-- in insert.html --&gt;
&lt;button generate-password class="mdl-button"&gt;generate&lt;/button&gt;

</code>

</pre>



<pre>
  
  <code class="language-js">
  // in Utils.js
angular
    .module('Utils', [])
    
    ...
    
    .directive('generatePassword', ['Generator', function(Generator) {
        return function(scope, el) {
            el.bind('click', function(e) {
                e.preventDefault();
                if(!scope.vm.formData) scope.vm.formData = {};
                scope.vm.formData.password = Generator.create();
                scope.$apply();
            });
        };
    }])

</code>

</pre>



<h4 id="saving-passwords">
  Saving Passwords
</h4>



<p>
  At this point, we want to store our passwords. The data structure for our password entries is fairly simple:
</p>



<pre>
  
  <code class="language-js">
  {
    "id": String
    "description": String,
    "username": String,
    "password": String
}

</code>

</pre>



<p>
  So all we really need is some kind of in-memory database that can optionally sync to file for backup. For this purpose, Loki.js seems like the ideal candidate. It does exactly what we need for the purpose of this application, and offers on top of it the 
  <em>
Dynamic Views
</em>
 feature, allowing us to do things similar to MongoDB’s Aggregation module.
</p>
 


<blockquote>
  
  
  <p>
    Dynamic Views do 
    <strong>
  not
</strong>
   offer all the functionality that MongodDB’s Aggregation module does. Please refer to the 
   <a href="http://lokijs.org/#/docs#views">
   documentation
 </a>
   for more information.
 </p>
   

</blockquote>



<p>
  Let’s start by creating a simple HTML form:
</p>



<pre>
  
  <code class="language-html">
  &lt;div class="insert" ng-controller="InsertCtrl as vm"&gt;
    &lt;form name="insertForm" no-validate&gt;
        &lt;fieldset ng-disabled="!vm.loaded"&gt;
            &lt;div class="mdl-textfield"&gt;
                &lt;input class="mdl-textfield__input" type="text" id="description" ng-model="vm.formData.description" required /&gt;
                &lt;label class="mdl-textfield__label" for="description"&gt;Description...&lt;/label&gt;
            &lt;/div&gt;
            &lt;div class="mdl-textfield"&gt;
                &lt;input class="mdl-textfield__input" type="text" id="username" ng-model="vm.formData.username" /&gt;
                &lt;label class="mdl-textfield__label" for="username"&gt;Username...&lt;/label&gt;
            &lt;/div&gt;
            &lt;div class="mdl-textfield"&gt;
                &lt;input class="mdl-textfield__input" type="password" id="password" ng-model="vm.formData.password" required /&gt;
                &lt;label class="mdl-textfield__label" for="password"&gt;Password...&lt;/label&gt;
            &lt;/div&gt;
            &lt;div class=""&gt;
                &lt;button generate-password class="mdl-button"&gt;generate&lt;/button&gt;
                &lt;button toggle-insert-view class="mdl-button"&gt;cancel&lt;/button&gt;
                &lt;button save-password class="mdl-button" ng-disabled="insertForm.$invalid"&gt;save&lt;/button&gt;
            &lt;/div&gt;
        &lt;/fieldset&gt;
    &lt;/form&gt;
&lt;/div&gt;

</code>

</pre>



<p>
  And now, let’s add the JavaScript logic to handle posting and saving of the form’s contents:
</p>



<pre>
  
  <code class="language-js">
  var loki = require('lokijs'),
    path = require('path');

angular
    .module('Utils', [])
    
    ...
    
    .service('Storage', ['$q', function($q) {
        this.db = new loki(path.resolve(__dirname, '../..', 'app.db'));
        this.collection = null;
        this.loaded = false;
        
        this.init = function() {
            var d = $q.defer();
            
            this.reload()
                .then(function() {
                    this.collection = this.db.getCollection('keychain');
                    d.resolve(this);
                }.bind(this))
                .catch(function(e) {
                    // create collection
                    this.db.addCollection('keychain');
                    // save and create file
                    this.db.saveDatabase();
                    
                    this.collection = this.db.getCollection('keychain');
                    d.resolve(this);
                }.bind(this));
                
                return d.promise;
        };
        
        this.addDoc = function(data) {
            var d = $q.defer();
            
            if(this.isLoaded() &amp;&amp; this.getCollection()) {
                this.getCollection().insert(data);
                this.db.saveDatabase();
                
                d.resolve(this.getCollection());
            } else {
                d.reject(new Error('DB NOT READY'));
            }
            
            return d.promise;
        };
    })
    
    .directive('savePassword', ['Storage', function(Storage) {
        return function(scope, el) {
            el.bind('click', function(e) {
                e.preventDefault();
                
                if(scope.vm.formData) {
                    Storage
                        .addDoc(scope.vm.formData)
                        .then(function() {
                           // reset form &amp; close insert window
                           scope.vm.formData = {};
                           ipc.send('toggle-insert-view');
                        });
                }
            });
        };
    }])

</code>

</pre>



<p>
  
  <strong>
  Key Points:
</strong>

</p>



<ul>
  
  
  <li>
    We first need to initialize the database. This process involves creating a new instance of the Loki Object, providing the path to the database file as an argument, looking up if that backup file exists, creating it if needed (including the ‘Keychain’ collection), and then loading the contents of this file in memory.
  </li>
  
  
  <li>
    We can retrieve a specific collection in the database with the 
    <code>
  getCollection()
</code>
   method.
 </li>
   
  
  <li>
    A collection object exposes several methods, including an 
    <code>
  insert()
</code>
   method, allowing us to add a new document to the collection.
 </li>
   
  
  <li>
    To persist the database contents to file, the Loki object exposes a 
    <code>
  saveDatabase()
</code>
   method.
 </li>
   
  
  <li>
    We will need to reset the form’s data and send an IPC event to tell the Main Process to close the window once the document is saved.
  </li>
  

</ul>



<p>
  We now have a simple form allowing us to generate and save new passwords. Let’s go back to the main view to list these entries.
</p>



<h3 id="listing-passwords">
  Listing Passwords
</h3>



<p>
  A few things need to happen here:
</p>



<ul>
  
  
  <li>
    We need to be able to get all the documents in our collection.
  </li>
  
  
  <li>
    We need to inform the main view whenever a new password is saved so it can refresh the view.
  </li>
  

</ul>



<p>
  We can retrieve the list of documents by calling the 
  <code>
getCollection()
</code>
 method on the Loki object. This method returns an object with a property called 
 <strong>
 data
</strong>
, which is simply an array of all the documents in that collection:
</p>



<pre>
  
  <code class="language-js">
  this.getCollection = function() {
    this.collection = this.db.getCollection('keychain');
    return this.collection;
};
        
this.getDocs = function() {
    return (this.getCollection()) ? this.getCollection().data : null;
};

</code>

</pre>



<p>
  We can then call the getDocs() in our Angular controller and retrieve all the passwords stored in the database, after we initialize it:
</p>



<pre>
  
  <code class="language-js">
  angular
    .module('MainView', ['Utils'])
    .controller('MainCtrl', ['Storage', function(Storage) {
        var vm = this;
        vm.keychain = null;
        
        Storage
            .init()
            .then(function(db) {
                vm.keychain = db.getDocs();
            });
    });     

</code>

</pre>



<p>
  A bit of Angular templating, and we have a password list:
</p>



<pre>
  
  <code class="language-html">
  &lt;tr ng-repeat="item in vm.keychain track by $index" class="item--{{$index}}"&gt;
    &lt;td class="mdl-data-table__cell--non-numeric"&gt;{{item.description}}&lt;/td&gt;
    &lt;td&gt;{{item.username || 'n/a'}}&lt;/td&gt;
    &lt;td&gt;
        &lt;span ng-repeat="n in [1,2,3,4,5,6]"&gt;&amp;bull;&lt;/span&gt;
    &lt;/td&gt;
    &lt;td&gt;
        &lt;a href="#" copy-password="{{$index}}"&gt;copy&lt;/a&gt;
        &lt;a href="#" remove-password="{{item}}"&gt;remove&lt;/a&gt;
    &lt;/td&gt;
&lt;/tr&gt;

</code>

</pre>



<p>
  
  <img src="https://assets.toptal.io/uploads/blog/image/91762/toptal-blog-image-1444917389172.2-a5aacb19dcc25c561422c7522d136a43.jpg" alt="" />

</p>



<p>
  A nice added feature would be to refresh the list of passwords after inserting a new one. For this, we can use Electron’s IPC module. As mentioned earlier, the Main Process’ IPC module can be called in a Renderer Process to turn it into a listener process, by using the remote module. Here is an example on how to implement it in 
  <code>
main.view.js
</code>
:
</p>



<pre>
  
  <code class="language-js">
  var remote = require('remote'),
    remoteIpc = remote.require('ipc');

angular
    .module('MainView', ['Utils'])
    .controller('MainCtrl', ['Storage', function(Storage) {
        var vm = this;
        vm.keychain = null;
        
        Storage
            .init()
            .then(function(db) {
                vm.keychain = db.getDocs();
                
                remoteIpc.on('update-main-view', function() {
                    Storage
                        .reload()
                        .then(function() {
                            vm.keychain = db.getDocs();
                        });
                });
            });
    }]);

</code>

</pre>



<p>
  
  <strong>
  Key Points:
</strong>

</p>



<ul>
  
  
  <li>
    We will need to use the remote module via its own 
    <code>
  require()
</code>
   method to require the remote IPC module from the Main Process.
 </li>
   
  
  <li>
    We can then setup our Renderer Process as an event listener via the 
    <code>
  on()
</code>
   method, and bind callback functions to these events.
 </li>
   

</ul>



<p>
  The insert view will then be in charge of dispatching this event whenever a new document is saved:
</p>



<pre>
  
  <code class="language-js">
  Storage
    .addDoc(scope.vm.formData)
    .then(function() {
        // refresh list in main view
        ipc.send('update-main-view');
        // reset form &amp; close insert window
        scope.vm.formData = {};
        ipc.send('toggle-insert-view');
    });

</code>

</pre>



<h3 id="copying-passwords">
  Copying Passwords
</h3>



<p>
  It is usually not a good idea to display passwords in plain text. Instead, we are going to hide and provide a convenience button allowing the end user to copy the password directly for a specific entry.
</p>



<p>
  Here again, Electron comes to our rescue by providing us with a 
  <a href="http://electron.atom.io/docs/v0.31.0/api/clipboard/">
clipboard
</a>
 module with easy methods to copy and paste not only text content, but also images and HTML code:
</p>
 


<pre>
  
  <code class="language-js">
  var clipboard = require('clipboard');

angular
    .module('Utils', [])
    
    ...
    
    .directive('copyPassword', [function() {
        return function(scope, el, attrs) {
            el.bind('click', function(e) {
                e.preventDefault();
                var text = (scope.vm.keychain[attrs.copyPassword]) ? scope.vm.keychain[attrs.copyPassword].password : '';
                // atom's clipboard module
                clipboard.clear();
                clipboard.writeText(text);
            });
        };
    }]);

</code>

</pre>



<p>
  Since the generated password will be a simple string, we can use the 
  <code>
writeText()
</code>
 method to copy the password to the system’s clipboard. We can then update our main view HTML, and add the copy button with the 
 <code>
 copy-password
</code>
 directive on it, providing the index of the array of passwords:
</p>
 


<pre>
  
  <code class="language-html">
  &lt;a href="#" copy-password="{{$index}}"&gt;copy&lt;/a&gt;

</code>

</pre>



<h3 id="removing-passwords">
  Removing Passwords
</h3>



<p>
  Our end users might also like to be able to delete passwords, in case they become obsolete. To do this, all we need to do is call the 
  <code>
remove()
</code>
 method on the keychain collection. We need to provide the entire doc to the ‘remove()’ method, as such:
</p>
 


<pre>
  
  <code class="language-js">
  this.removeDoc = function(doc) {
    return function() {
        var d = $q.defer();
        
        if(this.isLoaded() &amp;&amp; this.getCollection()) {
            // remove the doc from the collection &amp; persist changes
            this.getCollection().remove(doc);
            this.db.saveDatabase();
            
            // inform the insert view that the db content has changed
            ipc.send('reload-insert-view');
            
            d.resolve(true);
        } else {
            d.reject(new Error('DB NOT READY'));
        }
        
        return d.promise;
    }.bind(this);
};

</code>

</pre>



<blockquote>
  
  
  <p>
    Loki.js documentation states that we can also remove a doc by its id, but it does not seem to be working as expected.
  </p>
  

</blockquote>



<h2 id="creating-a-desktop-menu">
  Creating a Desktop Menu
</h2>



<p>
  Electron integrates seamlessly with our OS desktop environment to provide a “native” user experience look &amp; feel to our apps. Therefore, Electron comes bundled with a 
  <a href="http://electron.atom.io/docs/v0.31.0/api/menu/">
Menu module
</a>
, dedicated to creating complex desktop menu structures for our app.
</p>



<p>
  The menu module is a vast topic and almost deserves a tutorial of its own. I strongly recommend you read through 
  <a href="http://electron.atom.io/docs/v0.31.0/tutorial/desktop-environment-integration/">
Electron’s Desktop Environment Integration tutorial
</a>
 to discover all the features of this module.
</p>
 


<p>
  For the scope of this current tutorial, we will see how to create a custom menu, add a custom command to it, and implement the standard quit command.
</p>



<h3 id="creating--assigning-a-custom-menu-to-our-app">
  Creating &amp; Assigning a Custom Menu to Our App
</h3>



<p>
  Typically, the JavaScript logic for an Electron menu would belong in the main script file of our app, where our Main Process is defined. However, we can abstract it to a separate file, and access the Menu module via the remote module:
</p>



<pre>
  
  <code class="language-js">
  var remote = require('remote'),
    Menu = remote.require('menu');

</code>

</pre>



<p>
  To define a simple menu, we will need to use the 
  <code>
buildFromTemplate()
</code>
 method:
</p>
 


<pre>
  
  <code class="language-js">
  var appMenu = Menu.buildFromTemplate([
    {
        label: 'Electron',
        submenu: [{
            label: 'Credits',
            click: function() {
                alert('Built with Electron &amp; Loki.js.');
            }
        }]
    }
]);

</code>

</pre>



<p>
  The first item in the array is always used as the “default” menu item.
</p>



<blockquote>
  
  
  <p>
    The value of the 
    <code>
  label
</code>
   property does not matter much for the default menu item. In dev mode it will always display 
   <code>
   Electron
 </code>
  . We will see later how to assign a custom name to the default menu item during the build phase.
</p>
  

</blockquote>



<p>
  Finally, we need to assign this custom menu as the default menu for our app with the 
  <code>
setApplicationMenu()
</code>
 method:
</p>
 


<pre>
  
  <code class="language-js">
  Menu.setApplicationMenu(appMenu);

</code>

</pre>



<h3 id="mapping-keyboard-shortcuts">
  Mapping Keyboard Shortcuts
</h3>



<p>
  Electron provides “
  <a href="https://github.com/atom/electron/blob/master/docs/api/accelerator.md">
accelerators
</a>
”, a set of pre-defined strings that map to actual keyboard combinations, e.g.: 
<code>
Command+A
</code>
 or 
 <code>
 Ctrl+Shift+Z
</code>
.
</p>



<blockquote>
  
  
  <p>
    The 
    <code>
  Command
</code>
   accelerator does not work on Windows or Linux.
For our password keychain application, we should add a 
<code>
File
</code>
 menu item, offering two commands:
</p>
 

</blockquote>



<ul>
  
  
  <li>
    
    <strong>
    Create Password
  </strong>
  : open the insert view with 
  <em>
  Cmd (or Ctrl) + N
</em>

</li>
  
  
  <li>
    
    <strong>
    Quit
  </strong>
  : quit the app altogether with 
  <em>
  Cmd (or Ctrl) + Q
</em>

</li>
  

</ul>



<pre>
  
  <code class="language-js">
  ...
{
    label: 'File',
    submenu: [
        {
            label: 'Create Password',
            accelerator: 'CmdOrCtrl+N',
            click: function() {
                ipc.send('toggle-insert-view');
            }
        },
        {
            type: 'separator' // to create a visual separator
        },
        {
            label: 'Quit',
            accelerator: 'CmdOrCtrl+Q',
            selector: 'terminate:' // OS X only!!!
        }
    ]
}
...

</code>

</pre>



<p>
  
  <strong>
  Key Points:
</strong>

</p>



<ul>
  
  
  <li>
    We can add a visual separator by adding an item to the array with the 
    <code>
  type
</code>
   property set to 
   <code>
   separator
 </code>
  .
</li>
  
  
  <li>
    The 
    <code>
  CmdOrCtrl
</code>
   accelerator is compatible with both Mac and PC keyboards
 </li>
   
  
  <li>
    The 
    <code>
  selector
</code>
   property is OSX-compatible only!
 </li>
   

</ul>



<h2 id="styling-our-app">
  Styling Our App
</h2>



<p>
  You probably noticed throughout the various code examples references to class names starting with 
  <code>
mdl-
</code>
. For the purpose of this tutorial I opted to use the 
<a href="http://www.getmdl.io/">
Material Design Lite
</a>
 UI framework, but feel free to use any UI framework of your choice.
</p>
 


<p>
  Anything that we can do with HTML5 can be done in Electron; just keep in mind the growing size of the app’s binaries, and the resulting performance issues that may occur if you use too many third-party libraries.
</p>



<h2 id="packaging-electron-apps-for-distribution">
  Packaging Electron Apps for Distribution
</h2>



<p>
  You made an Electron app, it looks great, you wrote your e2e tests with 
  <a href="http://electron.atom.io/docs/v0.31.0/tutorial/using-selenium-and-webdriver/">
Selenium and WebDriver
</a>
, and you are ready to distribute it to the world!
</p>



<p>
  But you still want to personalize it, give it a custom name other than the default “Electron”, and maybe also provide custom application icons for both Mac and PC platforms.
</p>



<h3 id="building-with-gulp">
  Building with Gulp
</h3>



<p>
  These days, there is a 
  <a href="http://gulpjs.com/">
Gulp
</a>
 plugin for anything we can think of. All I had to do is type 
 <code>
 gulp electron
</code>
 in Google, and sure enough there is a 
 <a href="https://github.com/mainyaa/gulp-electron">
 gulp-electron
</a>
 plugin!
</p>
 


<p>
  This plugin is fairly 
  <a href="https://www.toptal.com/nodejs/an-introduction-to-automation-with-gulp">
easy to use
</a>
 as long as the folder structure detailed at the beginning of this tutorial was maintained. If not, you might have to move things around a bit.
</p>
 


<p>
  This plugin can be installed like any other Gulp plugin:
</p>



<pre>
  
  <code class="language-shell">
  $ npm install gulp-electron --save-dev

</code>

</pre>



<p>
  And then we can define our Gulp task as such:
</p>



<pre>
  
  <code class="language-js">
  var gulp = require('gulp'),
    electron = require('gulp-electron'),
    info = require('./src/package.json');

gulp.task('electron', function() {
    gulp.src("")
    .pipe(electron({
        src: './src',
        packageJson: info,
        release: './dist',
        cache: './cache',
        version: 'v0.31.2',
        packaging: true,
        platforms: ['win32-ia32', 'darwin-x64'],
        platformResources: {
            darwin: {
                CFBundleDisplayName: info.name,
                CFBundleIdentifier: info.bundle,
                CFBundleName: info.name,
                CFBundleVersion: info.version
            },
            win: {
                "version-string": info.version,
                "file-version": info.version,
                "product-version": info.version
            }
        }
    }))
    .pipe(gulp.dest(""));
});

</code>

</pre>



<p>
  
  <strong>
  Key Points:
</strong>

</p>



<ul>
  
  
  <li>
    the 
    <code>
  src/
</code>
   folder cannot be the same as the folder where the Gulpfile.js is, nor the same folder as the distribution folder.
 </li>
   
  
  <li>
    We can define the platforms we wish to export to via the 
    <code>
  platforms
</code>
   array.
 </li>
   
  
  <li>
    We should define a 
    <code>
  cache
</code>
   folder, where the Electron binaries will be download so they can be packaged with our app.
 </li>
   
  
  <li>
    The contents of the app’s package.json file need to be passed to the gulp task via the 
    <code>
  packageJson
</code>
   property.
 </li>
   
  
  <li>
    There is an optional 
    <code>
  packaging
</code>
   property, allowing us to also create zip archives of the generated apps.
 </li>
   
  
  <li>
    For each platform, there is a different set of “platform resources” that 
    <a href="https://github.com/mainyaa/gulp-electron#options">
  can be defined
</a>
  .
</li>
  

</ul>



<h4 id="adding-app-icons">
  Adding App Icons
</h4>



<p>
  One of the 
  <code>
platformResources
</code>
 properties is the 
 <code>
 icon
</code>
 property, allowing us to define a custom icon for our app:
</p>
 


<pre>
  
  <code class="language-js">
  "icon": "keychain.ico"

</code>

</pre>



<blockquote>
  
  
  <p>
    OS X requires icons with the 
    <code>
  .icns
</code>
   file extension. There are multiple online tools allowing us to convert 
   <code>
   .png
 </code>
   files into 
   <code>
   .ico
 </code>
   and 
   <code>
   .icns
 </code>
   for free.
 </p>
   

</blockquote>



<h2 id="conclusion">
  Conclusion
</h2>



<p>
  In this article we have only scratched the surface of what Electron can actually do. Think of great apps like Atom or 
  <a href="https://slack.com/apps">
Slack
</a>
 as a source of inspiration where you can go with this tool.
</p>
 


<p>
  I hope you found this tutorial useful, please feel free to leave your comments and share your experiences with Electron!
</p>

</body>

</html>
