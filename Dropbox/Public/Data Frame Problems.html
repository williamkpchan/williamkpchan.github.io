
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
  a {text-decoration: none}
  A:hover { color: yellow }
  A:focus { color: red }
 #newtype { color: pink}
 #brownword { color: #ff8000}
}
</STYLE>
</head>
<body bgcolor="#000000" text="#109030" leftmargin="10" topmargin="10" marginwidth="100" link="#08C8A8" vlink="#389898" alink="#28B8B8" target=_blank>
<FONT size=3>

<h1>Easy Solutions To Your Data Frame Problems In R</h1>

<p>R's data frames regularly create somewhat of a furor on public forums like Stack Overflow and Reddit. Starting R users often experience problems with the data frame in R and it doesn't always seem to be straightforward. But does it really need to be so?
Well, not necessarily.
With today's post, <a href="https://www.datacamp.com/?utm_source=data_frame_tutorial_post&amp;utm_medium=blog&amp;utm_campaign=data_frame_post">DataCamp</a> wants to show you that data frames don't need to be hard: we offer you 15 easy, straightforward solutions to the most frequently occurring problems with data.frame. These issues have been selected from the most recent and sticky or upvoted <a href="http://stackoverflow.com/">Stack Overflow</a> posts. If, however, you are more interested in getting an elaborate introduction to data frames, you might consider taking a look at our <a href="https://www.datacamp.com/courses/free-introduction-to-r?utm_source=data_frame_tutorial_post&amp;utm_medium=blog&amp;utm_campaign=data_frame_post" target="_blank">Introduction to R tutorial</a>.</p>

<p></p>
<h4>TOC</h4>
The Root: What's A Data Frame?<br>
The Basics Of Data Frames: The Questions And Solutions<br>
&emsp;How To Create A Simple Data Frame in R<br>
&emsp;How To Change A Data Frame's Row And Column Names<br>
&emsp;How To Check A Data Frame's Dimensions<br>
&emsp;How To Access And Change A Data Frame's Values<br>
&emsp;&emsp;The Variable Names<br>
&emsp;&emsp;The [,] and $ Notations<br>
&emsp;Why And How To Attach Data Frames<br>
&emsp;How To Apply Functions To Data Frames<br>
Surpassing The Data Frame Basics: More Questions, More Answers<br>
&emsp;How To Create An Empty Data Frame<br>
&emsp;How To Extract Rows And Colums, Subseting Your Data Frame<br>
&emsp;How To Remove Columns And Rows From A Data Frame<br>
&emsp;How To Add Rows And Columns To A Data Frame<br>
&emsp;Why And How To Reshape A Data Frame From Wide To Long Format And Vice Versa<br>
&emsp;&emsp;Using <code>stack()</code> For Simply Structured Data Frames<br>
&emsp;&emsp;Using <code>reshape()</code> For Complex Data Frames<br>
&emsp;&emsp;Reshaping Data Frames With <code>tidyr</code><br>
&emsp;&emsp;Reshaping Data Frames With <code>reshape2</code><br>
&emsp;How To Sort A Data Frame<br>
&emsp;&emsp;R's Built-In <code>Order()</code> Function<br>
&emsp;&emsp;Sorting With <code>dplyr</code><br>
&emsp;How To Merge Data Frames<br>
&emsp;&emsp;Merging Data Frames On Column Names<br>
&emsp;&emsp;What If… (Some Of) The Data Frame's Column Values Are Different?<br>
&emsp;&emsp;What If… Both Data Frames Have The Same Column Names?<br>
&emsp;&emsp;What If… The Data Frames' Column Names Are Different?<br>
&emsp;&emsp;Merging Data Frames On Row Names<br>
&emsp;How To Remove Data Frames' Rows And Columns With NA-Values<br>
&emsp;How To Convert Lists Or Matrices To Data Frames And Back<br>
&emsp;&emsp;From Lists or Matrices To Data Frames<br>
&emsp;&emsp;Changing A Data Frame To A Matrix Or List<br>
<p></p>

<h2>The Root: What's A Data Frame?</h2>

<p>
R's data frames offer you a great first step by allowing you to store your data in overviewable, rectangular grids. Each row of these grids corresponds to measurements or values of an instance, while each column is a vector containing data for a specific variable.
This means that a data frame's rows do not need to contain, but can contain, the same type of values: they can be numeric, character, logical, etc.; As you can see in the data frame below, each instance, listed in the first unnamed column with a number, has certain characteristics that are spread out over the remaining three columns. Each column needs to consist of values of the same type, since they are data vectors: as such, the <code>breaks</code> column only contains numerical values, while the <code>wool</code> and <code>tension</code> columns have characters as values that are stored as factors.
In case you're wondering, this data frame lists the number of breaks in yarn during weaving.</p>

<p></p>

<p></p>

<p class="border"><strong>Remember</strong> that factors are variables that can only contain a limited number of different values. As such, they are often called categorical variables.</p>

<p></p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">head(warpbreaks)
</code></pre>

<p></p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   breaks wool tension
## 1     26    A       L
## 2     30    A       L
## 3     54    A       L
## 4     25    A       L
## 5     70    A       L
## 6     52    A       L
</code></pre>

<p>
Maybe you will have already noticed that data frames ressemble matrices, except for the fact that their data values don't need to be of the same type, while matrices do require this. Data frames also have similarities with lists, which are basically collections of components. A data frame, however, is a list with vector structures of the same length. As such, data frames can actually be seen as special types of lists and can be accessed as either a matrix or a list.
If you want more information or if you just want to review and take a look at a comparison of the five general data structures in R, watch the small video below:<a href="https://vimeo.com/130411487" target="_blank"><img alt="Screenshot 2015-06-11 15.14.06" class="wp-image-594 size-full aligncenter" height="322" src="http://blog.datacamp.com/wp-content/uploads/2015/06/Screenshot-2015-06-11-15.14.06.png" width="571"></a>
As you can see, there are different data structures that impose different requirements on how the data is stored. Data frames are handy to store multiple data vectors, which makes it easier to organize your data, to apply functions to it and to save your work. It's almost similar to having a single spreadsheet with elements that all have equal lengths!</p>

<p></p>

<p></p>

<h2>The Basics Of Data Frames: The Questions And Solutions</h2>

<p></p>

<p></p>

<h3>How To Create A Simple Data Frame in R</h3>

<p>
Even though looking at built-in data frames such as <code>esoph</code> is interesting, it can easily get more exciting!
How?
By making your own data frame in R, of course! You can do this very easily by making some vectors first:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">Died.At &lt;- c(22,40,72,41)
Writer.At &lt;- c(16, 18, 36, 36)
First.Name &lt;- c("John", "Edgar", "Walt", "Jane")
Second.Name &lt;- c("Doe", "Poe", "Whitman", "Austen")
Sex &lt;- c("MALE", "MALE", "MALE", "FEMALE")
Date.Of.Death &lt;- c("2015-05-10", "1849-10-07", "1892-03-26","1817-07-18")
</code></pre>

<p>
Next, you just combine the vectors that you made with the <code>data.frame()</code> function:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">writers_df &lt;- data.frame(Died.At, Writer.At, First.Name, Second.Name, Sex, Date.Of.Death)
</code></pre>

<p></p>

<p></p>

<p class="border"><strong>Remember</strong> that data frames must have variables of the same length. Check if you have put an equal number of arguments in all <code>c()</code> functions that you assign to the vectors and that you have indicated strings of words with <code>""</code>.</p>

<p></p>

<p></p>

<p class="border"><strong>Note</strong> that when you use the <code>data.frame()</code> function, character variables are imported as factors or categorical variables. Use the <code>str()</code> function to get to know more about your data frame.</p>

<p></p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">str(writers_df)
</code></pre>

<p></p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">## 'data.frame':    4 obs. of  6 variables:
##  $ Died.At      : num  22 40 72 41
##  $ Writer.At    : num  16 18 36 36
##  $ First.Name   : Factor w/ 4 levels "Edgar","Jane",..: 3 1 4 2
##  $ Second.Name  : Factor w/ 4 levels "Austen","Doe",..: 2 3 4 1
##  $ Sex          : Factor w/ 2 levels "FEMALE","MALE": 2 2 2 1
##  $ Date.Of.Death: Factor w/ 4 levels "1817-07-18","1849-10-07",..: 4 2 3 1
</code></pre>

<p></p>

<p></p>

<p class="border"><strong>Note</strong> that if you're more interested in inspecting the first and the last lines of your data frame, you can use the <code>head()</code> and <code>tail()</code> functions, respectively.</p>

<p>
You see that the <code>First.Name</code>, <code>Second.Name</code>, <code>Sex</code> and <code>Date.Of.Death</code> variables of the <code>writers_df</code> data frame have all been read in as factors. But do you want this?</p>

<p></p>

<p></p>

<ul>
	<li>For the variables <code>First.Name</code> and <code>Second.Name</code>, you don't want this. You can use the <code>I()</code> function to insulate them. This function inhibits the interpretation of its arguments. In other words, by just slightly changing the definitions of the vectors <code>First.Name</code> and <code>Second.Name</code> with the addition of the <code>I()</code> function, you can make sure that the proper names are not interpreted as factors.</li>
	
	<li>You can keep the <code>Sex</code> vector as a factor, because there are only a limited amount of possible values that this variable can have.</li>
	
	<li>Also for the variable <code>Date.of.Death</code> you don't want to have a factor. It would be better if the values are registered as dates. You can add the <code>as.Date()</code> function to this variable to make sure this happens.</li>
	
	
	 
</ul>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">Died.At &lt;- c(22,40,72,41)
Writer.At &lt;- c(16, 18, 36, 36)
First.Name &lt;- I(c("John", "Edgar", "Walt", "Jane"))
Second.Name &lt;- I(c("Doe", "Poe", "Whitman", "Austen"))
Sex &lt;- c("MALE", "MALE", "MALE", "FEMALE")
Date.Of.Death &lt;- as.Date(c("2015-05-10", "1849-10-07", "1892-03-26","1817-07-18"))
writers_df &lt;- data.frame(Died.At, Writer.At, First.Name, Second.Name, Sex, Date.Of.Death)
str(writers_df)
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">## 'data.frame':    4 obs. of  6 variables:
##  $ Died.At      : num  22 40 72 41
##  $ Writer.At    : num  16 18 36 36
##  $ First.Name   :Class 'AsIs'  chr [1:4] "John" "Edgar" "Walt" "Jane"
##  $ Second.Name  :Class 'AsIs'  chr [1:4] "Doe" "Poe" "Whitman" "Austen"
##  $ Sex          : Factor w/ 2 levels "FEMALE","MALE": 2 2 2 1
##  $ Date.Of.Death: Date, format: "2015-05-10" "1849-10-07" ...
</code></pre>

<p>
If you use other functions such as <code>read.table()</code> or other functions that are used to input data, such as <code>read.csv()</code> and <code>read.delim()</code>, a data frame is returned as the result. This way, files that look like this one below or files that have other delimiters, will be converted to data frames once they are read into R with these functions.</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">22, 16, John, Doe, MALE, 2015-05-10
40, 18, Edgar, Poe, MALE, 1849-10-07
72, 36, Walt, Whitman, MALE, 1892-03-26
41, 36, Jane, Austen, FEMALE, 1817-07-18
</code></pre>

<p>
If you want to know more about how you can read and import Excel files into R, make sure to check out our <a href="http://blog.datacamp.com/r-tutorial-read-excel-into-r/?utm_source=data_frame_tutorial_post&amp;utm_medium=blog&amp;utm_campaign=data_frame_post">tutorial</a>! Alternatively, you could check out the <a href="http://www.rdocumentation.org/packages/utils/functions/read.table">Rdocumentation page on <code>read.table</code></a>.</p>

<p></p>

<p></p>

<h3>How To Change A Data Frame's Row And Column Names</h3>

<p>
Data frames can also have a names attribute, by which you can see the names of the variables that you have included into your data frame. In other words, you can also set the header for your data frame. You already did this before when making the data frame object <code>writers_df</code>; You see that the names of the variables <code>Died.At</code>, <code>Writer.At</code>, <code>First.Name</code>, <code>Second.Name</code>, <code>Sex</code> and <code>Date.Of.Death</code> appear:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">writers_df
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Died.At Writer.At First.Name Second.Name    Sex Date.Of.Death
## 1      22        16       John         Doe   MALE    2015-05-10
## 2      40        18      Edgar         Poe   MALE    1849-10-07
## 3      72        36       Walt     Whitman   MALE    1892-03-26
## 4      41        36       Jane      Austen FEMALE    1817-07-18
</code></pre>

<p>
You can also retrieve the names with the <code>names()</code> function:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">names(writers_df)
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">## [1] "Died.At"       "Writer.At"     "First.Name"    "Second.Name"
## [5] "Sex"           "Date.Of.Death"
</code></pre>

<p>
Now that you see the names of your data frame, you're not so sure if these are efficient or correct. To change the names that appear, you can easily continue using the <code>names()</code> function. Make sure, though, that you have a number of arguments in the <code>c()</code> function that is equal to the number of variables that you have included into your data frame. In this case, since there are six variables <code>Died.At</code>, <code>Writer.At</code>, <code>First.Name</code>, <code>Second.Name</code>, <code>Sex</code> and <code>Death</code>, you want six arguments in the <code>c()</code> function. Otherwise, the other variables will be interpreted as “NA”.</p>

<p></p>

<p></p>

<p class="border"><strong>Note</strong> also how the arguments of the <code>c()</code> function are inputted as strings!</p>

<p></p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">names(writers_df) &lt;- c("Age.At.Death", "Age.As.Writer", "Name", "Surname", "Gender", "Death")
names(writers_df)
</code></pre>

<p></p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">## [1] "Age.At.Death"  "Age.As.Writer" "Name"          "Surname"
## [5] "Gender"        "Death"
</code></pre>

<p></p>

<p></p>

<p class="border"><strong>Tip:</strong> try to leave out the two last arguments from the <code>c()</code> function and see what happens!</p>

<p><strong>Note</strong> that you can also access and change the column and row names of your data frame with the functions <code>colnames()</code> and <code>rownames()</code>, respectively:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">colnames(writers_df) = c("Age.At.Death", "Age.As.Writer", "Name", "Surname", "Gender", "Death")
rownames(writers_df) = c("ID1", "ID2", "ID3", "ID4")
</code></pre>

<p></p>

<p></p>

<h3>How To Check A Data Frame's Dimensions</h3>

<p>
As you know, the data frame is similar to a matrix, which means that its size is determined by how many rows and columns you have combined into it. To check how many rows and columns you have in your data frame, you can use the <code>dim()</code> function:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">dim(writers_df)
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">## [1] 4 6
</code></pre>

<p>
The result of this function is represented as <code>[1] 4 6</code>. Just like a matrix, the data frame's dimensions are defined by the number of rows, followed by the number of columns. If you are in doubt, you can check your numbers through a comparison with the original data frame!<strong>Note</strong> that you can also just retrieve the number of rows or columns by entering</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">dim(writers_df)[1] #Number of rows
dim(writers_df)[2] #Number of columns
</code></pre>

<p>
or by using the functions <code>nrow()</code> and <code>ncol()</code>, to retrieve the number of rows or columns, respectively:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">nrow(writers_df)
ncol(writers_df)
</code></pre>

<p>
Since the data frame structure is also similar to a list, you could also use the <code>length()</code> function to retrieve the number of rows:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">length(writers_df)
</code></pre>

<p></p>

<p></p>

<h3>How To Access And Change A Data Frame's Values</h3>

<p></p>

<p></p>

<h4>…. Through The Variable Names</h4>

<p>
Now that we have retrieved and set the names of our data frame, we want to take a closer look at the values that are actually stored in it. There are two straightforward ways that you can access these values. First, you can try to access them by just entering the data frame's name in combination with the variable name:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">writers_df$Age.As.Writer
</code></pre>

<p><em>Note</em> that if you change one of the values in the vector <code>Age</code> that this change will not be incorporated into the data frame:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">Writer.At[1]=2
writers_df
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Age.At.Death Age.As.Writer  Name Surname Gender      Death
## 1           22            16  John     Doe   MALE 2015-05-10
## 2           40            18 Edgar     Poe   MALE 1849-10-07
## 3           72            36  Walt Whitman   MALE 1892-03-26
## 4           41            36  Jane  Austen FEMALE 1817-07-18
</code></pre>

<p>
In the end, with this method of accessing the values, you just create a copy of a certain variable! That's why any changes to the variables do not change the data frame's variables.</p>

<p></p>

<p></p>

<h4>… Through The [,] and $ Notations</h4>

<p>
You can also access the data frame's values by using the [,] notation:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">writers_df [1:2,3] #Value located on the first and second row, third column
</code></pre>

<p>
gives</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">## [1] "John"  "Edgar"
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">writers_df[, 3] #Values located in the third column
</code></pre>

<p>
gives</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">## [1] "John"  "Edgar" "Walt"  "Jane"
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">writers_df[3,] #Values located in the third row
</code></pre>

<p>
gives</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Age.At.Death Age.As.Writer Name Surname Gender      Death
## 3           72            36 Walt Whitman   MALE 1892-03-26
</code></pre>

<p></p>

<p></p>

<p class="border"><strong>Remember</strong> that data frames' dimensions are defined as rows by columns.</p>

<p>
An alternative to the [,] notation is a notation with <code>$</code>:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">writers_df$Age.At.Death
</code></pre>

<p>
gives</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">## [1] 22 40 72 41
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">writers_df$Age.At.Death[3] #Value located on third row of the column `Age.At.Death`
</code></pre>

<p>
gives</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">## [1] 72
</code></pre>

<p><strong>Note</strong> that you can also change the values of your data frame by simply using these notations to perform mathematical operations:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">writers_df$Age.At.Death &lt;- writers_df$Age.At.Death-1
writers_df[,1] &lt;- writers_df$Age.At.Death-1
</code></pre>

<p>
If you really want to make your hands dirty some more and change some of the data frame's values, you can use the [,] notation to actually change the values inside your data frame one by one:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">writers_df[1,3] = "Jane"
writers_df[1,5] = "FEMALE"
writers_df
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Age.At.Death Age.As.Writer  Name Surname Gender      Death
## 1           22            16  Jane     Doe FEMALE 2015-05-10
## 2           40            18 Edgar     Poe   MALE 1849-10-07
## 3           72            36  Walt Whitman   MALE 1892-03-26
## 4           41            36  Jane  Austen FEMALE 1817-07-18
</code></pre>

<p></p>

<p></p>

<h3>Why And How To Attach Data Frames</h3>

<p>
The $ notation is pretty handy, but it can become very annoying when you have to type it each time that you want to work with your data. The <code>attach()</code> function offers a solution to this: it takes a data frame as an argument and places it in the search path at position 2. So unless there are variables in position 1 that are exactly the same as the ones from the data frame you have inputted, the variables from your data frame are considered as variables that can be immediately called on.<strong>Note</strong> that the search path is in fact the order in which R accesses files. You can look this up by entering the <code>search()</code> function:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">search()
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##  [1] ".GlobalEnv"         "package:knitr"      "package:RWordPress"
##  [4] "package:REmails"    "package:RJSONIO"    "package:httr"
##  [7] "writers_df"         "env:itools"         "package:data.table"
## [10] "package:RDatabases" "package:RMySQL"     "package:DBI"
## [13] "package:yaml"       "package:dplyr"      "tools:rstudio"
## [16] "package:stats"      "package:graphics"   "package:grDevices"
## [19] "package:utils"      "package:datasets"   "package:methods"
## [22] "Autoloads"          "package:base"
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">attach(writers_df)
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">## The following objects are masked _by_ .GlobalEnv:
##
##     Age.As.Writer, Age.At.Death, Death, Gender, Name, Surname
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">writers_df
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Age.At.Death Age.As.Writer  Name Surname Gender      Death
## 1           22            16  Jane     Doe FEMALE 2015-05-10
## 2           40            18 Edgar     Poe   MALE 1849-10-07
## 3           72            36  Walt Whitman   MALE 1892-03-26
## 4           41            36  Jane  Austen FEMALE 1817-07-18
</code></pre>

<p><strong>Note</strong> that you can alternatively use the <code>with()</code> function to attach the data frame, but that this requires you to specify some more arguments:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">with(writers_df, c("Age.At.Death", "Age.As.Writer", "Name", "Surname", "Gender", "Death"))
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">## [1] "Age.At.Death"  "Age.As.Writer" "Name"          "Surname"
## [5] "Gender"        "Death"
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">writers_df
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Age.At.Death Age.As.Writer  Name Surname Gender      Death
## 1           22            16  Jane     Doe FEMALE 2015-05-10
## 2           40            18 Edgar     Poe   MALE 1849-10-07
## 3           72            36  Walt Whitman   MALE 1892-03-26
## 4           41            36  Jane  Austen FEMALE 1817-07-18
</code></pre>

<p>
You can now safely execute the following command and you can actually access/change the values of all the data frame's variables:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">Age.At.Death
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">## [1] 22 40 72 41
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">Age.At.Death &lt;- Age.At.Death-1
Age.At.Death
</code></pre>

<p>
If you get an error that tells you that “The following objects are masked <em>by</em> .GlobalEnv:”, this is because you have objects in your global environment that have the same name as your data frame. Those objects could be the vectors that you created above, if you didn't change their names. You have two solutions to this:</p>

<p></p>

<p></p>

<ol>
	<li>You just don't create any objects with those names in your global environment. This is more a solution for those of you who imported their data through <code>read.table()</code>, <code>read.csv()</code> or <code>read.delim()</code>, but not really appropriate for this case.</li>
	
	<li>You rename the objects in the data frame so that there's no conflict. This is the solution that was applied in this tutorial. So, rename your columns with the <code>names()</code> or <code>colnames()</code> functions.</li>
	
	
	 
</ol>

<p></p>

<p></p>

<p class="border"><strong>Note</strong> that if all else fails, you can just remember to always refer to your data frame's column names with the $ notation!</p>

<p></p>

<p></p>

<p></p>

<h3>How To Apply Functions To Data Frames</h3>

<p>
Now that you have successfully made and modified your data frame by putting a header in place, you can start applying functions to it! In some cases where you want to calculate stuff, you might want to put the numeric data in a separate data frame:</p>

<p></p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">Ages &lt;- writers_df[,1:2]
</code></pre>

<p>
Only then can you start to get, for example, the mean and the median of your numeric data. You can do this with the <code>apply()</code> function. The first argument of this function should be your smaller data frame, in this case, <code>age</code>. The second argument designates what data you want to consider for the calculations of the mean or median: columns or rows. In this case, we want to calculate the median and mean of the variables <code>Age.At.Death</code> and <code>Age.As.Writer</code>, which designate columns in the data frame. The last argument then specifies the exact calculations that you want to do on your data:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">apply(Ages, 2, median)
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##  Age.At.Death Age.As.Writer
##          40.5          27.0
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">apply(Ages,1,median)
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">## [1] 19.0 29.0 54.0 38.5
</code></pre>

<p>
or</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">apply(Ages, 2, mean)
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##  Age.At.Death Age.As.Writer
##         43.75         26.50
</code></pre>

<p>
Do you want to know more about the <code>apply()</code> function and how to use it? Check out our <a href="https://www.datacamp.com/courses/intermediate-r?utm_source=data_frame_tutorial_post&amp;utm_medium=blog&amp;utm_campaign=data_frame_post">Intermediate R</a> course, which teaches you, amongst other things, how to make your R code more efficient and readable using this function.</p>

<p></p>

<p></p>

<h2>Surpassing The Data Frame Basics: More Questions, More Answers</h2>

<p>
Now that you have been introduced to the basic pitfalls of data frames, it's time to look at some problems, questions or difficulties that you might have while working with data frames more intensively.</p>

<p></p>

<p></p>

<h3>How To Create An Empty Data Frame</h3>

<p>
The easiest way to create an empty data frame is probably by just assigning a <code>data.frame()</code> function without any arguments to a vector:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">ab &lt;- data.frame()
ab
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">## data frame with 0 columns and 0 rows
</code></pre>

<p>
You can then start filling your data frame up by using the [,] notation. Be careful, however, because it's easy to make errors while doing this!<strong>Note</strong> how you don't see any column names in this empty data set. If you do want to have those, you can just initialize empty vectors in your data frame, like this:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">Age &lt;- numeric()
Name &lt;- character()
ID &lt;- integer()
Gender &lt;- factor()
Date &lt;- as.Date(character())
ab &lt;- data.frame(c(Age, Name, ID, Gender, Date))
ab
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">## [1] c.Age..Name..ID..Gender..Date.
## &lt;0 rows&gt; (or 0-length row.names)
</code></pre>

<p></p>

<p></p>

<h3>How To Extract Rows And Colums, Subseting Your Data Frame</h3>

<p>
Subsetting or extracting specific rows and columns from a data frame is an important skill in order to surpass the basics that have been introduced in step two, because it allows you to easily manipulate smaller sets of your original data frame. You basically extract those values from the rows and columns that you need in order to optimize the data analyses you make.
It's easy to start subsetting with the [,] notation that was described in step two:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">writer_names_df &lt;- writers_df[1:4, 3:4]
writer_names_df
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##    Name Surname
## 1  Jane     Doe
## 2 Edgar     Poe
## 3  Walt Whitman
## 4  Jane  Austen
</code></pre>

<p><em>Note</em> that you can also define this subset with the variable names:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">writer_names_df &lt;- writers_df[1:4, c("Name", "Surname")]
</code></pre>

<p></p>

<p></p>

<p class="border"><strong>Tip:</strong> be careful when you are subsetting just one column!</p>

<p>
R has the tendency to simplify your results, which means that it will read your subset as a vector, which normally, you don't want to get. To make sure that this doesn't happen, you can add the argument <code>drop=FALSE</code>:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">writer_names_df &lt;- writers_df[1:4, "Name", drop=FALSE]
str(writer_names_df)
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">## 'data.frame':    4 obs. of  1 variable:
##  $ Name:Class 'AsIs'  chr [1:4] "Jane" "Edgar" "Walt" "Jane"
</code></pre>

<p>
In a next step, you can try subsetting with the <code>subset()</code> function:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">writer_names_df &lt;- subset(writers_df, Age.At.Death &lt;= 40 &amp; Age.As.Writer &gt;= 18)
writer_names_df
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Age.At.Death Age.As.Writer  Name Surname Gender      Death
## 2           40            18 Edgar     Poe   MALE 1849-10-07
</code></pre>

<p>
You can also subset on a particular value:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">writer_names_df &lt;- subset(writers_df, Name =="Jane")
writer_names_df
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Age.At.Death Age.As.Writer Name Surname Gender      Death
## 1           22            16 Jane     Doe FEMALE 2015-05-10
## 4           41            36 Jane  Austen FEMALE 1817-07-18
</code></pre>

<p>
You can not only subset with the R functions that have been described above. You can also turn to <code>grep()</code> to get the job done. For example, if you want to work with the rows in the column <code>Age.At.Death</code> that have values that contain “4”, you can use the following line of code:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">fourty_writers &lt;- writers_df[grep("4", writers_df$Age.At.Death),]
fourty_writers
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Age.At.Death Age.As.Writer  Name Surname Gender      Death
## 2           40            18 Edgar     Poe   MALE 1849-10-07
## 4           41            36  Jane  Austen FEMALE 1817-07-18
</code></pre>

<p><strong>Note</strong> that by subsetting, you basically stop considering certain values of your data frame. This might mean that you remove certain features of a factor, by, for example, only considering the <code>MALE</code> members of the <code>writers_df</code> data frame. Notice how all factor levels of this column still remain present, even though you have created a subset:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">male_writers &lt;- writers_df[Gender =="MALE",]
str(male_writers)
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">## 'data.frame':    0 obs. of  6 variables:
##  $ Age.At.Death : num
##  $ Age.As.Writer: num
##  $ Name         :Class 'AsIs'  chr(0)
##  $ Surname      :Class 'AsIs'  chr(0)
##  $ Gender       : Factor w/ 2 levels "FEMALE","MALE":
##  $ Death        :Class 'Date'  num(0)
</code></pre>

<p>
To remove the factor levels that are no longer present, you can enter the following line of code:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">factor(Gender)</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">## factor(0)
## Levels:</code></pre>

<p></p>

<p></p>

<h3>How To Remove Columns And Rows From A Data Frame</h3>

<p>
If you want to remove values or entire columns from your data frame, you can assign a <code>NULL</code> value to the desired unit:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">writers_df[1,3] &lt;- NULL
Age.At.Death &lt;- NULL
</code></pre>

<p>
To remove rows, the procedure is a bit more complicated. You define a new vector in which you list for every row whether to have it included or not. Then, you apply this vector to your data frame:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">rows_to_keep &lt;- c(TRUE, FALSE, TRUE, FALSE)
limited_writers_df &lt;- writers_df[rows_to_keep,]
limited_writers_df
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Age.At.Death Age.As.Writer Name Surname Gender      Death
## 1           22            16 Jane     Doe FEMALE 2015-05-10
## 3           72            36 Walt Whitman   MALE 1892-03-26
</code></pre>

<p><strong>Note</strong> that you can also do the opposite by just adding <code>!</code>, stating that the reverse is true:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">less_writers_df &lt;- writers_df[!rows_to_keep,]
less_writers_df
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Age.At.Death Age.As.Writer  Name Surname Gender      Death
## 2           40            18 Edgar     Poe   MALE 1849-10-07
## 4           41            36  Jane  Austen FEMALE 1817-07-18
</code></pre>

<p>
You can also work with thresholds. For example, you can specify that you only want to keep all writers that were older than fourty when they died:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">fourty_sth_writers &lt;- writers_df[writers_df$Age.At.Death &gt; 40,]
fourty_sth_writers
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Age.At.Death Age.As.Writer Name Surname Gender      Death
## 3           72            36 Walt Whitman   MALE 1892-03-26
## 4           41            36 Jane  Austen FEMALE 1817-07-18
</code></pre>

<p></p>

<p></p>

<h3>How To Add Rows And Columns To A Data Frame</h3>

<p>
Much in the same way that you used the [,] and $ notations to access and change single values of your data frame, you can also easily add columns to your data frame:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">writers_df$Location &lt;- c("Belgium", "United Kingdom", "United States", "United Kingdom")
</code></pre>

<p>
Appending rows to an existing data frame is somewhat more complicated. To easily do this by first making a new row in a vector, respecting the column variables that have been defined in <code>writers_df</code> and by then binding this row to the original data frame with the <code>rbind()</code> function:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">new_row &lt;- c(50, 22, "Roberto", "Bolano", "MALE", "2003-07-15")
writers_df_large &lt;- rbind(writers_df, new_row)
</code></pre>

<p></p>

<p></p>

<h3>Why And How To Reshape A Data Frame From Wide To Long Format And Vice Versa</h3>

<p>
When you have multiple values, spread out over multiple columns, for the same instance, your data is in the “wide” format. On the other hand, when your data is in the “long” format if there is one observation row per variable. You therefore have multiple rows per instance. Let's illustrate this with an example. Long data looks like this:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">Subject &lt;- c(1,2,1,2,2,1)
Gender &lt;- c("M", "F", "M", "F", "F","M")
Test &lt;- c("Read", "Write", "Write", "Listen", "Read", "Listen")
Result &lt;- c(10, 4, 8, 6, 7, 7)
observations_long &lt;- data.frame(Subject, Gender, Test, Result)
observations_long
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Subject Gender   Test Result
## 1       1      M   Read     10
## 2       2      F  Write      4
## 3       1      M  Write      8
## 4       2      F Listen      6
## 5       2      F   Read      7
## 6       1      M Listen      7
</code></pre>

<p>
As you can see, there is one row for each value that you have in the <code>Test</code> variable. A lot of statistical tests favor this format.
This data frame would look like the following in the wide format:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">Subject &lt;- c(1,2)
Gender &lt;- c("M", "F")
Read &lt;- c(10, 7)
Write &lt;-c(8, 4)
Listen &lt;- c(7, 6)
observations_wide &lt;- data.frame(Subject, Gender, Read, Write, Listen)
observations_wide
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Subject Gender Read Write Listen
## 1       1      M   10     8      7
## 2       2      F    7     4      6
</code></pre>

<p>
You see that each column represents a unique pairing of the various factors with the values.
Since different functions may require you to input your data either in “long” or “wide” format, you might need to reshape your data set. There are two main options that you can choose here: you can use the <code>stack()</code> function or you can try using the <code>reshape()</code> function. The former is preferred when you work with simple data frames, while the latter is more often used on more complex data frames, mostly because there's a difference in the possibilities that both functions offer.
Make sure to keep on reading to know more about the differences in possibilities between the <code>stack()</code> and <code>reshape()</code> functions!</p>

<p></p>

<p></p>

<h4>Using <code>stack()</code> For Simply Structured Data Frames</h4>

<p>
The <code>stack()</code> function basically concatenates or combines multiple vectors into a single vector, along with a factor that indicates where each observation originates from.
To go from wide to long format, you will have to stack your observations, since you want one observation row per variable, with multiple rows per variable. In this case, you want to merge the columns <code>Read</code>, <code>Write</code> and <code>Listen</code> together, qua names and qua values:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">long_format &lt;- stack(observations_wide,
                     select=c(Read,
                              Write,
                              Listen))
long_format
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   values    ind
## 1     10   Read
## 2      7   Read
## 3      8  Write
## 4      4  Write
## 5      7 Listen
## 6      6 Listen
</code></pre>

<p>
To go from long to wide format, you will need to unstack your data, which makes sense because you want to have one row per instance with each value present as a different variable. Note here that you want to disentangle the <code>Result</code> and <code>Test</code> columns:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">wide_format &lt;- unstack(observations_long,
                       Result ~ Test)
wide_format
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Listen Read Write
## 1      6   10     4
## 2      7    7     8
</code></pre>

<p></p>

<p></p>

<h4>Using <code>reshape()</code> For Complex Data Frames</h4>

<p>
This function is part of the <code>stats</code> package. This function is similar to the <code>stack()</code> function, but is a little bit more elaborate. Read and see for yourself how reshaping your data works with the <code>reshape()</code> function:
To go from a wide to a long data format, you can first start off by entering the <code>reshape()</code> function. The first argument should always be your original wide data set. In this case, you can specify that you want to input the <code>observations_wide</code> to be converted to a long data format.
Then, you start adding other arguments to the <code>reshape()</code> function:</p>

<p></p>

<p></p>

<ol>
	<li>Include a list of variable names that define the different measurements through <code>varying</code>. In this case, you store the scores of specific tests in the columns “Read”, “Write” and “Listen”.</li>
	
	<li>Next, add the argument<code>v.names</code> to specify the name that you want to give to the variable that contains these values in your long dataset. In this case, you want to combine all scores for all reading, writing and listening tests into one variable <code>Score</code>.</li>
	
	<li>You also need to give a name to the variable that describes the different measurements that are inputted with the argument <code>timevar</code>. In this case, you want to give a name to the column that contains the types of tests that you give to your students. That's why this column's name should be called “Test”.</li>
	
	<li>Then, you add the argument <code>times</code>, because you need to specify that the new column “Test” can only take three values, namely, the test components that you have stored: “Read”, “Write”, “Listen”.</li>
	
	<li>You're finally there! Give in the end format for the data with the argument <code>direction</code>.</li>
	
	<li>Additionally, you can specify new row names with the argument <code>new.row.names</code>.</li>
	
	
	 
</ol>

<p></p>

<p></p>

<p class="border"><strong>Tip:</strong> try leaving out this last argument and see what happens!</p>

<p></p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">library(stats)
long_reshape &lt;- reshape(observations_wide,
             varying = c("Read", "Write", "Listen"),
             v.names = "Score",
             timevar = "Test",
             times = c("Read", "Write", "Listen"),
             direction = "long",
             new.row.names = 1:1000)
long_reshape
</code></pre>

<p></p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Subject Gender   Test Score id
## 1       1      M   Read    10  1
## 2       2      F   Read     7  2
## 3       1      M  Write     8  1
## 4       2      F  Write     4  2
## 5       1      M Listen     7  1
## 6       2      F Listen     6  2
</code></pre>

<p>
From long to wide, you take sort of the same steps. First, you take the <code>reshape()</code> function and give it its first argument, which is the data set that you want to reshape. The other arguments are as follows:</p>

<p></p>

<p></p>

<ol>
	<li>
	<code>timevar</code> allows you to specify that the variable <code>Test</code>, which describes the different tests that you give to your students, should be decomposed.</li>
	
	<li>You also specify that the <code>reshape()</code> function shouldn't take into account the variables <code>Subject</code> and <code>Gender</code> of the original data set. You put these column names into <code>idvar</code>.</li>
	
	<li>By not naming the variable <code>Result</code>, the <code>reshape()</code> function will know that both <code>Test</code> and <code>Result</code> should be recombined.</li>
	
	<li>You specify the direction of the reshaping, which is in this case, <code>wide</code>!</li>
	
	
	 
</ol>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">wide_reshape &lt;- reshape(observations_long,
                        timevar = "Test",
                        idvar = c("Subject", "Gender"),
                        direction = "wide")
wide_reshape
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Subject Gender Result.Read Result.Write Result.Listen
## 1       1      M          10            8             7
## 2       2      F           7            4             6
</code></pre>

<p></p>

<p></p>

<p class="border"><strong>Note</strong> that if you want you can also rename or sort the results of these new long and wide data formats! You can find detailed instructions below.</p>

<p></p>

<p></p>

<p></p>

<h4>Reshaping Data Frames With <code>tidyr</code>
</h4>

<p>
This package allows you to “easily tidy data with the <code>spread()</code> and <code>gather()</code> functions” and that's exactly what you're going to do if you use this package to reshape your data!
If you want to convert from wide to long format, the principle stays similar to the one that of <code>reshape()</code>: you use the <code>gather()</code> function and you start specifying its arguments:
1. Your data set is the first argument to the <code>gather()</code> function
2. Then, you specify the name of the column in which you will combine the the values of <code>Read</code>, <code>Write</code> and <code>Listen</code>. In this case, you want to call it something like <code>Test</code> or <code>Test.Type</code>.
3. You enter the name of the column in which all the values of the <code>Read</code>, <code>Write</code> and <code>Listen</code> columns are listed.
4. You indicate which columns are supposed to be combined into one. In this case, that will be the columns from <code>Read</code>, to <code>Listen</code>.</p>

<p></p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">library(tidyr)
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">long_tidyr &lt;- gather(observations_wide,
                     Test,
                     Result,
                     Read:Listen)
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">long_tidyr
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##     Subject Gender   Test Result
## 1       1      M   Read     10
## 2       2      F   Read      7
## 3       1      M  Write      8
## 4       2      F  Write      4
## 5       1      M Listen      7
## 6       2      F Listen      6
</code></pre>

<p><strong>Note</strong> how this the last argument specifies the columns in the same way as you did to subset your data frame or to select your data frame's columns in which you wanted to perform mathematical operations. You can also just specify the columns individually like this:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">long_tidyr &lt;- gather(observations_wide,
                     Test,
                     Result,
                     Read,
                     Write,
                     Listen)
</code></pre>

<p>
The opposite direction, from long to wide format, is very similar to the function above, but this time with the <code>spread()</code> function:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">library(tidyr)
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">wide_tidyr &lt;- spread(observations_long,
                     Test,
                     Result)
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">wide_tidyr
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##    Subject Gender Listen Read Write
## 1       1      M      7   10     8
## 2       2      F      6    7     4
</code></pre>

<p>
Again, you take as the first argument your data set. Then, you specify the column that contains the new column names. In this case, that is <code>Test</code>. Lastly, you input the name of the column that contains the values that should be put into the new columns.</p>

<p></p>

<p></p>

<p></p>

<p></p>

<h4>Reshaping Data Frames With <code>reshape2</code>
</h4>

<p>
This package, which allows you to “flexibly reshape data”, actually has very straightforward ways of reshaping your data frame.
To go from a wide to a long data format, you use the <code>melt()</code> function. This function is pretty easy, since it just takes your data set and the <code>id.vars</code> argument, which you may already know from the <code>reshape()</code> function. This argument allows you to specify which columns should be left alone by the function.</p>

<p></p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">library(reshape2)
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##
## Attaching package: 'reshape2'
##
## The following objects are masked from 'package:data.table':
##
##     dcast, melt
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">long_reshaped2 &lt;- melt(observations_wide,
                       id.vars=c("Subject", "Gender"))
long_reshaped2
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Subject Gender variable value
## 1       1      M     Read    10
## 2       2      F     Read     7
## 3       1      M    Write     8
## 4       2      F    Write     4
## 5       1      M   Listen     7
## 6       2      F   Listen     6
</code></pre>

<p><strong>Note</strong> that this function allows you to specify a couple more arguments:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">library(reshape2)
long_reshaped2 &lt;- melt(observations_wide,
                       id.vars=c("Subject", "Gender"),
                       measure.vars=c("Read", "Write", "Listen"),
                       variable.name="Test",
                       value.name="Result")
long_reshaped2
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Subject Gender   Test Result
## 1       1      M   Read     10
## 2       2      F   Read      7
## 3       1      M  Write      8
## 4       2      F  Write      4
## 5       1      M Listen      7
## 6       2      F Listen      6
</code></pre>

<p></p>

<p></p>

<ul>
	<li>
	<code>measure.vars</code> is there to name the destination column that will combine the original columns. If you leave out this argument, the <code>melt()</code> function will use all other variables as the <code>id.vars</code>.</li>
	
	<li>
	<code>variable.name</code> specifies how you want to name that destination column. If you don't specify this argument, you will have a column named “variable” in your result.</li>
	
	<li>
	<code>value.name</code> allows you to input the name of the column in which the values or test results will be stored. If you leave out this argument, this column will be named “measurement”.</li>
	
	
	 
</ul>

<p>
You can also go from a long to a wide format with the <code>reshape2</code> package with the <code>dcast()</code> function. This is fairly easy: you first give in your data set, as always. Then, you combine the columns which you don't want to be touched; In this case, you want to keep <code>Subject</code> and <code>Gender</code> as they are. The column <code>Test</code> however, you want to split! So, that is the second part of your second argument, indicated by a <code>~</code>. The last argument of this function is <code>value.var</code>, which holds the values of the different tests. You want to name this new column <code>Result</code>:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">library(reshape2)
long_reshaped2 &lt;- dcast(observations_long,
                        Subject + Gender ~ Test,
                        value.var="Result")
long_reshaped2
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Subject Gender Listen Read Write
## 1       1      M      7   10     8
## 2       2      F      6    7     4
</code></pre>

<p></p>

<p></p>

<h3>How To Sort A Data Frame</h3>

<p>
Sorting a data frame by columns might seem tricky, but this can be made easy by either using R's built-in <code>order()</code> function or by using a package.</p>

<p></p>

<p></p>

<h4>R's Built-In <code>Order()</code> Function</h4>

<p>
You can for example sort by one of the dataframe's columns. You order the rows of the data frame according to the values that are stored in the variable <code>Age.As.Writer</code>:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">writers_df[order(writers_df$Age.As.Writer),]
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Age.At.Death Age.As.Writer  Name Surname Gender      Death
## 1           22            16  Jane     Doe FEMALE 2015-05-10
## 2           40            18 Edgar     Poe   MALE 1849-10-07
## 3           72            36  Walt Whitman   MALE 1892-03-26
## 4           41            36  Jane  Austen FEMALE 1817-07-18
</code></pre>

<p>
If you want to sort the values starting from high to low, you can just add the extra argument <code>decreasing</code>, which can only take logical values. Another way is to add the function <code>rev()</code> so that it includes the <code>order()</code> function.</p>

<p></p>

<p></p>

<p class="border"><strong>Remember</strong> that logical values are <code>TRUE</code> or <code>FALSE</code>, respectively.</p>

<p></p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">writers_df[order(writers_df$Age.As.Writer, decreasing=TRUE),]
</code></pre>

<p></p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">writers_df[rev(order(writers_df$Age.As.Writer)),]
</code></pre>

<p>
You can also add a <code>-</code> in front of the <strong>numeric</strong> variable that you have given to order on.</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">writers_df[order(-writers_df$Age.As.Writer),]
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Age.At.Death Age.As.Writer  Name Surname Gender      Death
## 3           72            36  Walt Whitman   MALE 1892-03-26
## 4           41            36  Jane  Austen FEMALE 1817-07-18
## 2           40            18 Edgar     Poe   MALE 1849-10-07
## 1           22            16  Jane     Doe FEMALE 2015-05-10
</code></pre>

<p></p>

<p></p>

<h4>Sorting With <code>dplyr</code>
</h4>

<p>
The dplyr package, known for its abilities to manipulate data, has a specific function that allows you to sort rows by variables.
Dplyr's function to make this happen is <code>arrange()</code>. The first argument of this function is the data set that you want to sort, while the second and third arguments are the variables that you choose to sort. In this case we sort first on the variable <code>Age.At.Death</code> and then on <code>Age.As.Writer</code>.</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">data2 &lt;- arrange(writers_df, Age.At.Death, Age.As.Writer)
data2
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Age.At.Death Age.As.Writer  Name Surname Gender      Death
## 1           22            16  Jane     Doe FEMALE 2015-05-10
## 2           40            18 Edgar     Poe   MALE 1849-10-07
## 3           41            36  Jane  Austen FEMALE 1817-07-18
## 4           72            36  Walt Whitman   MALE 1892-03-26
</code></pre>

<p>
You can also use the following approach to get the same result:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">writers_df[with(writers_df, order(Age.At.Death, Age.As.Writer)), ]
</code></pre>

<p>
If you want to sort these columns in descending order, you can add the function <code>desc()</code> to the variables:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">desc_sorted_data &lt;- arrange(writers_df, desc(Age.At.Death))
</code></pre>

<p>
Interested in doing much more with the dplyr package? Check out our <a href="https://www.datacamp.com/courses/dplyr-data-manipulation-r-tutorial?utm_source=data_frame_tutorial_post&amp;utm_medium=blog&amp;utm_campaign=data_frame_post">Data Manipulation in R with dplyr</a> course, which will teach you how to to perform sophisticated data manipulation tasks using dplyr! Also, don't forget to look at the <a href="http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf">“Data Wrangling With dplyr And tidyr Cheat Sheet”</a>!</p>

<p></p>

<p></p>

<h3>How To Merge Data Frames</h3>

<p></p>

<p></p>

<h4>Merging Data Frames On Column Names</h4>

<p>
You can use the <code>merge()</code> function to join two, but only two, data frames. Let's say we have a data frame <code>data2</code>, which has the same values stored in a variable <code>Age.At.Death</code>, which we also find in <code>writers_df</code>, with exactly the same values. You thus want to merge the two data frames on the basis of this variable:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">data2 &lt;- data.frame(Age.At.Death=c(22,40,72,41), Location=5:8)
</code></pre>

<p>
We can easily merge these two:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">new_writers_df &lt;- merge(writers_df, data2)
new_writers_df
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Age.At.Death Age.As.Writer  Name Surname Gender      Death Location
## 1           22            16  Jane     Doe FEMALE 2015-05-10        5
## 2           40            18 Edgar     Poe   MALE 1849-10-07        6
## 3           41            36  Jane  Austen FEMALE 1817-07-18        8
## 4           72            36  Walt Whitman   MALE 1892-03-26        7
</code></pre>

<p></p>

<p></p>

<p class="border"><strong>Tip:</strong> check what happens if you change the order of the two arguments of the <code>merge()</code> function!</p>

<p>
This way of merging is equivalent to an outer join in SQL.
Unfortunately, you're not always this lucky with your data frames. In many cases, some of the columns names or variable values will differ, which makes it hard to follow the easy, standard procedure that was described just now. In addition, you may not always want to merge in the standard way that was described above. In the following, some of the most common issues are listed and solved!</p>

<p></p>

<p></p>

<h4>What If… (Some Of) The Data Frame's Column Values Are Different?</h4>

<p>
If (some of) the values of the variable on which you merge differ in the data frames, you have a small problem, because the <code>merge()</code> function supposes that these are the same so that any new variables that are present in the second data frame can be added correctly to the first data frame. Consider the following data frame:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">data2 &lt;- data.frame(x.Age.At.Death=c(21,39,71,40), Location=5:8)
</code></pre>

<p>
You see that the values for the attribute <code>Age.At.Death</code> do not fit with the ones that were defined for the <code>writers_df</code> data frame.
No worries, the <code>merge()</code> function provides extra arguments to solve this problem. The argument <code>all.x</code> allows you to specify to add the extra rows of the <code>Location</code> variable to the resulting data frame, even though this column is not present in <code>writers_df</code>. In this case, the values of the <code>Location</code> variable will be added to the <code>writers_df</code> data frame for those rows of which the values of the <code>Age.At.Death</code> attribute correspond. All rows where the <code>Age.At.Death</code> of the two data frames don't correspond, will be filled up with <code>NA</code> values.<strong>Note</strong> that this join corresponds to a left outer join in SQL and that the default value of the <code>all.x</code> argument is <code>FALSE</code>, which means that one normally only takes into account the corresponding values of the merging variable. Compare with:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">merge(writers_df, data2, all.x=FALSE)
</code></pre>

<p>
You can also specify the argument <code>all.y=TRUE</code> if you want to add extra rows for each row that <code>data2</code> has no matching row in <code>writers_df</code>:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">merge(writers_df, data2, all.y=TRUE)
</code></pre>

<p></p>

<p></p>

<p class="border"><strong>Note</strong> that this type of join corresponds to a right outer join in SQL.</p>

<p></p>

<p></p>

<p></p>

<h4>What If… Both Data Frames Have The Same Column Names?</h4>

<p>
What if your two data frames have exactly the same two variables, with or without the same values?</p>

<p></p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">data2 &lt;- data.frame(Age.At.Death=c(21,39,71,40), Age.As.Writer=c(11,25,36,28))
</code></pre>

<p>
You can chose to keep all values from all corresponding variables and to add rows to the resulting data frame:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">merge(writers_df, data2, all=TRUE)
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Age.At.Death Age.As.Writer  Name Surname Gender      Death
## 1           21            11  &lt;NA&gt;    &lt;NA&gt;   &lt;NA&gt;       &lt;NA&gt;
## 2           22            16  Jane     Doe FEMALE 2015-05-10
## 3           39            25  &lt;NA&gt;    &lt;NA&gt;   &lt;NA&gt;       &lt;NA&gt;
## 4           40            18 Edgar     Poe   MALE 1849-10-07
## 5           40            28  &lt;NA&gt;    &lt;NA&gt;   &lt;NA&gt;       &lt;NA&gt;
## 6           41            36  Jane  Austen FEMALE 1817-07-18
## 7           71            36  &lt;NA&gt;    &lt;NA&gt;   &lt;NA&gt;       &lt;NA&gt;
## 8           72            36  Walt Whitman   MALE 1892-03-26
</code></pre>

<p>
Or you can just chose to add values from one specific variable for which the ages of death correspond:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">merge(writers_df, data2, by="Age.At.Death")
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Age.At.Death Age.As.Writer.x  Name Surname Gender      Death
## 1           40              18 Edgar     Poe   MALE 1849-10-07
##   Age.As.Writer.y
## 1              28
</code></pre>

<p></p>

<p></p>

<h4>What If… The Data Frames' Column Names Are Different?</h4>

<p>
Lastly, what if the variable's names on which you merge differ in the two data frames?</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">data2 &lt;- data.frame(Age=c(22,40,72,41), Location=5:8)
</code></pre>

<p>
You just specify in the <code>merge()</code> function that there are two other specifications through the arguments <code>by.x</code> and <code>by.y</code>.</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">merge(writers_df, data2, by.x="Age.At.Death", by.y="Age")
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">#   Age.At.Death Age.As.Writer  Name Surname Gender      Death Location
## 1           22            16  Jane     Doe FEMALE 2015-05-10        5
## 2           40            18 Edgar     Poe   MALE 1849-10-07        6
## 3           41            36  Jane  Austen FEMALE 1817-07-18        8
## 4           72            36  Walt Whitman   MALE 1892-03-26        7
</code></pre>

<p></p>

<p></p>

<h4>Merging Data Frames On Row Names</h4>

<p>
You can indeed merge the columns of two data frames, that contain a distinct set of columns but some rows with the same names. The <code>merge()</code> function and its arguments come to the rescue!
Consider this second data frame:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">Address &lt;- c("50 West 10th", "77 St. Marks Place", "778 Park Avenue")
Maried &lt;- c("YES", "NO", "YES")
limited_writers_df &lt;- data.frame(Address, Maried)
limited_writers_df
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##              Address Maried
## 1       50 West 10th    YES
## 2 77 St. Marks Place     NO
## 3    778 Park Avenue    YES
</code></pre>

<p>
You see that this data set contains three rows, marked with numbers 1 to 3, and two additional columns that are not in the <code>writers_df</code> data frame. To merge these two data frames, we add the argument <code>by</code> to the <code>merge()</code> function and set it at the number 0, which specifies the row names. Since you choose to keep all values from all corresponding variables and to add columns to the resulting data frame, you set the <code>all</code> argument to <code>TRUE</code>:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">writers_row_sorted &lt;- merge(writers_df, limited_writers_df, by=0, all=TRUE)
writers_row_sorted
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Row.names Age.At.Death Age.As.Writer  Name Surname Gender      Death
## 1         1           22            16  Jane     Doe FEMALE 2015-05-10
## 2         2           40            18 Edgar     Poe   MALE 1849-10-07
## 3         3           72            36  Walt Whitman   MALE 1892-03-26
## 4         4           41            36  Jane  Austen FEMALE 1817-07-18
##              Address Maried
## 1       50 West 10th    YES
## 2 77 St. Marks Place     NO
## 3    778 Park Avenue    YES
## 4               &lt;NA&gt;   &lt;NA&gt;
</code></pre>

<p>
It could be that the fields for rows that don't occur in both data frames result in NA-values. You can easily solve this by removing them. This will be discussed below.</p>

<p></p>

<p></p>

<h3>How To Remove Data Frames' Rows And Columns With NA-Values</h3>

<p>
To remove all rows that contain NA-values, one of the easiest options is to use the <code>na.omit()</code> function, which takes your data frame as an argument. Let's recycle the code from the previous section in which two data frames were merged, with a lot of resulting NA-values:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">data2 &lt;- data.frame(Age.At.Death=c(21,39,71,40), Location=5:8)
merge &lt;- merge(writers_df, data2, all.y=TRUE)
na.omit(merge)
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Age.At.Death Age.As.Writer  Name Surname Gender      Death Location
## 3           40            18 Edgar     Poe   MALE 1849-10-07        8
</code></pre>

<p>
If you just want to select part of your data frame from which you want to remove the NA-values, it's better to use <code>complete.cases()</code>. In this case, you're interested to keep all rows for which the values of the columns <code>Age.As.Writer</code> and <code>Name</code> are complete:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">data2 &lt;- data.frame(Age.At.Death=c(21,39,71,40), Location=5:8)
merge &lt;- merge(writers_df, data2, all.y=TRUE)
merge[complete.cases(merge[,2:3]),]
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   Age.At.Death Age.As.Writer  Name Surname Gender      Death Location
## 3           40            18 Edgar     Poe   MALE 1849-10-07        8
</code></pre>

<p></p>

<p></p>

<h3>How To Convert Lists Or Matrices To Data Frames And Back</h3>

<p></p>

<p></p>

<h4>From Lists or Matrices To Data Frames</h4>

<p>
Lists or matrices that comply with the restrictions that the data frame imposes can be coerced into data frames with the <code>as.data.frame()</code> function. Remember that a data frame is similar to the structure of a matrix, where the columns can be of different types. Data frames are also similar to lists, where each column is an element of the list and each element has the same length. Any matrices or lists that you want to convert to data frames need to satisfy with these restrictions.
For example, the matrix A can be converted to a data frame because each column contains values of the numeric data type:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">A = matrix(c(2, 4, 3, 1, 5, 7), nrow=2, ncol=3, byrow = TRUE)
A
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##      [,1] [,2] [,3]
## [1,]    2    4    3
## [2,]    1    5    7
</code></pre>

<p>
You enter the matrix A as an argument to the <code>as.data.frame()</code> function:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">A_df &lt;- as.data.frame(A)
A_df
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##   V1 V2 V3
## 1  2  4  3
## 2  1  5  7
</code></pre>

<p>
You can follow the same procedures for lists like the one that is shown below:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">n = c(2, 3, 5)
s = c("aa", "bb", "cc")
b = c(TRUE, FALSE, TRUE)
x = list(n, s, b, 3)
x_df &lt;- as.data.frame(x)
</code></pre>

<p></p>

<p></p>

<h4>Changing A Data Frame To A Matrix Or List</h4>

<p>
To make the opposite move, that is, to convert data frames to matrices and lists, you first have to check for yourself if this is possible. Does you data frame contain one or more dimensions and what about the amount of data types? Rewatch the small animation of the introduction if you're not sure what data structure to pick.
Once you have an answer, you can use the functions <code>as.matrix()</code> and <code>as.list()</code> to convert your data frame to a matrix or a list, respectively:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">writers_matrix &lt;- as.matrix(writers_df)
writers_matrix
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">##      Age.At.Death Age.As.Writer Name    Surname   Gender   Death
## [1,] "22"         "16"          "Jane"  "Doe"     "FEMALE" "2015-05-10"
## [2,] "40"         "18"          "Edgar" "Poe"     "MALE"   "1849-10-07"
## [3,] "72"         "36"          "Walt"  "Whitman" "MALE"   "1892-03-26"
## [4,] "41"         "36"          "Jane"  "Austen"  "FEMALE" "1817-07-18"
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">writers_list &lt;- as.list(writers_df)
writers_list
</code></pre>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">## $Age.At.Death
## [1] 22 40 72 41
##
## $Age.As.Writer
## [1] 16 18 36 36
##
## $Name
## [1] "Jane"  "Edgar" "Walt"  "Jane"
##
## $Surname
## [1] "Doe"     "Poe"     "Whitman" "Austen"
##
## $Gender
## [1] FEMALE MALE   MALE   FEMALE
## Levels: FEMALE MALE
##
## $Death
## [1] "2015-05-10" "1849-10-07" "1892-03-26" "1817-07-18"
</code></pre>

<p>
For those of you who want to specifically make numeric matrices, you can use the function <code>data.matrix()</code> or add an <code>sapply()</code> function to the <code>as.matrix()</code> function:</p>

<p></p>

<p></p>

<pre class="pre-no-padding">
<code class="r">writers_matrix &lt;- data.matrix(writers_df)
writers_matrix &lt;- as.matrix(sapply(writers_df, as.numeric))
</code></pre>

<p></p>

<p></p>

<p class="border"><strong>Note</strong> that with the current <code>writers_df</code> data frame, which contains a mixture of data types, NA-values will be introduced in the resulting matrices.</p>

<p></p>

<p></p>

<p></p>

<h2>From Data Frames To Data Analysis, Data Manipulation and Data Visualization</h2>

<p>
Data frames are just the beginning of your data analysis! There is much more to see and know about data frames and the other R data structures. If this tutorial has gotten you thrilled to dig deeper into programming with R, make sure to check out our free interactive <a href="https://www.datacamp.com/courses/free-introduction-to-r?utm_source=data_frame_tutorial_post&amp;utm_medium=blog&amp;utm_campaign=data_frame_post">Introduction to R</a> course. Those of you who are already more advanced with R and that want to take their skills to a higher level might be interested in our courses on data manipulation and data visualization. Go to our <a href="https://www.datacamp.com/courses?utm_source=data_frame_tutorial_post&amp;utm_medium=blog&amp;utm_campaign=data_frame_post">course overview</a> and take a look!</p>

<div class="row"><h3 class="text-center">Up Next</h3></div>
    <div class="row">
				<div class="col-sm-6">
					
<section class="col-sm-12" data-tag-ids="[2, 6]">
  <div class="card post tutorial-card card-primary-extralight" data-href="/community/tutorials/the-importance-of-preprocessing-in-data-science-and-the-machine-learning-pipeline-iii-scaling-your-data-to-combat-noise">
      <div class="post-header">
        <a class="b0 p0 m0 text-primary" href="/community/tutorials/the-importance-of-preprocessing-in-data-science-and-the-machine-learning-pipeline-iii-scaling-your-data-to-combat-noise"><h1>The importance of preprocessing in data science and the machine learning pipeline III:  scaling your data to combat noise</h4></a>

    <div class="description">
      <p>
      In two previous posts, I explored the role of preprocessing data in the machine learning pipeline. In particular, I checked out the k-Nearest Neighbors (k-NN) and  logistic regression algorithms and saw how scaling numerical data strongly influenced the performance of the former but not that of the latter, as measured... <a href="/community/tutorials/the-importance-of-preprocessing-in-data-science-and-the-machine-learning-pipeline-iii-scaling-your-data-to-combat-noise" class="more">Read More</a>
      </p>
    </div>
  </div>
</section>

				</div>
				<div class="col-sm-6">
					
<section class="col-sm-12" data-tag-ids="[2, 6]">
  <div class="card post tutorial-card card-primary-extralight" data-href="/community/tutorials/the-importance-of-preprocessing-in-data-science-and-the-machine-learning-pipeline-ii-centering-scaling-and-logistic-regression">
      <div class="post-header">
        <a class="b0 p0 m0 text-primary" href="/community/tutorials/the-importance-of-preprocessing-in-data-science-and-the-machine-learning-pipeline-ii-centering-scaling-and-logistic-regression"><h1>The importance of preprocessing in data science and the machine learning pipeline II: centering, scaling and logistic regression</h4></a>
    <div class="description">
      <p>
      In the  first article in this series, I explored the role of preprocessing in machine learning (ML) classification tasks, with a deep dive into the k-Nearest Neighbours algorithm (k-NN) and the  wine quality dataset. There you saw that centering and scaling numerical data improved the performance of k-NN for a... <a href="/community/tutorials/the-importance-of-preprocessing-in-data-science-and-the-machine-learning-pipeline-ii-centering-scaling-and-logistic-regression" class="more">Read More</a>
      </p>
    </div>
  </div>
</section>
