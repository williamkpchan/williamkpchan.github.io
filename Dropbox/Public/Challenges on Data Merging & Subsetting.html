https://www.analyticsvidhya.com/blog/2016/06/9-challenges-data-merging-subsetting-r-python-beginner/?utm_source=feedburner&utm_medium=email&utm_campaign=Feed%3A+AnalyticsVidhya+%28Analytics+Vidhya%29

<base target="_blank">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">


<style type="text/css">
a {	text-decoration: none;}
A:hover {	color: yellow;}
A:focus {	color: red;}
#newtype { color: pink}
#redpink { color: #cc0099}
#redword { color: red}
#yellowword { color: yellow}
#greenword { color: green}
#limeword { color: #00ff00}
#orangeword { color: orange}
#cyanword { color: cyan}
#whiteword { color: white}
#grayword { color: gray}
#brownword { color: #ff8000}
#yellowgreen { color: #bfff00}
#palered { color: #ffcccc}
#goldword { color: GoldenRod}
.left {
    position: absolute;
    left: 100px;
    color: GoldenRod;
    border: 1px solid GoldenRod;
    padding: 2px;
    font-size: 60%;
}
.bord {
    color: redpink;
    border: 1px solid GoldenRod;
    padding: 1px;
    font-size: 90%;
}
.highlight { 
    color: white;
    background-color: #002030
  }
</STYLE>

</head>
<body bgcolor="#000000" text="#109030" leftmargin="10" topmargin="10" marginwidth="100" link="#08C8A8" vlink="#389898" alink="#28B8B8">
<FONT size=3>

<h1>9 Challenges on Data Merging and Subsetting in R &amp; Python (for beginners)</h1>

<h2>Introduction</h2>
<p style="text-align: justify;">Juggling with multiple data sets is a common task for a data scientist. And, it&#8217;s immensely important for a beginner or intermediate to learn this skill.</p>
<p style="text-align: justify;">I got the idea of writing this article from the past <a href="http://datahack.analyticsvidhya.com">data science competitions</a>. Many a times, people end up getting undesirable NA values while combining or subsetting data sets. If it still happens with you, don&#8217;t freak out. You just have to practice these challenges well and you won&#8217;t get any NAs again.</p>
<p style="text-align: justify;">After you finish these challenges successfully, it is expected that you will become proficient at manipulating data frames, merging multiple data sets to perform several basic operations on data frame(s). For your convenience, I&#8217;ve used R and Python to demonstrate the operations. Also, I&#8217;ve given 4 practice exercises.</p>
<p style="text-align: justify;">P.S &#8211; For fun, I&#8217;ve used a dummy data set from a popular TV Series named &#8216;Game of Thrones&#8217;. If you are crazy about it, great! If not, you will still find it easy to understand.</p>
<p style="text-align: justify;">Data set for every challenge is available for <a href="https://www.analyticsvidhya.com/wp-content/uploads/2016/06/Challenges.zip" target="_blank" rel="nofollow">download here</a>.</p>

<h2>Table of Contents</h2>
<ul>
<li>Challenge 1: Adding More Observations</li>
<li>Challenge 2: Dropping Observations</li>
<li>Challenge 3: Adding Column(s) Horizontally</li>
<li>Challenge 4: Adding Column(s) based on common attribute</li>
<li>Challenge 5: Adding Column(s) based on observation serial (index)</li>
<li>Challenge 6: Removing Duplicate Observations</li>
<li>Challenge 7: Dropping Columns</li>
<li>Challenge 8: Modifying Value(s) of a DataFrame</li>
<li>Challenge 9: Renaming Column Name(s)</li>
</ul>
<p>Before starting with the challenges, make sure you&#8217;ve <a href="https://www.analyticsvidhya.com/wp-content/uploads/2016/06/Challenges.tar-1.gz" target="_blank" rel="nofollow">downloaded the data</a>.</p>
<p>&nbsp;</p>
<h2>Challenge 1 : Adding more observations</h2>
<h3 style="text-align: justify;">i) In Structured Data Set</h3>
<p style="text-align: justify;">We have a dummy data set from Game of Thrones named <code><strong>house</strong></code>. It contains information about various clans (houses). Think of <em>houses</em> as families. Let&#8217;s say, two new houses have emerged whose information is contained in the data set <code><strong>house_extra</strong></code>.</p>
<p><strong>Task:</strong> To include the houses in <em>house_extra</em> in the data set <em>house</em> (i.e merging the two data sets)</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th style="text-align: center;" colspan="2" align="center">Data : house</th>
</tr>
<tr>
<th>House</th>
<th>Region</th>
</tr>
</thead>
<tbody>
<tr>
<td>Stark</td>
<td>The North</td>
</tr>
<tr>
<td>Targaryen</td>
<td style="text-align: left;">Slaver&#8217;s Bay</td>
</tr>
<tr>
<td>Lannister</td>
<td>The Westerlands</td>
</tr>
<tr>
<td>Baratheon</td>
<td>The Stormlands</td>
</tr>
<tr>
<td>Tyrell</td>
<td>The Reach</td>
</tr>
</tbody>
</table>
<table class="dataframe" style="display: inline-block; vertical-align: top; margin-left: 20px; padding-top: 0px;" border="1">
<thead>
<tr>
<th style="text-align: center;" colspan="2" align="center">Data : house_extra</th>
</tr>
<tr>
<th style="text-align: left;">House</th>
<th>Region</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tully</td>
<td>The Riverlands</td>
</tr>
<tr>
<td>Greyjoy</td>
<td>The Iron Islands</td>
</tr>
</tbody>
</table>
<p>You can make a row wise addition of <em>house_extra</em> to <em>house</em> data set by using the following code :</p>
<p><strong></strong></p>
<p><code>#row wise addition does vertical addition of new rows</code><br/>
<code> &gt; house = house.append(house_extra)</code><br/>
<code> or</code><br/>
<code> #axis=0 can also add new rows to data set</code><br/>
<code> &gt; house = pd.concat([house,house_extra],axis=0)</code></p>
<p><strong>R Code<br/>
</strong></p>
<p><code>#using base function merge</code><br/>
<code>&gt; house &lt;- merge(house,house_extra,all=TRUE,sort=FALSE)</code></p>
<p>The output will be :</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th>House</th>
<th>Region</th>
</tr>
</thead>
<tbody>
<tr>
<td>Stark</td>
<td>The North</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Slaver&#8217;s Bay</td>
</tr>
<tr>
<td>Lannister</td>
<td>The Westerlands</td>
</tr>
<tr>
<td>Baratheon</td>
<td>The Stormlands</td>
</tr>
<tr>
<td>Tyrell</td>
<td>The Reach</td>
</tr>
<tr>
<td>Tully</td>
<td>The Riverlands</td>
</tr>
<tr>
<td>Greyjoy</td>
<td>The Iron Islands</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h3>ii) In Unstructured Data Set</h3>
<p style="text-align: justify;">Now there might be a case where you have an unstructured data. Think of unstructured data as a data without any matrix or data frame. Still, could we add new observations to it?</p>
<p style="text-align: justify;">Suppose you have a new <em>house</em> in the <code><strong>house</strong></code> data frame. The new house is &#8220;Redwyne&#8221; which is present in &#8220;The Reach&#8221; region. Now, we want to add this new observation in our existing <code><strong>house</strong></code> data. Let&#8217;s see how to do it.</p>
<p><strong></strong></p>
<p><code></code><code>&gt; house.loc[len(house)]=['Redwyne','The Reach']</code></p>
<p><strong>R Code</strong></p>
<p><code>&gt; house &lt;- rbind(house,data.frame(House=c("Redwyne"),Region=c("The Reach")))</code></p>
<p>The output will be :</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th style="text-align: center;" colspan="2" align="center">Data : house</th>
</tr>
<tr>
<th>House</th>
<th>Region</th>
</tr>
</thead>
<tbody>
<tr>
<td>Stark</td>
<td>The North</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Slaver&#8217;s Bay</td>
</tr>
<tr>
<td>Lannister</td>
<td>The Westerlands</td>
</tr>
<tr>
<td>Baratheon</td>
<td>The Stormlands</td>
</tr>
<tr>
<td>Tyrell</td>
<td>The Reach</td>
</tr>
<tr>
<td>Tully</td>
<td>The Riverlands</td>
</tr>
<tr>
<td>Greyjoy</td>
<td>The Iron Islands</td>
</tr>
<tr>
<td>Redwyne</td>
<td>The Reach</td>
</tr>
</tbody>
</table>
<p>As you can see, a new house (Redwyne) has been added to the <code><strong>house</strong></code> data frame with its region.</p>
<p>&nbsp;</p>
<h3>Important Points</h3>
<p style="text-align: justify;"><strong>1. </strong>At times there are situations when we are required to add observations from a data set which has a new column than the existing one. Confused ? Let&#8217;s do some changes in data set and understand this point:</p>
<p style="text-align: justify;">Now, the <code><strong>house</strong></code> data set contains two columns (House, Region). Another data set, <code><strong>house_new</strong></code> contains columns (House, Region  and Religion). Keep in mind, <em>Religion</em> column is not available in other data set. We are asked to combine these data sets. How can we do?</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th style="text-align: center;" colspan="2" align="center">Data : house</th>
</tr>
<tr>
<th>House</th>
<th>Region</th>
</tr>
</thead>
<tbody>
<tr>
<td>Stark</td>
<td>The North</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Slaver&#8217;s Bay</td>
</tr>
<tr>
<td>Lannister</td>
<td>The Westerlands</td>
</tr>
<tr>
<td>Baratheon</td>
<td>The Stormlands</td>
</tr>
<tr>
<td>Tyrell</td>
<td>The Reach</td>
</tr>
</tbody>
</table>
<table class="dataframe" style="display: inline-block; vertical-align: top; margin-left: 20px; padding-top: 0px;" border="1">
<thead>
<tr>
<th style="text-align: center;" colspan="3" align="center">Data : house_new</th>
</tr>
<tr>
<th>House</th>
<th>Region</th>
<th>Religion</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tully</td>
<td>The Riverlands</td>
<td>Seven Gods</td>
</tr>
<tr>
<td>Greyjoy</td>
<td>The Iron Islands</td>
<td>Sea God</td>
</tr>
</tbody>
</table>
<p>Let&#8217;s find the solution.</p>
<p><strong></strong></p>
<p><code>&gt; house=house.append(house_new)</code><br/>
<code>or</code><br/>
<code>&gt; house=pd.concat([house,house_new],axis=0)</code></p>
<p><strong>R Code</strong></p>
<p><code>&gt; house &lt;- merge(house,house_new,all=TRUE,sort=FALSE)</code></p>
<p style="text-align: justify;">We can see that it assigned NaN to the elements of house data frame because &#8220;Religion&#8221; variable was not present in the <em>house</em> set.</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th>House</th>
<th>Region</th>
<th>Religion</th>
</tr>
</thead>
<tbody>
<tr>
<td>Stark</td>
<td>The North</td>
<td>NaN</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Slaver&#8217;s Bay</td>
<td>NaN</td>
</tr>
<tr>
<td>Lannister</td>
<td>The Westerlands</td>
<td>NaN</td>
</tr>
<tr>
<td>Baratheon</td>
<td>The Stormlands</td>
<td>NaN</td>
</tr>
<tr>
<td>Tyrell</td>
<td>The Reach</td>
<td>NaN</td>
</tr>
<tr>
<td>Tully</td>
<td>The Riverlands</td>
<td>Seven Gods</td>
</tr>
<tr>
<td>Greyjoy</td>
<td>The Iron Islands</td>
<td>Sea God</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p style="text-align: justify;"><strong>2.</strong> This point is only applicable for python users.</p>
<p style="text-align: justify;">Continuing from point 1, after adding the new houses to the old data set, we end up getting repeated index values. This is definitely a problem.</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th style="text-align: center;" colspan="4" align="center">Data : house</th>
</tr>
<tr>
<th></th>
<th>House</th>
<th>Region</th>
<th>Religion</th>
</tr>
</thead>
<tbody>
<tr>
<th>0</th>
<td>Stark</td>
<td>The North</td>
<td>NaN</td>
</tr>
<tr>
<th>1</th>
<td>Targaryen</td>
<td>Slaver&#8217;s Bay</td>
<td>NaN</td>
</tr>
<tr>
<th>2</th>
<td>Lannister</td>
<td>The Westerlands</td>
<td>NaN</td>
</tr>
<tr>
<th>3</th>
<td>Baratheon</td>
<td>The Stormlands</td>
<td>NaN</td>
</tr>
<tr>
<th>4</th>
<td>Tyrell</td>
<td>The Reach</td>
<td>NaN</td>
</tr>
<tr>
<th>0</th>
<td>Tully</td>
<td>The Riverlands</td>
<td>Seven Gods</td>
</tr>
<tr>
<th>1</th>
<td>Greyjoy</td>
<td>The Iron Islands</td>
<td>Sea God</td>
</tr>
</tbody>
</table>
<p style="text-align: justify;">Now, if we try to access the  first element of the data frame, what will we get? Take a minute to think about it.</p>
<p><code>&gt; house.ix[0]</code></p>
<p>The output will be:</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th></th>
<th>House</th>
<th>Region</th>
<th>Religion</th>
</tr>
</thead>
<tbody>
<tr>
<th>0</th>
<td>Stark</td>
<td>The North</td>
<td>NaN</td>
</tr>
<tr>
<th>0</th>
<td>Tully</td>
<td>The Riverlands</td>
<td>Seven Gods</td>
</tr>
</tbody>
</table>
<p>We see two elements in the output. Why is that ?</p>
<p style="text-align: justify;">This is because, after merging the two data frames, the index of new observations haven&#8217;t changed according to the new data set. So, if we try to access the first element of the data frame, the result will be same as above. To handle this problem, we can treat index also. It can be done by :</p>
<p><code>#ignore_index does not takes the old index in consideration</code><br/>
<code>&gt;house_data=pd.concat([house,house_new],axis=0,ignore_index=True)</code></p>
<p style="text-align: justify;">Now the output after vertically adding the data frames will be :</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th></th>
<th>House</th>
<th>Region</th>
<th>Religion</th>
</tr>
</thead>
<tbody>
<tr>
<th>0</th>
<td>Stark</td>
<td>The North</td>
<td>NaN</td>
</tr>
<tr>
<th>1</th>
<td>Targaryen</td>
<td>Slaver&#8217;s Bay</td>
<td>NaN</td>
</tr>
<tr>
<th>2</th>
<td>Lannister</td>
<td>The Westerlands</td>
<td>NaN</td>
</tr>
<tr>
<th>3</th>
<td>Baratheon</td>
<td>The Stormlands</td>
<td>NaN</td>
</tr>
<tr>
<th>4</th>
<td>Tyrell</td>
<td>The Reach</td>
<td>NaN</td>
</tr>
<tr>
<th>5</th>
<td>Tully</td>
<td>The Riverlands</td>
<td>Seven Gods</td>
</tr>
<tr>
<th>6</th>
<td>Greyjoy</td>
<td>The Iron Islands</td>
<td>Sea God</td>
</tr>
</tbody>
</table>
<div class="cell text_cell unselected rendered">As we see that the index is no longer the old index of individual data frames. Now, we can access any row without any problem.</div>
<p style="text-align: justify;"><strong>Exercise 1</strong> : What will be the output of the append or concat operations on house and house_new if there is an extra variable present in house data frame?<br/>
<strong>Exercise 2</strong> : Write the code for adding house data frame to house_new(house_new observations will be on top)?<br/>
Provide your answers in comments below.</p>
<p>&nbsp;</p>
<h2>Challenge 2 : Dropping Observations<strong><br/>
</strong></h2>
<p><strong>Dropping Rows</strong></p>
<p style="text-align: justify;">Suppose we have a data set <code><strong>candidates</strong></code> which contains information about heirs (successors) of each house (family). They are sorted on the basis of age in descending order within the same house. (There is no order between the houses).</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th style="text-align: center;" colspan="2" align="center">Data : candidates</th>
</tr>
<tr>
<th>House</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lannister</td>
<td>Jamie Lannister</td>
</tr>
<tr>
<td>Stark</td>
<td>Robb Stark</td>
</tr>
<tr>
<td>Stark</td>
<td>Arya Stark</td>
</tr>
<tr>
<td>Lannister</td>
<td>Cersi Lannister</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Daenerys Targaryen</td>
</tr>
<tr>
<td>Baratheon</td>
<td>Robert Baratheon</td>
</tr>
<tr>
<td>Mormont</td>
<td>Jorah Mormont</td>
</tr>
</tbody>
</table>
<p style="text-align: justify;">Now we want to remove the top two rows of the <code><strong>candidates</strong></code> data frame :</p>
<p><strong></strong></p>
<p><code># 0 and 1 are the index of the rows we want to remove<br/>
&gt; candidates=candidates.drop([0,1])</code></p>
<p><strong>R Code</strong></p>
<p><code># Note: In R, index starts from 1 and not 0.<br/>
&gt; candidates=candidates[-c(1:2),]</code></p>
<p>Output will be :</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th>House</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>Stark</td>
<td>Arya Stark</td>
</tr>
<tr>
<td>Lannister</td>
<td>Cersi Lannister</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Daenerys Targaryen</td>
</tr>
<tr>
<td>Baratheon</td>
<td>Robert Baratheon</td>
</tr>
<tr>
<td>Mormont</td>
<td>Jorah Mormont</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4>Dropping rows based on conditions</h4>
<p style="text-align: justify;">In the TV Series, Robb Stark was killed at a wedding. Since he&#8217;s no more alive, he can&#8217;t be an heir to the Stark House. We should remove him from the data set.</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th style="text-align: center;" colspan="2" align="center">Data : candidates</th>
</tr>
<tr>
<th>House</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lannister</td>
<td>Jamie Lannister</td>
</tr>
<tr>
<td>Stark</td>
<td>Robb Stark</td>
</tr>
<tr>
<td>Stark</td>
<td>Arya Stark</td>
</tr>
<tr>
<td>Lannister</td>
<td>Cersi Lannister</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Daenerys Targaryen</td>
</tr>
<tr>
<td>Baratheon</td>
<td>Robert Baratheon</td>
</tr>
<tr>
<td>Mormont</td>
<td>Jorah Mormont</td>
</tr>
</tbody>
</table>
<p style="text-align: justify;"><strong>Task:</strong> Prepare the new guest list with Robb Stark&#8217;s entry removed. This is how we do it :</p>
<p><strong></strong></p>
<p><code># We have taken all candidates except "Rob Stark"<br/>
&gt; candidates[candidates.Name!= "Robb Stark"]</code></p>
<p><strong>R Code</strong></p>
<p><code>&gt; candidates[which(candidates$Name!="Robb Stark"),]</code></p>
<p>Output will be :</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th>House</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lannister</td>
<td>Jamie Lannister</td>
</tr>
<tr>
<td>Stark</td>
<td>Arya Stark</td>
</tr>
<tr>
<td>Lannister</td>
<td>Cersi Lannister</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Daenerys Targaryen</td>
</tr>
<tr>
<td>Baratheon</td>
<td>Robert Baratheon</td>
</tr>
<tr>
<td>Mormont</td>
<td>Jorah Mormont</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h2>Challenge 3 : Adding Column(s) Horizontally</h2>
<p style="text-align: justify;">At times, a data set is provided in different files. Each file contains some unique information. We are required to merge them in such a way that we can extract maximum information.</p>
<p>In such cases, how can we decide what kind of merging technique we should apply?</p>
<p style="text-align: justify;">The answer is, it depends on the requirement of problem statement. Below are the different types of merge operations and insights on how to decide which merging technique to apply in various situations.</p>
<p>Sometimes the problem statement is straight forward.</p>
<p style="text-align: justify;">Let&#8217;s take this case. The data frames required to combine are shown below. Military strength of each house is given in the same sequence as the sequence of houses in <code><strong>hou</strong><strong>se</strong></code> data set. In such situation, we simply need to map the indexes with one another.</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th style="text-align: center;" colspan="2" align="center">Data : house</th>
</tr>
<tr>
<th>House</th>
<th>Region</th>
</tr>
</thead>
<tbody>
<tr>
<td>Stark</td>
<td>The North</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Slaver&#8217;s Bay</td>
</tr>
<tr>
<td>Lannister</td>
<td>The Westerlands</td>
</tr>
<tr>
<td>Baratheon</td>
<td>The Stormlands</td>
</tr>
<tr>
<td>Tyrell</td>
<td>The Reach</td>
</tr>
</tbody>
</table>
<table class="dataframe" style="display: inline-block; vertical-align: top; margin-left: 20px; padding-top: 0px;" border="1">
<thead>
<tr>
<th>Data : military</th>
</tr>
<tr>
<th>Military_Strength</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">20000</td>
</tr>
<tr>
<td style="text-align: center;">110000</td>
</tr>
<tr>
<td style="text-align: center;">60000</td>
</tr>
<tr>
<td style="text-align: center;">40000</td>
</tr>
<tr>
<td style="text-align: center;">30000</td>
</tr>
</tbody>
</table>
<p style="text-align: justify;">To get more information about each house&#8217;s military strength, we&#8217;ll simply add <code><strong>military</strong></code> data set to the <code><strong>house</strong></code> data set:</p>
<p><strong></strong></p>
<p><code>&gt; house=pd.concat([house,military],axis=1)</code></p>
<p><strong>R Code</strong></p>
<p><code>&gt; house=cbind(house,military)</code></p>
<p>The output will be:</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th>House</th>
<th>Region</th>
<th>Military_Strength</th>
</tr>
</thead>
<tbody>
<tr>
<td>Stark</td>
<td>The North</td>
<td>20000</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Slaver&#8217;s Bay</td>
<td>110000</td>
</tr>
<tr>
<td>Lannister</td>
<td>The Westerlands</td>
<td>60000</td>
</tr>
<tr>
<td>Baratheon</td>
<td>The Stormlands</td>
<td>40000</td>
</tr>
<tr>
<td>Tyrell</td>
<td>The Reach</td>
<td>30000</td>
</tr>
</tbody>
</table>
<p style="text-align: justify;">Wasn&#8217;t that easy ? Actually, since the index alignment was similar that&#8217;s why we were able to merge these two data sets but this is always not the case. In fact, this would rarely happen in any data science competition. Challenge 4 shows the real trouble.</p>
<p>&nbsp;</p>
<h2 style="text-align: left;">Challenge 4: Adding Column(s) based on common attribute<strong><br/>
</strong></h2>
<p>Now, how to merge the data sets if their indexes are not aligned?</p>
<p style="text-align: justify;">In such situations, there is always a common attribute (key or keys) that aids us in combining data sets. But, you need to find the common attribute(s) present in the data frames. They could be column(s) or index(s).<br/>
<strong>Hint : </strong>Most of the times, common attribute will be some sort of ID. Keep an eye for it.</p>
<p style="text-align: justify;">There can be different ways to merge the data depending upon the type of question asked. Here we have the <code><strong>house</strong></code> data set  and <code><strong>candidates</strong></code> data set. To show you different variations in applying these operations, I am going to solve different questions and situations around the data sets.</p>
<p>Think about the question for a while before diving into the solution.</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th style="text-align: center;" colspan="2" align="center">Data : candidates</th>
</tr>
<tr>
<th>House</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lannister</td>
<td>Jamie Lannister</td>
</tr>
<tr>
<td>Stark</td>
<td>Robb Stark</td>
</tr>
<tr>
<td>Stark</td>
<td>Arya Stark</td>
</tr>
<tr>
<td>Lannister</td>
<td>Cersi Lannister</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Daenerys Targaryen</td>
</tr>
<tr>
<td>Baratheon</td>
<td>Robert Baratheon</td>
</tr>
<tr>
<td>Mormont</td>
<td>Jorah Mormont</td>
</tr>
</tbody>
</table>
<table class="dataframe" style="display: inline-block; vertical-align: top; margin-left: 20px; padding-top: 0px;" border="1">
<thead>
<tr>
<th style="text-align: center;" colspan="3" align="center">Data : house</th>
</tr>
<tr>
<th>House</th>
<th>Region</th>
<th>Military_Strength</th>
</tr>
</thead>
<tbody>
<tr>
<td>Stark</td>
<td>The North</td>
<td>20000</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Slaver&#8217;s Bay</td>
<td>110000</td>
</tr>
<tr>
<td>Lannister</td>
<td>The Westerlands</td>
<td>60000</td>
</tr>
<tr>
<td>Baratheon</td>
<td>The Stormlands</td>
<td>40000</td>
</tr>
<tr>
<td>Tyrell</td>
<td>The Reach</td>
<td>30000</td>
</tr>
</tbody>
</table>
<h3></h3>
<h3>Question : Which of the candidate has the largest army ?</h3>
<p style="text-align: justify;">Just by looking at the heir&#8217;s name or his/her house name from the <code><strong>candidates</strong></code> data set will not answer this question. To answer this question, we have to extract the information about military strength from their corresponding houses.</p>
<p>How can we do that? Their index are not aligned, is there any common attribute between them?</p>
<p style="text-align: justify;">Yes, both the data frames have &#8220;House&#8221; column. We will now see how can we merge the above data set on the basis of a common column.</p>
<p><strong></strong></p>
<p><code>&gt; house = pd.merge(candidates,house,on="House",how="left")</code><br/>
<code>#or</code><br/>
<code>&gt; house = pd.merge(candidates,house,left_on="House",right_on="House",how="left")</code></p>
<p><strong>R Code</strong></p>
<p><code>&gt;house &lt;- merge(candidates,house,by='House',all.x=TRUE,sort=FALSE)</code></p>
<p>The output will be:</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th>House</th>
<th>Name</th>
<th>Region</th>
<th>Military_Strength</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lannister</td>
<td>Jamie Lannister</td>
<td>The Westerlands</td>
<td>60000</td>
</tr>
<tr>
<td>Stark</td>
<td>Robb Stark</td>
<td>The North</td>
<td>20000</td>
</tr>
<tr>
<td>Stark</td>
<td>Arya Stark</td>
<td>The North</td>
<td>20000</td>
</tr>
<tr>
<td>Lannister</td>
<td>Cersi Lannister</td>
<td>The Westerlands</td>
<td>60000</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Daenerys Targaryen</td>
<td>Slaver&#8217;s Bay</td>
<td>110000</td>
</tr>
<tr>
<td>Baratheon</td>
<td>Robert Baratheon</td>
<td>The Stormlands</td>
<td>40000</td>
</tr>
<tr>
<td>Mormont</td>
<td>Jorah Mormont</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<p style="text-align: justify;">By looking at the above data frame we can say that Daenerys Targaryen has the largest army. But, why did Jorah Mormont get <code>NaN </code>?</p>
<p>There are a few things to notice here (refer above for codes) :</p>
<ul>
<li>In first code we used <code><strong>on/by="House"</strong></code> which is the common attribute in both the data frames.</li>
<li style="text-align: justify;">In case we merge data on the basis of a particular key, but they have different column name we can use <code><strong>left_on/by.x</strong></code> &amp; <code><strong>right_on/by.y</strong></code> as shown in the second code.</li>
<li style="text-align: justify;">In both the codes, we used <code><strong>how='left'/all.x=TRUE</strong></code> which uses the key (&#8220;House&#8221;) from the left frame only. We used left because we want information about all the candidates.</li>
<li style="text-align: justify;">House Tyrell has no entry in the merged data frame because there was no candidate from house Tyrell, left merge took care of it.</li>
<li style="text-align: justify;">House Mormont don&#8217;t have any information in <code><strong>house</strong></code> data frame, so candidate <strong>Jorah Mormont </strong>is assigned with NaN in the merged data frame.</li>
</ul>
<p style="text-align: justify;">Left merge is used here because we want information about the candidates. So, in the code above, <code><strong>candidates</strong></code> was the left data set and it uses &#8220;House&#8221; key from left frame only.</p>
<p><img src="https://www.analyticsvidhya.com/wp-content/uploads/2016/06/images-e1465408774337.png" width="249" height="176"/></p>
<p style="text-align: center;">Left Merge</p>
<p style="text-align: justify;"><strong>Note : </strong>I have used &#8220;merge&#8221; in headings and explanations. It is the general term that I will be using  for combining or joining data set. Where as &#8220;merge&#8221; in the code is the syntax that is being used for merging, joining or combining.</p>
<p>&nbsp;</p>
<h3>Question : List all the houses along with their military strength and the rightful heir</h3>
<p>Now, we have to deliver information about each house. So, military strength is already present in <code><strong>house</strong></code> data set. All we have to do is to find the heir of each house who is present in <code><strong>candidates</strong></code> data set.</p>
<p>In simple words, we want to extract candidate&#8217;s name from  <code><strong>candidates</strong></code> data frame and place it with corresponding house. Let&#8217;s see.</p>
<p style="text-align: left;"><strong></strong></p>
<p style="text-align: justify;"><code>&gt; house = pd.merge(house,candidates,on="House",how="left")</code></p>
<p style="text-align: justify;">This will provide all the candidates from each house along with their military strength with older candidates at the top. In <code><strong>candidates</strong></code> data frame, an older member of a particular house is placed above the others. We can also perform a right merge operation to do the same thing.</p>
<p><code>&gt; house=pd.merge(candidates,house,on="House",how="right")</code></p>
<p><strong>R Code</strong></p>
<p><code>&gt; house &lt;- merge(candidates,house,by="House",all.y=TRUE,sort=FALSE)</code></p>
<p>The output will be:</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th>House</th>
<th>Name</th>
<th>Region</th>
<th>Military_Strength</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lannister</td>
<td>Jamie Lannister</td>
<td>The Westerlands</td>
<td>60000</td>
</tr>
<tr>
<td>Lannister</td>
<td>Cersi Lannister</td>
<td>The Westerlands</td>
<td>60000</td>
</tr>
<tr>
<td>Stark</td>
<td>Robb Stark</td>
<td>The North</td>
<td>20000</td>
</tr>
<tr>
<td>Stark</td>
<td>Arya Stark</td>
<td>The North</td>
<td>20000</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Daenerys Targaryen</td>
<td>Slaver&#8217;s Bay</td>
<td>110000</td>
</tr>
<tr>
<td>Baratheon</td>
<td>Robert Baratheon</td>
<td>The Stormlands</td>
<td>40000</td>
</tr>
<tr>
<td>Tyrell</td>
<td>NaN</td>
<td>The Reach</td>
<td>30000</td>
</tr>
</tbody>
</table>
<p>Here <code><strong>how="right"/all.y=True</strong></code> uses the key from right frame only.</p>
<p></p>
<p style="text-align: center;">Right Merge</p>
<h3><strong><br/>
</strong>Question : List the houses that have atleast one heir?<strong><br/>
</strong></h3>
<p style="text-align: justify;">Sometimes we just need the part of the combined data where information from both data set is present . In simple words, we can say that we want the intersection between the available information or elements of <code><strong>house</strong></code> &amp; <code><strong>candidates</strong></code> data frame.</p>
<p style="text-align: justify;">Rather than removing the observations having missing values we can directly merge the data set by using the following code :</p>
<p><strong></strong></p>
<p><code>&gt; merge_inner = pd.merge(candidates,house,on="House",how="inner")</code></p>
<p><strong>R Code</strong></p>
<p><code>&gt; merge_inner &lt;- merge(candidates,house,by="House",all=FALSE,sort=FALSE)</code></p>
<p style="text-align: left;">The output will be:</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th>House</th>
<th>Name</th>
<th>Region</th>
<th>Military_Strength</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lannister</td>
<td>Jamie Lannister</td>
<td>The Westerlands</td>
<td>60000</td>
</tr>
<tr>
<td>Lannister</td>
<td>Cersi Lannister</td>
<td>The Westerlands</td>
<td>60000</td>
</tr>
<tr>
<td>Stark</td>
<td>Robb Stark</td>
<td>The North</td>
<td>20000</td>
</tr>
<tr>
<td>Stark</td>
<td>Arya Stark</td>
<td>The North</td>
<td>20000</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Daenerys Targaryen</td>
<td>Slaver&#8217;s Bay</td>
<td>110000</td>
</tr>
<tr>
<td>Baratheon</td>
<td>Robert Baratheon</td>
<td>The Stormlands</td>
<td>40000</td>
</tr>
</tbody>
</table>
<p style="text-align: left;">Here <code><strong>how="inner"/all=FALSE</strong></code> uses intersection of keys from both frames.</p>
<p style="text-align: left;"></p>
<p style="text-align: center;">Intersection merge</p>
<p>&nbsp;</p>
<h3>Question : List all the available information about houses and heirs?<strong><br/>
</strong></h3>
<p style="text-align: justify;">We want all data about the candidates and houses together, regardless of availability of information. In simple words, we can say that we want the union of all the information of <code><strong>house</strong></code> &amp; <code><strong>candidates</strong></code> data frames.</p>
<p>We  can do that with following codes :</p>
<p style="text-align: left;"><strong></strong></p>
<p style="text-align: left;"><code>&gt; merge_outer = pd.merge(candidates,house,on="House",how="outer")</code></p>
<p style="text-align: left;"><strong>R Code</strong><code></code></p>
<p style="text-align: left;"><code>&gt; merge_outer &lt;- merge(candidates,house,all=TRUE,sort=FALSE)</code></p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th>House</th>
<th>Name</th>
<th>Region</th>
<th>Military_Strength</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lannister</td>
<td>Jamie Lannister</td>
<td>The Westerlands</td>
<td>60000</td>
</tr>
<tr>
<td>Lannister</td>
<td>Cersi Lannister</td>
<td>The Westerlands</td>
<td>60000</td>
</tr>
<tr>
<td>Stark</td>
<td>Robb Stark</td>
<td>The North</td>
<td>20000</td>
</tr>
<tr>
<td>Stark</td>
<td>Arya Stark</td>
<td>The North</td>
<td>20000</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Daenerys Targaryen</td>
<td>Slaver&#8217;s Bay</td>
<td>110000</td>
</tr>
<tr>
<td>Baratheon</td>
<td>Robert Baratheon</td>
<td>The Stormlands</td>
<td>40000</td>
</tr>
<tr>
<td>Mormont</td>
<td>Jorah Mormont</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>Tyrell</td>
<td>NaN</td>
<td>The Reach</td>
<td>30000</td>
</tr>
</tbody>
</table>
<p style="text-align: left;">Here <code><strong>how="outer"/all=True</strong></code> uses union of key from both frames.</p>
<p style="text-align: left;"></p>
<p style="text-align: center;">Union Merge</p>
<p>&nbsp;</p>
<h2>Challenge 5 : Adding Column(s) based on observation serial (index)</h2>
<p style="text-align: justify;">Sometimes the common attribute or the key is <strong>index</strong> in both the data frames or index in one and a column in the other. We are going to handle a similar problem where both the keys are index. Later, you have to find the solution for the other case in the exercise given. Suppose the data sets are :</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th style="text-align: center;" colspan="4" align="center">Data : candidates</th>
</tr>
<tr>
<th></th>
<th>Name</th>
</tr>
<tr>
<th>House</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<th style="text-align: left;">Lannister</th>
<td>Jamie Lannister</td>
</tr>
<tr>
<th style="text-align: left;">Stark</th>
<td>Robb Stark</td>
</tr>
<tr>
<th style="text-align: left;">Stark</th>
<td>Arya Stark</td>
</tr>
<tr>
<th style="text-align: left;">Lannister</th>
<td>Cersi Lannister</td>
</tr>
<tr>
<th style="text-align: left;">Targaryen</th>
<td>Daenerys Targaryen</td>
</tr>
<tr>
<th style="text-align: left;">Baratheon</th>
<td>Robert Baratheon</td>
</tr>
<tr>
<th style="text-align: left;">Mormont</th>
<td>Jorah Mormont</td>
</tr>
</tbody>
</table>
<table class="dataframe" style="display: inline-block; vertical-align: top; margin-left: 20px; padding-top: 0px;" border="1">
<thead>
<tr>
<th style="text-align: center;" colspan="4" align="center">Data : house</th>
</tr>
<tr>
<th style="text-align: left;"></th>
<th>Region</th>
<th>Military_Strength</th>
</tr>
<tr>
<th>House</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<th style="text-align: left;">Stark</th>
<td>The North</td>
<td>20000</td>
</tr>
<tr>
<th style="text-align: left;">Targaryen</th>
<td>Slaver&#8217;s Bay</td>
<td>110000</td>
</tr>
<tr>
<th style="text-align: left;">Lannister</th>
<td>The Westerlands</td>
<td>60000</td>
</tr>
<tr>
<th>Baratheon</th>
<td>The Stormlands</td>
<td>40000</td>
</tr>
<tr>
<th style="text-align: left;">Tyrell</th>
<td>The Reach</td>
<td>30000</td>
</tr>
</tbody>
</table>
<p>We can merge these two data frames by using the following codes :</p>
<p><strong></strong></p>
<p><code>&gt; house = candidates.join(house,how='left')<br/>
#or<br/>
#right_index and left_index enables the merging on the index.<br/>
#Here also how will have four options 'inner','outer','right' and 'left'<br/>
&gt; house = pd.merge(candidates, house, right_index=True, left_index=True,how ='left')</code></p>
<p style="text-align: justify;">Join function is a convenient method for combining two data frames on the basis of index (by default). But, we can also merge if one of the keys is a column by using &#8216;on&#8217; parameter.</p>
<p class="lang-r prettyprint prettyprinted"><strong>R Code</strong><code></code></p>
<p class="lang-r prettyprint prettyprinted"><code><span class="pln">&gt; house&lt;-merge(candidates,house,sort=FALSE,all.x=TRUE)</span></code></p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th></th>
<th>Name</th>
<th>Region</th>
<th>Military_Strength</th>
</tr>
<tr>
<th>House</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<th>Baratheon</th>
<td>Robert Baratheon</td>
<td>The Stormlands</td>
<td>40000</td>
</tr>
<tr>
<th>Lannister</th>
<td>Jamie Lannister</td>
<td>The Westerlands</td>
<td>60000</td>
</tr>
<tr>
<th>Lannister</th>
<td>Cersi Lannister</td>
<td>The Westerlands</td>
<td>60000</td>
</tr>
<tr>
<th>Mormont</th>
<td>Jorah Mormont</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<th>Stark</th>
<td>Robb Stark</td>
<td>The North</td>
<td>20000</td>
</tr>
<tr>
<th>Stark</th>
<td>Arya Stark</td>
<td>The North</td>
<td>20000</td>
</tr>
<tr>
<th>Targaryen</th>
<td>Daenerys Targaryen</td>
<td>Slaver&#8217;s Bay</td>
<td>110000</td>
</tr>
</tbody>
</table>
<h3>Caution:</h3>
<p style="text-align: justify;">What if the data frames you are merging have a same column name other than the common attribute? What will happen? You can handle that very easily. Let&#8217;s see</p>
<p>Suppose you have the following data frames :</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th style="text-align: center;" colspan="3" align="center">Data : house</th>
</tr>
<tr>
<th>House</th>
<th>Region</th>
<th>Military_Strength</th>
</tr>
</thead>
<tbody>
<tr>
<td>Stark</td>
<td>The North</td>
<td>20000</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Slaver&#8217;s Bay</td>
<td>110000</td>
</tr>
<tr>
<td>Lannister</td>
<td>The Westerlands</td>
<td>60000</td>
</tr>
<tr>
<td>Baratheon</td>
<td>The Stormlands</td>
<td>40000</td>
</tr>
<tr>
<td>Tyrell</td>
<td>The Reach</td>
<td>30000</td>
</tr>
</tbody>
</table>
<table class="dataframe" style="display: inline-block; vertical-align: top; margin-left: 20px; padding-top: 0px;" border="1">
<thead>
<tr>
<th style="text-align: center;" colspan="4" align="center">Data : candidates</th>
</tr>
<tr>
<th>House</th>
<th>Name</th>
<th>Region</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lannister</td>
<td>Jamie Lannister</td>
<td>Westros</td>
</tr>
<tr>
<td>Stark</td>
<td>Robb Stark</td>
<td>North</td>
</tr>
<tr>
<td>Stark</td>
<td>Arya Stark</td>
<td>Westros</td>
</tr>
<tr>
<td>Lannister</td>
<td>Cersi Lannister</td>
<td>Westros</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Daenerys Targaryen</td>
<td>Mereene</td>
</tr>
<tr>
<td>Baratheon</td>
<td>Robert Baratheon</td>
<td>Westros</td>
</tr>
<tr>
<td>Mormont</td>
<td>Jorah Mormont</td>
<td>Mereene</td>
</tr>
</tbody>
</table>
<p style="text-align: justify;">If you run the merge code, it will add some suffix by default (_x,_y) but you can add your own suffix by using the following code :</p>
<p><strong></strong></p>
<p><code>&gt; house = pd.merge(candidates,house, on='House', how='left', suffixes=('_left', '_right'))</code></p>
<p><strong>R Code</strong></p>
<p><code>&gt; house &lt;-merge(candidates,house,by="House",all.x=TRUE,<br/>
</code><code>sort=FALSE,suffixes=c("_left","_right")</code></p>
<p>The output will be :</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th>House</th>
<th>Name</th>
<th>Region_left</th>
<th>Region_right</th>
<th>Military_Strength</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lannister</td>
<td>Jamie Lannister</td>
<td>Westros</td>
<td>The Westerlands</td>
<td>60000</td>
</tr>
<tr>
<td>Stark</td>
<td>Robb Stark</td>
<td>North</td>
<td>The North</td>
<td>20000</td>
</tr>
<tr>
<td>Stark</td>
<td>Arya Stark</td>
<td>Westros</td>
<td>The North</td>
<td>20000</td>
</tr>
<tr>
<td>Lannister</td>
<td>Cersi Lannister</td>
<td>Westros</td>
<td>The Westerlands</td>
<td>60000</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Daenerys Targaryen</td>
<td>Mereene</td>
<td>Slaver&#8217;s Bay</td>
<td>110000</td>
</tr>
<tr>
<td>Baratheon</td>
<td>Robert Baratheon</td>
<td>Westros</td>
<td>The Stormlands</td>
<td>40000</td>
</tr>
<tr>
<td>Mormont</td>
<td>Jorah Mormont</td>
<td>Mereene</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p><strong>Exercise 3 : </strong>Comment the code that will left merge the following data set on the basis of &#8220;House&#8221; :</p>
<p>&nbsp;</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th style="text-align: center;" colspan="4" align="center">Data : house</th>
</tr>
<tr>
<th></th>
<th>Region</th>
<th>Military_Strength</th>
</tr>
<tr>
<th>House</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<th style="text-align: left;">Stark</th>
<td>The North</td>
<td>20000</td>
</tr>
<tr>
<th style="text-align: left;">Targaryen</th>
<td>Slaver&#8217;s Bay</td>
<td>110000</td>
</tr>
<tr>
<th style="text-align: left;">Lannister</th>
<td>The Westerlands</td>
<td>60000</td>
</tr>
<tr>
<th style="text-align: left;">Baratheon</th>
<td>The Stormlands</td>
<td>40000</td>
</tr>
<tr>
<th style="text-align: left;">Tyrell</th>
<td>The Reach</td>
<td>30000</td>
</tr>
</tbody>
</table>
<table class="dataframe" style="display: inline-block; vertical-align: top; margin-left: 20px; padding-top: 0px;" border="1">
<thead>
<tr>
<th style="text-align: center;" colspan="4" align="center">Data : candidates</th>
</tr>
<tr>
<th></th>
<th>Name</th>
</tr>
<tr>
<th>House</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<th style="text-align: left;">Lannister</th>
<td>Jamie Lannister</td>
</tr>
<tr>
<th style="text-align: left;">Stark</th>
<td>Robb Stark</td>
</tr>
<tr>
<th style="text-align: left;">Stark</th>
<td>Arya Stark</td>
</tr>
<tr>
<th style="text-align: left;">Lannister</th>
<td>Cersi Lannister</td>
</tr>
<tr>
<th style="text-align: left;">Targaryen</th>
<td>Daenerys Targaryen</td>
</tr>
<tr>
<th style="text-align: left;">Baratheon</th>
<td>Robert Baratheon</td>
</tr>
<tr>
<th style="text-align: left;">Mormont</th>
<td>Jorah Mormont</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h2>Challenge 6: Removing Duplicate Observations</h2>
<p style="text-align: justify;">Let me start this section with a question.</p>
<p style="text-align: justify;">Again, you have two data sets <code><strong>house</strong></code> &amp; <code><strong>candidates</strong></code> as shown below. You are asked about the details of the next heir for each house with his/her military strength (in this case next heir will be the older child).</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th style="text-align: center;" colspan="4" align="center">Data : house</th>
</tr>
<tr>
<th>House</th>
<th>Region</th>
<th>Military_Strength</th>
</tr>
</thead>
<tbody>
<tr>
<td>Stark</td>
<td>The North</td>
<td>20000</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Slaver&#8217;s Bay</td>
<td>110000</td>
</tr>
<tr>
<td>Lannister</td>
<td>The Westerlands</td>
<td>60000</td>
</tr>
<tr>
<td>Baratheon</td>
<td>The Stormlands</td>
<td>40000</td>
</tr>
<tr>
<td>Tyrell</td>
<td>The Reach</td>
<td>30000</td>
</tr>
</tbody>
</table>
<table class="dataframe" style="display: inline-block; vertical-align: top; margin-left: 20px; padding-top: 0px;" border="1">
<thead>
<tr>
<th style="text-align: center;" colspan="2" align="center">Data : candidates</th>
</tr>
<tr>
<th>House</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lannister</td>
<td>Jamie Lannister</td>
</tr>
<tr>
<td>Stark</td>
<td>Robb Stark</td>
</tr>
<tr>
<td>Stark</td>
<td>Arya Stark</td>
</tr>
<tr>
<td>Lannister</td>
<td>Cersi Lannister</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Daenerys Targaryen</td>
</tr>
<tr>
<td>Baratheon</td>
<td>Robert Baratheon</td>
</tr>
<tr>
<td>Mormont</td>
<td>Jorah Mormont</td>
</tr>
</tbody>
</table>
<p>Now, lets apply merge operation using the &#8220;house&#8221; key from <code><strong>candidates</strong></code> frame :</p>
<p><strong></strong></p>
<p><code>#using left join<br/>
&gt; heir = pd.merge(candidates,house,on="House",how='left')</code></p>
<p><strong>R Code</strong></p>
<p><code>&gt; heir = merge(candidates,house,by="House",all.x=TRUE,sort=FALSE)</code></p>
<p>The output will be :</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th>House</th>
<th>Name</th>
<th>Region</th>
<th>Military_Strength</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lannister</td>
<td>Jamie Lannister</td>
<td>The Westerlands</td>
<td>60000</td>
</tr>
<tr>
<td>Stark</td>
<td>Robb Stark</td>
<td>The North</td>
<td>20000</td>
</tr>
<tr>
<td>Stark</td>
<td>Arya Stark</td>
<td>The North</td>
<td>20000</td>
</tr>
<tr>
<td>Lannister</td>
<td>Cersi Lannister</td>
<td>The Westerlands</td>
<td>60000</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Daenerys Targaryen</td>
<td>Slaver&#8217;s Bay</td>
<td>110000</td>
</tr>
<tr>
<td>Baratheon</td>
<td>Robert Baratheon</td>
<td>The Stormlands</td>
<td>40000</td>
</tr>
<tr>
<td>Mormont</td>
<td>Jorah Mormont</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<p style="text-align: justify;">As you can see, we have repetition here which is not needed for the question I asked. You have to understand the structure of data sets and the method being applied for merging. Otherwise you can end up with a data set that you think is ready for analysis, but it is not the required one and can impact the output.</p>
<p>Just take a minute and think about the possible solutions for this problem.</p>
<p>To tackle this problem we can apply several methods. Here we are going to use the following method :</p>
<p style="text-align: justify;"><strong>1. Removing the duplicates : </strong>We can remove the redundant entries from the <strong>candidates </strong>data frame by keeping the first entry of the candidate from the top. We are using the first entry because candidates are sorted age wise in descending order. So, the older child will be at higher position in the data frame. Below are the codes to implement it :<br/>
<code><code>#keep = 'first' will keep the first occurrence<br/>
#keep = 'last' will keep the last occurrence<br/>
#keep = False will drop all the duplicates<br/>
# make sure to use inplace=True to save the modified data frame</code></code></p>
<p><strong></strong></p>
<p><code>&gt; candidates.drop_duplicates(subset=['House'],keep='first',inplace=True)</code></p>
<p><strong>R Code</strong></p>
<p><code>&gt; candidates &lt;- candidates[!duplicated(candidates[,1]),]</code></p>
<p>Now we can merge the data frames :</p>
<p><code>#In python</code><br/>
<code>&gt; pd.merge(candidates,house,on="House",how='left')</code></p>
<p><code>#In R</code><br/>
<code>&gt; merge(candidates,house,by="House",all.x=TRUE,sort=FALSE)</code></p>
<p style="text-align: justify;">The output will be :</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th>House</th>
<th>Name</th>
<th>Region</th>
<th>Military_Strength</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lannister</td>
<td>Jamie Lannister</td>
<td>The Westerlands</td>
<td>60000</td>
</tr>
<tr>
<td>Stark</td>
<td>Robb Stark</td>
<td>The North</td>
<td>20000</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Daenerys Targaryen</td>
<td>Slaver&#8217;s Bay</td>
<td>110000</td>
</tr>
<tr>
<td>Baratheon</td>
<td>Robert Baratheon</td>
<td>The Stormlands</td>
<td>40000</td>
</tr>
<tr>
<td>Mormont</td>
<td>Jorah Mormont</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<p style="text-align: justify;">As we can see &#8220;Arya Stark&#8221; from house &#8220;Stark&#8221; and &#8220;Cersi Lannister&#8221; from house &#8220;Lannister&#8221; are removed in the resultant data set thus providing the rightful heirs from each house.</p>
<p><strong>2. Aggregating the duplicates : </strong>Let understand this using an example.</p>
<p style="text-align: justify;">Suppose if there are two members from a house then each member will have the military strength shown separately. As given in <code><strong>house</strong></code><strong> </strong>data set, &#8220;Starks&#8221; have 20,000 soldiers. Then, both &#8220;Arya Stark&#8221; and &#8220;Robb Stark&#8221; gets 20,000 soldiers individually.</p>
<p style="text-align: justify;">But, while forming the list of the rightful heirs from each house, the oldest heir gets the first right to claim the throne / title. Hence, we don&#8217;t need just one heir for a house.</p>
<p style="text-align: justify;">How can we remove this redundancy? By simply removing the repetition as done in previous method will end up getting us wrong data, thus we have to add up the military strength for the members of same house. For different situation this technique will differ.</p>
<p>&nbsp;</p>
<h2 class="western">Challenge 7: Dropping Columns</h2>
<p style="text-align: justify;">After merging the data sets, we ended up with a data set consisting a large number of columns. Some of the columns are trivial or consist of information which is already present in other variables (co-related).</p>
<p>Suppose we have the data set :</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th style="text-align: center;" colspan="5" align="center">Data : merged_candidates</th>
</tr>
<tr>
<th>House</th>
<th>Name</th>
<th>Region_left</th>
<th>Region_right</th>
<th>Military_Strength</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lannister</td>
<td>Jamie Lannister</td>
<td>Westros</td>
<td>The Westerlands</td>
<td>60000</td>
</tr>
<tr>
<td>Stark</td>
<td>Robb Stark</td>
<td>North</td>
<td>The North</td>
<td>20000</td>
</tr>
<tr>
<td>Stark</td>
<td>Arya Stark</td>
<td>Westros</td>
<td>The North</td>
<td>20000</td>
</tr>
<tr>
<td>Lannister</td>
<td>Cersi Lannister</td>
<td>Westros</td>
<td>The Westerlands</td>
<td>60000</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Daenerys Targaryen</td>
<td>Mereene</td>
<td>Slaver&#8217;s Bay</td>
<td>110000</td>
</tr>
<tr>
<td>Baratheon</td>
<td>Robert Baratheon</td>
<td>Westros</td>
<td>The Stormlands</td>
<td>40000</td>
</tr>
<tr>
<td>Mormont</td>
<td>Jorah Mormont</td>
<td>Mereene</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<p style="text-align: justify;">The data frame shown above has two similar kind of variables <code class="western">Region_left</code> and <code class="western">Region_right</code>. Out of these two <code class="western">Region_right</code> is insignificant we want to remove this variable :</p>
<p><strong></strong></p>
<p><code class="western"># axis=1 will remove the mentioned columns<br/>
&gt; merged_candidates = merged_candidates.drop('Region_right',axis=1)</code></p>
<p><strong>R Code</strong></p>
<p><code>&gt; merged_candidates &lt;- subset(merged_candidates,select=-c(Region_Right))</code></p>
<p>The output will be :</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th>House</th>
<th>Name</th>
<th>Region_left</th>
<th>Military_Strength</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lannister</td>
<td>Jamie Lannister</td>
<td>Westros</td>
<td>60000</td>
</tr>
<tr>
<td>Stark</td>
<td>Robb Stark</td>
<td>North</td>
<td>20000</td>
</tr>
<tr>
<td>Stark</td>
<td>Arya Stark</td>
<td>Westros</td>
<td>20000</td>
</tr>
<tr>
<td>Lannister</td>
<td>Cersi Lannister</td>
<td>Westros</td>
<td>60000</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Daenerys Targaryen</td>
<td>Mereene</td>
<td>110000</td>
</tr>
<tr>
<td>Baratheon</td>
<td>Robert Baratheon</td>
<td>Westros</td>
<td>40000</td>
</tr>
<tr>
<td>Mormont</td>
<td>Jorah Mormont</td>
<td>Mereene</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h2 class="western">Challenge 8: Modifying Value(s) of a DataFrame</h2>
<p><strong>Modifying a particular element</strong></p>
<p style="text-align: justify;">Our work is not finished yet. There are some irregularities that we still have to take care of. A data set might contain incorrect information. In our merged data set from last section candidate &#8220;Arya Stark&#8221; is in &#8220;North&#8221; region but this data shows &#8220;Westros&#8221; as her region.</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th style="text-align: center;" colspan="4" align="center">Data : merged</th>
</tr>
<tr>
<th>House</th>
<th>Name</th>
<th>Region_left</th>
<th>Military_Strength</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lannister</td>
<td>Jamie Lannister</td>
<td>Westros</td>
<td>60000</td>
</tr>
<tr>
<td>Stark</td>
<td>Robb Stark</td>
<td>North</td>
<td>20000</td>
</tr>
<tr>
<td>Stark</td>
<td>Arya Stark</td>
<td>Westros</td>
<td>20000</td>
</tr>
<tr>
<td>Lannister</td>
<td>Cersi Lannister</td>
<td>Westros</td>
<td>60000</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Daenerys Targaryen</td>
<td>Mereene</td>
<td>110000</td>
</tr>
<tr>
<td>Baratheon</td>
<td>Robert Baratheon</td>
<td>Westros</td>
<td>40000</td>
</tr>
<tr>
<td>Mormont</td>
<td>Jorah Mormont</td>
<td>Mereene</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<p>We have to change the region of &#8220;Arya Stark&#8221; to &#8220;North&#8221; :</p>
<p><strong></strong></p>
<p><code class="western"># Arya Stark's region will be replaced from "Westros" to "North"<br/>
&gt;merged[merged['Name']=="Arya Stark"]=merged[merged['Name']=="Arya Stark"].replace("Westros","North")</code></p>
<p><strong>R Code</strong></p>
<p><code>&gt; merged$Region_left[which(merged$Name=="Arya Stark")] &lt;- "North"</code></p>
<p>The output will look like :</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th>House</th>
<th>Name</th>
<th>Region_left</th>
<th>Military_Strength</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lannister</td>
<td>Jamie Lannister</td>
<td>Westros</td>
<td>60000</td>
</tr>
<tr>
<td>Stark</td>
<td>Robb Stark</td>
<td>North</td>
<td>20000</td>
</tr>
<tr>
<td>Stark</td>
<td>Arya Stark</td>
<td>North</td>
<td>20000</td>
</tr>
<tr>
<td>Lannister</td>
<td>Cersi Lannister</td>
<td>Westros</td>
<td>60000</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Daenerys Targaryen</td>
<td>Mereene</td>
<td>110000</td>
</tr>
<tr>
<td>Baratheon</td>
<td>Robert Baratheon</td>
<td>Westros</td>
<td>40000</td>
</tr>
<tr>
<td>Mormont</td>
<td>Jorah Mormont</td>
<td>Mereene</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<p>After this operation region of &#8220;Arya Stark&#8221; is changed to &#8220;North&#8221;.</p>
<p>&nbsp;</p>
<p><strong>Modifying elements on the basis of a condition</strong></p>
<p style="text-align: justify;">In our data set, region &#8220;Westros&#8221; is a more general term consisting of many kingdoms so we have to change all the entries &#8220;Westros&#8221; to &#8220;Kings Landing&#8221;. Let&#8217;s see how to do it</p>
<p><strong></strong></p>
<p><code class="western"># All the Westros are replaced by Kings Landing<br/>
&gt; merged.replace("Westros","Kings Landing",inplace=True)</code></p>
<p><strong>R Code</strong></p>
<p><code>&gt; merged$Region_left[which(merged$Region_left=="Westros")]="Kings Landing"</code></p>
<p>The output will be:</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th>House</th>
<th>Name</th>
<th>Region_left</th>
<th>Military_Strength</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lannister</td>
<td>Jamie Lannister</td>
<td>Kings Landing</td>
<td>60000</td>
</tr>
<tr>
<td>Stark</td>
<td>Robb Stark</td>
<td>North</td>
<td>20000</td>
</tr>
<tr>
<td>Stark</td>
<td>Arya Stark</td>
<td>North</td>
<td>20000</td>
</tr>
<tr>
<td>Lannister</td>
<td>Cersi Lannister</td>
<td>Kings Landing</td>
<td>60000</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Daenerys Targaryen</td>
<td>Mereene</td>
<td>110000</td>
</tr>
<tr>
<td>Baratheon</td>
<td>Robert Baratheon</td>
<td>Kings Landing</td>
<td>40000</td>
</tr>
<tr>
<td>Mormont</td>
<td>Jorah Mormont</td>
<td>Mereene</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h2 class="western">Challenge 9: Renaming Column Name(s)</h2>
<p style="text-align: justify;">We are just finishing up with all the challenges, lastly there might be a scenario where you want to change a column name. Let&#8217;s say in our data set, we want to change the column name from &#8220;Region_left&#8221; to &#8220;Region&#8221; .</p>
<p>Before changing the column name our data set was :</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th style="text-align: center;" colspan="4" align="center">Data : merged</th>
</tr>
<tr>
<th>House</th>
<th>Name</th>
<th>Region_left</th>
<th>Military_Strength</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lannister</td>
<td>Jamie Lannister</td>
<td>Kings Landing</td>
<td>60000</td>
</tr>
<tr>
<td>Stark</td>
<td>Robb Stark</td>
<td>North</td>
<td>20000</td>
</tr>
<tr>
<td>Stark</td>
<td>Arya Stark</td>
<td>North</td>
<td>20000</td>
</tr>
<tr>
<td>Lannister</td>
<td>Cersi Lannister</td>
<td>Kings Landing</td>
<td>60000</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Daenerys Targaryen</td>
<td>Mereene</td>
<td>110000</td>
</tr>
<tr>
<td>Baratheon</td>
<td>Robert Baratheon</td>
<td>Kings Landing</td>
<td>40000</td>
</tr>
<tr>
<td>Mormont</td>
<td>Jorah Mormont</td>
<td>Mereene</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<p>Changing the column name using the following code</p>
<p><strong></strong></p>
<p><code class="western">&gt; merged.columns = merged.columns.str.replace("Region_left","Region")</code></p>
<p>R Code<strong></strong></p>
<p><code>&gt; colnames(merged)[which(names(merged)=="Region_left")] &lt;- "Region"</code></p>
<p>The output will be:</p>
<table class="dataframe" style="display: inline-block;" border="1">
<thead>
<tr>
<th>House</th>
<th>Name</th>
<th>Region</th>
<th>Military_Strength</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lannister</td>
<td>Jamie Lannister</td>
<td>Kings Landing</td>
<td>60000</td>
</tr>
<tr>
<td>Stark</td>
<td>Robb Stark</td>
<td>North</td>
<td>20000</td>
</tr>
<tr>
<td>Stark</td>
<td>Arya Stark</td>
<td>North</td>
<td>20000</td>
</tr>
<tr>
<td>Lannister</td>
<td>Cersi Lannister</td>
<td>Kings Landing</td>
<td>60000</td>
</tr>
<tr>
<td>Targaryen</td>
<td>Daenerys Targaryen</td>
<td>Mereene</td>
<td>110000</td>
</tr>
<tr>
<td>Baratheon</td>
<td>Robert Baratheon</td>
<td>Kings Landing</td>
<td>40000</td>
</tr>
<tr>
<td>Mormont</td>
<td>Jorah Mormont</td>
<td>Mereene</td>
<td>NaN</td>
</tr>
</tbody>
</table>
