
<base target="_blank">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<style type="text/css">

body {
 font-size: 20px;
 margin: 10%;
 background-color: #000000;
 color: #109030;
}
a { text-decoration: none;
  color: #28B8B8;}
a:visited { color: #389898;}
A:hover { color: yellow;}
A:focus { color: red;}
code { color: gray; background-color: #001800}
pre { color: gray; background-color: #001010}
#newtype { color: pink}
#redpink { color: #cc0099}
#redword { color: red}
#yellowword { color: yellow}
#greenword { color: lightgreen}
#limeword { color: #00ff00}
#orangeword { color: orange}
#cyanword { color: cyan}
#whiteword { color: white}
#grayword { color: gray}
#brownword { color: #ff8000}
#yellowgreen { color: #bfff00}
#palered { color: #ffcccc}
#blueword { color: dodgerblue}
#purpleword { color: darkorchid}
#goldword { color: GoldenRod}
#silverword { color: silver}
#blackword { color: black}
.left {
    position: absolute;
    left: 100px;
    color: GoldenRod;
    border: 1px solid GoldenRod;
    padding: 2px;
    font-size: 60%;
}
.aquacolor {
    color: Aqua;
}
.bord {
    color: redpink;
    border: 1px solid GoldenRod;
    padding: 1px;
    font-size: 90%;
}
.bordsub {
    color: #F07070;
    margin: 3px 90px 3px 90px;
    border: 1px solid darkcyan;
    padding: 1px;
    font-size: 90%;
}
.highlight { 
    color: white;
    background-color: #002030
  }
.redpink { color: .cc0099}
.redword { color: red}
.yellowword { color: yellow}
.greenword { color: lightgreen}
.limeword { color: .00ff00}
.orangeword { color: orange}
.cyanword { color: cyan}
.whiteword { color: white}
.grayword { color: gray}
.brownword { color: #ff8000}
.yellowgreen { color: #bfff00}
.palered { color: #ffcccc}
.blueword { color: dodgerblue}
.purpleword { color: darkorchid}
.goldword { color: GoldenRod}
.silverword { color: silver}
.blackword { color: black}

</STYLE>
</head>


        
  <h1>
    ESP8266 Thing Hookup Guide  </h1>

          <div class="section tutorial-page">
        <h2 id="introduction">Introduction</h2>
        <p>Over the past year, the ESP8266 has been a growing star among IoT or WiFi-related projects. It&rsquo;s an extremely cost-effective WiFi module, that &ndash; with a little extra effort &ndash; can be programmed just like any microcontroller. Unfortunately, the ESP8266 has mostly only been available in a <a href="https://www.sparkfun.com/products/13252">tiny, modular form</a>, which, with limited I/O and a funky pin-out, can be difficult to build a project around.</p>

<p style="text-align:center;">
  
<img src="https://cdn.sparkfun.com/r/400-400/assets/parts/1/0/4/5/3/13252-01.jpg"></p>

<p style="text-align:center;"> <em>The original ESP8266 WiFi module. Great for piggybacking onto an Arduino, hard to build a project around.</em></p>

<p>SparkFun&rsquo;s new development board for the ESP8266 breaks out all of the module&rsquo;s pins, and comes equipped with a LiPo charger, power supply, and all of the other supporting circuitry it requires. We lovingly call it the Thing &ndash; it&rsquo;s the perfect foundation for your Internet of Things.</p>

<p style="text-align:center;"> 
  <img src="https://cdn.sparkfun.com/assets/learn_tutorials/3/6/5/product-angled.jpg"/></p>

<h3>Covered in this Tutorial</h3>

<p>This tutorial will familiarize you with all things SparkFun Thing. It&rsquo;s split into sections, which cover:</p>

<ul>
<li><a href="https://learn.sparkfun.com/tutorials/esp8266-thing-hookup-guide/hardware-overview">Hardware Overview</a> &ndash; A quick rundown of the Thing&rsquo;s <strong>components and pinout</strong>.</li>
<li><a href="https://learn.sparkfun.com/tutorials/esp8266-thing-hookup-guide/powering-the-thing">Powering the Thing</a> &ndash; The Thing can be powered through either USB or a LiPo battery.</li>
<li><a href="https://learn.sparkfun.com/tutorials/esp8266-thing-hookup-guide/programming-the-thing">Programming the Thing</a> &ndash; Interface a 3.3V FTDI Basic with the Thing to program it.</li>
<li><a href="https://learn.sparkfun.com/tutorials/esp8266-thing-hookup-guide/hardware-assembly">Hardware Assembly</a> &ndash; Tips and recommendations on what to solder to the Thing&rsquo;s I/O pins.</li>
<li><a href="https://learn.sparkfun.com/tutorials/esp8266-thing-hookup-guide/installing-the-esp8266-arduino-addon">Installing the ESP8266 Arduino Addon</a> &ndash; The Thing can be programmed using Arduino! Just follow the instructions here to install the board definitions.</li>
<li><a href="https://learn.sparkfun.com/tutorials/esp8266-thing-hookup-guide/example-sketch-posting-to-phant">Example Sketch: Posting to Phant</a> &ndash; Our first example shows how you can use the Thing to post data to <a href="https://data.sparkfun.com">data.sparkfun.com</a>.</li>
<li><a href="https://learn.sparkfun.com/tutorials/esp8266-thing-hookup-guide/example-sketch-ap-web-server">Example Sketch: AP Web Server</a> &ndash; Set the Thing up as an access point and use it to serve web pages.</li>
<li><a href="https://learn.sparkfun.com/tutorials/esp8266-thing-hookup-guide/example-sketch-goodnight-thing-sleep-mode">Example Sketch: Goodnight Thing (Sleep Mode)</a> &ndash; Put the Thing to sleep to save that sweet battery juice.</li>
<li><a href="https://learn.sparkfun.com/tutorials/esp8266-thing-hookup-guide/using-the-arduino-addon">Using the Arduino Addon</a> &ndash; There are a few key differences between programming the Thing and any other Arduino board.</li>
</ul>


<h3>Required Materials</h3>

<p>To follow along with this tutorial, and get up-and-running with the Thing, you may need a few extra tools and materials. This wishlist includes everything we use in this tutorial to program and use the Thing:</p>

<script src="https://www.sparkfun.com/wish_lists/111881.js"></script>


<h3>Suggested Reading</h3>

<p>Before continuing on with this tutorial, you may want to familiarize yourself with some of these topics if they&rsquo;re unfamiliar to you:</p>

<ul>
<li><a href="https://learn.sparkfun.com/tutorials/how-to-power-a-project">How to Power a Project</a></li>
<li><a href="https://learn.sparkfun.com/tutorials/logic-levels">Logic Levels</a></li>
<li><a href="https://learn.sparkfun.com/tutorials/serial-communication">Serial Communication</a></li>
<li><a href="https://learn.sparkfun.com/tutorials/how-to-solder---through-hole-soldering">How to Solder</a></li>
</ul>
      </div>
          <div class="section tutorial-page">
        <h2 id="hardware-overview">Hardware Overview</h2>
        <p>The ESP8266 Thing</a> is a relatively simple board. The pins are broken out to two parallel, breadboard-compatible rows. USB and LiPo connectors at the top of the board provide power &ndash; controlled by the nearby ON/OFF switch. And LEDs towards the inside of the board indicate power, charge, and status of the IC.</p>

<p>Here&rsquo;s a quick overview of the Thing&rsquo;s main components:</p>

<p style="text-align:center;">
  <img src="https://cdn.sparkfun.com/r/600-600/assets/learn_tutorials/3/6/5/board-top-annotated_1.jpg"/></p>

<h3>The Pinout</h3>

<p>The Thing&rsquo;s I/O headers can be broken down into three sections:</p>

<h4>Serial Programming Header</h4>

<p>This six-pin header will be the main point of contact between the Thing and your development computer. The pinout of this header matches the extremely common &ldquo;FTDI header.&rdquo; That means you can interface it with either a <a href="https://www.sparkfun.com/products/9873">3.3V FTDI Basic</a> or a <a href="https://www.sparkfun.com/products/9717">3.3V I/O FTDI Cable</a> to program and debug the Thing.</p>

<p>For a quick breakdown of the pins on this header, consult the table below. If a pin is directly tied to an ESP8266 I/O, it&rsquo;ll be noted:</p>

<table class="table table-striped table-bordered table-hover">
<tr><th>Pin Label</th><th>ESP8266 I/O #</th><th>Notes</th></tr>
<tr class="success"><th>DTR</th><td></td><td>Performs auto-reset, and puts the ESP8266 into bootloader mode. Connects through a capacitor to RESET, and a buffer to the ESP8266's GPIO0.</td></tr>
<tr class="info"><th>TXO</th><td>7</td><td>ESP8266 UART1 data output.</td></tr>
<tr class="info"><th>RXI</th><td>8</td><td>ESP8266 UART1 data input.</td></tr>
<tr class="danger"><th>3V3</th><td></td><td>By default, this pin does not supply the ESP8266 directly (a jumper on the back can change that).</td></tr>
<tr><th>NC</th><td></td><td>Not connected to anything on the Thing.</td></tr>
<tr class="active"><th>GND</th><td></td><td>Ground (0V).</td></tr>
</table>


<h4>I<sup>2</sup>C Header</h4>

<p><a href="https://learn.sparkfun.com/tutorials/i2c">I<sup>2</sup>C</a> is a very popular communication protocol in the embedded world. Whether you want to hook the Thing up to a <a href="https://www.sparkfun.com/products/12636">motion sensor</a>, <a href="https://www.sparkfun.com/products/12055">light sensor</a>, <a href="https://www.sparkfun.com/products/12918">digital-to-analog converter</a>, or <a href="https://www.sparkfun.com/products/13003">OLED display</a>, I<sup>2</sup>C is often the protocol of choice.</p>

<p>This header includes four pins &ndash; all that should be required to connect an I<sup>2</sup>C device up to the Thing.</p>

<table class="table table-striped table-bordered table-hover">
<tr><th>Pin Label</th><th>ESP8266 I/O #</th><th>Notes</th></tr>
<tr class="active"><th>GND</th><td></td><td>Ground (0V).</td></tr>
<tr class="danger"><th>3V3</th><td></td><td>3.3V</td></tr>
<tr class="info"><th>SDA</th><td>2</td><td>Can either be used as ESP8266 GPIO2 or I<sup>2</sup>C serial data (SDA).</td></tr>
<tr class="info"><th>SCL</th><td>14</td><td>Can either be used as ESP8266 GPIO14 or I<sup>2</sup>C serial clock (SCL).<br>Also used as the SPI clock (SCLK).</td></tr>
</table>


<p>This pinout matches that of most of our I<sup>2</sup>C-based breakout boards, so you can piggyback them right on top of the Thing.</p>

<p>If you need the extra I/O, instead of I<sup>2</sup>C, the SDA and SCL pins can be used as GPIO 2 and 14 respectively. The SCL pin also serves as the clock (SCLK) for the ESP8266&rsquo;s SPI interface.</p>

<h4>General I/O Header</h4>

<p>The rest of the power, control, and I/O pins are broken out on the other side of the board. They are:</p>

<table class="table table-striped table-bordered table-hover">
<tr><th>Pin Label</th><th>ESP8266 I/O #</th><th>Notes</th></tr>
<tr class="active"><th>GND</th><td></td><td>Ground (0V).</td></tr>
<tr class="danger"><th>VIN</th><td></td><td>USB connected: ~4.5V output<br>LiPo connected (no USB): ~3.7V output<br>No supply: Can be used as a voltage supply input to the 3.3V regulator.</td></tr>
<tr class="info"><th>5</th><td>5</td><td>This pin is also tied to the on-board LED.</td></tr>
<tr class="info"><th>0</th><td>0</td><td></td></tr>
<tr class="info"><th>4</th><td>4</td><td></td></tr>
<tr class="info"><th>13</th><td>13</td><td>Hardware SPI MOSI</td></tr>
<tr class="info"><th>12</th><td>12</td><td>Hardware SPI MISO</td></tr>
<tr class="info"><th>XPD</th><td>16</td><td>Can be connected to reset to set the ESP8266 into deep sleep mode.</td></tr>
<tr class="info"><th>ADC</th><td>A0</td><td>A 10-bit ADC with a <b>maximum voltage of 1V</b>.</td></tr>
<tr class="info"><th>EN</th><td></td><td>ESP8266 enable pin. HIGH = on, LOW = off. Pulled HIGH on-board.</td></tr>
</table>


<p>What happened to the rest of the GPIO pins? Why the eclectic pin-numbering scheme? We&rsquo;re taking what the ESP8266 gives us. Unfortunately, most of the remaining GPIO are connected to the on-board SPI flash memory IC, which stores the ESP8266&rsquo;s program memory and potentially other data.</p>

<h3>Back of the Thing</h3>

<p>Flipping the Thing over revels a few trace jumpers and test points, which you may find handy for your application. (Plus a friendly <a href="http://phant.io">Phant.io</a> logo, to remind you about our data storage service on <a href="https://data.sparkfun.com">data.sparkfun.com</a>.)</p>

<p style="text-align:center;">
  
  <img src="https://cdn.sparkfun.com/assets/learn_tutorials/3/6/5/product-back.jpg"></p>

<h4>Jumpers</h4>

<table class="table table-striped table-bordered table-hover">
<tr><th>Jumper Label</th><th>Default Setting</th><th>Notes</th></tr>
<tr><th>DTR</th><td>Closed</td><td>Allows for auto-reset while programming the ESP8266, but makes serial debugging difficult.</td></tr>
<tr><th>I2C PU</th><td>Closed</td><td>Connects 10k&Omega; pull-up resistors to the SDA and SCL pins.</td></tr>
<tr><th>FTDI VCC</th><td>Open</td><td>Connects the 3V3 pin on the serial header directly to the ESP8266's 3.3V supply.</td></tr>
</table>


<p>Of these jumpers, the <em>DTR</em> one is the most commonly modified. The DTR output of the FTDI Basic is used for two purposes: to reset the ESP8266 and pull GPIO0 low (putting the chip in bootloader mode). Keeping this jumper closed enables programming, but makes debugging via the Serial Monitor difficult, as the board will reset into bootloader mode whenever the terminal opens. Using and modifying this jumper is discussed <a href="https://learn.sparkfun.com/tutorials/esp8266-thing-hookup-guide/using-the-arduino-addon#serial-dtr">later in this tutorial</a>.</p>

<p>The <em>FTDI_VCC</em> jumper defaults to open to ensure that, if a <a href="https://www.sparkfun.com/products/9717">3.3V Logic (5V power) FTDI Cable</a> is used to program the Thing, 5V isn&rsquo;t accidentally delivered to the IC. Also, most 3.3V FTDI boards don&rsquo;t have a lot of juice to supply on the 3.3V bus (they often supply about 50mA max).</p>

<h4>Test Points</h4>

<p>These pins are made available just in case they become necessary to your project. The six pins bundled up together are connected to the Thing&rsquo;s on-board SPI flash memory, but if you really need the extra GPIO, or want to experiment with the pins, they&rsquo;re available.</p>

<p>The <strong>RST</strong> pin is more useful, but we didn&rsquo;t leave room to break it out &ndash; at least not directly. <em>RST</em> is tied through a 0.1&micro;F capacitor to the <em>DTR</em> pin, to allow for automatic reset during programming. For many applications that need the <em>RST</em> pin, toggling the <em>DTR</em> pin works as well. Putting the ESP8266 into <a href="https://learn.sparkfun.com/tutorials/esp8266-thing-hookup-guide/example-sketch-goodnight-thing-sleep-mode">deep sleep</a> is one such application.</p>

<h3>Selecting the Antenna <a name="selecting-antenna"></a></h3>

<p>The Thing&rsquo;s default WiFi antenna is a PCB trace antenna based on <a href="http://www.ti.com/lit/an/swru120b/swru120b.pdf">this TI app note</a>. It&rsquo;s cost-effective and actually works really well!</p>

<p>If you need to connect a more sensitive antenna to the chip, a U.FL connector is also available on the board, but isn&rsquo;t connected by default to the ESP8266&rsquo;s antenna pin. To connect this antenna to the chip, you&rsquo;ll need to heat up the 0&Omega; resistor and rotate it 90&deg;:</p>

<p style="text-align:center;">
  
  <img src="https://cdn.sparkfun.com/r/600-600/assets/learn_tutorials/3/6/5/antenna-resistor-select.jpg"></p>

<p style="text-align:center;"> <em>An (ugly, uncleaned) resistor swapped from printed antenna to U.FL antenna.</em></p>

<p>A <a href="https://www.sparkfun.com/products/9507">soldering iron</a>, <a href="https://www.sparkfun.com/products/10602">pair of tweezers</a>, (2) steady hands, and good set of eyes should be enough to accomplish the task.</p>

<h3>Why Are There Unpopulated Parts?</h3>

<p>We initially set out to make the Thing a secure, common-sensor base station. The empty pads you see are landing spots for three unique IC&rsquo;s:</p>

<ul>
<li><a href="http://www.atmel.com/devices/ATECC108A.aspx">ATECC108A</a> &ndash; A &ldquo;full turnkey Elliptic Curve Digital Signature Algorithm (ECDSA) engine&rdquo;, which can be used for unique serial numbers, hashing, key storage, or random numbers. A great start to securing your IoT project!</li>
<li><a href="https://www.sparkfun.com/products/11931">TMP102 Temperature Sensor</a> &ndash; A simple, 12-bit, digital temperature sensor.</li>
<li><a href="https://www.sparkfun.com/products/12055">TSL2561 Light Sensor</a> &ndash; A nifty luminosity/light sensor.</li>
<li>Plus a few footprints for decoupling capacitors.</li>
</ul>


<p>After a late change of heart, we decided to keep the board as low cost as possible (that&rsquo;s the ESP8266&rsquo;s best feature!), while leaving the option for later expansion. The pads are still there. If you want to add any of these components, hopefully all you should need is a <a href="https://www.sparkfun.com/products/10706">hot air station</a> (<strike>maybe</strike> probably not a <a href="https://www.sparkfun.com/products/10326">Heaterizer</a>) and some tweezers.</p>      </div>
          <div class="section tutorial-page">
        <h2 id="powering-the-thing">Powering the Thing</h2>
        <p>The Thing provides for two methods of power delivery: USB or LiPo. The USB connector on the Thing is of the Micro-B variety. A <a href="https://www.sparkfun.com/products/10215">micro-B cable</a> plugged into either a computer USB port or a <a href="https://www.sparkfun.com/products/11456">5V USB Wall Wart</a> can power the Thing.</p>

<p>Any of our single-cell <a href="https://www.sparkfun.com/categories/54">LiPo batteries</a> will also work to power the Thing &ndash; they all have the same 2-pin JST connector.</p>

<p style="text-align:center;"> 
  
  <img src="https://cdn.sparkfun.com/r/600-600/assets/learn_tutorials/3/6/5/example-i2c-hookup.jpg"></p>

<p style="text-align:center;"> <em>Add an <a href="https://www.sparkfun.com/products/341">850mAh LiPo</a> and an <a href="https://www.sparkfun.com/products/12636">LSM9DS0 9DoF IMU</a> to the Thing, to create an IoT motion sensor.</em></p>

<p>If both USB and LiPo are connected to the Thing, it&rsquo;ll take power from the USB port and charge the LiPo battery at up to 500mA.</p>

<h3>Electrical Characteristics</h3>

<p>The ESP8266&rsquo;s maximum voltage is 3.6V, so the Thing has an onboard 3.3V regulator to deliver a safe, consistent voltage to the IC. That means the ESP8266&rsquo;s I/O pins also run at 3.3V, you&rsquo;ll need to <a href="https://learn.sparkfun.com/tutorials/using-the-logic-level-converter">level shift</a> any 5V signals running into the IC.</p>

<p>The input to this regulator can either be delivered by USB, LiPo battery, or through the <em>VIN</em> pin.</p>

<div class="alert alert-warning"><b>Max Input Voltage</b>: If you supply power to the board through the VIN, make sure the voltage does not exceed <b>6V</b>. That's the maximum input voltage of the <a href="http://www.diodes.com/datasheets/AP2112.pdf">AP2112K-3.3V regulator</a> the board uses.</div>


<p>Alternatively, if you have an external, regulated, supply you&rsquo;d like to deliver directly to the ESP8266, you can supply that voltage through the <em>3V3</em> pin (on the  I<sup>2</sup>C header). While this voltage doesn&rsquo;t have to be 3.3V, it must be within the range of <strong>1.7-3.6V</strong>.</p>

<h4>Current Ratings</h4>

<p>On average, the Thing pulls about 80mA. WiFi transmits and receives can momentarily increase that draw. Here&rsquo;s a table, transcribed from the ESP8266 datasheet, with some of the more common current characteristics.</p>

<table class="table table-striped table-bordered table-hover">
<tr><th>Parameter</th><th>Typical</td><th>Max</th><th>Unit</th></tr>
<tr><td>Transmit 802.11b (1 Mbps)</td><td>215</td><td></td><td>mA</td></tr>
<tr><td>Transmit 802.11b (11 Mbps)</td><td>197</td><td></td><td>mA</td></tr>
<tr><td>Transmit 802.11g (54 Mbps)</td><td>145</td><td></td><td>mA</td></tr>
<tr><td>Transmit 802.11n</td><td>135</td><td></td><td>mA</td></tr>
<tr><td>Receive 802.11b</td><td>60</td><td></td><td>mA</td></tr>
<tr><td>Receive 802.11g</td><td>60</td><td></td><td>mA</td></tr>
<tr><td>Receive 802.11n</td><td>62</td><td></td><td>mA</td></tr>
<tr><td>Standby</td><td>0.9</td><td></td><td>mA</td></tr>
<tr><td>Deep Sleep</td><td>10</td><td></td><td>&micro;A</td></tr>
<tr><td>Maximum I/O Pin Drive Capability</td><td></td><td>12</td><td>mA</td></tr>
</table>


<p>If your application requires maximum battery life, you&rsquo;ll likely need to make liberal use of the ESP8266&rsquo;s deep sleep functionality. That&rsquo;ll be covered later in this tutorial.</p>      </div>
          <div class="section tutorial-page">
        <h2 id="programming-the-thing">Programming the Thing</h2>
        <p>The ESP8266 has a built-in serial bootloader, which allows for easy programming and re-programming. You don&rsquo;t need a specialized, expensive programmer &ndash; just a simple, USB-to-Serial converter.</p>

<p>We use a <a href="https://www.sparkfun.com/products/9873">3.3V FTDI Basic</a> to program the Thing, but other serial converters with 3.3V I/O levels should work (e.g. <a href="https://www.sparkfun.com/products/12935">FTDI SmartBasic</a>, <a href="https://www.sparkfun.com/products/9717">FTDI Cable 5V VCC-3.3V I/O</a>, <a href="https://www.sparkfun.com/products/11736">FT231X Breakout</a>). The converter does need a DTR line in addition to the RX and TX pins.</p>

<div class="alert alert-danger"><b>Note:</b> While programming the Thing, it's best to power it off USB. We've noticed programming is more likely to fail if the Thing is only powered via the battery.</div>


<p>The FTDI Basic&rsquo;s 6-pin header matches up exactly to the Thing&rsquo;s 6-pin serial port header. To set up for programming, simply connect the FTDI directly to this port &ndash; take care to match up the DTR and GND pins!</p>

<p style="text-align:center;">
  
  <img src="https://cdn.sparkfun.com/r/600-600/assets/learn_tutorials/3/6/5/programming-the-thing.jpg"></p>

<p style="text-align:center;"> <em>If you&rsquo;re short on USB ports, the <a href="https://www.sparkfun.com/products/12016">SparkFun Cerberus Cable</a> might be just what you need.</em></p>

<p>If you solder female headers to the Thing, plugging a 6-pin row of <a href="https://www.sparkfun.com/products/553">right-angle male headers</a> between the FTDI and header helps create a temporary programming interface.</p>      </div>
          <div class="section tutorial-page">
        <h2 id="hardware-assembly">Hardware Assembly</h2>
        <p>Oh. We&rsquo;re getting ahead of ourselves. To connect the FTDI programmer to your Thing you&rsquo;ll need to solder <em>something</em> to the Thing.</p>

<p>If you&rsquo;ve never soldered before, this is a great time to start! These solder points are easy, through-hole pins, check out our <a href="https://learn.sparkfun.com/tutorials/how-to-solder---through-hole-soldering">How to Solder - Through-hole Soldering</a> for help getting started.</p>

<p>What, exactly, you solder to the board depends both on how you&rsquo;ll use it in your project, and how you&rsquo;ll interface it with the programmer. When it comes to selecting a header (or wire) to solder, there are a variety of options. We&rsquo;ve tried a lot of them with the Thing:</p>

<p><a href="https://www.sparkfun.com/products/11376">10-pin Stackable Headers</a> make it convenient to both breadboard the Thing and jumper wire out of it.</p>

<p style="text-align:center;">
  
  <img src="https://cdn.sparkfun.com/r/600-600/assets/learn_tutorials/3/6/5/stackable.jpg"></p>

<p>Or you can mix and match headers to best fit your needs. <a href="https://www.sparkfun.com/products/553">Right-angle male headers</a> may help to interface between the FTDI and the Thing. <a href="https://www.sparkfun.com/products/116">Straight male headers</a> are a good choice for low-profile connections. <a href="https://www.sparkfun.com/products/115">Straight female headers</a> may help with connecting to I<sup>2</sup>C sensors. And, of course, <a href="https://www.sparkfun.com/products/11367">wire</a> can be soldered to any of the pins that have a long way to connect to something.</p>

<p style="text-align:center;">
  
  <img src="https://cdn.sparkfun.com/r/600-600/assets/learn_tutorials/3/6/5/mult-header.jpg"></p>

<p>Once you&rsquo;ve soldered up at least the programming port, you&rsquo;re ready to load some code onto the Thing. Let&rsquo;s blink some LEDs and IoT (Internet our Thing).</p>      </div>
          <div class="section tutorial-page">
        <h2 id="installing-the-esp8266-arduino-addon">Installing the ESP8266 Arduino Addon</h2>
        <p>There are a variety of development environments that can be equipped to program the ESP8266. You can go with a simple Notepad/gcc setup, or fine-tune an Eclipse environment, use a virtual machine provided by Espressif, or come up with something of your own.</p>

<p>Fortunately, the amazing ESP8266 community recently took the IDE selection a step further by creating an Arduino addon. If you&rsquo;re just getting started programming the ESP8266, this is the environment we recommend beginning with, and the one we&rsquo;ll document in this tutorial.</p>

<p>This ESP8266 addon for Arduino is based on the amazing work by Ivan Grokhotkov and the rest of the ESP8266 community. Check out the <a href="https://github.com/esp8266/Arduino">ESP8266 Arduino GitHub repository</a> for more information.</p>

<h3>Installing the Addon With the Arduino Boards Manager</h3>

<p>With the release of Arduino 1.6.4, adding third party boards to the Arduino IDE is easily achieved through the new board manager. If you&rsquo;re running an older version of Arduino (1.6.3 or earlier), we recommend upgrading now. As always, you can download the latest version of Arduino from <a href="http://www.arduino.cc/en/Main/Software">arduino.cc</a>.</p>

<p>To begin, we&rsquo;ll need to update the board manager with a custom URL. Open up Arduino, then go to the Preferences (<strong>File</strong> > <strong>Preferences</strong>). Then, towards the bottom of the window, copy this URL into the &ldquo;Additional Board Manager URLs&rdquo; text box:</p>

<pre><code>http://arduino.esp8266.com/stable/package_esp8266com_index.json
</code></pre>

<p>If you already have a URL in there, and want to keep it, you can separate multiple URLs by placing a comma between them. (Arduino 1.6.5 added an expanded text box, separate links in here by line.)</p>

<p style="text-align:center;">
  
  <img src="https://cdn.sparkfun.com/r/600-600/assets/learn_tutorials/3/6/5/arduino-board-manager-link.png"></p>

<p>Hit OK. Then navigate to the Board Manager by going to <strong>Tools</strong> > <strong>Boards</strong> > <strong>Boards Manager</strong>. There should be a couple new entries in addition to the standard Arduino boards. Look for <strong>esp8266</strong>. Click on that entry, then select <strong>Install</strong>.</p>

<p style="text-align:center;">
  
  <img src="https://cdn.sparkfun.com/r/600-600/assets/learn_tutorials/3/6/5/arduino-board-install.png"></p>

<p>The board definitions and tools for the ESP8266 Thing include a whole new set of gcc, g++, and other reasonably large, compiled binaries, so it may take a few minutes to download and install (the archived file is ~110MB). Once the installation has completed, an Arduino-blue &ldquo;INSTALLED&rdquo; will appear next to the entry.</p>

<h3>Selecting the ESP8266 Thing Board</h3>

<p>With the Board addon installed, all that&rsquo;s left to do is select &ldquo;ESP8266 Thing&rdquo; from the <strong>Tools</strong> > <strong>Boards</strong> menu.</p>

<p style="text-align:center;">
  
  <img src="https://cdn.sparkfun.com/r/600-600/assets/learn_tutorials/3/6/5/arduino-board-select.png"></p>

<p>Then select your FTDI&rsquo;s port number under the <strong>Tools</strong> > <strong>Port</strong> menu.</p>

<h3>Upload Blink</h3>

<p>To verify that everything works, try uploading the old standard: Blink. Instead of blinking pin 13, like you may be used to though, toggle pin 5, which is attached to the onboard LED.</p>

<pre><code>language:c
#define ESP8266_LED 5

void setup() 
{
  pinMode(ESP8266_LED, OUTPUT);
}

void loop() 
{
  digitalWrite(ESP8266_LED, HIGH);
  delay(500);
  digitalWrite(ESP8266_LED, LOW);
  delay(500);
}
</code></pre>

<p>If the upload fails, first make sure the ESP8266 Thing is turned on &ndash; the red &ldquo;PWR&rdquo; LED should be illuminated.</p>

<div class="alert alert-success"><p><b>Faster Uploads!</b> The serial upload speed defaults to <b>115200 bps</b>, which is reliable, but can feel a bit slow. You can increase the upload speed by a factor of about 8 by selecting <b>921600</b> under the <b>Tools</b> > <b>Upload Speed</b> menu.</p>
<p style="text-align:center;">

<img src="https://cdn.sparkfun.com/assets/learn_tutorials/3/6/5/arduino-upload-speed.png">
</p>
<p>This faster upload speed can be slightly less reliable, but will save you loads of time!</p>
</div>


<p>There are still some bugs to be fleshed out of the esptool, sometimes it may take a couple tries to successfully upload a sketch. If you continue to fail, try turning the ESP8266 Thing on then off, or unplug then replug the FTDI in. If you still have trouble, get in touch with our amazing <a href="https://www.sparkfun.com/static/technical_assistance">tech support team</a>.</p>      </div>
          <div class="section tutorial-page">
        <h2 id="example-sketch-posting-to-phant">Example Sketch: Posting to Phant</h2>
        <p>Our main goal for creating the ESP8266 Thing was finding a good platform to interact with our free online data storage service: <a href="https://data.sparkfun.com">data.sparkfun.com</a>.</p>

<p>Here&rsquo;s a simple example sketch that posts four values to a <a href="https://data.sparkfun.com/streams/wpvZ9pE1qbFJAjaGd3bn">test stream</a>. Feel free to use that stream temporarily to make sure your Thing is working (don&rsquo;t abuse it please!).</p>

<div class="alert alert-info"><p><b>Install the Phant Library!</b> This example makes use of the SparkFun Phant Arduino library, to make assembling Phant POSTs as easy as possible. The Phant library can be installed using Arduino's <b>Library Manager</b>. Go to the <b>Sketch</b> > <b>Include Library</b> > <b>Manage Libraries...</b>, then search for "Phant" to find the library. Install the latest version (or at least 2.2.0).</p>
<p style="text-align:center;">
  
  <img src="https://cdn.sparkfun.com/r/600-600/assets/learn_tutorials/3/6/5/arduino-library-phant.png"></p>
<p>Or you can grab the Phant library from our <a href = "https://github.com/sparkfun/phant-arduino">phant-arduino</a> repository, and follow along with our <a href="https://learn.sparkfun.com/tutorials/esp8266-thing-hookup-guide/installing-the-esp8266-arduino-addon#">Installing an Arduino Library</a> for help installing the library.</p></div>


<p>Copy the code below, or <a href="https://cdn.sparkfun.com/assets/learn_tutorials/3/6/5/ESP8266_Phant.zip">download the example sketch</a>.</p>

<p>Before uploading your code to the Thing, make sure you modify the <code>WiFiSSD</code> and <code>WiFiPSK</code> variables, setting them to the SSID and password of your WiFi network. The rest of the sketch should just work.</p>

<pre><code>language:c
// Include the ESP8266 WiFi library. (Works a lot like the
// Arduino WiFi library.)
#include &lt;ESP8266WiFi.h&gt;
// Include the SparkFun Phant library.
#include &lt;Phant.h&gt;

//////////////////////
// WiFi Definitions //
//////////////////////
const char WiFiSSID[] = "WiFi_Network";
const char WiFiPSK[] = "WiFi_Password";

/////////////////////
// Pin Definitions //
/////////////////////
const int LED_PIN = 5; // Thing's onboard, green LED
const int ANALOG_PIN = A0; // The only analog pin on the Thing
const int DIGITAL_PIN = 12; // Digital pin to be read

////////////////
// Phant Keys //
////////////////
const char PhantHost[] = "data.sparkfun.com";
const char PublicKey[] = "wpvZ9pE1qbFJAjaGd3bn";
const char PrivateKey[] = "wzeB1z0xWNt1YJX27xdg";

/////////////////
// Post Timing //
/////////////////
const unsigned long postRate = 30000;
unsigned long lastPost = 0;

void setup() 
{
  initHardware();
  connectWiFi();
  digitalWrite(LED_PIN, HIGH);
}

void loop() 
{
  if (lastPost + postRate &lt;= millis())
  {
    if (postToPhant())
      lastPost = millis();
    else
      delay(100);    
  }
}

void connectWiFi()
{
  byte ledStatus = LOW;

  // Set WiFi mode to station (as opposed to AP or AP_STA)
  WiFi.mode(WIFI_STA);

  // WiFI.begin([ssid], [passkey]) initiates a WiFI connection
  // to the stated [ssid], using the [passkey] as a WPA, WPA2,
  // or WEP passphrase.
  WiFi.begin(WiFiSSID, WiFiPSK);

  // Use the WiFi.status() function to check if the ESP8266
  // is connected to a WiFi network.
  while (WiFi.status() != WL_CONNECTED)
  {
    // Blink the LED
    digitalWrite(LED_PIN, ledStatus); // Write LED high/low
    ledStatus = (ledStatus == HIGH) ? LOW : HIGH;

    // Delays allow the ESP8266 to perform critical tasks
    // defined outside of the sketch. These tasks include
    // setting up, and maintaining, a WiFi connection.
    delay(100);
    // Potentially infinite loops are generally dangerous.
    // Add delays -- allowing the processor to perform other
    // tasks -- wherever possible.
  }
}

void initHardware()
{
  Serial.begin(9600);
  pinMode(DIGITAL_PIN, INPUT_PULLUP);
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);
  // Don't need to set ANALOG_PIN as input, 
  // that's all it can be.
}

int postToPhant()
{
  // LED turns on when we enter, it'll go off when we 
  // successfully post.
  digitalWrite(LED_PIN, HIGH);

  // Declare an object from the Phant library - phant
  Phant phant(PhantHost, PublicKey, PrivateKey);

  // Do a little work to get a unique-ish name. Append the
  // last two bytes of the MAC (HEX'd) to "Thing-":
  uint8_t mac[WL_MAC_ADDR_LENGTH];
  WiFi.macAddress(mac);
  String macID = String(mac[WL_MAC_ADDR_LENGTH - 2], HEX) +
                 String(mac[WL_MAC_ADDR_LENGTH - 1], HEX);
  macID.toUpperCase();
  String postedID = "Thing-" + macID;

  // Add the four field/value pairs defined by our stream:
  phant.add("id", postedID);
  phant.add("analog", analogRead(ANALOG_PIN));
  phant.add("digital", digitalRead(DIGITAL_PIN));
  phant.add("time", millis());

  // Now connect to data.sparkfun.com, and post our data:
  WiFiClient client;
  const int httpPort = 80;
  if (!client.connect(PhantHost, httpPort)) 
  {
    // If we fail to connect, return 0.
    return 0;
  }
  // If we successfully connected, print our Phant post:
  client.print(phant.post());

  // Read all the lines of the reply from server and print them to Serial
  while(client.available()){
    String line = client.readStringUntil('\r');
    //Serial.print(line); // Trying to avoid using serial
  }

  // Before we exit, turn the LED off.
  digitalWrite(LED_PIN, LOW);

  return 1; // Return success
}
</code></pre>

<p>After loading the code onto your Thing, it will begin to run. The status LED connected to pin 5 will initially blink at about 2 Hz. After the Thing connects to your network, the green LED will turn solid and post to the <a href="https://data.sparkfun.com/streams/wpvZ9pE1qbFJAjaGd3bn">test stream</a>. At that point the LED will go dark, only blinking every 30s-or-so as the Thing posts to Phant again.</p>

<p>If the LED never stops blinking, your Thing is probably having trouble connecting to the WiFi network. Make sure the SSID and PSK variables are set correctly.</p>

<p>Four values are posted to the Phant stream: the reading from the ADC pin, a digital reading from pin 12, the Thing&rsquo;s ID (&ldquo;Thing&rdquo; appendd with the last two MAC bytes), and a time variable loaded from the <code>millis()</code> function. Load up the test stream to check for your Thing&rsquo;s signature there!</p>

<p style="text-align:center;">
  
  <img src="https://cdn.sparkfun.com/r/600-600/assets/learn_tutorials/3/6/5/data-sparkfun-example.png"></p>

<p style="text-align:center;"> <em>Example screenshot from our communal data.sparkfun.com stream.</em></p>

<p>Read through the comments in the code to get a line-by-line breakdown of what&rsquo;s going on in the sketch.</p>      </div>
          <div class="section tutorial-page">
        <h2 id="example-sketch-ap-web-server">Example Sketch: AP Web Server</h2>
        <p>Not only can the ESP8266 connect to a WiFi network and interact with the Internet, but it can also set up a network of its own, allowing other devices to connect directly to it. This example demonstrates how to turn the ESP8266 into an <strong>access point</strong> (AP), and serve up web pages to any connected client.</p>

<p>Copy and paste the code from below, or download it <a href="https://cdn.sparkfun.com/assets/learn_tutorials/3/6/5/ESP8266_SoftAP_Server.zip">here</a>.</p>

<pre><code>language:c
#include &lt;ESP8266WiFi.h&gt;

//////////////////////
// WiFi Definitions //
//////////////////////
const char WiFiAPPSK[] = "sparkfun";

/////////////////////
// Pin Definitions //
/////////////////////
const int LED_PIN = 5; // Thing's onboard, green LED
const int ANALOG_PIN = A0; // The only analog pin on the Thing
const int DIGITAL_PIN = 12; // Digital pin to be read

WiFiServer server(80);

void setup() 
{
  initHardware();
  setupWiFi();
  server.begin();
}

void loop() 
{
  // Check if a client has connected
  WiFiClient client = server.available();
  if (!client) {
    return;
  }

  // Read the first line of the request
  String req = client.readStringUntil('\r');
  Serial.println(req);
  client.flush();

  // Match the request
  int val = -1; // We'll use 'val' to keep track of both the
                // request type (read/set) and value if set.
  if (req.indexOf("/led/0") != -1)
    val = 0; // Will write LED low
  else if (req.indexOf("/led/1") != -1)
    val = 1; // Will write LED high
  else if (req.indexOf("/read") != -1)
    val = -2; // Will print pin reads
  // Otherwise request will be invalid. We'll say as much in HTML

  // Set GPIO5 according to the request
  if (val &gt;= 0)
    digitalWrite(LED_PIN, val);

  client.flush();

  // Prepare the response. Start with the common header:
  String s = "HTTP/1.1 200 OK\r\n";
  s += "Content-Type: text/html\r\n\r\n";
  s += "&lt;!DOCTYPE HTML&gt;\r\n&lt;html&gt;\r\n";
  // If we're setting the LED, print out a message saying we did
  if (val &gt;= 0)
  {
    s += "LED is now ";
    s += (val)?"on":"off";
  }
  else if (val == -2)
  { // If we're reading pins, print out those values:
    s += "Analog Pin = ";
    s += String(analogRead(ANALOG_PIN));
    s += "&lt;br&gt;"; // Go to the next line.
    s += "Digital Pin 12 = ";
    s += String(digitalRead(DIGITAL_PIN));
  }
  else
  {
    s += "Invalid Request.&lt;br&gt; Try /led/1, /led/0, or /read.";
  }
  s += "&lt;/html&gt;\n";

  // Send the response to the client
  client.print(s);
  delay(1);
  Serial.println("Client disonnected");

  // The client will actually be disconnected 
  // when the function returns and 'client' object is detroyed
}

void setupWiFi()
{
  WiFi.mode(WIFI_AP);

  // Do a little work to get a unique-ish name. Append the
  // last two bytes of the MAC (HEX'd) to "Thing-":
  uint8_t mac[WL_MAC_ADDR_LENGTH];
  WiFi.softAPmacAddress(mac);
  String macID = String(mac[WL_MAC_ADDR_LENGTH - 2], HEX) +
                 String(mac[WL_MAC_ADDR_LENGTH - 1], HEX);
  macID.toUpperCase();
  String AP_NameString = "ESP8266 Thing " + macID;

  char AP_NameChar[AP_NameString.length() + 1];
  memset(AP_NameChar, 0, AP_NameString.length() + 1);

  for (int i=0; i&lt;AP_NameString.length(); i++)
    AP_NameChar[i] = AP_NameString.charAt(i);

  WiFi.softAP(AP_NameChar, WiFiAPPSK);
}

void initHardware()
{
  Serial.begin(115200);
  pinMode(DIGITAL_PIN, INPUT_PULLUP);
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);
  // Don't need to set ANALOG_PIN as input, 
  // that's all it can be.
}
</code></pre>

<p>After uploading this sketch, find another device that you can connect to a WiFi network &ndash; phone, laptop, etc. Look for a network called &ldquo;Thing-XXXX&rdquo;, where XXXX is the last 2 bytes of the Thing&rsquo;s MAC address.</p>

<p style="text-align:center;">
  
  <img src="https://cdn.sparkfun.com/r/500-500/assets/learn_tutorials/3/6/5/thing-ap-connect.PNG"></p>

<p>The sketch sets the network&rsquo;s password to &ldquo;sparkfun&rdquo;.</p>

<p>After connecting to your Thing&rsquo;s AP network, load up a browser and point it to <code>192.168.4.1/read</code>. The Thing should serve up a web page showing you its ADC and digital pin 12 readings:</p>

<p style="text-align:center;">
  
  <img src="https://cdn.sparkfun.com/r/500-500/assets/learn_tutorials/3/6/5/thing-ap-web.PNG"></p>

<p>After that, give <code>192.168.4.1/led/0</code> and <code>192.168.4.1/led/1</code> a try, and keep an eye on the Thing&rsquo;s green LED while you do.</p>

<p>As always, check through the code comments to get a line-by-line breakdown of what&rsquo;s going on.</p>      </div>
          <div class="section tutorial-page">
        <h2 id="example-sketch-goodnight-thing-sleep-mode">Example Sketch: Goodnight Thing (Sleep Mode)</h2>
        <p>One of the Thing&rsquo;s most unique features is the integrated support for LiPo batteries. Unfortunately, the ESP8266 is still a pretty power hungry device. If you want your project to run off a battery for more than a few hours, you have two options: get a <em>huge</em> battery or cleverly put the Thing to sleep.</p>

<p>To use the Thing&rsquo;s sleep capability, you&rsquo;ll need to wire the <em>XPD</em> pin up to the ESP8266&rsquo;s reset line. <em>RST</em> isn&rsquo;t broken out, but the <em>DTR</em> pin will work for our application as well.</p>

<p style="text-align:center;">

  <img src="https://cdn.sparkfun.com/r/600-600/assets/learn_tutorials/3/6/5/sleep-hookup.jpg"></p>

<p style="text-align:center;"> <em>Wire up from the XPD pin to DTR to set up sleep-ability.</em></p>

<div class="alert alert-warning"><b>Watch out!</b> The ESP8266 can't be programmed while the <em>XPD</em> pin is connected to <em>DTR</em>. Make sure you disconnect the two pins before trying to upload a sketch.</div>


<p>After you tell the ESP8266 to sleep, it&rsquo;ll wait a specified number of microseconds, then trigger the XPD pin to toggle the reset line. When the ESP8266 wakes up, it&rsquo;ll begin back at the start of the sketch.</p>

<p>Let&rsquo;s riff off the first example in this tutorial &ndash; posting to Phant &ndash; but take advantage of sleeping to greatly increase the battery life. Here&rsquo;s some example code (or <a href="https://cdn.sparkfun.com/assets/learn_tutorials/3/6/5/ESP8266_Phant_Sleep.zip">click here to download</a>):</p>

<p>Once again, make sure you modify the <code>WiFiSSID</code> and <code>WiFiPSK</code> variables near the top of the sketch.</p>

<pre><code>language:c
// Include the ESP8266 WiFi library. (Works a lot like the
// Arduino WiFi library.)
#include &lt;ESP8266WiFi.h&gt;
// Include the SparkFun Phant library.
#include &lt;Phant.h&gt;

//////////////////////
// WiFi Definitions //
//////////////////////
const char WiFiSSID[] = "WiFi_Network";
const char WiFiPSK[] = "WiFi_Password";

/////////////////////
// Pin Definitions //
/////////////////////
const int LED_PIN = 5; // Thing's onboard, green LED
const int ANALOG_PIN = A0; // The only analog pin on the Thing
const int DIGITAL_PIN = 12; // Digital pin to be read

////////////////
// Phant Keys //
////////////////
const char PhantHost[] = "data.sparkfun.com";
const char PublicKey[] = "wpvZ9pE1qbFJAjaGd3bn";
const char PrivateKey[] = "wzeB1z0xWNt1YJX27xdg";

// Time to sleep (in seconds):
const int sleepTimeS = 30;

void setup() 
{
  initHardware();
  connectWiFi();
  digitalWrite(LED_PIN, HIGH);
  while (postToPhant() != 1)
  {
    delay(100);
  }
  digitalWrite(LED_PIN, LOW);
  // deepSleep time is defined in microseconds. Multiply
  // seconds by 1e6 
  ESP.deepSleep(sleepTimeS * 1000000);
}

void loop() 
{
}

void connectWiFi()
{
  byte ledStatus = LOW;

  // Set WiFi mode to station (as opposed to AP or AP_STA)
  WiFi.mode(WIFI_STA);
  // WiFI.begin([ssid], [passkey]) initiates a WiFI connection
  // to the stated [ssid], using the [passkey] as a WPA, WPA2,
  // or WEP passphrase.
  WiFi.begin(WiFiSSID, WiFiPSK);

  // Use the WiFi.status() function to check if the ESP8266
  // is connected to a WiFi network.
  while (WiFi.status() != WL_CONNECTED)
  {
    // Blink the LED
    digitalWrite(LED_PIN, ledStatus); // Write LED high/low
    ledStatus = (ledStatus == HIGH) ? LOW : HIGH;

    // Delays allow the ESP8266 to perform critical tasks
    // defined outside of the sketch. These tasks include
    // setting up, and maintaining, a WiFi connection.
    delay(100);
    // Potentially infinite loops are generally dangerous.
    // Add delays -- allowing the processor to perform other
    // tasks -- wherever possible.
  }
}

void initHardware()
{
  Serial.begin(9600);
  pinMode(DIGITAL_PIN, INPUT_PULLUP);
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);
  // Don't need to set ANALOG_PIN as input, 
  // that's all it can be.
}

int postToPhant()
{
  // LED turns on when we enter, it'll go off when we 
  // successfully post.
  digitalWrite(LED_PIN, HIGH);

  // Declare an object from the Phant library - phant
  Phant phant(PhantHost, PublicKey, PrivateKey);

  // Do a little work to get a unique-ish name. Append the
  // last two bytes of the MAC (HEX'd) to "Thing-":
  uint8_t mac[WL_MAC_ADDR_LENGTH];
  WiFi.macAddress(mac);
  String macID = String(mac[WL_MAC_ADDR_LENGTH - 2], HEX) +
                 String(mac[WL_MAC_ADDR_LENGTH - 1], HEX);
  macID.toUpperCase();
  String postedID = "Thing-" + macID;

  // Add the four field/value pairs defined by our stream:
  phant.add("id", postedID);
  phant.add("analog", analogRead(ANALOG_PIN));
  phant.add("digital", digitalRead(DIGITAL_PIN));
  phant.add("time", millis());

  // Now connect to data.sparkfun.com, and post our data:
  WiFiClient client;
  const int httpPort = 80;
  if (!client.connect(PhantHost, httpPort)) 
  {
    // If we fail to connect, return 0.
    return 0;
  }
  // If we successfully connected, print our Phant post:
  client.print(phant.post());

  // Read all the lines of the reply from server and print them to Serial
  while(client.available()){
    String line = client.readStringUntil('\r');
    //Serial.print(line); // Trying to avoid using serial
  }

  // Before we exit, turn the LED off.
  digitalWrite(LED_PIN, LOW);

  return 1; // Return success
}
</code></pre>

<p>This sketch accomplishes the same feat as that in our first example &ndash; it posts some data to a <a href="https://data.sparkfun.com/streams/wpvZ9pE1qbFJAjaGd3bn">data.sparkfun.com stream</a> every 30 seconds. But there&rsquo;s one huge difference: sleep.</p>

<p>Notice there&rsquo;s nothing in the <code>loop()</code>. The program halts when the <code>ESP.deepSleep(30000000)</code> is called. After 30 seconds, when the ESP8266 wakes up, it&rsquo;ll start running code back at the beginning of <code>setup()</code>.</p>

<p>If you put a <a href="https://learn.sparkfun.com/tutorials/how-to-use-a-multimeter">multimeter</a> in-line to measure the current draw, the Thing would pull about 80mA for the ~5 seconds it takes to connect and post to Phant. Then, while it sleeps for about 30 seconds, the current draw would be around 8mA. An average of about 18mA per second.</p>

<p style="text-align:center;">
 <img src="https://cdn.sparkfun.com/r/600-600/assets/learn_tutorials/3/6/5/multimeter-example.jpg"></p>

<p style="text-align:center;"> <em>In deep sleep mode, the Thing pulls about 8mA (that&rsquo;s mostly the power LED).</em></p>

<p>Most of the current draw in sleep mode is from the power LED indicator &ndash; if you want to save even more juice, you may consider removing the LED (or current-limiting resistor) or even cutting a trace. (Hint: cut the trace running through middle of the &lsquo;R&rsquo; in &ldquo;PWR&rdquo;.)</p>      </div>
          <div class="section tutorial-page">
        <h2 id="using-the-arduino-addon">Using the Arduino Addon</h2>
        <p>If you&rsquo;ve used Arduino in the past, there will be some new programming schemes to get used to in ESP8266 land.</p>

<h3>Pin Mappings</h3>

<p>As with any other Arduino, the pin mappings printed on the board match the pin you read or write to. The SDA and SCL pins can be referenced as 2 and 14 respectively.</p>

<p>There&rsquo;s only one analog input pin, labeled <em>ADC</em>. To read the <em>ADC</em> pin, make a function call to <code>analogRead(A0)</code>. Remember that this pin has a weird maximum voltage of 1V &ndash; you&rsquo;ll get a 10-bit value (0-1023) proportional to a voltage between 0 and 1V.</p>

<h3>Yielding</h3>

<p>This is one of the most critical differences between the ESP8266 and a more classical Arduino microcontroller. The ESP8266 runs a lot of utility functions in the background &ndash; keeping WiFi connected, managing the TCP/IP stack, and performing other duties. Blocking these functions from running can cause the ESP8266 to crash and reset itself. To avoid these mysterious resets, <strong>avoid long, blocking loops in your sketch</strong>.</p>

<p>If you have a long loop in your sketch, you can <strong>add a <code>delay([milliseconds])</code></strong> call within, to allow the critical background functions to execute. The ESP8266&rsquo;s <code>delay()</code> funciton, while of course delaying for a set number of milliseconds, also makes a quick call to the background functions.</p>

<p>The amazing creators of the ESP8266 Arduino libraries also implemented a <strong><code>yield()</code></strong> function, which calls on the background functions to allow them to do their thing. As an example, if your sketch is waiting for someone to press a button attached to pin 12, creating a loop like this will keep the ESP8266 from crashing:</p>

<pre><code>language:c
pinMode(12, INPUT_PULLUP); // Set pin 12 as an input w/ pull-up
while (digitalRead(12) == HIGH) // While pin 12 is HIGH (not activated)
    yield(); // Do (almost) nothing -- yield to allow ESP8266 background functions
Serial.println("Button is pressed!"); // Print button pressed message.
</code></pre>

<h3>ESP8266WiFi Class</h3>

<p>This is the ESP8266, so the WiFi class will probably be included in just about every sketch there is. If you&rsquo;ve used the <a href="http://www.arduino.cc/en/Reference/WiFi">Arduino WiFi library</a> before, the ESP8266 WiFi library will be very similar, there&rsquo;s just a few key differences:</p>

<ul>
<li>To <strong>include the ESP8266 WiFi library</strong> call <code>#include &lt;ESP8266WiFi.h&gt;</code> <em>not</em> <code>&lt;WiFi.h&gt;</code>.</li>
<li>To <strong>connect</strong> to a network, like the normal WiFi library, call <code>WiFi.begin(NetworkSSID, NetworkPassword)</code>. You can also set the ESP8266 up as a WiFi access point by calling <code>WiFi.softAP(AP_SSID, AP_Password)</code>.</li>
<li>To set the ESP8266&rsquo;s <strong>mode</strong>, which can be access point (AP), station (STA), or combo (the ESP8266 can do both at the same time!), call <code>WiFi.setMode([mode])</code> with either <code>WIFI_AP</code>, <code>WIFI_STA</code>, or <code>WIFI_STA_AP</code> as the parameter.</li>
</ul>


<p>The examples earlier in this tutorial should have demonstrated all of these differences.</p>

<h3>Libraries Available/Not Available and the Differences</h3>

<p>A lot of the core Arduino libraries have been re-written to work for the ESP8266, including:</p>

<ul>
<li><strong>Wire</strong> &ndash; The ESP8266 should work with any I<sup>2</sup>C sensor you can throw at it &ndash; just use the same <a href="http://www.arduino.cc/en/reference/Wire">Wire API</a> calls you&rsquo;re used to. There are a few differences:

<ul>
<li>Pin definition: The ESP2866 doesn&rsquo;t actually have any hardware I<sup>2</sup>C pins &ndash; those labeled on the Thing are the default, but you can actually use any two pins as SDA and SCL. Calling <code>Wire.begin()</code> will assume pins 2 and 14 are SDA and SCL, but you can manually set them to any other pin by calling <code>Wire.begin([SDA], [SCL])</code>.</li>
</ul>
</li>
<li><strong>SPI</strong> &ndash; The ESP8266 Thing can control an SPI bus using function calls made standard by the <a href="http://www.arduino.cc/en/reference/SPI">Arduino SPI library</a>.

<ul>
<li>An additional function to set the frequency &ndash; <code>SPI.setFrequency([frequency])</code> &ndash; is added. You may need to call that in your setup to slow the clock down from its default value. For example, <code>SPI.setFrequency(1000000)</code> will set the SPI clock to 1MHz.</li>
<li>The MISO, MOSI, and SCLK SPI pins are hard-coded and can&rsquo;t be moved, they are:</li>
</ul>
</li>
</ul>


<div style="margin-left: auto; margin-right: auto; width: 50%;"><table class="table table-striped table-bordered table-hover">
<tr style="text-align:center"><th style="text-align:center">Pin Number</th><th style="text-align:center">SPI Function</th></tr>
<tr style="text-align:center"><td>12</td><td>MISO</td></tr>
<tr style="text-align:center"><td>13</td><td>MOSI</td></tr>
<tr style="text-align:center"><td>14 (SCL)</td><td>SCLK</td></tr>
<tr style="text-align:center"><td>15</td><td>CS</td></tr>
</table></div>


<h3>Using the Serial Monitor <a id="serial-dtr"></a></h3>

<p>GPIO0 &ndash; while perfectly capable as a digital I/O &ndash; serves a secondary purpose as a bootload/run-mode controller. When the ESP8266 boots up, it looks at GPIO0&rsquo;s value to either enter the bootloader or start running the current program:</p>

<div style="margin-left: auto; margin-right: auto; width: 50%;"><table class="table table-striped table-bordered table-hover">
<tr style="text-align:center"><th style="text-align:center">GPIO0 Value</th><th style="text-align:center">ESP8266 Mode</th></tr>
<tr style="text-align:center"><td>HIGH (3.3V)</td><td>Run Program</td></tr>
<tr style="text-align:center"><td>LOW (0V)</td><td>Bootloader</td></tr>
</table></div>


<p>To make it easy to program the ESP8266, we&rsquo;ve tied GPIO0 to DTR (along with RST). When your programmer begins to upload a sketch, it&rsquo;ll pull DTR low, in turn setting GPIO0 low and making the ESP8266 enter bootloader mode.</p>

<p>Unfortunately, when you open a serial terminal, DTR usually goes low again. So every time you open the Arduino serial monitor, it&rsquo;ll cause the ESP8266 to enter bootloader mode, instead of run-program mode. If you open up the serial monitor, and all you see is a <a href="https://cdn.sparkfun.com/assets/learn_tutorials/3/6/5/gibberish-serial.png">line of gibberish</a>, you&rsquo;ve probably booted the ESP8266 into bootloader mode.</p>

<p>There are a few ways around this. We&rsquo;ve added the DTR jumper on the bottom of the board. You can cut the trace on the back and install a <a href="https://www.sparkfun.com/products/116">2-pin male header</a> combined with a <a href="https://www.sparkfun.com/products/9044">2-pin jumper</a>. If the jumper is present, the board will be able to be programmed. Removing the jumper will enable serial terminal mode.</p>

<p style="text-align:center;">
  <img src="https://cdn.sparkfun.com/r/600-600/assets/learn_tutorials/3/6/5/dtr-jumper.jpg"></p>

<p>Or you can find a serial terminal program that allows control of the DTR pin directly. <a href="https://learn.sparkfun.com/tutorials/terminal-basics/real-term-windows">RealTerm</a> allows for this control &ndash; navigate to the &ldquo;Pins&rdquo; tab, and click &ldquo;Clear&rdquo; next to &ldquo;DTR.&rdquo;</p>

<p style="text-align:center;">
  <img src="https://cdn.sparkfun.com/assets/learn_tutorials/3/6/5/real-term-clear-dtr.png"></p>

<p>Unfortunately, this Windows-only solution is the only terminal program we&rsquo;ve found so far with such control. Your best bet may be to try to avoid serial debugging whenever possible &ndash; that&rsquo;s what LED&rsquo;s are for, right? (Tongue only kind-of in cheek.)</p>      </div>
          <div class="section tutorial-page">
        <h2 id="resources--going-further">Resources and Going Further</h2>
        <p>An astoundingly awesome community has grown around the ESP8266. We owe them big time for the amazing Arduino addon they&rsquo;ve cooperatively built. For all of your ESP8266 needs, we recommend checking out the <a href="http://www.esp8266.com/">esp8266.com Community Forum</a>. In addition to that, here are a few ESP8266-related resources we&rsquo;ve found incredibly helpful:</p>

<ul>
<li><a href="https://github.com/esp8266">ESP8266 GitHub User Repos</a> &ndash; Tons of incredible tools can be found here. From <a href="https://github.com/esp8266/crosstool-NG">Crosstool</a> (to compile your own Xtensa GCC, G++, etc.) to the <a href="https://github.com/esp8266/Arduino">ESP8266 Arduino GitHub Repo</a></li>
<li><a href="http://www.esp8266.com/wiki/doku.php">ESP8266 Community Wiki</a> &ndash; Related to the community forum, there&rsquo;s a good amount of information available in this wiki.</li>
<li><a href="https://github.com/nodemcu/nodemcu-firmware">NodeMCU Firmware</a> and the <a href="https://github.com/nodemcu/nodemcu-flasher">NodeMCU Flasher</a> &ndash; NodeMCU is a popular firmware for the ESP8266. It implements a LUA-based interpreter on the ESP8266 MCU.</li>
<li><a href="http://bbs.espressif.com/">Espressif Board Forums</a> &ndash; Espressif, the manufacturers of the ESP8266, have a forum of their own. You can sometimes find updated software development kit downloads, or other helpful links here.</li>
<li><a href="https://github.com/espressif">Espressif GitHub Repos</a> &ndash; Espressif is also somewhat active on GitHub. They host a couple versions of the SDK here.</li>
</ul>


<p>The ESP8266 Thing is open source hardware! If you need, or just want to look at, the PCB design files, you can find them in our <a href="https://github.com/sparkfun/ESP8266_Thing">ESP8266 Thing GitHub repository</a>.</p>
      </body>
</html>

