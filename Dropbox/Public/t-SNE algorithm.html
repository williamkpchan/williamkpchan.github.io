<!doctype html>
<html>
<head>
<base target="_blank">
<meta charset="UTF-8">

<style>
body {
 margin: 10%;
 font-size: 24px;
 background-color: #000000;
 color: #109030;
}
a { text-decoration: none;
    color: #28B8B8;}
a:visited { color: #389898;}
A:hover {   color: yellow;}
A:focus {   color: red;}
code { color: pink; background-color: #302030}
pre { color: gray; background-color: #001010}
</style>
</head>
<body>

<h1 itemprop="name" class="entry-title">Comprehensive Guide on t-SNE algorithm with implementation in R &amp; Python</h1>
	

<h2>Introduction</h2>
<p style="text-align: justify">Imagine you get a dataset with hundreds of features (variables) and have little understanding about the domain the data belongs to. You are expected to identify hidden patterns in the data, explore and analyze the dataset. And not just that, you have to find out if there is a pattern in the data &#8211; is it signal or is it just noise?</p>
<p style="text-align: justify">Does that thought make you uncomfortable? It made my hands sweat when I came across this situation for the first time. Do you wonder how to explore a multidimensional dataset? It is one of the frequently asked question by many data scientists. In this article, I will take you through a very powerful way to exactly do this.</p>
<h3 style="text-align: justify"></h3>
<h3 style="text-align: justify">What about PCA?</h3>
<p style="text-align: justify">By now, some of you would be screaming &#8220;I’ll use PCA for dimensionality reduction and visualization&#8221;. Well, you are right! PCA is definitely a good choice for dimensionality reduction and visualization for datasets with a large number of features. <strong>But, what if you could use something more advanced than PCA? </strong>(If you don&#8217;t know PCA, I would strongly recommend to <a href="https://www.analyticsvidhya.com/blog/2016/03/practical-guide-principal-component-analysis-python/" target="_blank">read this article first</a>)</p>
<p style="text-align: justify">What if you could easily search for a pattern in non-linear style? <strong>In this article, I will tell you about a new algorithm called t-SNE (2008), which is much more effective than PCA (1933).</strong> I will take you through the basics of t-SNE algorithm first and then will walk you through why t-SNE is a good fit for dimensionality reduction algorithms.</p>
<p style="text-align: justify">You will also, get hands-on knowledge for using t-SNE in both R and Python.</p>
<p style="text-align: justify">Read on!</p>
<p>&nbsp;</p>
<h2>Table of Content</h2>
<ol>
<li><span style="font-weight: 400">What is t-SNE?</span></li>
<li><span style="font-weight: 400">What is dimensionality reduction?</span></li>
<li><span style="font-weight: 400">How does t-SNE fit in the dimensionality reduction algorithm space</span></li>
<li>Algorithmic details of t-SNE
<ul>
<li><span style="font-weight: 400">Algorithm</span></li>
<li>Time and Space Complexity</li>
</ul>
</li>
<li><span style="font-weight: 400">What does t-SNE actually do?</span></li>
<li><span style="font-weight: 400">Use cases </span></li>
<li><span style="font-weight: 400"> </span><span style="font-weight: 400">t-SNE compared to other dimensionality reduction algorithm</span></li>
<li><span style="font-weight: 400">Example Implementations</span>
<ul>
<li>In R
<ul>
<li><span style="font-weight: 400">Hyper parameter tuning</span></li>
<li><span style="font-weight: 400">Code</span></li>
<li><span style="font-weight: 400">Implementation Time </span></li>
<li><span style="font-weight: 400">Interpreting Results</span></li>
</ul>
</li>
<li>In Python
<ul>
<li><span style="font-weight: 400">Hyper parameter tuning</span></li>
<li><span style="font-weight: 400">Code</span></li>
<li><span style="font-weight: 400">Implementation Time </span><span style="font-weight: 400"> </span></li>
</ul>
</li>
</ul>
</li>
<li><span style="font-weight: 400">Where and when to use</span>
<ul>
<li>Data Scientist</li>
<li>Machine Learning Competition Enthusiast</li>
<li>Student</li>
</ul>
</li>
<li><span style="font-weight: 400">Common fallacies</span></li>
</ol>
<p>&nbsp;</p>
<h2>1. What is t-SNE?</h2>
<p style="text-align: justify"><span style="font-weight: 400">(t-SNE) t-Distributed Stochastic Neighbor Embedding</span><span style="font-weight: 400"> is a non-linear dimensionality reduction algorithm used for exploring high-dimensional data. It maps multi-dimensional data to two or more dimensions suitable for human observation. With help of the t-SNE algorithms, you may have to plot fewer exploratory data analysis plots next time you work with high dimensional data.</span></p>
<p><span style="font-weight: 400"> <img class="aligncenter wp-image-32398 size-medium" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/19100947/20131959678_bf1a8e3fcc_b-289x300.jpg" width="289" height="300" srcset="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/19100947/20131959678_bf1a8e3fcc_b-289x300.jpg 289w, https://static.analyticsvidhya.com/wp-content/uploads/2017/01/19100947/20131959678_bf1a8e3fcc_b-768x798.jpg 768w, https://static.analyticsvidhya.com/wp-content/uploads/2017/01/19100947/20131959678_bf1a8e3fcc_b-850x883.jpg 850w, https://static.analyticsvidhya.com/wp-content/uploads/2017/01/19100947/20131959678_bf1a8e3fcc_b.jpg 986w" sizes="(max-width: 289px) 100vw, 289px" /></span></p>
<p>&nbsp;</p>
<h2>2. What is dimensionality reduction?</h2>
<p style="text-align: justify"><span style="font-weight: 400">In order to understand how t-SNE works, let&#8217;s first understand what is dimensionality reduction?</span></p>
<p style="text-align: justify"><span style="font-weight: 400">Well, in simple terms, dimensionality reduction is the technique of representing multi-dimensional data (data with multiple features having a correlation with each other) in 2 or 3 dimensions. </span></p>
<p style="text-align: justify"><span style="font-weight: 400">Some of you might question why do we need Dimensionality Reduction when we can plot the data using scatter plots, histograms &amp; boxplots and make sense of the pattern in data using descriptive statistics. </span></p>
<p style="text-align: justify">Well, even if you can understand the patterns in data and present it on simple charts, it is still difficult for anyone without statistics background to make sense of it. Also, if you have hundreds of features, you have to study thousands of charts before you can make sense of this data. (Read more about <a href="https://www.analyticsvidhya.com/blog/2015/07/dimension-reduction-methods/" target="_blank">dimensionality reduction here</a>)</p>
<p style="text-align: justify">With the help of dimensionality reduction algorithm, you will be able to present the data explicitly.</p>
<p><span style="font-weight: 400">  </span></p>
<h2>3. How does t-SNE fit in the dimensionality reduction algorithm space?</h2>
<p style="text-align: justify"><span style="font-weight: 400">Now that you have an understanding of what is dimensionality reduction, let&#8217;s look at how we can use t-SNE algorithm for reducing dimensions. </span></p>
<p><span style="font-weight: 400">Following are a few dimensionality reduction algorithms that you can check out:</span></p>
<ol>
<li style="font-weight: 400"><span style="font-weight: 400">PCA (linear)</span></li>
<li style="font-weight: 400"><span style="font-weight: 400">t-SNE (non-parametric/ nonlinear)</span></li>
<li style="font-weight: 400"><span style="font-weight: 400">Sammon mapping (nonlinear)</span></li>
<li style="font-weight: 400"><span style="font-weight: 400"> Isomap (nonlinear)</span></li>
<li style="font-weight: 400"><span style="font-weight: 400"> LLE (nonlinear)</span></li>
<li style="font-weight: 400"><span style="font-weight: 400">CCA (nonlinear)</span></li>
<li style="font-weight: 400"><span style="font-weight: 400">SNE (nonlinear)</span></li>
<li style="font-weight: 400"><span style="font-weight: 400"> MVU (nonlinear)</span></li>
<li style="font-weight: 400"><span style="font-weight: 400"> Laplacian Eigenmaps (nonlinear)</span></li>
</ol>
<p style="text-align: justify"><span style="font-weight: 400">The good news is that you need to study only two of the algorithms mentioned above to effectively visualize data in lower dimensions &#8211; PCA and t-SNE.</span></p>
<p>&nbsp;</p>
<h3 style="text-align: justify">Limitations of PCA</h3>
<p style="text-align: justify"><span style="font-weight: 400">PCA is a linear algorithm. It will not be able to interpret complex polynomial relationship between features. On the other hand, t-SNE is based on probability distributions with random walk on neighborhood graphs to find the structure within the data. </span></p>
<p style="text-align: justify">A major problem with, linear dimensionality reduction algorithms is that they concentrate on placing dissimilar data points far apart in a lower dimension representation. But in order to represent high dimension data on low dimension, non-linear manifold, it is important that similar datapoints must be represented close together, which is not what linear dimensionality reduction algorithms do.</p>
<p>Now, you have a brief understanding of what PCA endeavors to do.</p>
<p><span style="font-weight: 400">Local approaches seek to map nearby points on the manifold to nearby points in the low-dimensional representation. Global approaches on the other hand attempt to preserve geometry at all scales, i.e mapping nearby points to nearby points and far away points to far away points  </span></p>
<p style="text-align: justify"><span style="font-weight: 400">It is important to know that most of the nonlinear techniques other than t-SNE are not capable of retaining both the local and global structure of the data at the same time.</span></p>
<p>&nbsp;</p>
<h2>4. Algorithmic details of t-SNE (optional read)</h2>
<p style="text-align: justify">This section is for the people interested in understanding the algorithm in depth. You can safely skip this section if you do not want to go through the math in detail.</p>
<p><span style="font-weight: 400">Let&#8217;s understand why you should know about t-SNE and the algorithmic details of t-SNE.  </span><span style="font-weight: 400">t-SNE is an improvement on the Stochastic Neighbor Embedding (SNE) algorithm.</span></p>
<p>&nbsp;</p>
<h3>4.1 Algorithm</h3>
<h4>Step 1</h4>
<p style="text-align: justify"><span style="font-weight: 400">Stochastic Neighbor Embedding (SNE) starts by converting the high-dimensional Euclidean distances between data points into conditional probabilities that represent similarities. The similarity of datapoint <img class="alignnone wp-image-32479 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21070012/xi.png" width="26" height="25" /></span><span style="font-weight: 400"> </span><span style="font-weight: 400">to datapoint <img class="alignnone wp-image-32473 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21064623/xj.png" width="34" height="28" /></span><span style="font-weight: 400"> is the conditional probability, <img class="alignnone size-full wp-image-32477" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21065958/pjli.png" alt="" width="40" height="26" /> ,  <img class="alignnone wp-image-32479 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21070012/xi.png" width="26" height="25" /></span><span style="font-weight: 400">would pick <img class="alignnone wp-image-32473 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21064623/xj.png" width="34" height="28" /></span><span style="font-weight: 400">as its neighbor if neighbors were picked in proportion to their probability density under a Gaussian centered at </span><span style="font-weight: 400"> <img class="alignnone wp-image-32479 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21070012/xi.png" width="26" height="25" />. </span></p>
<p style="text-align: justify"><span style="font-weight: 400">For nearby datapoints, <img class="alignnone size-full wp-image-32477" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21065958/pjli.png" alt="" width="40" height="26" /> is relatively high, whereas for widely separated datapoints, <img class="alignnone size-full wp-image-32477" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21065958/pjli.png" alt="" width="40" height="26" /> will be almost infinitesimal (for reasonable values of the variance of the Gaussian, <img class="alignnone size-full wp-image-32356" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/18122537/x3.png" alt="" width="24" height="28" />). Mathematically, the conditional probability <img class="alignnone size-full wp-image-32477" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21065958/pjli.png" alt="" width="40" height="26" /> is given by</span></p>
<p><img class="aligncenter wp-image-32267 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/17113403/TSN1.png" width="321" height="92" srcset="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/17113403/TSN1.png 321w, https://static.analyticsvidhya.com/wp-content/uploads/2017/01/17113403/TSN1-300x86.png 300w" sizes="(max-width: 321px) 100vw, 321px" /></p>
<p><span style="font-weight: 400">where <img class="alignnone size-full wp-image-32356" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/18122537/x3.png" alt="" width="24" height="28" /> </span><span style="font-weight: 400">is the variance of the Gaussian that is centered on datapoint <img class="alignnone wp-image-32479 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21070012/xi.png" width="26" height="25" /></span></p>
<p style="text-align: justify"><span style="font-weight: 400">If you are not interested in the math, think about it in this way, the algorithm starts by converting the shortest distance (a straight line) between the points into probability of similarity of points. Where, the similarity between points is: the conditional probability that </span><span style="font-weight: 400"> <img class="alignnone wp-image-32479 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21070012/xi.png" width="26" height="25" /> </span><span style="font-weight: 400">would pick <img class="alignnone wp-image-32473 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21064623/xj.png" width="34" height="28" /> </span><span style="font-weight: 400">as its neighbor if neighbors were picked in proportion to their probability density under a Gaussian (normal distribution) centered at <img class="alignnone wp-image-32479 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21070012/xi.png" width="26" height="25" /></span><span style="font-weight: 400">.</span></p>
<p>&nbsp;</p>
<h4 style="text-align: justify">Step 2</h4>
<p><span style="font-weight: 400">For the low-dimensional counterparts <img class="alignnone wp-image-32481 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21070035/yi.png" width="21" height="23" /> and <img class="alignnone wp-image-32482 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21070039/yj.png" width="22" height="21" /> of the high-dimensional datapoints <img class="alignnone wp-image-32479 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21070012/xi.png" width="26" height="25" /> and  <img class="alignnone wp-image-32473 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21064623/xj.png" width="34" height="28" /> it is possible to compute a similar conditional probability, which we denote by <img class="alignnone size-full wp-image-32474" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21064959/qjli.png" alt="" width="36" height="28" />.</span></p>
<p><img class="aligncenter wp-image-32268 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/17113456/TSN2.png" width="309" height="87" srcset="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/17113456/TSN2.png 309w, https://static.analyticsvidhya.com/wp-content/uploads/2017/01/17113456/TSN2-300x84.png 300w" sizes="(max-width: 309px) 100vw, 309px" /></p>
<p><span style="font-weight: 400">Note that, pi|i and pj|j are set to zero as we only want to model pair wise similarity.</span></p>
<p><span style="font-weight: 400">In simple terms step 1 and step2 calculate the conditional probability of similarity between a pair of points in </span></p>
<ol>
<li style="text-align: justify"><span style="font-weight: 400">High dimensional space</span></li>
<li style="text-align: justify"><span style="font-weight: 400">In low dimensional space</span></li>
</ol>
<p style="text-align: justify"><span style="font-weight: 400"> For the sake of simplicity, try to understand this in detail. </span></p>
<p style="text-align: justify"><span style="font-weight: 400">Let us map 3D space to 2D space. What step1 and step2 are doing is calculating the probability of similarity of points in 3D space and calculating the probability of similarity of points in the corresponding 2D space.  </span></p>
<p style="text-align: justify"><span style="font-weight: 400">Logically, the conditional probabilities <img class="alignnone size-full wp-image-32477" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21065958/pjli.png" alt="" width="40" height="26" /> and <img class="alignnone size-full wp-image-32474" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21064959/qjli.png" alt="" width="36" height="28" />must be equal for a perfect representation of the similarity of the datapoints in the different dimensional spaces, i.e the difference between <img class="alignnone size-full wp-image-32477" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21065958/pjli.png" alt="" width="40" height="26" /> and <img class="alignnone size-full wp-image-32474" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21064959/qjli.png" alt="" width="36" height="28" /> must be zero for the perfect replication of the plot in high and low dimensions.</span></p>
<p><span style="font-weight: 400">By this logic SNE attempts to minimize this difference of conditional probability.</span></p>
<p>&nbsp;</p>
<h4>Step 3</h4>
<p><span style="font-weight: 400">Now here is the difference between the SNE and t-SNE algorithms. </span></p>
<p style="text-align: justify"><span style="font-weight: 400">To measure the minimization of sum of difference of conditional probability SNE minimizes the sum of </span><a href="https://en.wikipedia.org/wiki/Kullback–Leibler_divergence" target="_blank" rel="nofollow"><span style="font-weight: 400">Kullback-Leibler divergences </span></a><span style="font-weight: 400">overall data points using a gradient descent method. We must know that KL divergences are asymmetric in nature. </span></p>
<p style="text-align: justify"><span style="font-weight: 400">In other words, the SNE cost function focuses on retaining the local structure of the data in the map (for reasonable values of the variance of the Gaussian in the high-dimensional space,<img class="alignnone size-full wp-image-32356" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/18122537/x3.png" alt="" width="24" height="28" />). </span></p>
<p style="text-align: justify"><span style="font-weight: 400">Additionally, it is very difficult (computationally inefficient) to optimize this cost function.</span></p>
<p style="text-align: justify"><span style="font-weight: 400">So t-SNE also tries to minimize the sum of the difference in conditional probabilities. But it does that by using the symmetric version of the SNE cost function, with simple gradients. Also, t-SNE employs a heavy-tailed distribution in the low-dimensional space to alleviate both the crowding problem (the area of the two-dimensional map that is available to accommodate moderately distant data points will not be nearly large enough compared with the area available to accommodate nearby data points)  and the optimization problems of SNE.</span></p>
<p>&nbsp;</p>
<h4 style="text-align: justify">Step 4</h4>
<p style="text-align: justify"><span style="font-weight: 400">If we see the equation to calculate the conditional probability, we have left out the variance from the discussion as of now. The remaining parameter to be selected is the variance <img class="alignnone size-full wp-image-32356" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/18122537/x3.png" alt="" width="24" height="28" />of the student’s t-distribution that is centered over each high-dimensional datapoint <img class="alignnone wp-image-32479 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21070012/xi.png" width="26" height="25" />. It is not likely that there is a single value of <img class="alignnone size-full wp-image-32356" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/18122537/x3.png" alt="" width="24" height="28" />that is optimal for all data points in the data set because the density of the data is likely to vary. In dense regions, a smaller value of <img class="alignnone size-full wp-image-32356" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/18122537/x3.png" alt="" width="24" height="28" /> is usually more appropriate than in sparser regions. Any particular value of <img class="alignnone size-full wp-image-32356" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/18122537/x3.png" alt="" width="24" height="28" />induces a probability distribution, <img class="alignnone size-full wp-image-32361" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/18130133/x6.png" alt="" width="28" height="34" /> , over all of the other data points. This distribution has an </span></p>
<p style="text-align: justify"><span style="font-weight: 400">This distribution has an </span><span style="font-weight: 400">entropy which increases as<img class="alignnone size-full wp-image-32356" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/18122537/x3.png" alt="" width="24" height="28" /> increases. t-SNE performs a binary search for the value of <img class="alignnone size-full wp-image-32356" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/18122537/x3.png" alt="" width="24" height="28" /> that produces a <img class="alignnone size-full wp-image-32361" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/18130133/x6.png" alt="" width="28" height="34" /> with a fixed perplexity that is specified by <img class="alignnone size-full wp-image-32356" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/18122537/x3.png" alt="" width="24" height="28" /> the user. The perplexity is defined as</span></p>
<p><img class="size-full wp-image-32269 aligncenter" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/17113730/TSN3.png" alt="" width="251" height="83" /></p>
<p><span style="font-weight: 400">where H(<img class="alignnone size-full wp-image-32361" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/18130133/x6.png" alt="" width="28" height="34" />) is the </span><a href="https://en.wikipedia.org/wiki/Entropy_(information_theory)" target="_blank" rel="nofollow"><span style="font-weight: 400">Shannon entropy</span></a><span style="font-weight: 400"> of  <img class="alignnone size-full wp-image-32361" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/18130133/x6.png" alt="" width="28" height="34" />measured in bits </span></p>
<p><img class="aligncenter wp-image-32270 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/17113922/TSN4.png" width="373" height="92" srcset="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/17113922/TSN4.png 373w, https://static.analyticsvidhya.com/wp-content/uploads/2017/01/17113922/TSN4-300x74.png 300w" sizes="(max-width: 373px) 100vw, 373px" /></p>
<p style="text-align: justify"><span style="font-weight: 400">The perplexity can be interpreted as a smooth measure of the effective number of neighbors. The performance of SNE is fairly robust to changes in the perplexity, and typical values are between 5 and 50.</span></p>
<p style="text-align: justify"><span style="font-weight: 400">The minimization of the cost function is performed using gradient decent. And physically, the gradient may be interpreted as the resultant force created by a set of springs between the map point <img class="alignnone wp-image-32481 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21070035/yi.png" width="21" height="23" />and all other map points <img class="alignnone wp-image-32482 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21070039/yj.png" width="22" height="21" /> . All springs exert a force along the direction ( <img class="alignnone wp-image-32481 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21070035/yi.png" width="21" height="23" />&#8211; <img class="alignnone wp-image-32482 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21070039/yj.png" width="22" height="21" />). The spring between <img class="alignnone wp-image-32481 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21070035/yi.png" width="21" height="23" /> and <img class="alignnone wp-image-32482 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21070039/yj.png" width="22" height="21" />repels or attracts the map points depending on whether the distance between the two in the map is too small or too large to represent the similarities between the two high-dimensional datapoints. The force exerted by the spring between <img class="alignnone size-full wp-image-32481" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21070035/yi.png" alt="" width="21" height="23" />and <img class="alignnone size-full wp-image-32482" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/21070039/yj.png" alt="" width="22" height="21" /> is proportional to its length, and also proportional to its stiffness, which is the mismatch (pj|i &#8211; qj|i + p i| j − q i| j ) between the pairwise similarities of the data points and the map points[1].-</span></p>
<p>&nbsp;</p>
<h3>4.2 Time and Space Complexity</h3>
<p style="text-align: justify"><span style="font-weight: 400">Now that we have understood the algorithm, it is time to analyze its performance. As you might have observed, that the algorithm computes pairwise conditional probabilities and tries to minimize the sum of the difference of the probabilities in higher and lower dimensions. This involves a lot of calculations and computations. <strong>So the algorithm is quite heavy on the system resources</strong>. </span></p>
<p style="text-align: justify"><span style="font-weight: 400">t-SNE has a quadratic time and space complexity in the number of data points. This makes it particularly slow and resource draining while applying it to data sets comprising of more than 10,000 observations. </span></p>
<p>&nbsp;</p>
<h2>5. What does t-SNE actually do?</h2>
<p style="text-align: justify"><span style="font-weight: 400">After we have looked into the mathematical description of how does the algorithms works, to sum up, what we have learned above. Here is a brief explanation of how t-SNE works.  </span></p>
<p style="text-align: justify"><span style="font-weight: 400">It’s quite simple actually, t-SNE a non-linear dimensionality reduction algorithm finds patterns in the data by identifying observed clusters based on similarity of data points with multiple features. But it is not a clustering algorithm it is a dimensionality reduction algorithm. This is because it maps the multi-dimensional data to a lower dimensional space, the input features are no longer identifiable. Thus you cannot make any inference based only on the output of t-SNE. So essentially it is mainly a data exploration and visualization technique.</span></p>
<p style="text-align: justify"><span style="font-weight: 400">But t-SNE can be used in the process of classification and clustering by using its output as the input feature for other classification algorithms.</span></p>
<p>&nbsp;</p>
<h2>6. Use cases</h2>
<p style="text-align: justify"><span style="font-weight: 400">You may ask, what are the use cases of such an algorithm. t-SNE can be used on almost all high dimensional data sets. But it is extensively applied in Image processing, NLP, genomic data and speech processing. It has been utilized for improving the analysis of brain and heart scans. Below are a few examples:</span></p>
<h3 style="text-align: justify">6.1 Facial Expression Recognition</h3>
<p style="text-align: justify"><span style="font-weight: 400">A lot of progress has been made on FER and many algorithms like PCA have been studied for FER. But, FER still remains a challenge due to the difficulties of dimension reduction and classification. t-Stochastic Neighbor Embedding (t-SNE) is used for reducing the high-dimensional data into a relatively low-dimensional subspace and then using other algorithms like AdaBoostM2, Random Forests, Logistic Regression, NNs and others as multi-classifier for the expression classification. </span></p>
<p style="text-align: justify"><span style="font-weight: 400">In one such attempt for facial recognition based on the Japanese Female Facial Expression (JAFFE) database with t-SNE and AdaBoostM2. Experimental results showed that the proposed new algorithm applied to FER gained the better performance compared with those traditional algorithms, such as PCA, LDA, LLE and SNE.[2]</span></p>
<p><span style="font-weight: 400">The flowchart for implementing such a combination on the data could be as follows:</span></p>
<p><span style="font-weight: 400">Preprocessing → normalization → t-SNE→ classification algorithm </span></p>
<p><span style="font-weight: 400">                       PCA      LDA    LLE     SNE    t-SNE</span></p>
<p><span style="font-weight: 400">SVM               73.5%  74.3%  84.7%  89.6%  90.3%</span></p>
<p><span style="font-weight: 400">AdaboostM2   75.4%  75.9%  87.7%  90.6%  94.5%</span></p>
<p>&nbsp;</p>
<h3>6.2 Identifying Tumor subpopulations (Medical Imaging)</h3>
<p style="text-align: justify"><span style="font-weight: 400">Mass spectrometry imaging (MSI) is a technology that simultaneously provides the spatial distribution for hundreds of biomolecules directly from tissue. Spatially mapped t-distributed stochastic neighbor embedding (t-SNE), a nonlinear visualization of the data that is able to better resolve the biomolecular intratumor heterogeneity. </span></p>
<p style="text-align: justify"><span style="font-weight: 400">In an unbiased manner, t-SNE can uncover tumor subpopulations that are statistically linked to patient survival in gastric cancer and metastasis status in primary tumors of breast cancer. Survival analysis performed on each t-SNE clusters will provide significantly useful results.[3]</span></p>
<p>&nbsp;</p>
<h3>6.3 Text comparison using wordvec</h3>
<p style="text-align: justify"><span style="font-weight: 400">Word vector representations capture many linguistic properties such as gender, tense, plurality and even semantic concepts like &#8220;capital city of&#8221;. Using dimensionality reduction, a 2D map can be computed where semantically similar words are close to each other. This combination of techniques can be used to provide a bird’s-eye view of different text sources, including text summaries and their source material. This enables users to explore a text source like a geographical map.[4]</span></p>
<p>&nbsp;</p>
<h2 style="text-align: justify">7. t-SNE compared to other dimensionality reduction algorithms</h2>
<p style="text-align: justify"><span style="font-weight: 400">While comparing the performance of t-SNE with other algorithms, we will compare t-SNE with other algorithms based on the achieved accuracy rather than the time and resource requirements with relation to accuracy.</span></p>
<p style="text-align: justify"><span style="font-weight: 400">t-SNE outputs provide better results than PCA and other linear dimensionality reduction models. This is because a linear method such as classical scaling is not good at modeling curved manifolds. It focuses on preserving the distances between widely separated data points rather than on preserving the distances between nearby data points.</span></p>
<p style="text-align: justify"><span style="font-weight: 400">The Gaussian kernel employed in the high-dimensional space by t-SNE defines a soft border between the local and global structure of the data. And for pairs of data points that are close together relative to the standard deviation of the Gaussian, the importance of modeling their separations is almost independent of the magnitudes of those separations. Moreover, t-SNE determines the local neighborhood size for each datapoint separately based on the local density of the data (by forcing each conditional probability distribution to have the same </span><span style="font-weight: 400">perplexity)[1]. This is because the algorithm defines a soft border between the local and global structure of the data.  And unlike other non-linear dimensionality reduction algorithms, it performs better than any of them. </span></p>
<p>&nbsp;</p>
<h2>8. Example Implementations</h2>
<p style="text-align: justify"><span style="font-weight: 400">Let&#8217;s implement the t-SNE algorithm on MNIST handwritten digit database. This is one of the most explored dataset for image processing.</span></p>
<h3 style="text-align: justify">1. In R</h3>
<p style="text-align: justify"><span style="font-weight: 400">The “Rtsne” package has an implementation of t-SNE in R. The “Rtsne” package can be installed in R using the following command typed in the R console:</span></p>
<pre><i><span style="font-weight: 400">install.packages(“Rtsne”)</span></i></pre>
<ul>
<li>
<h4>Hyper parameter tuning</h4>
<p><img class="aligncenter wp-image-32452 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/20083801/TSNE1.png" width="669" height="391" srcset="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/20083801/TSNE1.png 669w, https://static.analyticsvidhya.com/wp-content/uploads/2017/01/20083801/TSNE1-300x175.png 300w" sizes="(max-width: 669px) 100vw, 669px" /></li>
</ul>
<ul>
<li>
<h4>Code</h4>
<p>MNIST data can be downloaded from the MNIST website and can be converted into a csv file with small amount of code.For this example, please download the following preprocessed MNIST data. <a href="https://drive.google.com/file/d/0B6E7D59TV2zWYlJLZHdGeUYydlk/view?usp=sharing">link</a></li>
</ul>
<pre><span style="font-weight: 400">## calling the installed package
</span>train&lt;- read.csv(file.choose()) ## Choose the train.csv file downloaded from the link above  
<span style="font-weight: 400">library(Rtsne)</span>
<span style="font-weight: 400">## Curating the database for analysis with both t-SNE and PCA</span>
<span style="font-weight: 400">Labels&lt;-train$label</span>
<span style="font-weight: 400">train$label&lt;-as.factor(train$label)</span>
<span style="font-weight: 400">## for plotting</span>
<span style="font-weight: 400">colors = rainbow(length(unique(train$label)))</span>
<span style="font-weight: 400">names(colors) = unique(train$label)</span>

<span style="font-weight: 400">## Executing the algorithm on curated data</span>
<span style="font-weight: 400">tsne &lt;- Rtsne(train[,-1], dims = 2, perplexity=30, verbose=TRUE, max_iter = 500)</span>
<span style="font-weight: 400">exeTimeTsne&lt;- system.time(Rtsne(train[,-1], dims = 2, perplexity=30, verbose=TRUE, max_iter = 500))</span>

<span style="font-weight: 400">## Plotting</span>
<span style="font-weight: 400">plot(tsne$Y, t='n', main="tsne")</span>
<span style="font-weight: 400">text(tsne$Y, labels=train$label, col=colors[train$label])</span></pre>
<p>&nbsp;</p>
<ul>
<li>
<h4>Implementation Time</h4>
</li>
</ul>
<pre><span style="font-weight: 400">exeTimeTsne</span>
  <span style="font-weight: 400">user       system  elapsed </span>
  <span style="font-weight: 400">118.037   0.000  118.006</span>

<span style="font-weight: 400">exectutiontimePCA</span>
  <span style="font-weight: 400"> user     system   elapsed </span>
  <span style="font-weight: 400">11.259   0.012     11.360</span></pre>
<p><span style="font-weight: 400">As can be seen t-SNE takes considerably longer time to execute on the same sample size of data than PCA.  </span></p>
<p>&nbsp;</p>
<ul>
<li>
<h4>Interpreting Results</h4>
</li>
</ul>
<p style="text-align: justify"><span style="font-weight: 400"> The plots can be used for exploratory analysis. The output x &amp; y co-ordinates and as well as cost can be used as features in classification algorithms.</span></p>
<p><img class="aligncenter wp-image-32271 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/17114122/TSN5.png" width="694" height="350" srcset="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/17114122/TSN5.png 694w, https://static.analyticsvidhya.com/wp-content/uploads/2017/01/17114122/TSN5-300x151.png 300w" sizes="(max-width: 694px) 100vw, 694px" /></p>
<p><img class="aligncenter wp-image-32282 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/17141033/TSN61.png" width="712" height="375" srcset="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/17141033/TSN61.png 712w, https://static.analyticsvidhya.com/wp-content/uploads/2017/01/17141033/TSN61-300x158.png 300w" sizes="(max-width: 712px) 100vw, 712px" /></p>
<h3>2. In Python</h3>
<p style="text-align: justify"><span style="font-weight: 400">An important thing to note is that the “pip install tsne” produces an error. Installing “tsne” package is not recommended. t-SNE algorithm can be accessed from sklearn package.</span></p>
<ul>
<li>
<h4>Hyper parameter tuning</h4>
</li>
</ul>
<p style="text-align: justify"><img class="aligncenter wp-image-32453 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/20083812/tsne2.png" width="668" height="468" srcset="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/20083812/tsne2.png 668w, https://static.analyticsvidhya.com/wp-content/uploads/2017/01/20083812/tsne2-300x210.png 300w" sizes="(max-width: 668px) 100vw, 668px" /></p>
<ul>
<li>
<h4>Code</h4>
</li>
</ul>
<p><span style="font-weight: 400"> The following code is taken from the sklearn examples on the sklearn website. </span></p>
<pre><span style="font-weight: 400">## importing the required packages</span>
<span style="font-weight: 400">from time import time</span>
<span style="font-weight: 400">import numpy as np</span>
<span style="font-weight: 400">import matplotlib.pyplot as plt</span>
<span style="font-weight: 400">from matplotlib import offsetbox
</span><span style="font-weight: 400">from sklearn import (manifold, datasets, decomposition, ensemble,</span>
<span style="font-weight: 400">             discriminant_analysis, random_projection)
</span><span style="font-weight: 400">## Loading and curating the data</span>
<span style="font-weight: 400">digits = datasets.load_digits(n_class=10)</span>
<span style="font-weight: 400">X = digits.data</span>
<span style="font-weight: 400">y = digits.target</span>
<span style="font-weight: 400">n_samples, n_features = X.shape</span>
<span style="font-weight: 400">n_neighbors = 30</span>
<span style="font-weight: 400">## Function to Scale and visualize the embedding vectors</span>
<span style="font-weight: 400">def plot_embedding(X, title=None):</span>
<span style="font-weight: 400">    x_min, x_max = np.min(X, 0), np.max(X, 0)
</span><span style="font-weight: 400">    X = (X - x_min) / (x_max - x_min)     
</span><span style="font-weight: 400">    plt.figure()</span>
<span style="font-weight: 400">    ax = plt.subplot(111)</span>
<span style="font-weight: 400">    for i in range(X.shape[0]):</span>
<span style="font-weight: 400">        plt.text(X[i, 0], X[i, 1], str(digits.target[i]),</span>
<span style="font-weight: 400">                 color=plt.cm.Set1(y[i] / 10.),
</span><span style="font-weight: 400">                 fontdict={'weight': 'bold', 'size': 9})
</span>    if hasattr(offsetbox, 'AnnotationBbox'):
<span style="font-weight: 400">        ## only print thumbnails with matplotlib &gt; 1.0</span>
<span style="font-weight: 400">        shown_images = np.array([[1., 1.]])  # just something big
</span><span style="font-weight: 400">        for i in range(digits.data.shape[0]):</span>
<span style="font-weight: 400">            dist = np.sum((X[i] - shown_images) ** 2, 1)
</span><span style="font-weight: 400">            if np.min(dist) &lt; 4e-3:
</span><span style="font-weight: 400">                ## don't show points that are too close</span>
<span style="font-weight: 400">                continue</span>
<span style="font-weight: 400">            shown_images = np.r_[shown_images, [X[i]]]</span>
<span style="font-weight: 400">            imagebox = offsetbox.AnnotationBbox(</span>
<span style="font-weight: 400">                offsetbox.OffsetImage(digits.images[i], cmap=plt.cm.gray_r),
</span><span style="font-weight: 400">                X[i])
</span><span style="font-weight: 400">            ax.add_artist(imagebox)
</span><span style="font-weight: 400">    plt.xticks([]), plt.yticks([])
</span><span style="font-weight: 400">    if title is not None:</span>
<span style="font-weight: 400">        plt.title(title)
</span><span style="font-weight: 400">
#----------------------------------------------------------------------</span>
<span style="font-weight: 400">## Plot images of the digits</span>
<span style="font-weight: 400">n_img_per_row = 20</span>
<span style="font-weight: 400">img = np.zeros((10 * n_img_per_row, 10 * n_img_per_row))</span>
<span style="font-weight: 400">for i in range(n_img_per_row):</span>
<span style="font-weight: 400">    ix = 10 * i + 1</span>
<span style="font-weight: 400">    for j in range(n_img_per_row):
</span><span style="font-weight: 400">        iy = 10 * j + 1
</span><span style="font-weight: 400">        img[ix:ix + 8, iy:iy + 8] = X[i * n_img_per_row + j].reshape((8, 8))</span><span style="font-weight: 400">
plt.imshow(img, cmap=plt.cm.binary)</span>
<span style="font-weight: 400">plt.xticks([])</span>
<span style="font-weight: 400">plt.yticks([])</span>
<span style="font-weight: 400">plt.title('A selection from the 64-dimensional digits dataset')
</span><span style="font-weight: 400">## Computing PCA</span>
<span style="font-weight: 400">print("Computing PCA projection")</span>
<span style="font-weight: 400">t0 = time()</span>
<span style="font-weight: 400">X_pca = decomposition.TruncatedSVD(n_components=2).fit_transform(X)</span>
<span style="font-weight: 400">plot_embedding(X_pca,</span>
<span style="font-weight: 400">               "Principal Components projection of the digits (time %.2fs)" %
</span><span style="font-weight: 400">               (time() - t0))
</span><span style="font-weight: 400">## Computing t-SNE</span>
<span style="font-weight: 400">print("Computing t-SNE embedding")</span>
<span style="font-weight: 400">tsne = manifold.TSNE(n_components=2, init='pca', random_state=0)</span>
<span style="font-weight: 400">t0 = time()</span>
<span style="font-weight: 400">X_tsne = tsne.fit_transform(X)
</span><span style="font-weight: 400">plot_embedding(X_tsne,</span>
<span style="font-weight: 400">               "t-SNE embedding of the digits (time %.2fs)" %</span>
<span style="font-weight: 400">               (time() - t0))</span>
<span style="font-weight: 400">plt.show()</span></pre>
<p>&nbsp;</p>
<ul>
<li>
<h4>Implementation Time</h4>
</li>
</ul>
<pre><span style="font-weight: 400">Tsne: 13.40 s</span>

<span style="font-weight: 400">PCA: 0.01 s</span></pre>
<p><img class="aligncenter wp-image-32285 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/17141345/tsn7.png" width="521" height="360" srcset="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/17141345/tsn7.png 521w, https://static.analyticsvidhya.com/wp-content/uploads/2017/01/17141345/tsn7-300x207.png 300w" sizes="(max-width: 521px) 100vw, 521px" /> <img class="aligncenter wp-image-32286 size-full" src="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/17141405/tsn8.png" width="561" height="372" srcset="https://static.analyticsvidhya.com/wp-content/uploads/2017/01/17141405/tsn8.png 561w, https://static.analyticsvidhya.com/wp-content/uploads/2017/01/17141405/tsn8-300x199.png 300w" sizes="(max-width: 561px) 100vw, 561px" /></p>
<h2>9. Where and When to use t-SNE?</h2>
<h4>9.1 Data Scientist</h4>
<p style="text-align: justify"><span style="font-weight: 400">Well for the data scientist the main problem while using t-SNE is the black box type nature of the algorithm. This impedes the process of providing inferences and insights based on the results. Also, another problem with the algorithm is that it doesn&#8217;t always provide a similar output on successive runs.</span></p>
<p style="text-align: justify"><span style="font-weight: 400">So then how could you use the algorithm? The best way to used the algorithm is to use it for exploratory data analysis. It will give you a very good sense of patterns hidden inside the data. It can also be used as an input parameter for other classification &amp; clustering algorithms.</span></p>
<p>&nbsp;</p>
<h4>9.2 Machine Learning Hacker</h4>
<p style="text-align: justify"><span style="font-weight: 400">Reduce the dataset to 2 or 3 dimensions and stack this with a non-linear stacker. Using a holdout set for stacking / blending. Then you can boost the t-SNE vectors using XGboost to get better results.</span></p>
<p>&nbsp;</p>
<h4>9.3 Data Science Enthusiasts</h4>
<p style="text-align: justify"><span style="font-weight: 400">For data science enthusiasts who are beginning to work with data science, this algorithm presents the best opportunities in terms of research and performance enhancements. There have been a few research papers attempting to improve the time complexity of the algorithm by utilizing linear functions. But an optimal solution is still required. Research papers on implementing t-SNE for a variety of NLP problems and image processing applications is an unexplored territory and has enough scope. </span></p>
<p><b> </b><span style="font-weight: 400">   </span></p>
<h2>10. Common Fallacies</h2>
<p><span style="font-weight: 400">Following are a few common fallacies to avoid while interpreting the results of t-SNE:</span></p>
<ol>
<li style="font-weight: 400;text-align: justify"><span style="font-weight: 400">For the algorithm to execute properly, the perplexity should be smaller than the number of points. Also, the suggested perplexity is in the range of (5 to 50)</span></li>
<li style="font-weight: 400;text-align: justify"><span style="font-weight: 400">Sometimes, different runs with same hyper parameters may produce different results.</span></li>
<li style="font-weight: 400;text-align: justify"><span style="font-weight: 400">Cluster sizes in any t-SNE plot must not be evaluated for standard deviation, dispersion or any other similar measures. </span>This is because t-SNE expands denser clusters and contracts sparser clusters to even out cluster sizes. This is one of the reasons for the crisp and clear plots it produces.</li>
<li style="font-weight: 400;text-align: justify"><span style="font-weight: 400">Distances between clusters may change because global geometry is closely related to optimal perplexity. And in a dataset with many clusters with different number of elements one perplexity cannot optimize distances for all clusters.</span></li>
<li style="font-weight: 400;text-align: justify"><span style="font-weight: 400">Patterns may be found in random noise as well, so multiple runs of the algorithm with different sets of hyperparameter must be checked before deciding if a pattern exists in the data.</span></li>
<li style="font-weight: 400"><span style="font-weight: 400">Different cluster shapes may be observed at different perplexity levels.</span></li>
<li style="font-weight: 400;text-align: justify"><span style="font-weight: 400"> Topology cannot be analyzed based on a single t-SNE plot, multiple plots must be observed before making any assessment.</span></li>
</ol>
<p>&nbsp;</p>
<h3>Reference</h3>
<p style="text-align: justify">[1] L.J.P. van der Maaten and G.E. Hinton. Visualizing High-Dimensional Data Using  t-SNE. <i>Journal of Machine Learning Research</i> 9(Nov):2579-2605, 2008</p>
<p style="text-align: justify"><em><span style="font-weight: 400">[2] Jizheng Yi et.al. Facial expression recognition Based on t-SNE and AdaBoostM2.</span></em></p>
<p style="text-align: justify"><em><span style="font-weight: 400">IEEE International Conference on Green Computing and Communications and IEEE Internet of Things and IEEE Cyber,Physical and Social Computing (2013)</span></em></p>
<p style="text-align: justify"><em><span style="font-weight: 400">[3]  Walid M. Abdelmoulaa et.al. Data-driven identification of prognostic tumor subpopulations using spatially mapped t-SNE of mass spectrometry imaging data.</span></em></p>
<p style="text-align: justify"><em><span style="font-weight: 400">12244–12249 | PNAS | October 25, 2016 | vol. 113 | no. 43</span></em></p>
<p style="text-align: justify"><em><span style="font-weight: 400">[4]  Hendrik Heuer. Text comparison using word vector representations and dimensionality reduction. </span></em><em><span style="font-weight: 400">8th EUR. CONF. ON PYTHON IN SCIENCE (EUROSCIPY 2015)</span></em></p>

</body>
</html>
