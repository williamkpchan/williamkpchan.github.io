<base href=http://adv-r.had.co.nz/>
<!DOCTYPE html>
<html>
  <head>
    <title>Exceptions and debugging &middot; Advanced R.</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="https://dl.dropboxusercontent.com/u/62029863/my.min.css" rel="stylesheet">
    <link href="https://dl.dropboxusercontent.com/u/62029863/Myhighlight.css" rel="stylesheet">

    <link href='http://fonts.googleapis.com/css?family=Inconsolata:400,700'
      rel='stylesheet' type='text/css'>
    <script src="https://dl.dropboxusercontent.com/u/62029863/toc.js"></script>
  </head>

<body bgcolor="#000000" text="#109030" leftmargin="10" topmargin="10" marginwidth="10" link="#08C8A8" vlink="#389898" alink="#28B8B8">
<FONT size=3>

    <div class="container">

      <div class="masthead">
        <ul class="nav nav-pills pull-right">
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">
              Table of contents<b class="caret"></b>
            </a>
            <ul class="dropdown-menu pull-right" role="menu">
              <li><a href="Introduction.html">Introduction</a></li>
<li class="dropdown-header">Foundations</li>
<li><a href="Data-structures.html">Data structures</a></li>
<li><a href="Subsetting.html">Subsetting</a></li>
<li><a href="Vocabulary.html">Vocabulary</a></li>
<li><a href="Style.html">Style</a></li>
<li><a href="Functions.html">Functions</a></li>
<li><a href="OO-essentials.html">OO field guide</a></li>
<li><a href="Environments.html">Environments</a></li>
<li><a href="Exceptions-Debugging.html">Exceptions and debugging</a></li>

<li class="dropdown-header">Functional programming</li>
<li><a href="Functional-programming.html">Functional programming</a></li>
<li><a href="Functionals.html">Functionals</a></li>
<li><a href="Function-operators.html">Function operators</a></li>

<li class="dropdown-header">Metaprogramming</li>
<li><a href="Computing-on-the-language.html">Non-standard evaluation</a></li>
<li><a href="Expressions.html">Expressions</a></li>
<li><a href="dsl.html">Domain specific languages</a></li>

<li class="dropdown-header">Performant code</li>
<li><a href="Performance.html">Performance</a></li>
<li><a href="Profiling.html">Profiling</a></li>
<li><a href="memory.html">Memory</a></li>
<li><a href="Rcpp.html">Rcpp</a></li>
<li><a href="C-interface.html">R's C interface</a></li>

            </ul>
          </li>
        </ul>

        <div>
          <h1 id="debugging">Debugging, condition handling, and defensive programming</h1>
<p>What happens when something goes wrong with your R code? What do you do? What tools do you have to address the problem? <br>
This chapter will teach you how to fix unanticipated problems (debugging), <br>
show you how functions can communicate problems and how you can take action based on those communications (condition handling), <br>
and teach you how to avoid common problems before they occur (defensive programming).</p>
<p>Debugging is the art and science of fixing unexpected problems in your code. In this section you’ll learn the tools and techniques that help you get to the root cause of an error. You’ll learn general strategies for debugging, useful R functions like <code>traceback()</code> and <code>browser()</code>, and interactive tools in RStudio.</p>
<p>Not all problems are unexpected. When writing a function, you can often anticipate potential problems (like a non-existent file or the wrong type of input). Communicating these problems to the user is the job of <strong>conditions</strong>: errors, warnings, and messages.</p>
<ul>
<li><p>Fatal errors are raised by <code>stop()</code> and force all execution to terminate. Errors are used when there is no way for a function to continue.  </p></li>
<li><p>Warnings are generated by <code>warning()</code> and are used to display potential problems, such as when some elements of a vectorised input are invalid, like <code>log(-1:2)</code>.</p></li>
<li><p>Messages are generated by <code>message()</code> and are used to give informative output in a way that can easily be suppressed by the user (<code>?suppressMessages()</code>). I often use messages to let the user know what value the function has chosen for an important missing argument.</p></li>
</ul>
<p>Conditions are usually displayed prominently, in a bold font or coloured red depending on your R interface. You can tell them apart because errors always start with “Error” and warnings with “Warning message”. Function authors can also communicate with their users with <code>print()</code> or <code>cat()</code>, but I think that’s a bad idea because it’s hard to capture and selectively ignore this sort of output. Printed output is not a condition, so you can’t use any of the useful condition handling tools you’ll learn about below.</p>
<p>Condition handling tools, like <code>withCallingHandlers()</code>, <code>tryCatch()</code>, and <code>try()</code> allow you to take specific actions when a condition occurs. For example, if you’re fitting many models, you might want to continue fitting the others even if one fails to converge. R offers an exceptionally powerful condition handling system based on ideas from Common Lisp, but it’s currently not very well documented or often used. This chapter will introduce you to the most important basics, but if you want to learn more, I recommend the following two sources:</p>
<ul>
<li><p><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html"><em>A prototype of a condition system for R</em></a> by Robert Gentleman and Luke Tierney. This describes an early version of R’s condition system. While the implementation has changed somewhat since this document was written, it provides a good overview of how the pieces fit together, and some motivation for its design.</p></li>
<li><p><a href="http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html"><em>Beyond Exception Handling: Conditions and Restarts</em></a> by Peter Seibel. This describes exception handling in Lisp, which happens to be very similar to R’s approach. It provides useful motivation and more sophisticated examples. I have provided an R translation of the chapter at <a href="http://adv-r.had.co.nz/beyond-exception-handling.html">http://adv-r.had.co.nz/beyond-exception-handling.html</a>.</p></li>
</ul>
<p>The chapter concludes with a discussion of “defensive” programming: ways to avoid common errors before they occur. In the short run you’ll spend more time writing code, but in the long run you’ll save time because error messages will be more informative and will let you narrow in on the root cause more quickly. The basic principle of defensive programming is to “fail fast”, to raise an error as soon as something goes wrong. In R, this takes three particular forms: checking that inputs are correct, avoiding non-standard evaluation, and avoiding functions that can return different types of output.</p>
<h5>Quiz</h5>
<p>Want to skip this chapter? Go for it, if you can answer the questions below. Find the answers at the end of the chapter in <a href="Exceptions-Debugging.html#debugging-answers">answers</a>.</p>
<ol style="list-style-type: decimal">
<li><p>How can you find out where an error occured?</p></li>
<li><p>What does <code>browser()</code> do? List the five useful single-key commands that you can use inside of a <code>browser()</code> environment.</p></li>
<li><p>What function do you use to ignore errors in block of code?</p></li>
<li><p>Why might you want to create an error with a custom S3 class?</p></li>
</ol>
<h5>Outline</h5>
<ol style="list-style-type: decimal">
<li><p><a href="Exceptions-Debugging.html#debugging-techniques">Debugging techniques</a> outlines a general approach for finding and resolving bugs.</p></li>
<li><p><a href="Exceptions-Debugging.html#debugging-tools">Debugging tools</a> introduces you to the R functions and Rstudio features that help you locate exactly where an error occurred.</p></li>
<li><p><a href="Exceptions-Debugging.html#condition-handling">Condition handling</a> shows you how you can catch conditions (errors, warnings, and messages) in your own code. This allows you to create code that’s both more robust and more informative in the presence of errors.</p></li>
<li><p><a href="Exceptions-Debugging.html#defensive-programming">Defensive programming</a> introduces you to some important techniques for defensive programming, techniques that help prevent bugs from occurring in the first place.</p></li>
</ol>
<h2 id="debugging-techniques">Debugging techniques</h2>
<blockquote>
<p>“Finding your bug is a process of confirming the many things that you believe are true — until you find one which is not true.”</p>
<p>—Norm Matloff</p>
</blockquote>
<p>Debugging code is challenging. Many bugs are subtle and hard to find. Indeed, if a bug was obvious, you probably would’ve been able to avoid it in the first place. While it’s true that with a good technique, you can productively debug a problem with just <code>print()</code>, there are times when additional help would be welcome. In this section, we’ll discuss some useful tools, which R and RStudio provide, and outline a general procedure for debugging.  </p>
<p>While the procedure below is by no means foolproof, it will hopefully help you to organise your thoughts when debugging. There are four steps:</p>
<ol style="list-style-type: decimal">
<li><p><strong>Realise that you have a bug</strong></p>
<p>If you’re reading this chapter, you’ve probably already completed this step. It is a surprisingly important one: you can’t fix a bug until you know it exists. This is one reason why automated test suites are important when producing high-quality code. Unfortunately, automated testing is outside the scope of this book, but you can read more about it at <a href="http://r-pkgs.had.co.nz/tests.html">http://r-pkgs.had.co.nz/tests.html</a>.</p></li>
<li><p><strong>Make it repeatable</strong></p>
<p>Once you’ve determined you have a bug, you need to be able to reproduce it on command. Without this, it becomes extremely difficult to isolate its cause and to confirm that you’ve successfully fixed it.</p>
<p>Generally, you will start with a big block of code that you know causes the error and then slowly whittle it down to get to the smallest possible snippet that still causes the error. Binary search is particularly useful for this. To do a binary search, you repeatedly remove half of the code until you find the bug. This is fast because, with each step, you reduce the amount of code to look through by half.</p>
<p>If it takes a long time to generate the bug, it’s also worthwhile to figure out how to generate it faster. The quicker you can do this, the quicker you can figure out the cause.</p>
<p>As you work on creating a minimal example, you’ll also discover similar inputs that don’t trigger the bug. Make note of them: they will be helpful when diagnosing the cause of the bug.</p>
<p>If you’re using automated testing, this is also a good time to create an automated test case. If your existing test coverage is low, take the opportunity to add some nearby tests to ensure that existing good behaviour is preserved. This reduces the chances of creating a new bug.</p></li>
<li><p><strong>Figure out where it is</strong></p>
<p>If you’re lucky, one of the tools in the following section will help you to quickly identify the line of code that’s causing the bug. Usually, however, you’ll have to think a bit more about the problem. It’s a great idea to adopt the scientific method. Generate hypotheses, design experiments to test them, and record your results. This may seem like a lot of work, but a systematic approach will end up saving you time. I often waste a lot of time relying on my intuition to solve a bug (“oh, it must be an off-by-one error, so I’ll just subtract 1 here”), when I would have been better off taking a systematic approach.</p></li>
<li><p><strong>Fix it and test it</strong></p>
<p>Once you’ve found the bug, you need to figure out how to fix it and to check that the fix actually worked. Again, it’s very useful to have automated tests in place. Not only does this help to ensure that you’ve actually fixed the bug, it also helps to ensure you haven’t introduced any new bugs in the process. In the absence of automated tests, make sure to carefully record the correct output, and check against the inputs that previously failed.</p></li>
</ol>
<h2 id="debugging-tools">Debugging tools</h2>
<p>To implement a strategy of debugging, you’ll need tools. In this section, you’ll learn about the tools provided by R and the RStudio IDE. RStudio’s integrated debugging support makes life easier by exposing existing R tools in a user friendly way. I’ll show you both the R and RStudio ways so that you can work with whatever environment you use. You may also want to refer to the official <a href="http://www.rstudio.com/ide/docs/debugging/overview">RStudio debugging documentation</a> which always reflects the tools in the latest version of RStudio.</p>
<p>There are three key debugging tools:</p>
<ul>
<li><p>RStudio’s error inspector and <code>traceback()</code> which list the sequence of calls that lead to the error.</p></li>
<li><p>RStudio’s “Rerun with Debug” tool and <code>options(error = browser)</code> which open an interactive session where the error occurred.</p></li>
<li><p>RStudio’s breakpoints and <code>browser()</code> which open an interactive session at an arbitrary location in the code.</p></li>
</ul>
<p>I’ll explain each tool in more detail below.</p>
<p>You shouldn’t need to use these tools when writing new functions. If you find yourself using them frequently with new code, you may want to reconsider your approach. Instead of trying to write one big function all at once, work interactively on small pieces. If you start small, you can quickly identify why something doesn’t work. But if you start large, you may end up struggling to identify the source of the problem.</p>
<h3>Determining the sequence of calls</h3>
<p>The first tool is the <strong>call stack</strong>, the sequence of calls that lead up to an error. Here’s a simple example: you can see that <code>f()</code> calls <code>g()</code> calls <code>h()</code> calls <code>i()</code> which adds together a number and a string creating a error:  </p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span>function(a) <span class="kw">g</span>(a)
g &lt;-<span class="st"> </span>function(b) <span class="kw">h</span>(b)
h &lt;-<span class="st"> </span>function(c) <span class="kw">i</span>(c)
i &lt;-<span class="st"> </span>function(d) <span class="st">&quot;a&quot;</span> +<span class="st"> </span>d
<span class="kw">f</span>(<span class="dv">10</span>)</code></pre>
<p>When we run this code in Rstudio we see:</p>
<p><img src='screenshots/traceback-hidden.png' width=541 height=69 /></p>
<p>Two options appear to the right of the error message: “Show Traceback” and “Rerun with Debug”. If you click “Show traceback” you see:</p>
<p><img src='screenshots/traceback-shown.png' width=541 height=130 /></p>
<p>If you’re not using Rstudio, you can use <code>traceback()</code> to get the same information:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">traceback</span>()
<span class="co"># 4: i(c) at exceptions-example.R#3</span>
<span class="co"># 3: h(b) at exceptions-example.R#2</span>
<span class="co"># 2: g(a) at exceptions-example.R#1</span>
<span class="co"># 1: f(10)</span></code></pre>
<p>Read the call stack from bottom to top: the initial call is <code>f()</code>, which calls <code>g()</code>, then <code>h()</code>, then <code>i()</code>, which triggers the error. If you’re calling code that you <code>source()</code>d into R, the traceback will also display the location of the function, in the form <code>filename.r#linenumber</code>. These are clickable in Rstudio, and will take you to the corresponding line of code in the editor.</p>
<p>Sometimes this is enough information to let you track down the error and fix it. However, it’s usually not. <code>traceback()</code> shows you where the error occurred, but not why. The next useful tool is the interactive debugger, which allows you to pause execution of a function and interactively explore its state.</p>
<h3>Browsing on error</h3>
<p>The easiest way to enter the interactive debugger is through RStudio’s “Rerun with Debug” tool. This reruns the command that created the error, pausing execution where the error occurred. You’re now in an interactive state inside the function, and you can interact with any object defined there. You’ll see the corresponding code in the editor (with the statement that will be run next highlighted), objects in the current environment in the “Environment” pane, the call stack in a “Traceback” pane, and you can run arbitrary R code in the console. </p>
<p>As well as any regular R function, there are a few special commands you can use in debug mode. You can access them either with the Rstudio toolbar (<img src='screenshots/debug-toolbar.png' width=238 height=18 />) or with the keyboard:</p>
<ul>
<li><p>Next, <code>n</code>: executes the next step in the function. Be careful if you have a variable named <code>n</code>; to print it you’ll need to do <code>print(n)</code>.</p></li>
<li><p>Step into, <img src='screenshots/step-into.png' width=23 height=16 /> or <code>s</code>: works like next, but if the next step is a function, it will step into that function so you can work through each line.</p></li>
<li><p>Finish, <img src='screenshots/finish-loop.png' width=23 height=16 /> or <code>f</code>: finishes execution of the current loop or function.</p></li>
<li><p>Continue, <code>c</code>: leaves interactive debugging and continues regular execution of the function. This is useful if you’ve fixed the bad state and want to check that the function proceeds correctly.</p></li>
<li><p>Stop, <code>Q</code>: stops debugging, terminates the function, and returns to the global workspace. Use this once you’ve figured out where the problem is, and you’re ready to fix it and reload the code.</p></li>
</ul>
<p>There are two other slightly less useful commands that aren’t available in the toolbar:</p>
<ul>
<li><p>Enter: repeats the previous command. I find this too easy to activate accidentally, so I turn it off using <code>options(browserNLdisabled = TRUE)</code>.</p></li>
<li><p><code>where</code>: prints stack trace of active calls (the interactive equivalent of <code>traceback</code>).</p></li>
</ul>
<p>To enter this style of debugging outside of RStudio, you can use the <code>error</code> option which specifies a function to run when an error occurs. The function most similar to Rstudio’s debug is <code>browser()</code>: this will start an interactive console in the environment where the error occurred. Use <code>options(error = browser)</code> to turn it on, re-run the previous command, then use <code>options(error = NULL)</code> to return to the default error behaviour. You could automate this with the <code>browseOnce()</code> function as defined below: </p>
<pre class="sourceCode r"><code class="sourceCode r">browseOnce &lt;-<span class="st"> </span>function() {
  old &lt;-<span class="st"> </span><span class="kw">getOption</span>(<span class="st">&quot;error&quot;</span>)
  function() {
    <span class="kw">options</span>(<span class="dt">error =</span> old)
    <span class="kw">browser</span>()
  }
}
<span class="kw">options</span>(<span class="dt">error =</span> <span class="kw">browseOnce</span>())

f &lt;-<span class="st"> </span>function() <span class="kw">stop</span>(<span class="st">&quot;!&quot;</span>)
<span class="co"># Enters browser</span>
<span class="kw">f</span>()
<span class="co"># Runs normally</span>
<span class="kw">f</span>()</code></pre>
<p>(You’ll learn more about functions that return functions in <a href="Functional-programming.html#functional-programming">Functional programming</a>.)</p>
<p>There are two other useful functions that you can use with the <code>error</code> option:</p>
<ul>
<li><p><code>recover</code> is a step up from <code>browser</code>, as it allows you to enter the environment of any of the calls in the call stack. This is useful because often the root cause of the error is a number of calls back. </p></li>
<li><p><code>dump.frames</code> is an equivalent to <code>recover</code> for non-interactive code. It creates a <code>last.dump.rda</code> file in the current working directory. Then, in a later interactive R session, you load that file, and use <code>debugger()</code> to enter an interactive debugger with the same interface as <code>recover()</code>. This allows interactive debugging of batch code. </p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># In batch R process ----</span>
dump_and_quit &lt;-<span class="st"> </span>function() {
  <span class="co"># Save debugging info to file last.dump.rda</span>
  <span class="kw">dump.frames</span>(<span class="dt">to.file =</span> <span class="ot">TRUE</span>)
  <span class="co"># Quit R with error status</span>
  <span class="kw">q</span>(<span class="dt">status =</span> <span class="dv">1</span>)
}
<span class="kw">options</span>(<span class="dt">error =</span> dump_and_quit)

<span class="co"># In a later interactive session ----</span>
<span class="kw">load</span>(<span class="st">&quot;last.dump.rda&quot;</span>)
<span class="kw">debugger</span>()</code></pre></li>
</ul>
<p>To reset error behaviour to the default, use <code>options(error = NULL)</code>. Then errors will print a message and abort function execution.</p>
<h3>Browsing arbitrary code</h3>
<p>As well as entering an interactive console on error, you can enter it at an arbitrary code location by using either an Rstudio breakpoint or <code>browser()</code>. You can set a breakpoint in Rstudio by clicking to the left of the line number, or pressing <code>Shift + F9</code>. Equivalently, add <code>browser()</code> where you want execution to pause. Breakpoints behave similarly to <code>browser()</code> but they are easier to set (one click instead of nine key presses), and you don’t run the risk of accidentally including a <code>browser()</code> statement in your source code. There are two small downsides to breakpoints:  </p>
<ul>
<li><p>There are a few unusual situations in which breakpoints will not work: read <a href="http://www.rstudio.com/ide/docs/debugging/breakpoint-troubleshooting">breakpoint troubleshooting</a> for more details.</p></li>
<li><p>RStudio currently does not support conditional breakpoints, whereas you can always put <code>browser()</code> inside an <code>if</code> statement.</p></li>
</ul>
<p>As well as adding <code>browser()</code> yourself, there are two other functions that will add it to code:</p>
<ul>
<li><p><code>debug()</code> inserts a browser statement in the first line of the specified function. <code>undebug()</code> removes it. Alternatively, you can use <code>debugonce()</code> to browse only on the next run. </p></li>
<li><p><code>utils::setBreakpoint()</code> works similarly, but instead of taking a function name, it takes a file name and line number and finds the appropriate function for you. </p></li>
</ul>
<p>These two functions are both special cases of <code>trace()</code>, which inserts arbitrary code at any position in an existing function. <code>trace()</code> is occasionally useful when you’re debugging code that you don’t have the source for. To remove tracing from a function, use <code>untrace()</code>. You can only perform one trace per function, but that one trace can call multiple functions. </p>
<h3>The call stack: <code>traceback()</code>, <code>where</code>, and <code>recover()</code></h3>
<p>Unfortunately the call stacks printed by <code>traceback()</code>, <code>browser()</code> + <code>where</code>, and <code>recover()</code> are not consistent. The following table shows how the call stacks from a simple nested set of calls are displayed by the three tools. </p>
<table>
<thead>
<tr class="header">
<th align="left"><code>traceback()</code></th>
<th align="left"><code>where</code></th>
<th align="left"><code>recover()</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>4: stop(&quot;Error&quot;)</code></td>
<td align="left"><code>where 1: stop(&quot;Error&quot;)</code></td>
<td align="left"><code>1: f()</code></td>
</tr>
<tr class="even">
<td align="left"><code>3: h(x)</code></td>
<td align="left"><code>where 2: h(x)</code></td>
<td align="left"><code>2: g(x)</code></td>
</tr>
<tr class="odd">
<td align="left"><code>2: g(x)</code></td>
<td align="left"><code>where 3: g(x)</code></td>
<td align="left"><code>3: h(x)</code></td>
</tr>
<tr class="even">
<td align="left"><code>1: f()</code></td>
<td align="left"><code>where 4: f()</code></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>Note that numbering is different between <code>traceback()</code> and <code>where</code>, and that <code>recover()</code> displays calls in the opposite order, and omits the call to <code>stop()</code>. RStudio displays calls in the same order as <code>traceback()</code> but omits the numbers.</p>
<h3>Other types of failure</h3>
<p>There are other ways for a function to fail apart from throwing an error or returning an incorrect result.</p>
<ul>
<li><p>A function may generate an unexpected warning. The easiest way to track down warnings is to convert them into errors with <code>options(warn = 2)</code> and use the regular debugging tools. When you do this you’ll see some extra calls in the call stack, like <code>doWithOneRestart()</code>, <code>withOneRestart()</code>, <code>withRestarts()</code>, and <code>.signalSimpleWarning()</code>. Ignore these: they are internal functions used to turn warnings into errors. </p></li>
<li><p>A function may generate an unexpected message. There’s no built-in tool to help solve this problem, but it’s possible to create one: </p>
<pre class="sourceCode r"><code class="sourceCode r">message2error &lt;-<span class="st"> </span>function(code) {
  <span class="kw">withCallingHandlers</span>(code, <span class="dt">message =</span> function(e) <span class="kw">stop</span>(e))
}

f &lt;-<span class="st"> </span>function() <span class="kw">g</span>()
g &lt;-<span class="st"> </span>function() <span class="kw">message</span>(<span class="st">&quot;Hi!&quot;</span>)
<span class="kw">g</span>()
<span class="co"># Error in message(&quot;Hi!&quot;): Hi!</span>
<span class="kw">message2error</span>(<span class="kw">g</span>())
<span class="kw">traceback</span>()
<span class="co"># 10: stop(e) at #2</span>
<span class="co"># 9: (function (e) stop(e))(list(message = &quot;Hi!\n&quot;, </span>
<span class="co">#      call = message(&quot;Hi!&quot;)))</span>
<span class="co"># 8: signalCondition(cond)</span>
<span class="co"># 7: doWithOneRestart(return(expr), restart)</span>
<span class="co"># 6: withOneRestart(expr, restarts[[1L]])</span>
<span class="co"># 5: withRestarts()</span>
<span class="co"># 4: message(&quot;Hi!&quot;) at #1</span>
<span class="co"># 3: g()</span>
<span class="co"># 2: withCallingHandlers(code, message = function(e) stop(e)) </span>
<span class="co">#      at #2</span>
<span class="co"># 1: message2error(g())</span></code></pre>
<p>As with warnings, you’ll need to ignore some of the calls on the traceback (i.e., the first two and the last seven).</p></li>
<li><p>A function might never return. This is particularly hard to debug automatically, but sometimes terminating the function and looking at the call stack is informative. Otherwise, use the basic debugging strategies described above.</p></li>
<li><p>The worst scenario is that your code might crash R completely, leaving you with no way to interactively debug your code. This indicates a bug in the underlying C code. This is hard to debug. Sometimes an interactive debugger, like <code>gdb</code>, can be useful, but describing how to use it is beyond the scope of this book. </p>
<p>If the crash is caused by base R code, post a reproducible example to R-help. If it’s in a package, contact the package maintainer. If it’s your own C or C++ code, you’ll need to use numerous <code>print()</code> statements to narrow down the location of the bug, and then you’ll need to use many more print statements to figure out which data structure doesn’t have the properties that you expect.</p></li>
</ul>
<h2 id="condition-handling">Condition handling</h2>
<p>Unexpected errors require interactive debugging to figure out what went wrong. Some errors, however, are expected, and you want to handle them automatically. In R, expected errors crop up most frequently when you’re fitting many models to different datasets, such as bootstrap replicates. Sometimes the model might fail to fit and throw an error, but you don’t want to stop everything. Instead, you want to fit as many models as possible and then perform diagnostics after the fact. </p>
<p>In R, there are three tools for handling conditions (including errors) programmatically:</p>
<ul>
<li><p><code>try()</code> gives you the ability to continue execution even when an error occurs.</p></li>
<li><p><code>tryCatch()</code> lets you specify <strong>handler</strong> functions that control what happens when a condition is signalled.</p></li>
<li><p><code>withCallingHandlers()</code> is a variant of <code>tryCatch()</code> that runs its handlers in a different context. It’s rarely needed, but is useful to be aware of.</p></li>
</ul>
<p>The following sections describe these tools in more detail.</p>
<h3 id="try">Ignore errors with try</h3>
<p><code>try()</code> allows execution to continue even after an error has occurred. For example, normally if you run a function that throws an error, it terminates immediately and doesn’t return a value: </p>
<pre class="sourceCode r"><code class="sourceCode r">f1 &lt;-<span class="st"> </span>function(x) {
  <span class="kw">log</span>(x)
  <span class="dv">10</span>
}
<span class="kw">f1</span>(<span class="st">&quot;x&quot;</span>)
<span class="co">#&gt; Error in log(x): non-numeric argument to mathematical function</span></code></pre>
<p>However, if you wrap the statement that creates the error in <code>try()</code>, the error message will be printed but execution will continue:</p>
<pre class="sourceCode r"><code class="sourceCode r">f2 &lt;-<span class="st"> </span>function(x) {
  <span class="kw">try</span>(<span class="kw">log</span>(x))
  <span class="dv">10</span>
}
<span class="kw">f2</span>(<span class="st">&quot;a&quot;</span>)
<span class="co">#&gt; Error in log(x) : non-numeric argument to mathematical function</span>
<span class="co">#&gt; [1] 10</span></code></pre>
<p>You can suppress the message with <code>try(..., silent = TRUE)</code>.</p>
<p>To pass larger blocks of code to <code>try()</code>, wrap them in <code>{}</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">try</span>({
  a &lt;-<span class="st"> </span><span class="dv">1</span>
  b &lt;-<span class="st"> &quot;x&quot;</span>
  a +<span class="st"> </span>b
})</code></pre>
<p>You can also capture the output of the <code>try()</code> function. If successful, it will be the last result evaluated in the block (just like a function). If unsuccessful it will be an (invisible) object of class “try-error”:</p>
<pre class="sourceCode r"><code class="sourceCode r">success &lt;-<span class="st"> </span><span class="kw">try</span>(<span class="dv">1</span> +<span class="st"> </span><span class="dv">2</span>)
failure &lt;-<span class="st"> </span><span class="kw">try</span>(<span class="st">&quot;a&quot;</span> +<span class="st"> &quot;b&quot;</span>)
<span class="kw">class</span>(success)
<span class="co">#&gt; [1] &quot;numeric&quot;</span>
<span class="kw">class</span>(failure)
<span class="co">#&gt; [1] &quot;try-error&quot;</span></code></pre>
<p><code>try()</code> is particularly useful when you’re applying a function to multiple elements in a list:</p>
<pre class="sourceCode r"><code class="sourceCode r">elements &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="kw">c</span>(-<span class="dv">1</span>, <span class="dv">10</span>), <span class="kw">c</span>(T, F), letters)
results &lt;-<span class="st"> </span><span class="kw">lapply</span>(elements, log)
<span class="co">#&gt; Warning in FUN(X[[i]], ...): NaNs produced</span>
<span class="co">#&gt; Error in FUN(X[[i]], ...): non-numeric argument to mathematical function</span>
results &lt;-<span class="st"> </span><span class="kw">lapply</span>(elements, function(x) <span class="kw">try</span>(<span class="kw">log</span>(x)))
<span class="co">#&gt; Warning in log(x): NaNs produced</span></code></pre>
<p>There isn’t a built-in function to test for the try-error class, so we’ll define one. Then you can easily find the locations of errors with <code>sapply()</code> (as discussed in <a href="Functionals.html#functionals">Functionals</a>), and extract the successes or look at the inputs that lead to failures.</p>
<pre class="sourceCode r"><code class="sourceCode r">is.error &lt;-<span class="st"> </span>function(x) <span class="kw">inherits</span>(x, <span class="st">&quot;try-error&quot;</span>)
succeeded &lt;-<span class="st"> </span>!<span class="kw">sapply</span>(results, is.error)

<span class="co"># look at successful results</span>
<span class="kw">str</span>(results[succeeded])
<span class="co">#&gt; List of 3</span>
<span class="co">#&gt;  $ : num [1:10] 0 0.693 1.099 1.386 1.609 ...</span>
<span class="co">#&gt;  $ : num [1:2] NaN 2.3</span>
<span class="co">#&gt;  $ : num [1:2] 0 -Inf</span>

<span class="co"># look at inputs that failed</span>
<span class="kw">str</span>(elements[!succeeded])
<span class="co">#&gt; List of 1</span>
<span class="co">#&gt;  $ : chr [1:26] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ...</span></code></pre>
<p>Another useful <code>try()</code> idiom is using a default value if an expression fails. Simply assign the default value outside the try block, and then run the risky code:</p>
<pre class="sourceCode r"><code class="sourceCode r">default &lt;-<span class="st"> </span><span class="ot">NULL</span>
<span class="kw">try</span>(default &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;possibly-bad-input.csv&quot;</span>), <span class="dt">silent =</span> <span class="ot">TRUE</span>)</code></pre>
<p>There is also <code>plyr::failwith()</code>, which makes this strategy even easier to implement. See <a href="Function-operators.html#output-fos">Function Operators</a> for more details.</p>
<h3>Handle conditions with <code>tryCatch()</code></h3>
<p><code>tryCatch()</code> is a general tool for handling conditions: in addition to errors, you can take different actions for warnings, messages, and interrupts. You’ve seen errors (made by <code>stop()</code>), warnings (<code>warning()</code>) and messages (<code>message()</code>) before, but interrupts are new. They can’t be generated directly by the programmer, but are raised when the user attempts to terminate execution by pressing Ctrl + Break, Escape, or Ctrl + C (depending on the platform).  </p>
<p>With <code>tryCatch()</code> you map conditions to <strong>handlers</strong>, named functions that are called with the condition as an input. If a condition is signalled, <code>tryCatch()</code> will call the first handler whose name matches one of the classes of the condition. The only useful built-in names are <code>error</code>, <code>warning</code>, <code>message</code>, <code>interrupt</code>, and the catch-all <code>condition</code>. A handler function can do anything, but typically it will either return a value or create a more informative error message. For example, the <code>show_condition()</code> function below sets up handlers that return the type of condition signalled: </p>
<pre class="sourceCode r"><code class="sourceCode r">show_condition &lt;-<span class="st"> </span>function(code) {
  <span class="kw">tryCatch</span>(code,
    <span class="dt">error =</span> function(c) <span class="st">&quot;error&quot;</span>,
    <span class="dt">warning =</span> function(c) <span class="st">&quot;warning&quot;</span>,
    <span class="dt">message =</span> function(c) <span class="st">&quot;message&quot;</span>
  )
}
<span class="kw">show_condition</span>(<span class="kw">stop</span>(<span class="st">&quot;!&quot;</span>))
<span class="co">#&gt; [1] &quot;error&quot;</span>
<span class="kw">show_condition</span>(<span class="kw">warning</span>(<span class="st">&quot;?!&quot;</span>))
<span class="co">#&gt; [1] &quot;warning&quot;</span>
<span class="kw">show_condition</span>(<span class="kw">message</span>(<span class="st">&quot;?&quot;</span>))
<span class="co">#&gt; [1] &quot;message&quot;</span>

<span class="co"># If no condition is captured, tryCatch returns the </span>
<span class="co"># value of the input</span>
<span class="kw">show_condition</span>(<span class="dv">10</span>)
<span class="co">#&gt; [1] 10</span></code></pre>
<p>You can use <code>tryCatch()</code> to implement <code>try()</code>. A simple implementation is shown below. <code>base::try()</code> is more complicated in order to make the error message look more like what you’d see if <code>tryCatch()</code> wasn’t used. Note the use of <code>conditionMessage()</code> to extract the message associated with the original error.</p>
<pre class="sourceCode r"><code class="sourceCode r">try2 &lt;-<span class="st"> </span>function(code, <span class="dt">silent =</span> <span class="ot">FALSE</span>) {
  <span class="kw">tryCatch</span>(code, <span class="dt">error =</span> function(c) {
    msg &lt;-<span class="st"> </span><span class="kw">conditionMessage</span>(c)
    if (!silent) <span class="kw">message</span>(c)
    <span class="kw">invisible</span>(<span class="kw">structure</span>(msg, <span class="dt">class =</span> <span class="st">&quot;try-error&quot;</span>))
  })
}

<span class="kw">try2</span>(<span class="dv">1</span>)
<span class="co">#&gt; [1] 1</span>
<span class="kw">try2</span>(<span class="kw">stop</span>(<span class="st">&quot;Hi&quot;</span>))
<span class="kw">try2</span>(<span class="kw">stop</span>(<span class="st">&quot;Hi&quot;</span>), <span class="dt">silent =</span> <span class="ot">TRUE</span>)</code></pre>
<p>As well as returning default values when a condition is signalled, handlers can be used to make more informative error messages. For example, by modifying the message stored in the error condition object, the following function wraps <code>read.csv()</code> to add the file name to any errors:</p>
<pre class="sourceCode r"><code class="sourceCode r">read.csv2 &lt;-<span class="st"> </span>function(file, ...) {
  <span class="kw">tryCatch</span>(<span class="kw">read.csv</span>(file, ...), <span class="dt">error =</span> function(c) {
    c$message &lt;-<span class="st"> </span><span class="kw">paste0</span>(c$message, <span class="st">&quot; (in &quot;</span>, file, <span class="st">&quot;)&quot;</span>)
    <span class="kw">stop</span>(c)
  })
}
<span class="kw">read.csv</span>(<span class="st">&quot;code/dummy.csv&quot;</span>)
<span class="co">#&gt; Error in file(file, &quot;rt&quot;): cannot open the connection</span>
<span class="kw">read.csv2</span>(<span class="st">&quot;code/dummy.csv&quot;</span>)
<span class="co">#&gt; Error in file(file, &quot;rt&quot;): cannot open the connection (in code/dummy.csv)</span></code></pre>
<p>Catching interrupts can be useful if you want to take special action when the user tries to abort running code. But be careful, it’s easy to create a loop that you can never escape (unless you kill R)! </p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Don&#39;t let the user interrupt the code</span>
i &lt;-<span class="st"> </span><span class="dv">1</span>
while(i &lt;<span class="st"> </span><span class="dv">3</span>) {
  <span class="kw">tryCatch</span>({
    <span class="kw">Sys.sleep</span>(<span class="fl">0.5</span>)
    <span class="kw">message</span>(<span class="st">&quot;Try to escape&quot;</span>)
  }, <span class="dt">interrupt =</span> function(x) {
    <span class="kw">message</span>(<span class="st">&quot;Try again!&quot;</span>)
    i &lt;&lt;-<span class="st"> </span>i +<span class="st"> </span><span class="dv">1</span>
  })
}</code></pre>
<p><code>tryCatch()</code> has one other argument: <code>finally</code>. It specifies a block of code (not a function) to run regardless of whether the initial expression succeeds or fails. This can be useful for clean up (e.g., deleting files, closing connections). This is functionally equivalent to using <code>on.exit()</code> but it can wrap smaller chunks of code than an entire function. </p>
<h3><code>withCallingHandlers()</code></h3>
<p>An alternative to <code>tryCatch()</code> is <code>withCallingHandlers()</code>. There are two main differences between these functions: </p>
<ul>
<li><p>The return value of <code>tryCatch()</code> handlers is returned by <code>tryCatch()</code>, whereas the return value of <code>withCallingHandlers()</code> handlers is ignored:</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span>function() <span class="kw">stop</span>(<span class="st">&quot;!&quot;</span>)
<span class="kw">tryCatch</span>(<span class="kw">f</span>(), <span class="dt">error =</span> function(e) <span class="dv">1</span>)
<span class="co">#&gt; [1] 1</span>
<span class="kw">withCallingHandlers</span>(<span class="kw">f</span>(), <span class="dt">error =</span> function(e) <span class="dv">1</span>)
<span class="co">#&gt; Error in f(): !</span></code></pre></li>
<li><p>The handlers in <code>withCallingHandlers()</code> are called in the context of the call that generated the condition whereas the handlers in <code>tryCatch()</code> are called in the context of <code>tryCatch()</code>. This is shown here with <code>sys.calls()</code>, which is the run-time equivalent of <code>traceback()</code> — it lists all calls leading to the current function.</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span>function() <span class="kw">g</span>()
g &lt;-<span class="st"> </span>function() <span class="kw">h</span>()
h &lt;-<span class="st"> </span>function() <span class="kw">stop</span>(<span class="st">&quot;!&quot;</span>)

<span class="kw">tryCatch</span>(<span class="kw">f</span>(), <span class="dt">error =</span> function(e) <span class="kw">print</span>(<span class="kw">sys.calls</span>()))
<span class="co"># [[1]] tryCatch(f(), error = function(e) print(sys.calls()))</span>
<span class="co"># [[2]] tryCatchList(expr, classes, parentenv, handlers)</span>
<span class="co"># [[3]] tryCatchOne(expr, names, parentenv, handlers[[1L]])</span>
<span class="co"># [[4]] value[[3L]](cond)</span>

<span class="kw">withCallingHandlers</span>(<span class="kw">f</span>(), <span class="dt">error =</span> function(e) <span class="kw">print</span>(<span class="kw">sys.calls</span>()))
<span class="co"># [[1]] withCallingHandlers(f(), </span>
<span class="co">#    error = function(e) print(sys.calls()))</span>
<span class="co"># [[2]] f()</span>
<span class="co"># [[3]] g()</span>
<span class="co"># [[4]] h()</span>
<span class="co"># [[5]] stop(&quot;!&quot;)</span>
<span class="co"># [[6]] .handleSimpleError(</span>
<span class="co">#    function (e) print(sys.calls()), &quot;!&quot;, quote(h()))</span>
<span class="co"># [[7]] h(simpleError(msg, call))</span></code></pre>
<p>This also affects the order in which <code>on.exit()</code> is called.</p></li>
</ul>
<p>These subtle differences are rarely useful, except when you’re trying to capture exactly what went wrong and pass it on to another function. For most purposes, you should never need to use <code>withCallingHandlers()</code>.</p>
<h3>Custom signal classes</h3>
<p>One of the challenges of error handling in R is that most functions just call <code>stop()</code> with a string. That means if you want to figure out if a particular error occurred, you have to look at the text of the error message. This is error prone, not only because the text of the error might change over time, but also because many error messages are translated, so the message might be completely different to what you expect. </p>
<p>R has a little known and little used feature to solve this problem. Conditions are S3 classes, so you can define your own classes if you want to distinguish different types of error. Each condition signalling function, <code>stop()</code>, <code>warning()</code>, and <code>message()</code>, can be given either a list of strings, or a custom S3 condition object. Custom condition objects are not used very often, but are very useful because they make it possible for the user to respond to different errors in different ways. For example, “expected” errors (like a model failing to converge for some input datasets) can be silently ignored, while unexpected errors (like no disk space available) can be propagated to the user.</p>
<p>R doesn’t come with a built-in constructor function for conditions, but we can easily add one. Conditions must contain <code>message</code> and <code>call</code> components, and may contain other useful components. When creating a new condition, it should always inherit from <code>condition</code> and one of <code>error</code>, <code>warning</code>, or <code>message</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">condition &lt;-<span class="st"> </span>function(subclass, message, <span class="dt">call =</span> <span class="kw">sys.call</span>(-<span class="dv">1</span>), ...) {
  <span class="kw">structure</span>(
    <span class="dt">class =</span> <span class="kw">c</span>(subclass, <span class="st">&quot;condition&quot;</span>),
    <span class="kw">list</span>(<span class="dt">message =</span> message, <span class="dt">call =</span> call),
    ...
  )
}
is.condition &lt;-<span class="st"> </span>function(x) <span class="kw">inherits</span>(x, <span class="st">&quot;condition&quot;</span>)</code></pre>
<p>You can signal an arbitrary condition with <code>signalCondition()</code>, but nothing will happen unless you’ve instantiated a custom signal handler (with <code>tryCatch()</code> or <code>withCallingHandlers()</code>). Instead, use <code>stop()</code>, <code>warning()</code>, or <code>message()</code> as appropriate to trigger the usual handling. R won’t complain if the class of your condition doesn’t match the function, but you should avoid this in real code. </p>
<pre class="sourceCode r"><code class="sourceCode r">c &lt;-<span class="st"> </span><span class="kw">condition</span>(<span class="kw">c</span>(<span class="st">&quot;my_error&quot;</span>, <span class="st">&quot;error&quot;</span>), <span class="st">&quot;This is an error&quot;</span>)
<span class="kw">signalCondition</span>(c)
<span class="co"># NULL</span>
<span class="kw">stop</span>(c)
<span class="co"># Error: This is an error</span>
<span class="kw">warning</span>(c)
<span class="co"># Warning message: This is an error</span>
<span class="kw">message</span>(c)
<span class="co"># This is an error</span></code></pre>
<p>You can then use <code>tryCatch()</code> to take different actions for different types of errors. In this example we make a convenient <code>custom_stop()</code> function that allows us to signal error conditions with arbitrary classes. In a real application, it would be better to have individual S3 constructor functions that you could document, describing the error classes in more detail.</p>
<pre class="sourceCode r"><code class="sourceCode r">custom_stop &lt;-<span class="st"> </span>function(subclass, message, <span class="dt">call =</span> <span class="kw">sys.call</span>(-<span class="dv">1</span>), 
                        ...) {
  c &lt;-<span class="st"> </span><span class="kw">condition</span>(<span class="kw">c</span>(subclass, <span class="st">&quot;error&quot;</span>), message, <span class="dt">call =</span> call, ...)
  <span class="kw">stop</span>(c)
}

my_log &lt;-<span class="st"> </span>function(x) {
  if (!<span class="kw">is.numeric</span>(x))
    <span class="kw">custom_stop</span>(<span class="st">&quot;invalid_class&quot;</span>, <span class="st">&quot;my_log() needs numeric input&quot;</span>)
  if (<span class="kw">any</span>(x &lt;<span class="st"> </span><span class="dv">0</span>))
    <span class="kw">custom_stop</span>(<span class="st">&quot;invalid_value&quot;</span>, <span class="st">&quot;my_log() needs positive inputs&quot;</span>)

  <span class="kw">log</span>(x)
}
<span class="kw">tryCatch</span>(
  <span class="kw">my_log</span>(<span class="st">&quot;a&quot;</span>),
  <span class="dt">invalid_class =</span> function(c) <span class="st">&quot;class&quot;</span>,
  <span class="dt">invalid_value =</span> function(c) <span class="st">&quot;value&quot;</span>
)
<span class="co">#&gt; [1] &quot;class&quot;</span></code></pre>
<p>Note that when using <code>tryCatch()</code> with multiple handlers and custom classes, the first handler to match any class in the signal’s class hierarchy is called, not the best match. For this reason, you need to make sure to put the most specific handlers first:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tryCatch</span>(<span class="kw">customStop</span>(<span class="st">&quot;my_error&quot;</span>, <span class="st">&quot;!&quot;</span>),
  <span class="dt">error =</span> function(c) <span class="st">&quot;error&quot;</span>,
  <span class="dt">my_error =</span> function(c) <span class="st">&quot;my_error&quot;</span>
)
<span class="co">#&gt; [1] &quot;error&quot;</span>
<span class="kw">tryCatch</span>(<span class="kw">custom_stop</span>(<span class="st">&quot;my_error&quot;</span>, <span class="st">&quot;!&quot;</span>),
  <span class="dt">my_error =</span> function(c) <span class="st">&quot;my_error&quot;</span>,
  <span class="dt">error =</span> function(c) <span class="st">&quot;error&quot;</span>
)
<span class="co">#&gt; [1] &quot;my_error&quot;</span></code></pre>
<h3>Exercises</h3>
<ul>
<li><p>Compare the following two implementations of <code>message2error()</code>. What is the main advantage of <code>withCallingHandlers()</code> in this scenario? (Hint: look carefully at the traceback.)</p>
<pre class="sourceCode r"><code class="sourceCode r">message2error &lt;-<span class="st"> </span>function(code) {
  <span class="kw">withCallingHandlers</span>(code, <span class="dt">message =</span> function(e) <span class="kw">stop</span>(e))
}
message2error &lt;-<span class="st"> </span>function(code) {
  <span class="kw">tryCatch</span>(code, <span class="dt">message =</span> function(e) <span class="kw">stop</span>(e))
}</code></pre></li>
</ul>
<h2 id="defensive-programming">Defensive programming</h2>
<p>Defensive programming is the art of making code fail in a well-defined manner even when something unexpected occurs. A key principle of defensive programming is to “fail fast”: as soon as something wrong is discovered, signal an error. This is more work for the author of the function (you!), but it makes debugging easier for users because they get errors earlier rather than later, after unexpected input has passed through several functions.  </p>
<p>In R, the “fail fast” principle is implemented in three ways:</p>
<ul>
<li><p>Be strict about what you accept. For example, if your function is not vectorised in its inputs, but uses functions that are, make sure to check that the inputs are scalars. You can use <code>stopifnot()</code>, the <a href="https://github.com/hadley/assertthat">assertthat</a> package, or simple <code>if</code> statements and <code>stop()</code>.</p></li>
<li><p>Avoid functions that use non-standard evaluation, like <code>subset</code>, <code>transform</code>, and <code>with</code>. These functions save time when used interactively, but because they make assumptions to reduce typing, when they fail, they often fail with uninformative error messages. You can learn more about non-standard evaluation in <a href="Computing-on-the-language.html#nse">non-standard evaluation</a>.</p></li>
<li><p>Avoid functions that return different types of output depending on their input. The two biggest offenders are <code>[</code> and <code>sapply()</code>. Whenever subsetting a data frame in a function, you should always use <code>drop = FALSE</code>, otherwise you will accidentally convert 1-column data frames into vectors. Similarly, never use <code>sapply()</code> inside a function: always use the stricter <code>vapply()</code> which will throw an error if the inputs are incorrect types and return the correct type of output even for zero-length inputs.</p></li>
</ul>
<p>There is a tension between interactive analysis and programming. When you’re working interactively, you want R to do what you mean. If it guesses wrong, you want to discover that right away so you can fix it. When you’re programming, you want functions that signal errors if anything is even slightly wrong or underspecified. Keep this tension in mind when writing functions. If you’re writing functions to facilitate interactive data analysis, feel free to guess what the analyst wants and recover from minor misspecifications automatically. If you’re writing functions for programming, be strict. Never try to guess what the caller wants.</p>
<h3>Exercises</h3>
<ul>
<li><p>The goal of the <code>col_means()</code> function defined below is to compute the means of all numeric columns in a data frame.</p>
<pre class="sourceCode r"><code class="sourceCode r">col_means &lt;-<span class="st"> </span>function(df) {
  numeric &lt;-<span class="st"> </span><span class="kw">sapply</span>(df, is.numeric)
  numeric_cols &lt;-<span class="st"> </span>df[, numeric]

  <span class="kw">data.frame</span>(<span class="kw">lapply</span>(numeric_cols, mean))
}</code></pre>
<p>However, the function is not robust to unusual inputs. Look at the following results, decide which ones are incorrect, and modify <code>col_means()</code> to be more robust. (Hint: there are two function calls in <code>col_means()</code> that are particularly prone to problems.)</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">col_means</span>(mtcars)
<span class="kw">col_means</span>(mtcars[, <span class="dv">0</span>])
<span class="kw">col_means</span>(mtcars[<span class="dv">0</span>, ])
<span class="kw">col_means</span>(mtcars[, <span class="st">&quot;mpg&quot;</span>, <span class="dt">drop =</span> F])
<span class="kw">col_means</span>(<span class="dv">1</span>:<span class="dv">10</span>)
<span class="kw">col_means</span>(<span class="kw">as.matrix</span>(mtcars))
<span class="kw">col_means</span>(<span class="kw">as.list</span>(mtcars))

mtcars2 &lt;-<span class="st"> </span>mtcars
mtcars2[-<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">lapply</span>(mtcars2[-<span class="dv">1</span>], as.character)
<span class="kw">col_means</span>(mtcars2)</code></pre></li>
<li><p>The following function “lags” a vector, returning a version of <code>x</code> that is <code>n</code> values behind the original. Improve the function so that it (1) returns a useful error message if <code>n</code> is not a vector, and (2) has reasonable behaviour when <code>n</code> is 0 or longer than <code>x</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">lag &lt;-<span class="st"> </span>function(x, <span class="dt">n =</span> 1L) {
  xlen &lt;-<span class="st"> </span><span class="kw">length</span>(x)
  <span class="kw">c</span>(<span class="kw">rep</span>(<span class="ot">NA</span>, n), x[<span class="kw">seq_len</span>(xlen -<span class="st"> </span>n)])
}</code></pre></li>
</ul>
<h2 id="debugging-answers">Quiz answers</h2>
<ol style="list-style-type: decimal">
<li><p>The most useful tool to determine where a error occured is <code>traceback()</code>. Or use Rstudio, which displays it automatically where an error occurs.</p></li>
<li><p><code>browser()</code> pauses execution at the specified line and allows you to enter an interactive environment. In that environment, there are five useful commands: <code>n</code>, execute the next command; <code>s</code>, step into the next function; <code>f</code>, finish the current loop or function; <code>c</code>, continue execution normally; <code>Q</code>, stop the function and return to the console.</p></li>
<li><p>You could use <code>try()</code> or <code>tryCatch()</code>.</p></li>
<li><p>Because you can then capture specific types of error with <code>tryCatch()</code>, rather than relying on the comparison of error strings, which is risky, especially when messages are translated.</p></li>
</ol>

        </div>
      </div>

    </div> <!-- /container -->

  <script src="//code.jquery.com/jquery.js"></script>
  <script src="www/bootstrap.min.js"></script>
  <script src="www/toc.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-67989-16', 'had.co.nz');
    ga('send', 'pageview');

  </script>
  </body>
</html>
