<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">

<style>

a:hover,a:active{color:red}
table.w3-table-all{margin:20px 0}
.top {
 position:relative;
 background-color:black;
 height:68px;
 padding-top:20px;
 line-height:50px;
 overflow:hidden;
 z-index:2;
}
body {
 background-color: #000000;
 color: MediumSeaGreen;
 margin-left: 14%;
 margin-right: 14%;
 font-size: 24px;
}
a { text-decoration: none;
	color: #58D858;}
a:visited { color: #88C898;}
A:hover {	color: yellow;}
A:focus {	color: red;}
code { color: gray; background-color: #001010; font-size: 18px;}
pre { color: gray; background-color: #001010; font-size: 18px;}
h1, h2, h3, h4, h5, .goldword {
	color: gold;
}
table{
	width: 100%;
	font-size: 20px;
	border-collapse: collapse;
	border: 1px solid gray;
}
th{
	border: 1px solid gray;
	font-weight:bold;
	color: lightgreen;
}
td{
	padding:10px;
	border: 1px dotted dimgray;
}
tr>th:first-child{
	width:40%;
}
tr>td:first-child{
	color: lime;

}
img{
	margin-top:1%;
	margin-bottom:2%;
	width: 800px;
}
.topic{
    color: lime;
}
.goldsha {
    color: white;
    border: 1px solid gold;
    padding: 2px;
    border-radius: 3px;
	box-shadow: -2px -2px 3px gold inset;
}
.redsha {
    color: gold;
    border: 1px solid red;
    padding: 2px;
    border-radius: 3px;
	box-shadow: -2px -2px 3px red inset;
}
.whitesha {
    color: red;
    border: 1px solid white;
    padding: 2px;
    border-radius: 3px;
	box-shadow: -3px -2px 3px white inset;
}
.orangesha {
    color: yellow;
    border: 1px solid orange;
    padding: 2px;
    border-radius: 3px;
	box-shadow: -2px -2px 3px orange inset;
}
.yellowsha {
    color: lime;
    border: 1px solid yellow;
    padding: 2px;
    border-radius: 3px;
	box-shadow: 3px 3px 3px silver;
	display: inline-block;
}
.greensha {
    color: lightblue;
    border: 1px solid green;
    padding: 2px;
    border-radius: 3px;
	box-shadow: -2px -2px 3px green inset;
}
.left {
    position: absolute;
    left: 100px;
    color: GoldenRod;
    border: 1px solid GoldenRod;
    padding: 2px;
    font-size: 60%;
}
.bord {
    color: redpink;
    border: 1px solid GoldenRod;
    padding: 1px;
    font-size: 90%;
}
.yellowbord {
    color: lime;
    border: 1px solid yellow;
    padding: 2px;
    border-radius: 3px;
	box-shadow: 3px 3px 3px silver;
}
.bluebord {
    color: white;
    border: 1px solid lightblue;
    padding: 2px;
    border-radius: 3px;
	box-shadow: -2px -2px 3px silver inset;
}
.highlight { 
    color: white;
    background-color: #002030
  }
hr {width: 50%;}
li{
	list-style-type: decimal;
}
#toc, #tang, #san, #pill {
	margin-left: 15%;
	margin-right: 15%;
	color: gold;
	padding: 1%;
	text-align: left;
	box-shadow: 5px 5px 15px silver;
	border-radius: 5px;
	border: 1px solid DarkSlateGray;
    font-size: 90%;
}
.mywords{
    color: Crimson;
}
.orangeword{
    color: orange;
}
.remarks {
	font-size: 22px;
	color: MediumSeaGreen;
}
</STYLE>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script>
$(document).ready(function(){
    $('h1, h2, h3, h4, h5, .goldword, .topic').click(function(){
    parent.history.back();
    return false;
    });
});
</script>


</head><body>

<center><h2>webscraping with Selenium - part 1</h2></center>
<div id="toc"><ul></ul></div>
<br>
<br>
<br>


  <p>If you are webscraping with Python chances are that you have already tried <code class="highlighter-rouge">urllib</code>, <code class="highlighter-rouge">httplib</code>, <code class="highlighter-rouge">requests</code>, etc. These are excellent libraries, but some websites don’t like to be webscraped. In these cases you may need to disguise your webscraping bot as a human being. Selenium is just the tool for that. Selenium is a webdriver: it takes control of your browser, which then does all the work. Hence what the website “sees” is Chrome or Firefox or IE; it does not see Python or Selenium. That makes it a lot harder for the website to tell your bot from a human being.</p>

<p>In this tutorial I will show you how to webscrape with Selenium. This first post covers the basics: locating HTML elements and interacting with them. Later posts will cover things like downloading, error handling, dynamic names, and mass webscraping.</p>

<p>There are Selenium bindings for Python, Java, C#, Ruby, and Javascript. All the examples in this tutorial will be in Python, but translating them to those other languages is trivial.</p>

<p><h3>installing Selenium</h3></p>

<p>To install the Selenium bindings for Python, simply use PIP:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">pip install selenium</code></pre></figure>

<p>You also need a “driver”, which is a small program that allows Selenium to, well, “drive” your browser. This driver is browser-specific, so first we need to choose which browser we want to use. For now we will use Chrome (later we will switch to PhantomJS). Download the latest version of the <a href="http://chromedriver.storage.googleapis.com/index.html">chromedriver</a>, unzip it, and note where you saved the unzipped file.</p>

<p><h3>choosing our target</h3></p>

<p>In this tutorial we will webscrape <a href="https://www.lexisnexis.com/hottopics/lnacademic/?verb=sf&amp;sfi=AC00NBGenSrch">LexisNexis Academic</a>. It’s a gated database but you are probably in academia (just a guess) so you should have access to it through your university.</p>

<p>(Obs.: LexisNexis Academic is set to have a new interface starting December 23rd, so if you are in the future the code below may not work. It will still help you understand Selenium though. And adapting it to the new LexisNexis interface will be a nice learning exercise.)</p>

<p><h3>opening a webpage</h3></p>

<p>Now on to coding. First we start the webdriver:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">selenium</span> <span class="kn">import</span> <span class="n">webdriver</span>

<span class="n">path_to_chromedriver</span> <span class="o">=</span> <span class="s">'/Users/yourname/Desktop/chromedriver'</span> <span class="c"># change path as needed</span>
<span class="n">browser</span> <span class="o">=</span> <span class="n">webdriver</span><span class="o">.</span><span class="n">Chrome</span><span class="p">(</span><span class="n">executable_path</span> <span class="o">=</span> <span class="n">path_to_chromedriver</span><span class="p">)</span></code></pre></figure>

<p>When you run this code you’ll see a new instance of Chrome magically launch.</p>

<p>Now let’s open the page we want:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">url</span> <span class="o">=</span> <span class="s">'https://www.lexisnexis.com/hottopics/lnacademic/?verb=sf&amp;amp;sfi=AC00NBGenSrch'</span>
<span class="n">browser</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span></code></pre></figure>

<p>The page looks like this:</p>

<p><a href="http://imgur.com/fWbtCGO"><img src="http://i.imgur.com/fWbtCGO.jpg" alt="" /></a></p>

<p><h3>locating page elements</h3></p>

<p>Before we fill out forms and click buttons we need to locate these elements. This step is going to be easier if you know some HTML but that is not a pre-requisite (you will end up learning some HTML on-the-fly as you do more and more webscraping).</p>

<p>A page element usually has a few attributes - a name, an id, a CSS selector, an xpath, etc. (Don’t worry if you’ve never heard of these things before.) We can use these attributes to help us locate the element we want.</p>

<p>How can we find what these attributes are for a given element? Simple: just right-click it and choose “Inspect Element”. Your browser will then show you the corresponding HTML code. For instance, if you do this with the “Search Terms” form on the page we opened above you’ll see something like this:</p>

<p><a href="http://imgur.com/rmDpfyL"><img src="http://i.imgur.com/rmDpfyL.jpg" alt="" /></a></p>

<p>The HTML code of the element you selected appears highlighted in blue. Let me copy and paste it below, so you can have a better look at it:</p>

<figure class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;textarea</span> <span class="na">id=</span><span class="s">"terms"</span> <span class="na">style=</span><span class="s">"vertical-align: top;"</span> <span class="na">name=</span><span class="s">"terms"</span><span class="nt">&gt;&lt;/textarea&gt;</span></code></pre></figure>

<p>Ha! Now we know two attributes of the “Search Terms” form: its name is “terms” and its id is (also) “terms”.</p>

<p>We are not ready to locate the element though. HTML pages usually contain multiple “frames” and our element is probably inside one of these frames. We need to know which one. To find out, start on that blue-highlighted line we saw before and keep scrolling up until you find <code class="highlighter-rouge">&lt;frame</code>. You’ll eventually find this line:</p>

<figure class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;frame</span> <span class="na">src=</span><span class="s">""</span> <span class="na">name=</span><span class="s">"mainFrame"</span> <span class="na">id=</span><span class="s">"mainFrame"</span> <span class="na">title=</span><span class="s">"mainFrame"</span><span class="nt">&gt;</span></code></pre></figure>

<p>That means our “Search Terms” form is inside a frame named “mainFrame”. Now keep scrolling up to see if “mainFrame” is inside some other frame. Here it is not, but that is always a possibility and you need to check.</p>

<p>The next thing we do is go to that frame. Here is how we do it:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">browser</span><span class="o">.</span><span class="n">switch_to_frame</span><span class="p">(</span><span class="s">'mainFrame'</span><span class="p">)</span></code></pre></figure>

<p>Once we are on the correct frame we can finally search for the element. Let’s search it using its id:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_id</span><span class="p">(</span><span class="s">'terms'</span><span class="p">)</span></code></pre></figure>

<p>And that’s it. We have located the element.</p>

<p><h3>see the beauty?</h3></p>

<p>As the code above shows, Selenium is very intuitive. To switch frames we use <code class="highlighter-rouge">switch_to_frame</code>. To find an element by its id we use <code class="highlighter-rouge">find_element_by_id</code>. And so on.</p>

<p>Another great feature of Selenium is that it’s very similar across all languages it supports. In Java, for instance, this is how we switch frames and find elements by id:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">browser</span><span class="o">.</span><span class="na">switchTo</span><span class="o">().</span><span class="na">frame</span><span class="o">(</span><span class="s">"frameName"</span><span class="o">);</span>
<span class="n">browser</span><span class="o">.</span><span class="na">findElement</span><span class="o">(</span><span class="n">By</span><span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="s">"elementId"</span><span class="o">));</span></code></pre></figure>

<p>So even if you first learn Selenium in Python it’s very easy to use it in other languages later.</p>

<p><h3>interacting with page elements</h3></p>

<p>Now that we’ve found the “Search Terms” form we can interact with it. First we want to make sure that the form is empty:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_id</span><span class="p">(</span><span class="s">'terms'</span><span class="p">)</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></code></pre></figure>

<p>Now we can write on the form. Here we are interested in all occurrences of the word “balloon” in the news today. We start by writing “balloon” on the form:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_id</span><span class="p">(</span><span class="s">'terms'</span><span class="p">)</span><span class="o">.</span><span class="n">send_keys</span><span class="p">(</span><span class="s">'balloon'</span><span class="p">)</span></code></pre></figure>

<p>Next we need to specify the date. There is a “Specify Date” drop-down menu. Let us locate it. As usual we start by right-clicking the element and selecting “Inspect Element”. That gives us the following HTML code:</p>

<figure class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;select</span> <span class="na">class=</span><span class="s">"input"</span> <span class="na">id=</span><span class="s">"dateSelector1"</span> <span class="na">style=</span><span class="s">"vertical-align: top;"</span> <span class="na">name=</span><span class="s">"dateSelector1"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;option</span> <span class="na">value=</span><span class="s">""</span><span class="nt">&gt;</span>All available dates<span class="nt">&lt;/option&gt;</span>
  <span class="nt">&lt;option</span> <span class="na">value=</span><span class="s">"0:DY"</span><span class="nt">&gt;</span>Today<span class="nt">&lt;/option&gt;</span>
  <span class="nt">&lt;option</span> <span class="na">value=</span><span class="s">"is"</span><span class="nt">&gt;</span>Date is…<span class="nt">&lt;/option&gt;</span>
  <span class="nt">&lt;option</span> <span class="na">value=</span><span class="s">"before"</span><span class="nt">&gt;</span>Date is before…<span class="nt">&lt;/option&gt;</span>
  <span class="nt">&lt;option</span> <span class="na">value=</span><span class="s">"after"</span><span class="nt">&gt;</span>Date is after…<span class="nt">&lt;/option&gt;</span>
  <span class="nt">&lt;option</span> <span class="na">value=</span><span class="s">"from"</span><span class="nt">&gt;</span>Date is between…<span class="nt">&lt;/option&gt;</span>
  <span class="nt">&lt;option</span> <span class="na">value=</span><span class="s">"1:WK"</span><span class="nt">&gt;</span>Previous week<span class="nt">&lt;/option&gt;</span>
  <span class="nt">&lt;option</span> <span class="na">value=</span><span class="s">"1:MO"</span><span class="nt">&gt;</span>Previous month<span class="nt">&lt;/option&gt;</span>
  <span class="nt">&lt;option</span> <span class="na">value=</span><span class="s">"3:MO"</span><span class="nt">&gt;</span>Previous 3 months<span class="nt">&lt;/option&gt;</span>
  <span class="nt">&lt;option</span> <span class="na">value=</span><span class="s">"6:MO"</span><span class="nt">&gt;</span>Previous 6 months<span class="nt">&lt;/option&gt;</span>
  <span class="nt">&lt;option</span> <span class="na">value=</span><span class="s">"1:YR"</span><span class="nt">&gt;</span>Previous year<span class="nt">&lt;/option&gt;</span>
  <span class="nt">&lt;option</span> <span class="na">value=</span><span class="s">"2:YR"</span><span class="nt">&gt;</span>Previous 2 years<span class="nt">&lt;/option&gt;</span>
  <span class="nt">&lt;option</span> <span class="na">value=</span><span class="s">"5:YR"</span><span class="nt">&gt;</span>Previous 5 years<span class="nt">&lt;/option&gt;</span>
  <span class="nt">&lt;option</span> <span class="na">value=</span><span class="s">"previous"</span><span class="nt">&gt;</span>Previous…<span class="nt">&lt;/option&gt;&lt;/select&gt;</span></code></pre></figure>

<p>We can see the element’s name and id but here we will use neither. This is a drop-down menu and we will need to select one of its options (“All available dates”, “Today”, etc), so here we will use the element’s xpath. How do you get it? We are using Chrome here, so this is really simple: we just right-click the blue-highlighted line that corresponds to the element’s HTML code and select “Copy XPath”. Like this:</p>

<p><a href="http://imgur.com/cUIAYCI"><img src="http://i.imgur.com/cUIAYCI.jpg" alt="" /></a></p>

<p>That gives us the following xpath:</p>

<figure class="highlight"><pre><code class="language-html" data-lang="html">//*[@id="dateSelector1"]</code></pre></figure>

<p>Now, as usual, scroll up from the blue-highlighted line until you find out which frame contains the element. Here that is the same frame of “Search Terms” (i.e., “mainFrame”), so we are already there, no need to move.</p>

<p>If all we wanted were to locate the element, we would do this:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_xpath</span><span class="p">(</span><span class="s">'//*[@id="dateSelector1"]'</span><span class="p">)</span></code></pre></figure>

<p>But we want to open that drop-down menu and select “Today”. So we do this instead:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_xpath</span><span class="p">(</span><span class="s">'//*[@id="dateSelector1"]/option[contains(text(), "Today")]'</span><span class="p">)</span><span class="o">.</span><span class="n">click</span><span class="p">()</span></code></pre></figure>

<p>Now we’ve entered our search term (balloon) and selected our date (today). Next we need to select our news sources. That’s another drop-down menu, a bit further down the page. You know the drill: right-click the element, retrieve relevant attributes, scroll up to find out the frame. There isn’t anything new to learn here (and we haven’t left “mainFrame” yet), so I’ll just give you the code (let’s say we want to select all news sources in English):</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_xpath</span><span class="p">(</span><span class="s">'//*[@id="byType"]/option[text()="All News (English)"]'</span><span class="p">)</span><span class="o">.</span><span class="n">click</span><span class="p">()</span></code></pre></figure>

<p>Finally, we need to click the “Search” button (next to the “Search Terms” form) to submit the search. Same drill: right-click element, get attributes, scroll up to find frame. Except that here there is no id or name:</p>

<figure class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"submit"</span> <span class="na">value=</span><span class="s">"Search"</span> <span class="nt">/&gt;</span></code></pre></figure>

<p>So we need to use xpath again, even though this is not a drop-down menu:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_xpath</span><span class="p">(</span><span class="s">'//*[@id="searchForm"]/fieldset/ol/li[2]/span/span/input'</span><span class="p">)</span><span class="o">.</span><span class="n">click</span><span class="p">()</span></code></pre></figure>

<p>Now that is one ugly-looking xpath. Our code will look better if we use the element’s CSS selector instead:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_css_selector</span><span class="p">(</span><span class="s">'input[type=</span><span class="se">\"</span><span class="s">submit</span><span class="se">\"</span><span class="s">]'</span><span class="p">)</span><span class="o">.</span><span class="n">click</span><span class="p">()</span></code></pre></figure>

<p>I don’t know of any “copy-and-paste” way to get an element’s CSS selector, but if you stare at the line above long enough you can see how it derives from the element’s HTML code.</p>

<p>That’s it. You should now see Chrome leaving the search page and opening the results page.</p>

<p>There is a lot more to cover, but that will have to wait.</p>

<h2>webscraping with Selenium - part 2</h2>
  <span class="post-date">14 Nov 2013</span>
  <p>In <a href="http://thiagomarzagao.com/2013/11/12/webscraping-with-selenium-part-1/">part 1</a> we learned how to locate page elements and how to interact with them. Here we will learn how to do deal with dynamic names and how to download things with Selenium.</p>

<p><h3>handling dynamic names</h3></p>

<p>In part 1 we submitted a search on LexisNexis Academic. We will now retrieve the search results.</p>

<p>The results page of LexisNexis Academic looks like this:</p>

<p><a href="http://imgur.com/Yi8Rmqn"><img src="http://i.imgur.com/Yi8Rmqn.jpg" alt="" /></a></p>

<p>Our first task is to switch to the default frame of the page.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">browser</span><span class="o">.</span><span class="n">switch_to_default_content</span><span class="p">()</span></code></pre></figure>

<p>Now we need to click the “Download Documents” button (it’s the one that looks like a floppy disk; it’s right above the search results). We already know how to do that with Selenium: right-click the element, inspect its HTML code, scroll up to see what frame contains it, use all this information to locate the element and interact with it. We’ve learned all that in part 1. By following that recipe we find that the “Download Documents” button is inside the frame named “fr_resultsNav~ResultsMaxGroupTemplate0.6175091262270153″, which in turn is inside the frame named “mainFrame”. So our first instinct is to do this:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">browser</span><span class="o">.</span><span class="n">switch_to_frame</span><span class="p">(</span><span class="s">'mainFrame'</span><span class="p">)</span>
<span class="n">browser</span><span class="o">.</span><span class="n">switch_to_frame</span><span class="p">(</span><span class="s">'fr_resultsNav~ResultsMaxGroupTemplate0.6175091262270153'</span><span class="p">)</span>
<span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_css_selector</span><span class="p">(</span><span class="s">'img[alt=</span><span class="se">\"</span><span class="s">Download Documents</span><span class="se">\"</span><span class="s">]'</span><span class="p">)</span><span class="o">.</span><span class="n">click</span><span class="p">()</span></code></pre></figure>

<p>Except it won’t work here.</p>

<p>Here is the problem: that <code class="highlighter-rouge">fr_resultsNav~ResultsMaxGroupTemplate0.6175091262270153</code> frame has a different name every time you do a new search. So your code will miss it and crash (which is precisely what LexisNexis wants to happen, since they don’t care for webscrapers).</p>

<p>What are we to do then? Here the solution is simple. That frame name always changes, but only partially: it always begins with <code class="highlighter-rouge">fr_resultsNav</code>. So we can look for the frame that contains <code class="highlighter-rouge">fr_resultsNav</code> in its name.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">browser</span><span class="o">.</span><span class="n">switch_to_frame</span><span class="p">(</span><span class="s">'mainFrame'</span><span class="p">)</span>
<span class="n">dyn_frame</span> <span class="o">=</span> <span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_xpath</span><span class="p">(</span><span class="s">'//frame[contains(@name, "fr_resultsNav")]'</span><span class="p">)</span></code></pre></figure>

<p>Our dyn_frame object contains the full frame name as an attribute, which we can then extract and store.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">framename</span> <span class="o">=</span> <span class="n">dyn_frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s">'name'</span><span class="p">)</span></code></pre></figure>

<p>Now we can finally move to that frame and click the “Download Documents” button.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">browser</span><span class="o">.</span><span class="n">switch_to_frame</span><span class="p">(</span><span class="n">framename</span><span class="p">)</span>
<span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_css_selector</span><span class="p">(</span><span class="s">'img[alt=</span><span class="se">\"</span><span class="s">Download Documents</span><span class="se">\"</span><span class="s">]'</span><span class="p">)</span><span class="o">.</span><span class="n">click</span><span class="p">()</span></code></pre></figure>

<p>Great! We have solved the dynamic name problem.</p>

<p>Notice the sequence here: first we move to “mainFrame” and <em>then</em> we move to <code class="highlighter-rouge">fr_resultsNav~ResultsMaxGroupTemplate…</code>. The sequence is important: we need to move to the parent frame before we can move to the child frame. If we try to move to <code class="highlighter-rouge">fr_resultsNav~ResultsMaxGroupTemplate…</code> directly that won’t work.</p>

<p>Now, what if the entire name changed? What would we do then?</p>

<p>In that case we could use the position of the frame. If you inspect the HTML code of the page you will see that inside “mainFrame” we have eight different frames and that <code class="highlighter-rouge">fr_resultsNav~ResultsMaxGroupTemplate…</code> is the 6th. As long as that position remains constant we can do this:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">browser</span><span class="o">.</span><span class="n">switch_to_frame</span><span class="p">(</span><span class="s">'mainFrame.5.child'</span><span class="p">)</span>
<span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_css_selector</span><span class="p">(</span><span class="s">'img[alt=</span><span class="se">\"</span><span class="s">Download Documents</span><span class="se">\"</span><span class="s">]'</span><span class="p">)</span><span class="o">.</span><span class="n">click</span><span class="p">()</span></code></pre></figure>

<p>In other words, we can switch to a frame based on its position. Here we are selecting the 6th child frame of “mainFrame” - whatever its name is. (As it is usually the case in Python the indexing starts from zero, so the index of the 6th item is 5, not 6).</p>

<p><h3>switching windows</h3></p>

<p>Once we click the “Download Documents” button LexisNexis will launch a pop-up window.</p>

<p><a href="http://imgur.com/zO3f2Gx"><img src="http://i.imgur.com/zO3f2Gx.jpg" alt="" /></a></p>

<p>We need to navigate to that window. To do that we will need the <code class="highlighter-rouge">browser.window_handles</code> object, which (as its name suggests) contains the handles of all the open windows. The pop-up window we want is the second window we opened in the browser, so its index is 1 in the <code class="highlighter-rouge">browser.window_handles</code> object (remember,  Python indexes from zero). Switching windows, in turn, is similar to switching frames: <code class="highlighter-rouge">browser.switch_to_window()</code>. Putting it all together:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">browser</span><span class="o">.</span><span class="n">switch_to_window</span><span class="p">(</span><span class="n">browser</span><span class="o">.</span><span class="n">window_handles</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></code></pre></figure>

<p>That pop-up window contains a bunch of forms and buttons, but all we want to do here is choose the format in which we want our results to be. Let’s say we want them to be in a plain text file.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_xpath</span><span class="p">(</span><span class="s">'//select[@id="delFmt"]/option[text()="Text"]'</span><span class="p">)</span><span class="o">.</span><span class="n">click</span><span class="p">()</span></code></pre></figure>

<p>Finally we click the “Download” button.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_css_selector</span><span class="p">(</span><span class="s">'img[alt=</span><span class="se">\"</span><span class="s">Download</span><span class="se">\"</span><span class="s">]'</span><span class="p">)</span><span class="o">.</span><span class="n">click</span><span class="p">()</span></code></pre></figure>

<p>So far so good.</p>

<p><h3>downloading with Selenium</h3></p>

<p>Once we click the “Download” button LexisNexis shoves all the search results into a file and gives us a link to it.</p>

<p><a href="http://imgur.com/RoUt7Nh"><img src="http://i.imgur.com/RoUt7Nh.jpg" alt="" /></a></p>

<p>Now we are in a bit of a pickle. Let me explain why.</p>

<p>When you click that link (whether manually or programmatically) your browser opens a dialog box asking you where you want to save that file. That is a problem here because Selenium can make your browser interact with webpages but cannot make your browser interact with itself. In other words, Selenium cannot make your browser change its bookmarks, switch to incognito mode, or (what matters here) interact with dialog boxes.</p>

<p>I know, this sounds preposterous, but here is a bit of context: Selenium was conceived as a testing tool, not as a webscraping tool. Selenium’s primary purpose is to help web developers automate tests on the sites they develop. Now, web developers can only control what the website does; they cannot control how your computer reacts when you click a download link. So to web developers it doesn’t matter that Selenium can’t interact with dialog boxes.</p>

<p>In other words, Selenium wasn’t created for us. It’s a great webscraping tool - the best one I’ve found so far. I can’t imagine how you would even submit a search on LexisNexis using <code class="highlighter-rouge">urllib</code> or <code class="highlighter-rouge">httplib</code>, let alone retrieve the search results. But, yes, we are not Selenium’s target audience. But just hang in there and everything will be allright.</p>

<p>Ok, enough context - how can we solve the problem? There are a number of solutions (some better than the others) and I will talk about each of them in turn.</p>

<p><em>Solution #1: combine LexisNexis with some OS command</em></p>

<p>If you are on a Linux system you can simply use <code class="highlighter-rouge">wget</code> to get the file. <code class="highlighter-rouge">wget</code> is not a Python module, it is a Linux command for getting files from the web. For instance, to download R’s source code you open the terminal and do</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">wget http://cran.stat.ucla.edu/src/base/R-3/R-3.0.2.tar.gz</code></pre></figure>

<p>The trick here is to find the URL behind the link LexisNexis generates. That link is dynamically generated, so it changes every time we do a new search. It looks like this:</p>

<figure class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"/lnacui2api/delivery/DownloadDoc.do?fileSize=5000&amp;amp;dnldFilePath=%2Fl-n%2Fshared%2Fprod%2Fdiscus%2Fqds%2Frepository%2Fdocs%2F6%2F43%2F2827%3A436730436%2Fformatted_doc&amp;amp;zipDelivery=false&amp;amp;dnldFileName=All_English_Language_News2013-11-12_22-26.TXT&amp;amp;jobHandle=2827%3A436730436"</span><span class="nt">&gt;</span>All_English_Language_News2013-11-12_22-26.TXT<span class="nt">&lt;/a&gt;</span></code></pre></figure>

<p>If you stare at this HTML code long enough you will see some structure in it. Yes, it changes every time we do a new search, but some parts of it change in a predictable way. The news source (<code class="highlighter-rouge">All_English_Language_News</code>) is always there. So are the date (“2013-11-12”) and the hour (“22-26”) of the request. And so is the file extension (“.TXT”). We can use this structure to retrieve the URL. For instance, we can use the “.TXT” extension to do that, like this:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">results_url</span> <span class="o">=</span> <span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_partial_link_text</span><span class="p">(</span><span class="s">'.TXT'</span><span class="p">)</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s">'href'</span><span class="p">)</span></code></pre></figure>

<p>Now we have our URL. On to <code class="highlighter-rouge">wget</code> then. This is an OS command, so first we need to import Python’s os module.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">os</span> <span class="c"># this line should go in the beginning of your script, for good style</span></code></pre></figure>

<p>Now we execute <code class="highlighter-rouge">wget</code>.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">'wget {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">results_url</span><span class="p">))</span></code></pre></figure>

<p>And voilà, the file is downloaded to your computer.</p>

<p>If you are on a Mac you can use <code class="highlighter-rouge">curl</code> instead (or install <code class="highlighter-rouge">wget</code> from MacPorts). There must be something similar for Windows as well, just google around a bit.</p>

<p>I know, platform-specific solutions are bad. I tried using <code class="highlighter-rouge">urllib2</code> and <code class="highlighter-rouge">requests</code> but that didn’t work. What I got back was not the text file I had requested but some HTML gibberish instead.</p>

<p><em>Solution #2: set a default download folder</em></p>

<p>This one doesn’t always work. I only show it for the sake of completeness.</p>

<p>Here you set a default download folder. That way the browser will automatically send all downloads to that folder, without opening up any dialog boxes (in theory, at least). Here is the code:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">chrome_options</span> <span class="o">=</span> <span class="n">webdriver</span><span class="o">.</span><span class="n">ChromeOptions</span><span class="p">()</span>
<span class="n">prefs</span> <span class="o">=</span> <span class="p">{</span><span class="s">'download.default_directory'</span><span class="p">:</span> <span class="s">'/Users/yourname/Desktop/LexisNexis_results/'</span><span class="p">}</span>
<span class="n">chrome_options</span><span class="o">.</span><span class="n">add_experimental_option</span><span class="p">(</span><span class="s">'prefs'</span><span class="p">,</span> <span class="n">prefs</span><span class="p">)</span>
<span class="n">browser</span> <span class="o">=</span> <span class="n">webdriver</span><span class="o">.</span><span class="n">Chrome</span><span class="p">(</span><span class="n">executable_path</span> <span class="o">=</span> <span class="n">path_to_chromedriver</span><span class="p">,</span> <span class="n">chrome_options</span> <span class="o">=</span> <span class="n">chrome_options</span><span class="p">)</span></code></pre></figure>

<p>(I stole this code from <a href="http://stackoverflow.com/questions/18026391/setting-chrome-preferences-w-selenium-webdriver-in-python/19024814#19024814">here</a>.)</p>

<p>It looks like a great solution, but often it simply doesn’t work at all. I’ve had trouble with it in Chrome and I’ve also had trouble with a similar solution for Firefox.</p>

<p>This is not surprising. The ChromeOptions capability is an experimental feature, as the code itself tells us (check the third line). Remember: Selenium wasn’t originally conceived for webscrapers, so it can’t make the browser interact with itself. The ChromeOptions capability was not created by the Selenium folks but by the chromedriver folks. Hopefully these tools will eventually become reliable but we are not quite there yet.</p>

<p>You may be thinking “what if I set the browser’s preferences <em>manually</em>?” It doesn’t work. The preferences you set manually are saved under your user profile and they are loaded every time <em>you</em> launch the browser but ignored when <em>Selenium</em> launches the browser. So, no good (believe me, I’ve tried it).</p>

<p><em>Solution #3: improve Selenium</em></p>

<p>If you are feeling adventurous you could add download capabilities to Selenium yourself. <a href="http://ardesco.lazerycode.com/index.php/2012/07/how-to-download-files-with-selenium-and-why-you-shouldnt/">This guy</a> did it (he also argues that people shouldn’t download anything with Selenium in the first place but he is talking to web developers, not to webscrapers, so never mind that). He uses Java but I suppose that a Python equivalent shouldn’t be too hard to produce.</p>

<p>Alas, that solution has 171 lines of code whereas the <code class="highlighter-rouge">wget</code> solution has only one line of code (two if you count <code class="highlighter-rouge">import os</code>), so I never bothered trying. But just because I was happy to settle for a quick-and-dirty workaround doesn’t mean everyone will be.</p>

<p><em>Solution #4: just don’t download at all</em></p>

<p>If you happen to be webscraping LexisNexis Academic there is yet another way: just have LexisNexis email the search results to you.</p>

<p>Code-wise there isn’t much novelty here. These lines remain the same:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">browser</span><span class="o">.</span><span class="n">switch_to_default_content</span><span class="p">()</span>
<span class="n">browser</span><span class="o">.</span><span class="n">switch_to_frame</span><span class="p">(</span><span class="s">'mainFrame'</span><span class="p">)</span>
<span class="n">dyn_frame</span> <span class="o">=</span> <span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_xpath</span><span class="p">(</span><span class="s">'//frame[contains(@name, "fr_resultsNav")]'</span><span class="p">)</span>
<span class="n">framename</span> <span class="o">=</span> <span class="n">dyn_frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s">'name'</span><span class="p">)</span>
<span class="n">browser</span><span class="o">.</span><span class="n">switch_to_frame</span><span class="p">(</span><span class="n">framename</span><span class="p">)</span></code></pre></figure>

<p>But then we click the “Email Documents” button instead of the “Download Documents” button.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_css_selector</span><span class="p">(</span><span class="s">'img[alt=</span><span class="se">\"</span><span class="s">Email Documents</span><span class="se">\"</span><span class="s">]'</span><span class="p">)</span><span class="o">.</span><span class="n">click</span><span class="p">()</span></code></pre></figure>

<p>We get a pop-up window very similar to the one we saw before.</p>

<p><a href="http://imgur.com/AQjaQNR"><img src="http://i.imgur.com/AQjaQNR.jpg" alt="" /></a></p>

<p>We switch to the new window.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">browser</span><span class="o">.</span><span class="n">switch_to_window</span><span class="p">(</span><span class="n">browser</span><span class="o">.</span><span class="n">window_handles</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></code></pre></figure>

<p>We ask that the document be sent as an attachment and that it be in plain text format.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_xpath</span><span class="p">(</span><span class="s">'//select[@id="sendAs"]/option[text()="Attachment"]'</span><span class="p">)</span><span class="o">.</span><span class="n">click</span><span class="p">()</span>                
<span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_xpath</span><span class="p">(</span><span class="s">'//select[@id="delFmt"]/option[text()="Text"]'</span><span class="p">)</span><span class="o">.</span><span class="n">click</span><span class="p">()</span></code></pre></figure>

<p>We enter our email address.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_name</span><span class="p">(</span><span class="s">'emailTo'</span><span class="p">)</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_name</span><span class="p">(</span><span class="s">'emailTo'</span><span class="p">)</span><span class="o">.</span><span class="n">send_keys</span><span class="p">(</span><span class="s">'youremail@somedomain.com'</span><span class="p">)</span>						</code></pre></figure>

<p>We create a little note to help us remember what this search is about.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_id</span><span class="p">(</span><span class="s">'emailNote'</span><span class="p">)</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_id</span><span class="p">(</span><span class="s">'emailNote'</span><span class="p">)</span><span class="o">.</span><span class="n">send_keys</span><span class="p">(</span><span class="s">'balloon'</span><span class="p">)</span></code></pre></figure>

<p>And finally we send it.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_css_selector</span><span class="p">(</span><span class="s">'img[alt=</span><span class="se">\"</span><span class="s">Send</span><span class="se">\"</span><span class="s">]'</span><span class="p">)</span><span class="o">.</span><span class="n">click</span><span class="p">()</span></code></pre></figure>

<p>That’s it. No platform-specific commands, no experimental features. The downside of this solution is that it is LexisNexis-specific.</p>

<p>This is it for now. On the next post we will cover error handling (if you are coding along and getting error messages like NoSuchElementException or NoSuchFrameException just hang in there; for now you can just add a <code class="highlighter-rouge">time.sleep(15)</code> statement before each window opens and that should do it; but I will show you better solutions). I will also show you how to make your code work for any number of search results in LexisNexis (the code we’ve seen so far only works when the number of results is 1 to 500; if there are 0 results or 500+ results the code will crash). In later posts we will cover some advanced topics, like using PhantomJS as a browser.</p>

<h2>webscraping with Selenium - part 3</h2>
  <span class="post-date">15 Nov 2013</span>
  <p>In <a href="http://thiagomarzagao.com/2013/11/14/webscraping-with-selenium-part-2/">part 2</a> we learned how to handle dynamic names and how to download content with Selenium. Here we will learn how to make our code robust to network flukes.</p>

<p><h3>handling errors</h3></p>

<p>When you run a regression multiple times the result is always be the same, provided that the data and code you are using are the same. You run it a million times and there it is, same result. In other words, the result is deterministic.</p>

<p>With webscraping, however, the result is probabilistic. Sometimes a page element doesn’t load properly. Sometimes the servers are too busy to respond to a click. Sometimes your own internet connection flickers for a millisecond. And so on.</p>

<p>In LexisNexis, for instance, sometimes you get this:</p>

<p><a href="http://imgur.com/wCRHdgJ"><img src="http://i.imgur.com/wCRHdgJ.jpg" alt="" /></a></p>

<p>In these cases Selenium will fail to find the elements you want and will crash. Selenium will throw out error messages like <code class="highlighter-rouge">NoSuchElementException</code> or <code class="highlighter-rouge">NoSuchFrameException</code>. If you’ve tried the code from parts 1 and 2 you may have encountered these errors already. It’s not that the code is wrong, it’s just that it is incomplete; we haven’t prepared it for network flukes. Let’s do it now.</p>

<p>One thing we can do is ensure that Selenium waits for a few seconds before it gives up on finding elements. There are different ways to do that. First there is the implicit wait statement:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">browser</span><span class="o">.</span><span class="n">implicitly_wait</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span></code></pre></figure>

<p>This statement makes Selenium wait up to 30 seconds before throwing an exception. You set the time limit once in your code and it is valid for the entire session.</p>

<p>Alternatively, you can set individual wait parameters for each action. To do that we first need to import a bunch of other stuff from the Selenium bindings:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">selenium.webdriver.common.by</span> <span class="kn">import</span> <span class="n">By</span>
<span class="kn">from</span> <span class="nn">selenium.webdriver.support.ui</span> <span class="kn">import</span> <span class="n">WebDriverWait</span>
<span class="kn">import</span> <span class="nn">selenium.webdriver.support.expected_conditions</span> <span class="k">as</span> <span class="n">EC</span>
<span class="kn">from</span> <span class="nn">selenium.common.exceptions</span> <span class="kn">import</span> <span class="n">TimeoutException</span></code></pre></figure>

<p>Now suppose that we want to wait for up to two minutes before we declare an element “missing”. Let’s say that the element is a button and that we know its CSS selector. We can do this:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">some_object</span> <span class="o">=</span> <span class="n">WebDriverWait</span><span class="p">(</span><span class="n">browser</span><span class="p">,</span> <span class="mi">120</span><span class="p">)</span><span class="o">.</span><span class="n">until</span><span class="p">(</span><span class="n">EC</span><span class="o">.</span><span class="n">element_to_be_located</span><span class="p">((</span><span class="n">By</span><span class="o">.</span><span class="n">CSS_SELECTOR</span><span class="p">,</span> <span class="s">'img[alt=</span><span class="se">\"</span><span class="s">Some Button</span><span class="se">\"</span><span class="s">]'</span><span class="p">)))</span></code></pre></figure>

<p>Selenium will look for the element every 500 milliseconds and, as soon as the element is found, the wait is over. If 120 seconds elapse and the element hasn’t been found, Selenium throws a <code class="highlighter-rouge">TimeoutException</code>.</p>

<p>You need to decide what to do about the <code class="highlighter-rouge">TimeoutException</code>. Do you re-try a couple of times? Do you go back to the search page and move on to the next search? That of course depends on your particular research needs. But whatever path you choose you want your code to handle that exception gracefully. In Python that is done with <code class="highlighter-rouge">try/except</code> statements, like this:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">try</span><span class="p">:</span>
    <span class="n">some_object</span> <span class="o">=</span> <span class="n">WebDriverWait</span><span class="p">(</span><span class="n">browser</span><span class="p">,</span> <span class="mi">120</span><span class="p">)</span><span class="o">.</span><span class="n">until</span><span class="p">(</span><span class="n">EC</span><span class="o">.</span><span class="n">element_to_be_located</span><span class="p">((</span><span class="n">By</span><span class="o">.</span><span class="n">CSS_SELECTOR</span><span class="p">,</span> <span class="s">'img[alt=</span><span class="se">\"</span><span class="s">Some Button</span><span class="se">\"</span><span class="s">]'</span><span class="p">)))</span>
<span class="k">except</span> <span class="n">TimeoutException</span><span class="p">:</span>
    <span class="c"># do something (retry, move on, exit, curse your internet provider, etc)</span></code></pre></figure>

<p>That way your code won’t crash when Selenium throws a <code class="highlighter-rouge">TimeoutException</code>. It will do whatever is inside the <code class="highlighter-rouge">except</code> statement instead.</p>

<p>Here we used the <code class="highlighter-rouge">element_to_be_located</code> condition, but that is not always what we need. Sometimes the element is located but cannot be interacted with (yet). Selenium offers wait conditions for several different possibilites. For instance, sometimes the element is located but Selenium crashes and the error message says that the element is not clickable. In that case we can do something like this:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">try</span><span class="p">:</span>
    <span class="n">some_object</span> <span class="o">=</span> <span class="n">WebDriverWait</span><span class="p">(</span><span class="n">browser</span><span class="p">,</span> <span class="mi">120</span><span class="p">)</span><span class="o">.</span><span class="n">until</span><span class="p">(</span><span class="n">EC</span><span class="o">.</span><span class="n">element_to_be_clickable</span><span class="p">((</span><span class="n">By</span><span class="o">.</span><span class="n">CSS_SELECTOR</span><span class="p">,</span> <span class="s">'img[alt=</span><span class="se">\"</span><span class="s">Some Button</span><span class="se">\"</span><span class="s">]'</span><span class="p">)))</span>
<span class="k">except</span> <span class="n">TimeoutException</span><span class="p">:</span>
    <span class="c"># do something</span></code></pre></figure>

<p>The full gamut of wait conditions is <a href="http://selenium.googlecode.com/svn/trunk/docs/api/py/webdriver_support/selenium.webdriver.support.expected_conditions.html">here</a>.</p>

<p>Deciding what elements to (explicitly) wait for, with what conditions, and for how long is a trial-and-error process. Run your code without any waits first and see where it crashes. Add a wait condition for the problematic element, encapsulate the wait condition within a <code class="highlighter-rouge">try/except</code> statement, and run the code again. Repeat until your code doesn’t crash anymore.</p>

<p>This is often a frustrating process and you’ll need patience. You think that you’ve covered all the possibilities and your code runs for an entire week and you are all happy and celebratory and then on day #8 the damn thing crashes. The servers went down for a millisecond or your Netflix streaming clogged your internet connection or whatnot. It happens.</p>

<p>It’s always a good idea to log errors. You can create a log file in the beginning of your code, like this:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">path_to_log</span> <span class="o">=</span> <span class="s">'/Users/yourname/Desktop/'</span>
<span class="n">log_errors</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">path_to_log</span> <span class="o">+</span> <span class="s">'log_errors.txt'</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s">'w'</span><span class="p">)</span></code></pre></figure>

<p>And then add an entry to that file every time you get a <code class="highlighter-rouge">TimeoutException</code>:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">try</span><span class="p">:</span>
    <span class="n">some_object</span> <span class="o">=</span> <span class="n">WebDriverWait</span><span class="p">(</span><span class="n">browser</span><span class="p">,</span> <span class="mi">120</span><span class="p">)</span><span class="o">.</span><span class="n">until</span><span class="p">(</span><span class="n">EC</span><span class="o">.</span><span class="n">element_to_be_located</span><span class="p">((</span><span class="n">By</span><span class="o">.</span><span class="n">CSS_SELECTOR</span><span class="p">,</span> <span class="s">'img[alt=</span><span class="se">\"</span><span class="s">Some Button</span><span class="se">\"</span><span class="s">]'</span><span class="p">)))</span>
<span class="k">except</span> <span class="n">TimeoutException</span><span class="p">:</span>
    <span class="n">log_errors</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">'couldnt locate button XYZ when searching for "balloon"'</span> <span class="o">+</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span>
    <span class="c"># do something</span></code></pre></figure>

<p>Once your code has finished running you can inspect the log file and see what searches you need to re-do.</p>

<h2>webscraping with Selenium - part 4</h2>
  <span class="post-date">16 Nov 2013</span>
  <p>I’ve assumed that you know a bit of programming, so you are probably familiar with loops and conditional expressions. I won’t cover these (or any) general programming concepts, but I want to discuss two specific points. The first one is the importance of pacing your bot. The second one is how to iterate over searches on LexisNexis Academic. This second point is really about LexisNexis, not about webscraping in general, so you can safely skip it if that’s not the site you want to webscrape.</p>

<p><h3>the importance of pacing</h3></p>

<p>Your computer can fetch online content much faster than you can, so it’s tempting to just release the beast (i.e., your bot) into the wild and let it move full speed ahead. But that’s a dead giveaway. You want your bot to pass for a human but if it moves at blazing-fast speeds that may set off all kinds of alarms with the administrators of the website (or with the bots they’ve built to do detect enemy bots).</p>

<p>Hence you need to pace things. To do that just insert a <code class="highlighter-rouge">time.sleep(seconds)</code> statement between each iteration of the loop. Do a few searches manually first, see how long it takes, and use that information to set <code class="highlighter-rouge">seconds</code> in a way that slows your bot down to human speed.</p>

<p>Better yet: make <code class="highlighter-rouge">seconds</code> partially random. Something like this:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">random</span>

<span class="n">seconds</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">+</span> <span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">seconds</span><span class="p">)</span></code></pre></figure>

<p><code class="highlighter-rouge">random.random()</code> will generate a random number between 0 and 1. So we are randomizing the delay between searches, which will vary between 5 and 10 seconds. That looks a lot more like human activity than a uniform delay. Try doing 100 searches with exactly 5 seconds between them. You can’t. And if you can’t do it then you don’t want your bot to do it.</p>

<p>“Then why would I want to webscrape in the first place? If the bot can’t go faster than I can then what’s the point? I could simply manually fetch all the content I want.” You could and you should, if that’s at all feasible. Building a webscraping bot can take a couple of weeks, depending on the complexity of the website and on whether you have done this before. If fetching everything manually would take only a couple of minutes then there is little reason to do it programmatically.</p>

<p>Webscraping is for when fetching everything manually would take days or weeks or months. But even then you won’t necessarily be done any faster. It may still take weeks or months or years for your bot to do all the work (well, hopefully not years). The key point is: webscraping is not about finishing faster, it’s about freeing you to work on other, more interesting, tasks. While your bot is hard at work on LexisNexis or Factiva or any other site you are free to work on other parts of your dissertation, finish a conference paper, or binge-watch House of Cards on Netflix.</p>

<p>Also, fetching online content manually is error-prone. If you are doing it programmatically everything is transparent: you have the code, hence you know exactly what searches were performed. You can also log any errors, as we saw in part 3, so if something went wrong you will know all about it: day, hour, search expression, button clicked, etc.</p>

<p>But if you’re doing things manually how can you be sure that you did search for Congo Brazzaville and not for Congo Kinshasa instead? Imagine how tired and bored you will be by day #10. Do you really trust yourself not to make any typos? Or not to skip a search? You can hire undergrads to do the work, but if <em>you</em> can can make mistakes while doing it then imagine people who have no stake whatsoever in your research results.</p>

<p>So, even if your bot doesn’t go any faster than you would you will still be better off with it.</p>

<p>All that said, in part 5 (coming soon) we will see that you can actually make things go faster - if you have multiple bots. But that’s dangerous in a number of ways you need to know about all the dangers first. So hang in there.</p>

<p><h3>looping over searches on LexisNexis Academic</h3></p>

<p>Back in part 1 we submitted a search on LexisNexis Academic. We searched for all occurrences of the word “balloon” in the news that day. In part 2 we went to the results page and saw that there were 121 results. We then wrote some code to retrieve those 121 results.</p>

<p>That was all fine and dandy for introductory purposes but the thing is, that code only works when the number of results is between 1 and 500. If there are 0 results we don’t get the results page, we get this page instead:</p>

<p><a href="http://imgur.com/b7srGv0"><img src="http://i.imgur.com/b7srGv0.jpg" alt="" /></a></p>

<p>Selenium will look for the ‘fr_resultsNav…’ frame (remember that?), won’t find it and will throw a <code class="highlighter-rouge">NoSuchElementException</code>.</p>

<p>Conversely, if there are over 3000 results we get this page instead:</p>

<p><a href="http://imgur.com/73x5lJt"><img src="http://i.imgur.com/73x5lJt.jpg" alt="" /></a></p>

<p>Same as before: Selenium will look for the ‘fr_resultsNav…’ frame, won’t find it  and will throw a <code class="highlighter-rouge">NoSuchElementException</code>.</p>

<p>Finally, if the number of results is between 501 and 3000 the code from part 2 will work fine up to the point where  the “Download” or “Send” button is clicked (according to whether you are downloading the results or having LexisNexis email them to you). Then LexisNexis will give you an error message.</p>

<p><a href="http://imgur.com/n1ay2XS"><img src="http://i.imgur.com/n1ay2XS.jpg" alt="" /></a></p>

<p>Yep, we can only retrieve 500 results at a time. The code from part 2 tries to download/email “All Documents”. But here we have 587 results, so we can’t do that.</p>

<p>You can see where this is going: you will need to branch your loop in order to account for those different scenarios.</p>

<p>Selenium-wise there is nothing new here so I won’t give you all the code, just pieces of it.</p>

<p><em>Scenario #1: no results</em></p>

<p>We need to locate the “No Documents Found” message that we get when there are no results. You already know how to find page elements (see part 1 if you don’t). But we can’t simply use <code class="highlighter-rouge">browser.find_element_by_</code>. If we do and we are <em>not</em> on the “no results” page Selenium will fail to find the “No Documents Found” message and the code will crash. Hence we need to encapsulate <code class="highlighter-rouge">browser.find_element_by_</code> inside a <code class="highlighter-rouge">try/except</code> statement. If the “No Documents Found” element is found then we click “Edit Search” (top of the page) and move on to the next search. Otherwise we have one or more results and hence we need to move on to the results page.</p>

<p>Here’s some pseudocode for that (say we know the id of the element).</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">try</span><span class="p">:</span>
    <span class="c"># element_id = id of "No Documents Found" element</span>
    <span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_id</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="c"># click "Edit Search"</span>
    <span class="c"># move on to next search</span>
<span class="k">except</span> <span class="n">NoSuchElementException</span><span class="p">:</span>
    <span class="c"># move on to the results page</span></code></pre></figure>

<p>This works. It’s not the most elegant solution though. Not hitting the “no results” page is not exactly an error. So it feels weird to treat it as such.</p>

<p>Selenium doesn’t have a “check if element exists” method, but we can emulate one. Something like this:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">exists_by_id</span><span class="p">(</span><span class="nb">id</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_id</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">NoSuchElementException</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span></code></pre></figure>

<p>(I stole this code from <a href="http://stackoverflow.com/a/12150013/2453555">here</a>.)</p>

<p>I know, we didn’t get rid of the <code class="highlighter-rouge">try/except</code> statement. But at least it is now contained inside a function and we don’t have to see it every time we need to check for some element’s existence based on its id.</p>

<p>You can write similar functions for other identifiers (name, xpath, etc). You can also write a more general function where you pass the identifier as an argument. Whatever suits your stylistic preferences.</p>

<p>You may want to log any searches that yield no results.</p>

<p><em>Scenario #2: more than 3000 results</em></p>

<p>This is similar to “no results” scenario, with only two differences. First, we need to look for the “More than 3000 Results” message (rather than the “No Documents Found” message); as before, we need to look for that message in a “safe” way, with a <code class="highlighter-rouge">try/except</code> statement or a user-defined function. Second, we have the option to go back and edit the search or proceed to the results page.</p>

<p>We can choose the latter by clicking the “Retrieve Results” button. But caution: when there are more than 3000 results the results page will only give us 1000 results. I don’t know what criteria LexisNexis uses to select those 1000 results (I asked them but they never bothered to reply my email). Depending on what you intend to do later you may want to consider issues of comparability and selection bias.</p>

<p><em>Scenario #3: 1-3000 results</em></p>

<p>If we are neither on the “no results” page nor on the “3000+ results” page then our first step is to retrieve the total number of results.</p>

<p>That number is contained in the <code class="highlighter-rouge">totalDocsInResult</code> object, as attribute “value”. Here is the object’s HTML code:</p>

<figure class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"hidden"</span> <span class="na">name=</span><span class="s">"totalDocsInResult"</span> <span class="na">value=</span><span class="s">"587"</span><span class="nt">&gt;</span></code></pre></figure>

<p><code class="highlighter-rouge">totalDocsInResult</code>, in turn, is contained inside the <code class="highlighter-rouge">fr_resultsNav...</code> frame that we already saw in part 2, which in turn is inside ‘mainFrame’. We already know how to move into <code class="highlighter-rouge">fr_resultsNav...</code> (see part 2). Once we are there extracting the total number of results is straightforward.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">total</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_name</span><span class="p">(</span><span class="s">'totalDocsInResult'</span><span class="p">)</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s">'value'</span><span class="p">))</span></code></pre></figure>

<p>(<code class="highlighter-rouge">totalDocsInResult</code> stores the number as a string, so we need to use <code class="highlighter-rouge">int()</code> to convert it to a number.)</p>

<p>If we have between 1 and 500 results nothing changes and we can use the code from part 2. But if we have between 501 and 3000 results that code won’t work, since we can only retrieve 500 results at a time. We need to iterate over batches of 500 results if we have 501-3000 results. Here is some starter code.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">if</span> <span class="n">total</span> <span class="o">&gt;</span> <span class="mi">500</span><span class="p">:</span>
    <span class="n">initial</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">final</span> <span class="o">=</span> <span class="mi">500</span>
    <span class="n">batch</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">final</span> <span class="o">&lt;=</span> <span class="n">total</span> <span class="ow">and</span> <span class="n">final</span> <span class="o">&gt;=</span> <span class="n">initial</span><span class="p">:</span>
        <span class="n">batch</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_css_selector</span><span class="p">(</span><span class="s">'img[alt=</span><span class="se">\"</span><span class="s">Email Documents</span><span class="se">\"</span><span class="s">]'</span><span class="p">)</span><span class="o">.</span><span class="n">click</span><span class="p">()</span>
        <span class="n">browser</span><span class="o">.</span><span class="n">switch_to_default_content</span><span class="p">()</span>
        <span class="n">browser</span><span class="o">.</span><span class="n">switch_to_window</span><span class="p">(</span><span class="n">browser</span><span class="o">.</span><span class="n">window_handles</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_xpath</span><span class="p">(</span><span class="s">'//select[@id="sendAs"]/option[text()="Attachment"]'</span><span class="p">)</span><span class="o">.</span><span class="n">click</span><span class="p">()</span>
        <span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_xpath</span><span class="p">(</span><span class="s">'//select[@id="delFmt"]/option[text()="Text"]'</span><span class="p">)</span><span class="o">.</span><span class="n">click</span><span class="p">()</span>
        <span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_name</span><span class="p">(</span><span class="s">'emailTo'</span><span class="p">)</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_name</span><span class="p">(</span><span class="s">'emailTo'</span><span class="p">)</span><span class="o">.</span><span class="n">send_keys</span><span class="p">(</span><span class="n">email</span><span class="p">)</span>						
        <span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_id</span><span class="p">(</span><span class="s">'emailNote'</span><span class="p">)</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_id</span><span class="p">(</span><span class="s">'emailNote'</span><span class="p">)</span><span class="o">.</span><span class="n">send_keys</span><span class="p">(</span><span class="s">'balloon'</span><span class="p">)</span>
        <span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_id</span><span class="p">(</span><span class="s">'sel'</span><span class="p">)</span><span class="o">.</span><span class="n">click</span><span class="p">()</span>
        <span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_id</span><span class="p">(</span><span class="s">'rangetextbox'</span><span class="p">)</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_id</span><span class="p">(</span><span class="s">'rangetextbox'</span><span class="p">)</span><span class="o">.</span><span class="n">send_keys</span><span class="p">(</span><span class="s">'{}-{}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span> <span class="n">final</span><span class="p">))</span>
        <span class="n">browser</span><span class="o">.</span><span class="n">find_element_by_css_selector</span><span class="p">(</span><span class="s">'img[alt=</span><span class="se">\"</span><span class="s">Send</span><span class="se">\"</span><span class="s">]'</span><span class="p">)</span><span class="o">.</span><span class="n">click</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">element</span> <span class="o">=</span> <span class="n">WebDriverWait</span><span class="p">(</span><span class="n">browser</span><span class="p">,</span> <span class="mi">120</span><span class="p">)</span><span class="o">.</span><span class="n">until</span><span class="p">(</span><span class="n">EC</span><span class="o">.</span><span class="n">element_to_be_clickable</span><span class="p">((</span><span class="n">By</span><span class="o">.</span><span class="n">CSS_SELECTOR</span><span class="p">,</span> <span class="s">'img[alt=</span><span class="se">\"</span><span class="s">Close Window</span><span class="se">\"</span><span class="s">]'</span><span class="p">)))</span>
        <span class="k">except</span> <span class="n">TimeoutException</span><span class="p">:</span>
            <span class="n">log_errors</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">'oops, TimeoutException when searching for balloon'</span> <span class="o">+</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
            <span class="n">browser</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">initial</span> <span class="o">+=</span> <span class="mi">500</span>
        <span class="k">if</span> <span class="n">final</span> <span class="o">+</span> <span class="mi">500</span> <span class="o">&gt;</span> <span class="n">total</span><span class="p">:</span>
            <span class="n">final</span> <span class="o">=</span> <span class="n">total</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">final</span> <span class="o">+=</span> <span class="mi">500</span>
        <span class="n">backwindow</span> <span class="o">=</span> <span class="n">browser</span><span class="o">.</span><span class="n">window_handles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">browser</span><span class="o">.</span><span class="n">switch_to_window</span><span class="p">(</span><span class="n">backwindow</span><span class="p">)</span>
        <span class="n">browser</span><span class="o">.</span><span class="n">switch_to_default_content</span><span class="p">()</span>
        <span class="n">browser</span><span class="o">.</span><span class="n">switch_to_frame</span><span class="p">(</span><span class="s">'mainFrame'</span><span class="p">)</span>
        <span class="n">framelist</span> <span class="o">=</span> <span class="n">browser</span><span class="o">.</span><span class="n">find_elements_by_xpath</span><span class="p">(</span><span class="s">'//frame[contains(@name, '</span><span class="n">fr_resultsNav</span><span class="s">')]'</span><span class="p">)</span>
        <span class="n">framename</span> <span class="o">=</span> <span class="n">framelist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s">'name'</span><span class="p">)</span>
        <span class="n">browser</span><span class="o">.</span><span class="n">switch_to_frame</span><span class="p">(</span><span class="n">framename</span><span class="p">)</span></code></pre></figure>

<p>Lines 1-5 create the necessary accumulators and start the loop. Lines 16-18 fill out the “Select Items” form, which we didn’t need in part 2 (we had fewer than 500 results, so just selected “All Documents”). Line 19 clicks the “Send” button.</p>

<p>As before, once we click “Send” LexisNexis will shove the results into a text file and email it. Generating that file may take a while. The more so since we are now selecting 500 results, which is a lot. It may take a whole minute or so before the “Close Window” button finally appears on the pop-up.</p>

<p>That’s why we need the explicit wait you see in lines 20-25 (see part 3 if this is new to you). If the “Close Window” button takes over two minutes to appear we close the pop-up by brute force (and we hope that the file with the results was generated and sent correctly).</p>

<p>Lines 26-30 update the accumulators and lines 31-37 take us back to the results page.</p>

<p>Naturally this entire loop will be inside the big loop that iterates over your searches. I won’t give you any code for that outer loop, but really it’s simpler than the inner loop above.</p>

<p>Here I only used an explicit wait for the “Close Window” button but of course you will want to sprinkle explicit waits whenever you feel the need (i.e., whenever your code crashes while trying to locate an element or interact with it). Review part 3 if needed.</p>

<p>That’s about it for now. On the next post we will cover headless browsing and parallel webscraping.</p>

<h2>webscraping with Selenium - part 5</h2>
  <span class="post-date">17 Nov 2013</span>
  <p>This the final part of our Selenium tutorial. Here we will cover headless browsing and parallel webscraping.</p>

<p><h3>why switch to headless browsing</h3></p>

<p>While you are building and testing your Selenium script you want to use a conventional browser like Chrome or Firefox. That way you can see whether the browser is doing what you want it do. You can see it clicking the buttons, filling out the text fields, etc. But once you are ready to release your bot into the wild you should consider switching to a headless browser. Headless browsers are browsers that you don’t see. All the action happens in the background; there are no windows.</p>

<p>Why would anyone want that? Two reasons.</p>

<p>First, you decrease the probability of errors. Your bot will be doing only one thing: interacting with the HTML code behind the website. Opening windows and rendering content can always result in errors, so why do these things now that your script is functional? This is especially the case if you are parallelizing your webscraping. You don’t want five or six simultaneous Chrome windows. That would make it five or six times more likely that you get a graphics-related error.</p>

<p>Second, it makes it easier to use remote computers. Like Amazon EC2, Google Compute Engine, or your university’s supercomputing center. Remote computers have no displays, the standard way to use them is via the command line interface. To use software that has a graphical user interface, like Chrome or Firefox, you need workarounds like X11 forwarding and virtual displays. Since a headless browser doesn’t have a graphical user interface you don’t need to worry about any of that. So why complicate things?</p>

<p>I know, it sounds weird to not see the action. But really, you’ve built and tested your script, you know it works, so now it’s time to get rid of the visual. In the words of Master Kenobi, “stretch out with your feelings”.</p>

<iframe width="420" height="315" src="https://www.youtube.com/embed/X69NCLxwLEY" frameborder="0" allowfullscreen=""></iframe>

<p><h3>using a headless browser</h3></p>

<p>There are several headless browsers, like ZombieJS, EnvJS, and PhantomJS (they tend to be written in JavaScript - hence the JS in the names). PhantomJS is the most popular, so that’s my pick (the more popular the tool the more documented and tested it is and the more people can answer your questions on <a href="http://stackoverflow.com/">StackOverflow</a>).</p>

<p>Download <a href="http://phantomjs.org/">PhantomJS</a> and save the binary to the same folder where you downloaded chromedriver before. That binary contains both the browser itself and the Selenium driver, so there is no need to download a “phantomjsdriver” (actually they call it <a href="https://github.com/detro/ghostdriver">ghostdriver</a>; it used to be a separate thing but now it’s just embedded in the PhantomJS binary, for your convenience).</p>

<p>You can start PhantomJS the same way you start Chrome.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">path_to_phantomjs</span> <span class="o">=</span> <span class="s">'/Users/yourname/Desktop/phantomjs'</span> <span class="c"># change path as needed</span>
<span class="n">browser</span> <span class="o">=</span> <span class="n">webdriver</span><span class="o">.</span><span class="n">PhantomJS</span><span class="p">(</span><span class="n">executable_path</span> <span class="o">=</span> <span class="n">path_to_phantomjs</span><span class="p">)</span></code></pre></figure>

<p>But you don’t want that. Websites know which browser you are using. And they know that humans use Chrome, Firefox, Safari, etc. But PhantomJS? ZombieJS? Only bots use these. Hence many websites refuse to deal with headless browsers. We want the website to think that we are using something else. To do that we need to change the user-agent string.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">dcap</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">DesiredCapabilities</span><span class="o">.</span><span class="n">PHANTOMJS</span><span class="p">)</span>
<span class="n">dcap</span><span class="p">[</span><span class="s">"phantomjs.page.settings.userAgent"</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
     <span class="s">"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/53 "</span>
     <span class="s">"(KHTML, like Gecko) Chrome/15.0.87"</span><span class="p">)</span></code></pre></figure>

<p>Now we start PhantomJS but using the modified user-agent string.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">path_to_phantomjs</span> <span class="o">=</span> <span class="s">'/Users/yourname/Desktop/phantomjs'</span> <span class="c"># change path as needed</span>
<span class="n">browser</span> <span class="o">=</span> <span class="n">webdriver</span><span class="o">.</span><span class="n">PhantomJS</span><span class="p">(</span><span class="n">executable_path</span> <span class="o">=</span> <span class="n">path_to_phantomjs</span><span class="p">,</span> <span class="n">desired_capabilities</span> <span class="o">=</span> <span class="n">dcap</span><span class="p">)</span></code></pre></figure>

<p>And that’s it. The rest of your code doesn’t change. The only difference is that when you run your script you won’t see any windows popping up.</p>

<p><h3>parallel webscraping</h3></p>

<p>If you have tons of searches to do you may launch multiple instances of your code and have them run in parallel. Webscraping is a case of <a href="http://en.wikipedia.org/wiki/Embarrassingly_parallel">embarrassingly parallel</a> problem, since no communication is required between the tasks. You don’t even need to write a parallel script, you can simply copy and paste your script into n different files and have each do 1/n of the searches. The math is simple: if you divide the work by two you get done in half the time, if you divide the work by 10 you get done in a tenth of the time, and so on.</p>

<p>That is all very tempting and our first instinct is to parallelize as much as possible. We want to launch hundreds or thousands of simultaneous searches and be done in only a fraction of the time. We want to build and deploy a big, scary army of bots.</p>

<p><a href="http://imgur.com/vhqO1Vp"><img src="http://i.imgur.com/vhqO1Vp.jpg" alt="" /></a></p>

<p>But you shouldn’t do that, both for your own sake and for the sake of others.</p>

<p>First of all you don’t want to disrupt the website’s operation. Be especially considerate with websites that normally don’t attract a lot of vistors. They don’t have that many servers, so if you overparallelize you can cause the whole thing to shut down. This is really bad karma. Remember that other human beings also need that website - to make a living (if they are the ones running it) or for their own research needs (people like you). Be nice.</p>

<p>Second, if you overparallelize your bots may lose their human façade. Humans can only handle a couple of simultaneous searches, so if the webadmins see 300 simultaneous searches coming from the same IP address they will know that something is off. So even if you don’t bring the website down you can still get in trouble. You worked hard to put your Selenium script together, you don’t want your bots to lose their cover now.</p>

<p>So, proceed gently. How many parallel bots is safe? I have no idea. That depends entirely on the website, on how many IPs you are using, on whether you have proper delays between your searches (see part 4), etc. As a general rule I wouldn’t have more than three or four parallel bots per IP address (because that’s what a human being could manage).</p>

<p>Multiple IPs don’t mean you are safe though. If those IP addresses are all from the same place - say, your campus - then you are not fooling anyone. Suppose your university subscribes to LexisNexis and that, on average, about 500 people use it everyday on campus. Then you deploy 500 parallel bots. The LexisNexis webadmins will see that there is a sudden 100% increase in traffic coming from your campus. It doesn’t matter whether you are using 1 or 500 IP addresses.</p>

<p>If you get caught things can get ugly. LexisNexis, for instance, may cut off your entire university if they catch even one person webscraping. Imagine being the person who caused your entire university to lose access to LexisNexis. Or to Factiva. Or to any other major database on which thousands of people in your campus rely for their own research needs. Bad, bad karma.</p>

<p>By the way, LexisNexis’ terms of use explicitly prohibit webscraping; check item 2.2. It’s safe to have up to 3 or 4 parallel bots; as long as you have proper delays between searches (see part 4) no one can tell your 3-4 bots from a human being. Remember: Selenium doesn’t connect to the site directly but through the browser, so all that LexisNexis sees is Chrome or Firefox or Safari. But if you overparallelize then you may become the person who caused LexisNexis to cut off your entire university.</p>

<p>(A quick rant: item 2.2 is immoral. Universities pay millions of dollars to LexisNexis in subscriptions but then when we really need to use the content they say we can’t? That’s like selling 1000 gallons of water but delivering only one drop at a time. This is especially outrageous now that we have the hardware and software to text-mine millions of texts. The optimal answer here is buyers’ collusion but I don’t see that happening. So I see our webscraping LexisNexis as a legitimate act of civil disobedience.)</p>

<p>In sum, parallelizing can speed things up but you need to be careful and mindful of others when doing it.</p>

<hr />

<p>This is it. I hope you have found this tutorial useful. There is a lot I haven’t covered, like interacting with hidden elements and executing arbitrary JavaScript code, but at this point you can figure out anything by yourself.</p>

<p>I wrote this tutorial because even though Selenium is perhaps the most powerful webscraping tool ever made it’s still somewhat unknown to webscrapers. If you found it useful as well then help spread the word.</p>

<p>Comments are always welcome.</p>

<p>Happy webscraping!</p>
<br>
<br><br><br><br><br>
<script>
  $(function() {
    var toc = $('#toc>ul');

    function makeLi(text, href) {
      return $('<a href="' + href + '" target="_self">' + text + '</a><br>');
    }

    $('h2, h3').each(function(i) {
      var chapter = $(this), chapterNumber = i + 1;
      toc.append(
        makeLi(chapter.text(), '#chapter-' + chapterNumber)
      );
      chapter.attr('id', 'chapter-' + chapterNumber);
    });

  });
</script>
</body>
</html>
