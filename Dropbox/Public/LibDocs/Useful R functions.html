<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"/>
<link rel="stylesheet" href="..\maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script>
$(document).ready(function(){
    $('h1, h2, h3, h4, h5, .goldword, .apply, div.title').click(function(){
    parent.history.back();
    return false;
    });
});
</script>
<style>
h1, h2 {color: gold;}
</style>
</head><body>
<center><h1>Useful R functions</h1></center>
<div id="toc"></div>
<br>
<br>
<br>


<p>Almost every R user knows about popular packages like dplyr and ggplot2. But with 10,000+ packages on CRAN and yet more on GitHub, it's not always easy to unearth libraries with great R functions. One of the best way to find cool, new-to-you R code is to see what other useRs have discovered. So, I'm sharing a few of my discoveries -- and hope you'll share some of yours in return (
<a href="#contactinfo2" rel="nofollow">contact info below</a>).</p>
<p>
<strong>Choose a ColorBrewer palette from an interactive app.</strong> Need a color scheme for a map or app? 
<a href="http://colorbrewer2.org/#type=sequential&amp;scheme=BuGn&amp;n=3" rel="noopener nofollow" target="_blank">ColorBrewer</a> is well known as a source for pre-configured palettes, and the RColorBrewer package imports those into R. But it's not always easy to remember what's available. The tmaptools package's palette_explorer creates an interactive application that shows you the possibilities.</p>
<p>First, install tmaptools with 
<code>install.packages("tmaptools")</code>, then load tmaptools with 
<code>library("tmaptools")</code> and run 
<code>palette_explorer()</code> (or, don't load tmaptools and run 
<code>tmaptools::palette_explorer()</code> ). You'll see all available palettes as in the image above, as well as sliders to adjust options like number of colors. There's also info about basic syntax for using a color scheme below each group of palettes.</p>
<aside id="fsb-2055" class="fakesidebar fakesidebar-auto">
<strong>[ To comment on this story, visit 
<a href="https://www.facebook.com/Computerworld/" target="_blank" rel="nofollow">Computerworld's Facebook page</a>. ]</strong></aside>
<p>palette_explorer also needs shiny and shinyjs packages installed in order to generate the interactive app.</p>
<aside class="nativo-promo nativo-promo-1 smartphone" id=""> </aside>
<p>
<strong>Create character vectors without quotation marks. </strong>It can be a bit annoying to manually turn 
<code>Firefox, Chrome, Edge, Safari, Internet Explorer, Opera</code> into the 
<code>c("Firefox", "Chrome", "Edge", "Safari", "InternetExplorer", "Opera")</code> format R needs to use such text as a vector of character strings.</p>
<p>That's what the Hmisc package's Cs function was designed to do. After loading the Hmisc package,</p>
<pre class="prettyprint">
<code>Cs(Firefox, Chrome, Edge, Safari, InternetExplorer, Opera)</code></pre>
<p>will evaluate the same as</p>
<aside id="fsb-2586" class="fakesidebar fakesidebar-auto fakesidebar-sponsored">
<strong>[ 
<a href="https://pluralsight.pxf.io/c/321564/424552/7490?u=https%3A%2F%2Fwww.pluralsight.com%2Fcourses%2Fintro-dwbi-course-2017" rel="nofollow">Data warehousing and business intelligence are critical to business success. Take this online course and get fluent with the fundamentals.</a> ]</strong></aside>
<pre class="prettyprint">
<code>c("Firefox", "Chrome", "Edge", "Safari", "InternetExplorer", "Opera")</code></pre>
<p>If you've ever manually added quotation marks to a lengthy string of words, you'll appreciate the elegance. Note the lack of a space in Internet Explorer -- spaces will trip up the Cs function.</p>
<aside class="nativo-promo nativo-promo-1 tablet desktop" id=""> </aside>
<p>RStudio bonus: If you use RStudio, there's another option for sleek vector-string creation. Security pro Bob Rudis created 
<a href="https://github.com/hrbrmstr/hrbraddins" rel="noopener nofollow" target="_blank">an RStudio add-in</a> that takes selected comma-separated text and adds the necessary quotes and c(). And it can handle spaces. Install it with 
<code>devtools::install_github("hrbrmstr/hrbraddins")</code> (which means you need the devtools package as well), and you'll see Bare Combine as an option in the RStudio Tools &gt; Addins menu.</p>
<p>You can run it from that Addins menu, but selecting text and then leaving your coding window to go to the Tools &gt; Addins menu to select Bare Combine doesn't necessarily feel less cumbersome than typing a few quotation marks. Much better to create a custom keyboard shortcut for the addin.</p>
<p>You can do that by going to Tools &gt; Modify Keyboard Shortcuts. Scroll down until you see Bare Combine in the Addins section -- or search for Bare Combine in the filter box. Double click in the shortcut area and type the keystroke(s) you want to assign to the addin (I used 
<code>alt-shift-'</code>).</p>
<figure class="large ">
<img src="https://images.techhive.com/images/article/2017/03/favorites_3-100715111-large.jpg"> 
<small class="credit">Screenshot of RStudio software</small>

<figcaption>

<p>Customizing keyboard shortcuts in RStudio</p>
</figcaption>
</figure>
<p>Now, any time you want to turn comma-separated plain text into an R vector of character strings, you can highlight the text and use your keyboard shortcuts.</p>
<p>By the way, RStudio add-ins are mostly just plain R. If you'd like having keyboard shortcuts for R tasks like this, it might be worth 
<a href="https://rstudio.github.io/rstudioaddins/#developing-addins" rel="noopener nofollow" target="_blank">learning the syntax</a>.</p>
<p>Finally, the datapasta package's 
<code>vector_paste()</code> offers another unconventional alternative. You can copy a string like 
<code>Firefox, Chrome, Edge, Safari, Internet Explorer, Opera</code> 
<em>into your clipboard </em>and then run vector_paste(). That's it, just 
<code>vector_paste()</code>, and it converts your clipboard contents into R code, such as 
<code>c("Firefox", "Chrome", "Edge", "Safari", "Internet Explorer", "Opera")</code>. This works if there are tabs between the words as well as commas, or if each word is on its own line.</p>
<p>If you'd rather include data in your command, you can use vector_paste() with a syntax such as 
<code>vector_paste("Firefox, Chrome, Safari, Edge")</code> to generate the code such as 
<code>c("Firefox", "Chrome", "Safari", "Edge")</code>. datapasta has some other neat function, including df_paste(), which will turn a table copied into your clipboard from the Web, Excel, or other source, into code to generate a data frame.</p>
<p>
<strong>Produce an interactive table with one line of code.</strong> Regardless of how much you like and use the command line, sometimes it's still nice to look at a spreadsheet-like table of data to scan, sort and filter. RStudio provided a basic view like this; but for large data sets, I like RStudio's DT package, a wrapper for the DataTables JavaScript library. 
<code>DT::datatable(mydf)</code> creates an interactive HTML table; 
<code>DT::datatable(mydf, filter = "top")</code> adds a filter box above each row.</p>
<aside class="nativo-promo nativo-promo-2 tablet desktop smartphone" id=""> </aside>
<figure class="large ">
<img src="https://images.techhive.com/images/article/2017/03/favorites_02-100715108-large.jpg"> 
<small class="credit">Screen shot of an HTML table created with the R DT package</small>

<figcaption>

<p>Example of an HTML table created with the R DT package, an interface to the DataTables JavaScript library.</p>
</figcaption>
</figure>
<p>
<strong>Easy file conversions. </strong>rio is one of my favorite R packages. Instead of remembering which functions to use for importing what types of files (read.csv? read.table? read_excel?), rio vastly simplifies the process with one 
<code>import</code> function for a couple of dozen file formats. As long as the file extension is a format that rio recognizes, it will appropriately import from files such as .csv, .json, .xlsx and .html (tables). Same for rio's 
<code>export</code> command if you'd like to save to a particular file format. But rio has a third major function: convert, which will import and export in a single step. Have a million-row Excel file you need to save as a CSV? An HTML table you'd like to save as JSON? Use a syntax like 
<code>convert("myfile.xlsx", "myfile.csv")</code>, where the first argument is your existing file and the second is your desired file with the desired extension, and your file will be created.</p>
<p>
<strong>Copy and paste from R to your clipboard.</strong> rio bonus: You can copy between your clipboard and R with rio. Send some data from a small R variable to your clipboard with 
<code>export(myRobject, "clipboard")</code>. Importing to the clipboard should work as well, although I've had mixed success with that.</p>
<p>
<strong>Import large files quickly - and save space.</strong> It recently took close to 30 seconds when reading in a large spreadsheet. That's doable once, but annoying when I needed to access it multiple times. For saving space as well as wait time, the 
<a href="http://www.fstpackage.org/" rel="noopener nofollow" target="_blank">fst</a> package was an excellent choice because it offers compression as well as high performance. In my testing, 
<code>write.fst(mydf, "myfile.fst", 100)</code> -- maximum compression -- was extremely quick -- and the .fst file took about one-third the space of the original spreadsheet.</p>
<p>
<strong>Turn a data frame of numbers into one of percents.</strong> If you've got a data frame with one column of categories and the rest numbers -- imagine, say, a data frame showing election results by candidate and precinct -- the janitor package's 
<code>adorn_percentages()</code> will calculate all the percentages for you. You can choose whether the denominator for each percent should be summed by "row", "col" or "all". And, the function automatically assumes the first row has category information and skips it, without you having to manually deal with a non-numeric column.</p>
<p>janitor has several other handy functions worth knowing. adorn_totals() adds a totals row and/or column to a data frame. And, clean_names() takes column names with spaces and other non-R-friendly characters in them and makes them R-compatible.</p>
<p>
<strong>table() alternatives. </strong>Need to calculate frequencies of variables in a data frame? I like janitor's 
<a href="https://github.com/sfirke/janitor/blob/master/vignettes/tabyls.md" rel="nofollow noopener" target="_blank">tabyl() function</a>, which easily creates crosstabs with counts and percents and returns a data frame.</p>
<p>In addition, janitor's tabyl() can be used instead of base R's table(), helpfully returning a conventional data frame with counts and percents.</p>
<p>
<em>A few additional favorite functions from readers and social media:</em></p>
<p>"I'm a huge fan of xtabs()" for crosstabs, Timothy Teravainen posted at Google+. "It's in base R, but I sadly went years without knowing about it."</p>
<p>The format is 
<code>xtabs(~df$col1 + df$col2)</code>, which will return a frequency table with col1 as the rows and col2 as the columns.</p>
<p>
<strong>More with quotes. </strong>In response to the Cs() function that 
<em>adds </em>quotes, Kwan Lowe touted the usefulness of noquote(), which 
<em>strips </em>quotes -- useful for importing certain types of data into R. noquote() is a base R function, aimed it making it easier to wrangle variables.</p>
<p>
<strong>Un-factoring factors.</strong> Another useful function: unfactor() in the 
<a href="https://cran.r-project.org/web/packages/varhandle/" rel="noopener nofollow" target="_blank">varhandle package</a>, which aims to detect the "real" class of an R data frame column of factors and then turn it into either numeric or character variables.</p>
<p>
<strong>Text searching. </strong>If you've been using regular expressions to search for text that starts or ends with a certain character string, there's an easier way. "startsWith() and endsWith() -- did I really not know these?" tweeted data scientist Jonathan Carroll. "That's it, I'm sitting down and reading through dox for every #rstats function."</p>
<p>
<strong>Loading packages -- and auto-installing if they're not present. </strong>For reproducible research, an R script can't simply load external packages -- it's got to check whether those packages are loaded on the user's machine and install them if they're not. There are several ways to do this in base R, such as using require() to check if various packages load and then installing the packages if they're not. The 
<a href="https://cran.r-project.org/web/packages/pacman/vignettes/Introduction_to_pacman.html" rel="noopener nofollow" target="_blank">pacman package</a> simplifies this immensely. To load packages and install them from CRAN if not available, the syntax is: 
<code>p_load("package1", "package2", "package3")</code>. There's also a p_load_gh() version for packages on GitHub. Thanks to Twitter user 
<a href="https://twitter.com/Himmie_He" rel="noopener nofollow" target="_blank">@Himmie_He</a> for the tip.</p>
<p>
<strong>Identifying your project's home directory. </strong>The here package's here() function finds the working directory for a current R project. This is especially handy for RStudio projects when a) your code needs access other directories and b) you'd like that code to work on other systems with a different directory structure. Thanks to Jenny Bryan and Hadley Wickham for that info via Twitter.</p>
<p>
<strong>Get minimum and maximum values with a single command. </strong>Need to find the minimum and maximum values in a vector? Base R's range() function does just that, returning a 2-value vector with lowest and highest values. The help file says range() works on numeric and character values, but I've also had success using it with date objects.</p>
<p>
<strong>Extract or operate on items in a list that are several layers deep. </strong>This is particularly useful if you're working with XML or JSON data imported into R, or you'd like to operate on multiple data frames but keep them separate. For example, this 
<a target="_blank" href="https://twitter.com/netzstreuner/status/992330156697161729" rel="nofollow">task tweeted by @netzstreuner</a> asking if there was a better way to add a column to each data frame in a list of identically structured data frames:</p>
<figure class="large ">

<img src="https://images.idgesg.net/images/article/2018/05/rtweetquestion-100756789-large.jpg">

<small class="credit">
<a href="https://twitter.com/netzstreuner/status/992330156697161729" target="_blank" rel="nofollow">From @netzstreuner on Twitter</a> </small>	
<figcaption>
<p>Question from @netzstreuner on Twitter about operating on a specific column in every data frame within a list</p></figcaption>
</figure>
<p>The answer: purrr's modify_depth() function. 
<code>modify_depth(mylist, 2, ~ myfunction)</code> will run myfunction() on every item in mylist 
<em>at the second level of that list</em>. </p>
<p>That's for a generic list. Specifically for this question involving a 
<em>list of data frames</em>, dplyr's mutate() can add a new column to 
<em>one</em> data frame. To do this for a 
<em>list</em> of data frames, you can combine mutate() and modify_depth(). Here's my proposed solution to @netzstreuner's question:</p>
<p>
<pre class="prettyprint">
<code>ll_edited &lt;- modify_depth(ll, 2, ~ mutate(.x, b = a %% 2 == 0))</code></pre></p>
<p>That code says: "For every item two levels deep in the list ll, add a column b calculating if the value in column a is divisible by 2 with no remainder."</p>
<p id="contactinfo2">
<em>Want to share your own favorites? Tell me via Twitter 
<a href="https://twitter.com/sharon000" rel="noopener nofollow" target="_blank">@sharon000</a> or email at 
<a href="mailto:sharon_machlis@idg.com" rel="nofollow">sharon_machlis@idg.com</a>.</em></p>
<p>
<em>For more on useful R functions, see</em> 
<strong>
<a href="http://www.computerworld.com/article/2921176/business-intelligence/great-r-packages-for-data-import-wrangling-visualization.html">Great R packages for data import, wrangling and visualization</a></strong>.</p>
<br>
<br>
<br>
<br>

<script>
  $(function() {
    var toc = $('#toc');

    function makeLi(text, href) {
      return $('<a href="' + href + '" target="_self">' + text + '</a><br>');
    }

    $('strong').each(function(i) {
      var chapter = $(this), chapterNumber = i + 1;
      toc.append(
        makeLi(chapter.text(), '#chapter-' + chapterNumber)
      );
      chapter.attr('id', 'chapter-' + chapterNumber);
    });

  });
</script>
</body>
</html>
