<meta http-equiv="Content-Type" content="text/html; charset=utf-8">


<style type="text/css">
body {
 margin: 10%;
 font-size: 24px;
 background-color: #000000;
 color: #109030;
}
a { text-decoration: none;
    color: #28B8B8;}
a:visited { color: #389898;}
A:hover {   color: yellow;}
A:focus {   color: red;}
code { color: pink; background-color: #001500}
pre { color: gray; background-color: #001010}

.newtype { color: pink}
.redpink { color: #cc0099}
.redword { color: red}
.yellowword { color: yellow}
.greenword { color: green}
.limeword { color: #00ff00}
.orangeword { color: orange}
.cyanword { color: cyan}
.whiteword { color: white}
.grayword { color: gray}
.brownword { color: #ff8000}
.yellowgreen { color: #bfff00}
.palered { color: #ffcccc}
.blueword { color: dodgerblue}
.purpleword { color: darkorchid}
.goldword { color: GoldenRod}
.silverword { color: silver}
.blackword { color: black}
.left {
    position: absolute;
    left: 100px;
    color: GoldenRod;
    border: 1px solid GoldenRod;
    padding: 2px;
    font-size: 60%;
}
.bord {
    border: 1px solid GoldenRod;
    padding: 1px;
    font-size: 90%;
}
.highlight { 
    color: white;
    background-color: #002030
  }
</STYLE>

</head>
<body bgcolor="#000000" text="#109030" leftmargin="10" topmargin="10" marginwidth="100" link="#08C8A8" vlink="#389898" alink="#28B8B8">


<h1>Practicing Machine Learning Techniques in R with MLR Package</h1>

<h2>Introduction</h2>
<p style="text-align: justify;">In R, we often use multiple packages for doing various machine learning tasks. For example: we impute missing value using one package, then build a model with another and finally evaluate their performance using a third package.</p>
<p style="text-align: justify;">The problem is, every package has a set of specific parameters. While working with many packages, we end up spending a lot of time to figure out which parameters are important. Don&#8217;t you think?</p>
<p style="text-align: justify;">To solve this problem, I researched and came across a R package named <code>MLR</code>, which is absolutely incredible at performing machine learning tasks. <span style="line-height: 1.5;">This package includes all of the ML algorithms which we use frequently. </span></p>
<p style="text-align: justify;">In this tutorial, I&#8217;ve taken up a classification problem and tried improving its accuracy using machine learning. I haven&#8217;t explained the ML algorithms (theoretically) but focus is kept on their implementation. By the end of this article, you are expected to become proficient at implementing several ML algorithms in R. But, only if you practice alongside.</p>
<p style="text-align: justify;"><em>Note: This article is meant only for beginners and early starters with Machine Learning in R. Basic statistic knowledge is required. </em></p>
<p style="text-align: center;"><img class="aligncenter wp-image-26671" src="https://www.analyticsvidhya.com/wp-content/uploads/2016/08/feat1.png" alt="machine learning techniques in R" width="800" height="412" srcset="https://www.analyticsvidhya.com/wp-content/uploads/2016/08/feat1.png 1365w, https://www.analyticsvidhya.com/wp-content/uploads/2016/08/feat1-300x155.png 300w, https://www.analyticsvidhya.com/wp-content/uploads/2016/08/feat1-768x396.png 768w, https://www.analyticsvidhya.com/wp-content/uploads/2016/08/feat1-1024x527.png 1024w, https://www.analyticsvidhya.com/wp-content/uploads/2016/08/feat1-850x438.png 850w" sizes="(max-width: 800px) 100vw, 800px"/></p>
<p>&nbsp;</p>
<h2>Table of Content</h2>
<ol>
<li>Getting Data</li>
<li>Exploring Data</li>
<li>Missing Value Imputation</li>
<li>Feature Engineering
<ul>
<li>Outlier Removal by Capping</li>
<li>New Features</li>
</ul>
</li>
<li>Machine Learning
<ul>
<li>Feature Importance</li>
<li>QDA</li>
<li>Logistic Regression
<ul>
<li>Cross Validation</li>
</ul>
</li>
<li>Decision Tree
<ul>
<li>Cross Validation</li>
<li>Parameter Tuning using Grid Search</li>
</ul>
</li>
<li>Random Forest</li>
<li>SVM</li>
<li>GBM (Gradient Boosting)
<ul>
<li>Cross Validation</li>
<li>Parameter Tuning using Random Search (Faster)</li>
</ul>
</li>
<li>XGBoost (Extreme Gradient Boosting)</li>
<li>Feature Selection</li>
</ul>
</li>
</ol>
<p>&nbsp;</p>
<h2>Machine Learning with MLR Package</h2>
<p style="text-align: justify;">Until now, R didn&#8217;t have any package / library similar to <a href="http://scikit-learn.org/stable/" target="_blank" rel="nofollow">Scikit-Learn</a> from Python, wherein you could get all the functions required to do machine learning. But, since February 2016, R users have got mlr package using which they can perform most of their ML tasks.</p>
<p style="text-align: justify;">Let&#8217;s now understand the basic concept of how this package works. If you get it right here, understanding the whole package would be a mere cakewalk.</p>
<p style="text-align: justify;">The entire structure of this package relies on this premise:</p>
<p style="text-align: center;" id="yellowword">Create a Task. Make a Learner. Train Them.</p>
<p style="text-align: center;" id="limeword">Creating a task means loading data in the package. <br>
Making a learner means choosing an algorithm ( learner) which learns from task (or data). <br>
Finally, train them.</p>
<p style="text-align: justify;">MLR package has several algorithms in its bouquet. These algorithms have been categorized into regression, classification, clustering, survival, multiclassification and cost sensitive classification. Let&#8217;s look at some of the available algorithms for classification problems:</p>
<p><code>&gt; listLearners("classif")[c("class","package")]</code><br/>
<code>  class                           package</code><br/>
<code>1 classif.avNNet                   nnet</code><br/>
<code>2 classif.bartMachine            bartMachine</code><br/>
<code>3 classif.binomial                 stats</code><br/>
<code>4 classif.boosting               adabag,rpart</code><br/>
<code>5 classif.cforest                  party</code><br/>
<code>6 classif.ctree                    party</code><br/>
<code>7 classif.extraTrees             extraTrees</code><br/>
<code>8 classif.knn                      class</code><br/>
<code>9 classif.lda                      MASS</code><br/>
<code>10 classif.logreg                  stats</code><br/>
<code>11 classif.lvq1                    class</code><br/>
<code>12 classif.multinom                 nnet</code><br/>
<code>13 classif.neuralnet             neuralnet</code><br/>
<code>14 classif.nnet                     nnet</code><br/>
<code>15 classif.plsdaCaret              caret</code><br/>
<code>16 classif.probit                  stats</code><br/>
<code>17 classif.qda                      MASS</code><br/>
<code>18 classif.randomForest         randomForest</code><br/>
<code>19 classif.randomForestSRC      randomForestSRC</code><br/>
<code>20 classif.randomForestSRCSyn   randomForestSRC</code><br/>
<code>21 classif.rpart                    rpart</code><br/>
<code>22 classif.xgboost                 xgboost</code></p>
<p style="text-align: justify;">And, there are many more. Let&#8217;s start working now!</p>
<p>&nbsp;</p>
<h2>1. Getting Data</h2>
<p style="text-align: justify;">For this tutorial, I&#8217;ve taken up one of the popular ML problem from DataHack  (one time login will be required to get data): <a href="https://datahack.analyticsvidhya.com/contest/practice-problem-loan-prediction-iii/" target="_blank" rel="nofollow">Download Data</a>.</p>
<p style="text-align: justify;">After you&#8217;ve downloaded the data, let&#8217;s quickly get done with initial commands such as setting the working directory and loading data.</p>
<p><code>&gt; path &lt;- "~/Data/Playground/MLR_Package"</code><br/>
<code>&gt; setwd(path)</code></p>
<p><code>#load libraries and data</code><br/>
<code>&gt; install.packages("mlr")</code><br/>
<code>&gt; library(mlr)</code><br/>
<code>&gt; train &lt;- read.csv("train_loan.csv", na.strings = c(""," ",NA))</code><br/>
<code>&gt; test &lt;- read.csv("test_Y3wMUE5.csv", na.strings = c(""," ",NA))</code></p>
<p>&nbsp;</p>
<h2>2. Exploring Data</h2>
<p>Once the data is loaded, you can access it using:</p>
<p><code>&gt; summarizeColumns(train)</code></p>
<p><code> name              type    na    mean           disp      median     mad    min   max   nlevs</code><br/>
<code>LoanAmount       integer  22   146.4121622  85.5873252   128.0   47.4432    9    700    0</code><br/>
<code>Loan_Amount_Term integer  14   342.0000000  65.1204099   360.0    0.0000   12    480    0</code><br/>
<code>Credit_History   integer  50   0.8421986    0.3648783     1.0     0.0000   0      1     0</code><br/>
<code>Property_Area    factor   0      NA         0.6205212     NA        NA    179    233    3</code><br/>
<code>Loan_Status      factor   0      NA         0.3127036     NA        NA    192    422    2</code></p>
<p style="text-align: justify;">This functions gives a much comprehensive view of the data set as compared to base <code>str()</code> function. Shown above are the last 5 rows of the result. Similarly you can do for test data also:</p>
<p><code>&gt; summarizeColumns(test)</code></p>
<p>From these outputs, we can make the following inferences:</p>
<ol>
<li style="text-align: justify;">In the data, we have 12 variables, out of which <code>Loan_Status</code> is the dependent variable and rest are independent variables.</li>
<li style="text-align: justify;">Train data has 614 observations. Test data has 367 observations.</li>
<li style="text-align: justify;">In train and test data, 6 variables have missing values (can be seen in na column).</li>
<li style="text-align: justify;"><code>ApplicantIncome</code> and <code>Coapplicant Income</code> are highly skewed variables. How do we know that ? Look at their min, max and median value. We&#8217;ll have to normalize these variables.</li>
<li style="text-align: justify;"><code>LoanAmount</code>, <code>ApplicantIncome</code> and <code>CoapplicantIncome</code> has outlier values, which should be treated.</li>
<li style="text-align: justify;"><code>Credit_History</code> is an integer type variable. But, being binary in nature, we should convert it to factor.</li>
</ol>
<p>Also, you can check the presence of skewness in variables mentioned above using a simple histogram.</p>
<p><code>&gt; hist(train$ApplicantIncome, breaks = 300, main = "Applicant Income Chart",xlab = "ApplicantIncome")</code><img class="aligncenter wp-image-26607" src="https://www.analyticsvidhya.com/wp-content/uploads/2016/08/21.png" alt="21" width="600" height="336" srcset="https://www.analyticsvidhya.com/wp-content/uploads/2016/08/21.png 715w, https://www.analyticsvidhya.com/wp-content/uploads/2016/08/21-300x168.png 300w, https://www.analyticsvidhya.com/wp-content/uploads/2016/08/21-257x144.png 257w" sizes="(max-width: 600px) 100vw, 600px"/></p>
<p><code>&gt; hist(train$CoapplicantIncome, breaks = 100,main = "Coapplicant Income Chart",xlab = "CoapplicantIncome")</code><img class="aligncenter wp-image-26608" src="https://www.analyticsvidhya.com/wp-content/uploads/2016/08/22.png" alt="22" width="600" height="336" srcset="https://www.analyticsvidhya.com/wp-content/uploads/2016/08/22.png 715w, https://www.analyticsvidhya.com/wp-content/uploads/2016/08/22-300x168.png 300w, https://www.analyticsvidhya.com/wp-content/uploads/2016/08/22-257x144.png 257w" sizes="(max-width: 600px) 100vw, 600px"/></p>
<p style="text-align: justify;">As you can see in charts above, skewness is nothing but concentration of majority of data on one side of the chart. What we see is a right skewed graph. To visualize outliers, we can use a boxplot:</p>
<p style="text-align: justify;"><code>&gt; boxplot(train$ApplicantIncome)</code><img class="aligncenter wp-image-26610 size-full" src="https://www.analyticsvidhya.com/wp-content/uploads/2016/08/24-e1470369724209.png" alt="24" width="527" height="263" srcset="https://www.analyticsvidhya.com/wp-content/uploads/2016/08/24-e1470369724209.png 527w, https://www.analyticsvidhya.com/wp-content/uploads/2016/08/24-e1470369724209-300x150.png 300w" sizes="(max-width: 527px) 100vw, 527px"/></p>
<p>Similarly, you can create a boxplot for <code>CoapplicantIncome</code> and <code>LoanAmount</code> as well.</p>
<p style="text-align: justify;">Let&#8217;s change the class of <code>Credit_History</code> to factor. Remember, the class <code>factor</code> is always used for categorical variables.</p>
<p><code>&gt; train$Credit_History &lt;- as.factor(train$Credit_History)</code><br/>
<code>&gt; test$Credit_History &lt;- as.factor(test$Credit_History)</code></p>
<p>To check the changes, you can do:</p>
<p><code>&gt; class(train$Credit_History)</code><br/>
<code>[1] "factor"</code></p>
<p>You can further scrutinize the data using:</p>
<p><code>&gt; summary(train)</code><br/>
<code>&gt; summary(test)</code></p>
<p style="text-align: justify;">We find that the variable <code>Dependents</code> has a level <code>3+</code> which shall be treated too. It&#8217;s quite simple to modify the name levels in a factor variable. It can be done as:</p>
<p><code>#rename level of Dependents</code><br/>
<code>&gt; levels(train$Dependents)[4] &lt;- "3"</code><br/>
<code>&gt; levels(test$Dependents)[4] &lt;- "3"</code></p>
<p>&nbsp;</p>
<h2>3. Missing Value Imputation</h2>
<p style="text-align: justify;">Not just beginners, even good R analyst struggle with missing value imputation. MLR package offers a nice and convenient way to impute missing value using multiple methods. After we are done with much needed modifications in data, let&#8217;s impute missing values.</p>
<p style="text-align: justify;">In our case, we&#8217;ll use basic mean and mode imputation to impute data. You can also use any ML algorithm to impute these values, but that comes at the cost of computation.</p>
<p><code>#impute missing values by mean and mode</code><br/>
<code>&gt; imp &lt;- impute(train, classes = list(factor = imputeMode(), integer = imputeMean()), dummy.classes = c("integer","factor"), dummy.type = "numeric")</code><br/>
<code>&gt; imp1 &lt;- impute(test, classes = list(factor = imputeMode(), integer = imputeMean()), dummy.classes = c("integer","factor"), dummy.type = "numeric")</code></p>
<p style="text-align: justify;">This function is convenient because you don&#8217;t have to specify each variable name to impute. It selects variables on the basis of their classes. It also creates new dummy variables for missing values. Sometimes, these (dummy) features contain a trend which can be captured using this function. <code>dummy.classes</code> says for which classes should I create a dummy variable. <code>dummy.type</code> says what should be the class of new dummy variables.</p>
<p style="text-align: justify;"><code>$data</code> attribute of imp function contains the imputed data.</p>
<p style="text-align: justify;"><code>&gt; imp_train &lt;- imp$data</code><br/>
<code>&gt; imp_test &lt;- imp1$data</code></p>
<p style="text-align: justify;">Now, we have the complete data. You can check the new variables using:</p>
<p style="text-align: justify;"><code>&gt;summarizeColumns(imp_train)</code><br/>
<code>&gt;summarizeColumns(imp_test)</code></p>
<p style="text-align: justify;">Did you notice a disparity among both data sets? No ? See again. The answer is <code>Married.dummy</code> variable exists only in <code>imp_train</code> and not in <code>imp_test</code>. Therefore, we&#8217;ll have to remove it before modeling stage.</p>
<p style="text-align: justify;"><strong>Optional:</strong> You might be excited or curious to try out imputing missing values using a ML algorithm. In fact, there are some algorithms which don&#8217;t require you to impute missing values. You can simply supply them missing data. They take care of missing values on their own. Let&#8217;s see which algorithms are they:</p>
<p><code>&gt; listLearners("classif", check.packages = TRUE, properties = "missings")[c("class","package")]</code><br/>
<code>class                           package</code><br/>
<code>1 classif.bartMachine          bartMachine</code><br/>
<code>2 classif.boosting            adabag,rpart</code><br/>
<code>3 classif.cforest                party</code><br/>
<code>4 classif.ctree                  party</code><br/>
<code>5 classif.gbm                     gbm</code><br/>
<code>6 classif.naiveBayes             e1071</code><br/>
<code>7 classif.randomForestSRC   randomForestSRC</code><br/>
<code>8 classif.rpart                  rpart</code></p>
<p style="text-align: justify;">However, it is always advisable to treat missing values separately. Let&#8217;s see how can you treat missing value using rpart:</p>
<p><code>&gt; rpart_imp &lt;- impute(train, target = "Loan_Status",</code><br/>
<code> classes = list(numeric = imputeLearner(makeLearner("regr.rpart")),</code><br/>
<code> factor = imputeLearner(makeLearner("classif.rpart"))),</code><br/>
<code> dummy.classes = c("numeric","factor"),</code><br/>
<code> dummy.type = "numeric")</code></p>
<p>&nbsp;</p>
<h2>4. Feature Engineering</h2>
<p style="text-align: justify;">Feature Engineering is the most interesting part of predictive modeling. So, feature engineering has two aspects: Feature Transformation and Feature Creation. We&#8217;ll try to work on both the aspects here.</p>
<p style="text-align: justify;">At first, let&#8217;s remove outliers from variables like <code>ApplicantIncome</code>, <code>CoapplicantIncome</code>, <code>LoanAmount</code>. There are <a href="https://www.analyticsvidhya.com/blog/2016/01/guide-data-exploration/#three" target="_blank" rel="nofollow">many techniques</a> to remove outliers. Here, we&#8217;ll cap all the large values in these variables and set them to a threshold value as shown below:</p>
<p><code>#for train data set</code><br/>
<code>&gt; cd &lt;- capLargeValues(imp_train, target = "Loan_Status",cols = c("ApplicantIncome"),threshold = 40000)</code><br/>
<code>&gt; cd &lt;- capLargeValues(cd, target = "Loan_Status",cols = c("CoapplicantIncome"),threshold = 21000)</code><br/>
<code>&gt; cd &lt;- capLargeValues(cd, target = "Loan_Status",cols = c("LoanAmount"),threshold = 520)</code></p>
<p><code>#rename the train data as cd_train</code><br/>
<code>&gt; cd_train &lt;- cd</code></p>
<p><code>#add a dummy Loan_Status column in test data</code><br/>
<code>&gt; imp_test$Loan_Status &lt;- sample(0:1,size = 367,replace = T)</code></p>
<p><code>&gt; cde &lt;- capLargeValues(imp_test, target = "Loan_Status",cols = c("ApplicantIncome"),threshold = 33000)</code><br/>
<code>&gt; cde &lt;- capLargeValues(cde, target = "Loan_Status",cols = c("CoapplicantIncome"),threshold = 16000)</code><br/>
<code>&gt; cde &lt;- capLargeValues(cde, target = "Loan_Status",cols = c("LoanAmount"),threshold = 470)</code></p>
<p><code>#renaming test data</code><br/>
<code>&gt; cd_test &lt;- cde</code></p>
<p style="text-align: justify;">I&#8217;ve chosen the threshold value with my discretion, after analyzing the variable distribution. To check the effects, you can do <code>summary(cd_train$ApplicantIncome)</code> and see that the maximum value is capped at 33000.</p>
<p style="text-align: justify;">In both data sets, we see that all dummy variables are numeric in nature. Being binary in form, they should be categorical. Let&#8217;s convert their classes to factor. This time, we&#8217;ll use simple <code>for</code> and <code>if</code> loops.</p>
<p><code>#convert numeric to factor - train</code><br/>
<code>&gt; for (f in names(cd_train[, c(14:20)])) {</code><br/>
<code> if( class(cd_train[, c(14:20)] [[f]]) == "numeric"){</code><br/>
<code> levels &lt;- unique(cd_train[, c(14:20)][[f]])</code><br/>
<code> cd_train[, c(14:20)][[f]] &lt;- as.factor(factor(cd_train[, c(14:20)][[f]], levels = levels))</code><br/>
<code> }</code><br/>
<code>}</code></p>
<p><code>#convert numeric to factor - test</code><br/>
<code>&gt; for (f in names(cd_test[, c(13:18)])) {</code><br/>
<code> if( class(cd_test[, c(13:18)] [[f]]) == "numeric"){</code><br/>
<code> levels &lt;- unique(cd_test[, c(13:18)][[f]])</code><br/>
<code> cd_test[, c(13:18)][[f]] &lt;- as.factor(factor(cd_test[, c(13:18)][[f]], levels = levels))</code><br/>
<code> }</code><br/>
<code>}</code></p>
<p style="text-align: justify;">These loops say &#8211; &#8216;for every column name which falls column number 14 to 20 of cd_train / cd_test data frame, if the class of those variables in numeric, take out the unique value from those columns as levels and convert them into a factor (categorical) variables.</p>
<p>Let&#8217;s create some new features now.</p>
<p><code>#Total_Income</code><br/>
<code>&gt; cd_train$Total_Income &lt;- cd_train$ApplicantIncome + cd_train$CoapplicantIncome</code><br/>
<code>&gt; cd_test$Total_Income &lt;- cd_test$ApplicantIncome + cd_test$CoapplicantIncome</code></p>
<p><code>#Income by loan</code><br/>
<code>&gt; cd_train$Income_by_loan &lt;- cd_train$Total_Income/cd_train$LoanAmount</code><br/>
<code>&gt; cd_test$Income_by_loan &lt;- cd_test$Total_Income/cd_test$LoanAmount</code></p>
<p><code>#change variable class</code><br/>
<code>&gt; cd_train$Loan_Amount_Term &lt;- as.numeric(cd_train$Loan_Amount_Term)</code><br/>
<code>&gt; cd_test$Loan_Amount_Term &lt;- as.numeric(cd_test$Loan_Amount_Term)</code></p>
<p><code>#Loan amount by term</code><br/>
<code>&gt; cd_train$Loan_amount_by_term &lt;- cd_train$LoanAmount/cd_train$Loan_Amount_Term</code><br/>
<code>&gt; cd_test$Loan_amount_by_term &lt;- cd_test$LoanAmount/cd_test$Loan_Amount_Term</code></p>
<p style="text-align: justify;">While creating new features(if they are numeric), we must check their correlation with existing variables as there are high chances often. Let&#8217;s see if our new variables too happens to be correlated:</p>
<p><code>#splitting the data based on class</code><br/>
<code>&gt; az &lt;- split(names(cd_train), sapply(cd_train, function(x){ class(x)}))</code></p>
<p><code>#creating a data frame of numeric variables</code><br/>
<code>&gt; xs &lt;- cd_train[az$numeric]</code></p>
<p><code>#check correlation</code><br/>
<code>&gt; cor(xs)</code></p>
<p style="text-align: justify;"><code></code><span style="text-align: justify; line-height: 1.5;">As we see, there exists a very high correlation of </span><code style="text-align: justify; line-height: 1.5;">Total_Income</code><span style="text-align: justify; line-height: 1.5;"> with </span><code style="text-align: justify; line-height: 1.5;">ApplicantIncome</code><span style="text-align: justify; line-height: 1.5;">. It means that the new variable isn&#8217;t providing any new information. Thus, this variable is not helpful for modeling data.</span></p>
<p style="text-align: justify;">Now we can remove the variable.</p>
<p><code>&gt; cd_train$Total_Income &lt;- NULL</code><br/>
<code>&gt; cd_test$Total_Income &lt;- NULL</code></p>
<p style="text-align: justify;">There is still enough potential left to create new variables. Before proceeding, I want you to think deeper on this problem and try creating newer variables. After doing so much modifications in data, let&#8217;s check the data again:</p>
<p><code>&gt; summarizeColumns(cd_train)</code><br/>
<code>&gt; summarizeColumns(cd_test)</code></p>
<p>&nbsp;</p>
<h2>5. Machine Learning</h2>
<p style="text-align: justify;">Until here, we&#8217;ve performed all the important transformation steps except normalizing the skewed variables. That will be done after we create the task.</p>
<p style="text-align: justify;">As explained in the beginning, for mlr, a task is nothing but the data set on which a learner learns. Since, it&#8217;s a classification problem, we&#8217;ll create a classification task. So, the task type solely depends on type of problem at hand.</p>
<p><code>#create a task</code><br/>
<code>&gt; trainTask &lt;- makeClassifTask(data = cd_train,target = "Loan_Status")</code><br/>
<code>&gt; testTask &lt;- makeClassifTask(data = cd_test, target = "Loan_Status")</code></p>
<p>Let&#8217;s check trainTask</p>
<p><code>&gt; trainTask</code><br/>
<code>Supervised task: cd_train</code><br/>
<code>Type: classif</code><br/>
<code>Target: Loan_Status</code><br/>
<code>Observations: 614</code><br/>
<code>Features:</code><br/>
<code>numerics factors ordered </code><br/>
<code> 13         8       0 </code><br/>
<code>Missings: FALSE</code><br/>
<code>Has weights: FALSE</code><br/>
<code>Has blocking: FALSE</code><br/>
<code>Classes: 2</code><br/>
<code> N   Y </code><br/>
<code>192 422 </code><br/>
<code>Positive class: N</code></p>
<p style="text-align: justify;">As you can see, it provides a description of <code>cd_train</code> data. However, an evident problem is that it is considering positive class as N, whereas it should be Y. Let&#8217;s modify it:</p>
<p><code>&gt; trainTask &lt;- makeClassifTask(data = cd_train,target = "Loan_Status", positive = "Y")</code></p>
<p style="text-align: justify;">For a deeper view, you can check your task data using <code>str(getTaskData(trainTask))</code>.</p>
<p style="text-align: justify;">Now, we will normalize the data. For this step, we&#8217;ll use <code>normalizeFeatures</code> function from mlr package. By default, this packages normalizes all the numeric features in the data. Thankfully, only 3 variables which we have to normalize are numeric, rest of the variables have classes other than numeric.</p>
<p><code>#normalize the variables</code><br/>
<code>&gt; trainTask &lt;- normalizeFeatures(trainTask,method = "standardize")</code><br/>
<code>&gt; testTask &lt;- normalizeFeatures(testTask,method = "standardize")</code></p>
<p>Before we start applying algorithms, we should remove the variables which are not required.</p>
<p><code>&gt; trainTask &lt;- dropFeatures(task = trainTask,features = c("Loan_ID","Married.dummy"))</code></p>
<p style="text-align: justify;">MLR package has an in built function which returns the important variables from data. Let&#8217;s see which variables are important. Later, we can use this knowledge to subset out input predictors for model improvement. While running this code, R might prompt you to install &#8216;FSelector&#8217; package, which you should do.</p>
<p><code>#Feature importance</code><br/>
<code>&gt; im_feat &lt;- generateFilterValuesData(trainTask, method = c("information.gain","chi.squared"))</code><br/>
<code>&gt; plotFilterValues(im_feat,n.show = 20)</code></p>
<p><img class="alignnone size-full wp-image-26628" src="https://www.analyticsvidhya.com/wp-content/uploads/2016/08/26.png" alt="26" width="1266" height="484" srcset="https://www.analyticsvidhya.com/wp-content/uploads/2016/08/26.png 1266w, https://www.analyticsvidhya.com/wp-content/uploads/2016/08/26-300x115.png 300w, https://www.analyticsvidhya.com/wp-content/uploads/2016/08/26-768x294.png 768w, https://www.analyticsvidhya.com/wp-content/uploads/2016/08/26-1024x391.png 1024w, https://www.analyticsvidhya.com/wp-content/uploads/2016/08/26-850x325.png 850w" sizes="(max-width: 1266px) 100vw, 1266px"/></p>
<p><code>#to launch its shiny application</code><br/>
<code>&gt; plotFilterValuesGGVIS(im_feat)</code></p>
<p style="text-align: justify;">If you are still wondering about <code>information.gain</code><code></code>, let me provide a simple explanation. Information gain is generally used in context with decision trees. Every node split in a decision tree is based on information gain. In general, it tries to find out variables which carries the maximum information using which the target class is easier to predict.</p>
<p style="text-align: justify;">Let&#8217;s start modeling now. I won&#8217;t explain these algorithms in detail but I&#8217;ve provided links to helpful resources. We&#8217;ll take up simpler algorithms at first and end this tutorial with the complexed ones.</p>
<p style="text-align: justify;">With MLR, we can choose &amp; set algorithms using <code>makeLearner</code>. This learner will train on <code>trainTask</code> and try to make predictions on <code>testTask</code>.</p>
<p>&nbsp;</p>
<p><strong>1. Quadratic Discriminant Analysis (QDA)</strong>.</p>
<p style="text-align: justify;">In general, qda is a parametric algorithm. Parametric means that it makes certain assumptions about data. If the data is actually found to follow the assumptions, such algorithms sometime outperform several non-parametric algorithms. <a href="https://onlinecourses.science.psu.edu/stat505/node/97" target="_blank" rel="nofollow">Read More</a>.</p>
<p><code>#load qda </code><br/>
<code>&gt; qda.learner &lt;- makeLearner("classif.qda", predict.type = "response")</code></p>
<p><code>#train model</code><br/>
<code>&gt; qmodel &lt;- train(qda.learner, trainTask)</code></p>
<p><code>#predict on test data</code><br/>
<code>&gt; qpredict &lt;- predict(qmodel, testTask)</code></p>
<p><code>#create submission file</code><br/>
<code>&gt; submit &lt;- data.frame(Loan_ID = test$Loan_ID, Loan_Status = qpredict$data$response)</code><br/>
<code>&gt; write.csv(submit, "submit1.csv",row.names = F)</code></p>
<p style="text-align: justify;"><a href="https://datahack.analyticsvidhya.com/contest/practice-problem-loan-prediction-iii/" target="_blank" rel="nofollow">Upload</a> this submission file and check your leaderboard rank (wouldn&#8217;t be good). Our accuracy is ~ 71.5%. I understand, this submission might not put you among the top on leaderboard, but there&#8217;s along way to go. So, let&#8217;s proceed.</p>
<p>&nbsp;</p>
<p><strong>2. <a href="https://www.analyticsvidhya.com/blog/2015/11/beginners-guide-on-logistic-regression-in-r/" target="_blank" rel="nofollow">Logistic Regression</a></strong></p>
<p style="text-align: justify;">This time, let&#8217;s also check <a href="https://www.analyticsvidhya.com/blog/2015/11/improve-model-performance-cross-validation-in-python-r/" target="_blank" rel="nofollow">cross validation</a> accuracy. Higher CV accuracy determines that our model does not suffer from high variance and generalizes well on unseen data.</p>
<p><code>#logistic regression</code><br/>
<code> &gt; logistic.learner &lt;- makeLearner("classif.logreg",predict.type = "response")</code></p>
<p><code>#cross validation (cv) accuracy</code><br/>
<code>&gt; cv.logistic &lt;- crossval(learner = logistic.learner,task = trainTask,iters = 3,stratify = TRUE,measures = acc,show.info = F)</code></p>
<p style="text-align: justify;">Similarly, you can perform CV for any learner. Isn&#8217;t it incredibly easy? So, I&#8217;ve used stratified sampling with 3 fold CV. I&#8217;d always recommend you to use stratified sampling in classification problems since it maintains the proportion of target class in n folds. We can check CV accuracy by:</p>
<p><code>#cross validation accuracy</code><br/>
<code>&gt; cv.logistic$aggr<br/>
acc.test.mean<br/>
0.7947553<br/>
</code></p>
<p>This is the average accuracy calculated on 5 folds. To see, respective accuracy each fold, we can do this:</p>
<p><code>&gt; cv.logistic$measures.test</code><br/>
<code>  iter    acc</code><br/>
<code>1  1    0.8439024</code><br/>
<code>2  2    0.7707317</code><br/>
<code>3  3    0.7598039</code></p>
<p>Now, we&#8217;ll train the model and check the prediction accuracy on test data.</p>
<p><code>#train model</code><br/>
<code>&gt; fmodel &lt;- train(logistic.learner,trainTask)</code><br/>
<code>&gt; getLearnerModel(fmodel)</code></p>
<p><code>#predict on test data</code><br/>
<code>&gt; fpmodel &lt;- predict(fmodel, testTask)</code></p>
<p><code>#create submission file</code><br/>
<code>&gt; submit &lt;- data.frame(Loan_ID = test$Loan_ID, Loan_Status = fpmodel$data$response)</code><br/>
<code>&gt; write.csv(submit, "submit2.csv",row.names = F)</code></p>
<p style="text-align: justify;">Woah! This algorithm gave us a significant boost in accuracy. Moreover, this is a stable model since our CV score and leaderboard score matches closely. This submission returns accuracy of 79.16%. Good, we are improving now. Let&#8217;s get ahead to the next algorithm.</p>
<p>&nbsp;</p>
<h3>3. <a href="https://www.analyticsvidhya.com/blog/2016/04/complete-tutorial-tree-based-modeling-scratch-in-python/#one" target="_blank" rel="nofollow">Decision Tree</a></h3>
<p style="text-align: justify;">A decision tree is said to capture non-linear relations better than a logistic regression model. Let&#8217;s see if we can improve our model further. This time we&#8217;ll hyper tune the tree parameters to achieve optimal results. To get the list of parameters for any algorithm, simply write (in this case rpart):</p>
<p><code>&gt; getParamSet("classif.rpart")</code></p>
<p style="text-align: justify;">This will return a long list of tunable and non-tunable parameters. Let&#8217;s build a decision tree now. Make sure you have installed the <code>rpart package</code> before creating the tree learner:</p>
<p><code>#make tree learner</code><br/>
<code>&gt; makeatree &lt;- makeLearner("classif.rpart", predict.type = "response")</code></p>
<p><code>#set 3 fold cross validation</code><br/>
<code>&gt; set_cv &lt;- makeResampleDesc("CV",iters = 3L)</code></p>
<p>I&#8217;m doing a 3 fold CV because we have less data. Now, let&#8217;s set tunable parameters:</p>
<p><code>#Search for hyperparameters</code><br/>
<code>&gt; gs &lt;- makeParamSet(</code><br/>
<code> makeIntegerParam("minsplit",lower = 10, upper = 50),</code><br/>
<code> makeIntegerParam("minbucket", lower = 5, upper = 50),</code><br/>
<code> makeNumericParam("cp", lower = 0.001, upper = 0.2)</code><br/>
<code>)</code></p>
<p style="text-align: justify;">As you can see, I&#8217;ve set 3 parameters. <code>minsplit</code> represents the minimum number of observation in a node for a split to take place. <code>minbucket</code> says the minimum number of observation I should keep in terminal nodes. cp is the complexity parameter. The lesser it is, the tree will learn more specific relations in the data which might result in overfitting.</p>
<p><code>#do a grid search</code><br/>
<code>&gt; gscontrol &lt;- makeTuneControlGrid()</code></p>
<p><code>#hypertune the parameters</code><br/>
<code>&gt; stune &lt;- tuneParams(learner = makeatree, resampling = set_cv, task = trainTask, par.set = gs, control = gscontrol, measures = acc)</code></p>
<p style="text-align: justify;">You may go and take a walk until the parameter tuning completes. May be, go catch some pokemons! It took 15 minutes to run at my machine. I&#8217;ve 8GB intel i5 processor windows machine.</p>
<p><code>#check best parameter</code><br/>
<code>&gt; stune$x</code><br/>
<code># $minsplit</code><br/>
<code># [1] 37</code><br/>
<code># </code><br/>
<code># $minbucket</code><br/>
<code># [1] 15</code><br/>
<code># </code><br/>
<code># $cp</code><br/>
<code># [1] 0.001</code></p>
<p>It returns a list of best parameters. You can check the CV accuracy with:</p>
<p><code>#cross validation result</code><br/>
<code>&gt; stune$y</code><br/>
<code>0.8127132</code></p>
<p style="text-align: justify;">Using <code>setHyperPars</code> function, we can directly set the best parameters as modeling parameters in the algorithm.</p>
<p><code>#using hyperparameters for modeling</code><br/>
<code>&gt; t.tree &lt;- setHyperPars(makeatree, par.vals = stune$x)</code></p>
<p><code>#train the model</code><br/>
<code>&gt; t.rpart &lt;- train(t.tree, trainTask)</code><br/>
<code>getLearnerModel(t.rpart)</code></p>
<p><code>#make predictions</code><br/>
<code>&gt; tpmodel &lt;- predict(t.rpart, testTask)</code></p>
<p><code>#create a submission file</code><br/>
<code>&gt; submit &lt;- data.frame(Loan_ID = test$Loan_ID, Loan_Status = tpmodel$data$response)</code><br/>
<code>&gt; write.csv(submit, "submit3.csv",row.names = F)</code></p>
<p style="text-align: justify;">Decision Tree is doing no better than logistic regression. This algorithm has returned the same accuracy of 79.14% as of logistic regression. So, one tree isn&#8217;t enough. Let&#8217;s build a forest now.</p>
<p>&nbsp;</p>
<h3>4. <a href="https://www.analyticsvidhya.com/blog/2016/04/complete-tutorial-tree-based-modeling-scratch-in-python/#nine" target="_blank" rel="nofollow">Random Forest</a></h3>
<p style="text-align: justify;">Random Forest is a powerful algorithm known to produce astonishing results. Actually, it&#8217;s prediction derive from an ensemble of trees. It averages the prediction given by each tree and produces a generalized result. From here, most of the steps would be similar to followed above, but this time I&#8217;ve done <code>random search</code> instead of <code>grid search</code> for parameter tuning, because it&#8217;s faster.</p>
<p><code>&gt; getParamSet("classif.randomForest")</code></p>
<p><code>#create a learner</code><br/>
<code>&gt; rf &lt;- makeLearner("classif.randomForest", predict.type = "response", par.vals = list(ntree = 200, mtry = 3))</code><br/>
<code>&gt; rf$par.vals &lt;- list(</code><br/>
<code> importance = TRUE</code><br/>
<code>)</code></p>
<p><code>#set tunable parameters</code><br/>
<code>#grid search to find hyperparameters</code><br/>
<code>&gt; rf_param &lt;- makeParamSet(</code><br/>
<code> makeIntegerParam("ntree",lower = 50, upper = 500),</code><br/>
<code> makeIntegerParam("mtry", lower = 3, upper = 10),</code><br/>
<code> makeIntegerParam("nodesize", lower = 10, upper = 50)</code><br/>
<code>)</code></p>
<p><code>#let's do random search for 50 iterations</code><br/>
<code>&gt; rancontrol &lt;- makeTuneControlRandom(maxit = 50L)</code></p>
<p style="text-align: justify;">Though, random search is faster than grid search, but sometimes it turns out to be less efficient. In grid search, the algorithm tunes over every possible combination of parameters provided. In a random search, we specify the number of iterations and it randomly passes over the parameter combinations. In this process, it might miss out some important combination of parameters which could have returned maximum accuracy, who knows.</p>
<p><code>#set 3 fold cross validation</code><br/>
<code>&gt; set_cv &lt;- makeResampleDesc("CV",iters = 3L)</code></p>
<p><code>#hypertuning</code><br/>
<code>&gt; rf_tune &lt;- tuneParams(learner = rf, resampling = set_cv, task = trainTask, par.set = rf_param, control = rancontrol, measures = acc)</code></p>
<p>Now, we have the final parameters. Let&#8217;s check the list of parameters and CV accuracy.</p>
<p><code>#cv accuracy</code><br/>
<code>&gt; rf_tune$y</code><br/>
<code>acc.test.mean </code><br/>
<code> 0.8192571</code></p>
<p><code>#best parameters</code><br/>
<code>&gt; rf_tune$x</code><br/>
<code>$ntree</code><br/>
<code>[1] 168</code></p>
<p><code>$mtry</code><br/>
<code>[1] 6</code></p>
<p><code>$nodesize</code><br/>
<code>[1] 29</code></p>
<p>Let&#8217;s build the random forest model now and check its accuracy.</p>
<p><code>#using hyperparameters for modeling</code><br/>
<code>&gt; rf.tree &lt;- setHyperPars(rf, par.vals = rf_tune$x)</code></p>
<p><code>#train a model</code><br/>
<code>&gt; rforest &lt;- train(rf.tree, trainTask)</code><br/>
<code>&gt; getLearnerModel(t.rpart)</code></p>
<p><code>#make predictions</code><br/>
<code>&gt; rfmodel &lt;- predict(rforest, testTask)</code></p>
<p><code>#submission file</code><br/>
<code>&gt; submit &lt;- data.frame(Loan_ID = test$Loan_ID, Loan_Status = rfmodel$data$response)</code><br/>
<code>&gt; write.csv(submit, "submit4.csv",row.names = F)</code></p>
<p style="text-align: justify;">No new story to cheer about. This model too returned an accuracy of 79.14%. So, try using grid search instead of random search, and tell me in comments if your model improved.</p>
<p>&nbsp;</p>
<h3>5. <a href="https://www.analyticsvidhya.com/blog/2015/10/understaing-support-vector-machine-example-code/">SVM</a></h3>
<p style="text-align: justify;">Support Vector Machines (SVM) is also a supervised learning algorithm used for regression and classification problems. In general, it creates a hyperplane in n dimensional space to classify the data based on target class. Let&#8217;s step away from tree algorithms for a while and see if this algorithm can bring us some improvement.</p>
<p style="text-align: justify;">Since, most of the steps would be similar as performed above, I don&#8217;t think understanding these codes for you would be a challenge anymore.</p>
<p style="text-align: justify;"><code>#load svm</code><br/>
<code>&gt; getParamSet("classif.ksvm") #do install kernlab package </code><br/>
<code>&gt; ksvm &lt;- makeLearner("classif.ksvm", predict.type = "response")</code></p>
<p><code>#Set parameters</code><br/>
<code>&gt; pssvm &lt;- makeParamSet(</code><br/>
<code> makeDiscreteParam("C", values = 2^c(-8,-4,-2,0)), #cost parameters</code><br/>
<code> makeDiscreteParam("sigma", values = 2^c(-8,-4,0,4)) #RBF Kernel Parameter</code><br/>
<code>)</code></p>
<p><code>#specify search function</code><br/>
<code>&gt; ctrl &lt;- makeTuneControlGrid()</code></p>
<p><code>#tune model</code><br/>
<code>&gt; res &lt;- tuneParams(ksvm, task = trainTask, resampling = set_cv, par.set = pssvm, control = ctrl,measures = acc)</code></p>
<p><code>#CV accuracy</code><br/>
<code>&gt; res$y</code><br/>
<code>acc.test.mean </code><br/>
<code> 0.8062092</code></p>
<p><code>#set the model with best params</code><br/>
<code>&gt; t.svm &lt;- setHyperPars(ksvm, par.vals = res$x)</code></p>
<p><code>#train</code><br/>
<code>&gt; par.svm &lt;- train(ksvm, trainTask)</code></p>
<p><code>#test</code><br/>
<code>&gt; predict.svm &lt;- predict(par.svm, testTask)</code></p>
<p><code>#submission file</code><br/>
<code>&gt; submit &lt;- data.frame(Loan_ID = test$Loan_ID, Loan_Status = predict.svm$data$response)</code><br/>
<code>&gt; write.csv(submit, "submit5.csv",row.names = F)</code></p>
<p style="text-align: justify;">This model returns an accuracy of 77.08%. Not bad, but lesser than our highest score. Don&#8217;t feel hopeless here. This is core machine learning. ML doesn&#8217;t work unless it gets some good variables. May be, you should think longer on feature engineering aspect, and create more useful variables. Let&#8217;s do boosting now.</p>
<p>&nbsp;</p>
<p><strong>6. <a href="https://www.analyticsvidhya.com/blog/2015/09/complete-guide-boosting-methods/" target="_blank" rel="nofollow">GBM</a></strong></p>
<p style="text-align: justify;">Now you are entering the territory of boosting algorithms. GBM performs sequential modeling i.e after one round of prediction, it checks for incorrect predictions, assigns them relatively more weight and predict them again until they are predicted correctly.</p>
<p style="text-align: justify;"><code>#load GBM</code><br/>
<code>&gt; getParamSet("classif.gbm")</code><br/>
<code>&gt; g.gbm &lt;- makeLearner("classif.gbm", predict.type = "response")</code></p>
<p><code>#specify tuning method</code><br/>
<code>&gt; rancontrol &lt;- makeTuneControlRandom(maxit = 50L)</code></p>
<p><code>#3 fold cross validation</code><br/>
<code>&gt; set_cv &lt;- makeResampleDesc("CV",iters = 3L)</code></p>
<p><code>#parameters</code><br/>
<code>&gt; gbm_par&lt;- makeParamSet(</code><br/>
<code> makeDiscreteParam("distribution", values = "bernoulli"),</code><br/>
<code> makeIntegerParam("n.trees", lower = 100, upper = 1000), #number of trees</code><br/>
<code> makeIntegerParam("interaction.depth", lower = 2, upper = 10), #depth of tree</code><br/>
<code> makeIntegerParam("n.minobsinnode", lower = 10, upper = 80),</code><br/>
<code> makeNumericParam("shrinkage",lower = 0.01, upper = 1)</code><br/>
<code>)</code></p>
<p style="text-align: justify;"><code>n.minobsinnode</code> refers to the minimum number of observations in a tree node. <code>shrinkage</code> is the regulation parameter which dictates how fast / slow the algorithm should move.</p>
<p><code>#tune parameters</code><br/>
<code>&gt; tune_gbm &lt;- tuneParams(learner = g.gbm, task = trainTask,resampling = set_cv,measures = acc,par.set = gbm_par,control = rancontrol)</code></p>
<p><code>#check CV accuracy</code><br/>
<code>&gt; tune_gbm$y</code></p>
<p><code>#set parameters</code><br/>
<code>&gt; final_gbm &lt;- setHyperPars(learner = g.gbm, par.vals = tune_gbm$x)</code></p>
<p><code>#train</code><br/>
<code>&gt; to.gbm &lt;- train(final_gbm, traintask)</code></p>
<p><code>#test </code><br/>
<code>&gt; pr.gbm &lt;- predict(to.gbm, testTask)</code></p>
<p><code>#submission file</code><br/>
<code>&gt; submit &lt;- data.frame(Loan_ID = test$Loan_ID, Loan_Status = pr.gbm$data$response)</code><br/>
<code>&gt; write.csv(submit, "submit6.csv",row.names = F)</code></p>
<p style="text-align: justify;">The accuracy of this model is 78.47%. GBM performed better than SVM, but couldn&#8217;t exceed random forest&#8217;s accuracy. Finally, let&#8217;s test XGboost also.</p>
<p>&nbsp;</p>
<h3>7. <a href="https://www.analyticsvidhya.com/blog/2016/04/complete-tutorial-tree-based-modeling-scratch-in-python/#ten" target="_blank" rel="nofollow">Xgboost</a></h3>
<p style="text-align: justify;">Xgboost is considered to be better than GBM because of its inbuilt properties including first and second order gradient, parallel processing and ability to prune trees. General implementation of xgboost requires you to convert the data into a matrix. With mlr, that is not required.</p>
<p style="text-align: justify;">As I said in the beginning, a benefit of using this (MLR) package is that you can follow same set of commands for implementing different algorithms.</p>
<p><code>#load xgboost</code><br/>
<code>&gt; set.seed(1001)</code><br/>
<code>&gt; getParamSet("classif.xgboost")</code></p>
<p><code>#make learner with inital parameters</code><br/>
<code>&gt; xg_set &lt;- makeLearner("classif.xgboost", predict.type = "response")</code><br/>
<code>&gt; xg_set$par.vals &lt;- list(</code><br/>
<code> objective = "binary:logistic",</code><br/>
<code> eval_metric = "error",</code><br/>
<code> nrounds = 250</code><br/>
<code>)</code></p>
<p><code>#define parameters for tuning</code><br/>
<code>&gt; xg_ps &lt;- makeParamSet(</code><br/>
<code> makeIntegerParam("nrounds",lower=200,upper=600),</code><br/>
<code> makeIntegerParam("max_depth",lower=3,upper=20),</code><br/>
<code> makeNumericParam("lambda",lower=0.55,upper=0.60),</code><br/>
<code> makeNumericParam("eta", lower = 0.001, upper = 0.5),</code><br/>
<code> makeNumericParam("subsample", lower = 0.10, upper = 0.80),</code><br/>
<code> makeNumericParam("min_child_weight",lower=1,upper=5),</code><br/>
<code> makeNumericParam("colsample_bytree",lower = 0.2,upper = 0.8)</code><br/>
<code>)</code></p>
<p><code>#define search function</code><br/>
<code>&gt; rancontrol &lt;- makeTuneControlRandom(maxit = 100L) #do 100 iterations</code></p>
<p><code>#3 fold cross validation</code><br/>
<code>&gt; set_cv &lt;- makeResampleDesc("CV",iters = 3L)</code></p>
<p><code>#tune parameters</code><br/>
<code>&gt; xg_tune &lt;- tuneParams(learner = xg_set, task = trainTask, resampling = set_cv,measures = acc,par.set = xg_ps, control = rancontrol)</code></p>
<p><code>#set parameters</code><br/>
<code>&gt; xg_new &lt;- setHyperPars(learner = xg_set, par.vals = xg_tune$x)</code></p>
<p><code>#train model</code><br/>
<code>&gt; xgmodel &lt;- train(xg_new, trainTask)</code></p>
<p><code>#test model</code><br/>
<code>&gt; predict.xg &lt;- predict(xgmodel, testTask)</code></p>
<p><code>#submission file</code><br/>
<code>&gt; submit &lt;- data.frame(Loan_ID = test$Loan_ID, Loan_Status = predict.xg$data$response)</code><br/>
<code>&gt; write.csv(submit, "submit7.csv",row.names = F)</code></p>
<p style="text-align: justify;">Terrible XGBoost. This model returns an accuracy of 68.5%, even lower than qda. What could happen ? Overfitting. So, this model returned CV accuracy of ~ 80% but leaderboard score declined drastically, because the model couldn&#8217;t predict correctly on unseen data.</p>
<p>&nbsp;</p>
<h3>What can you do next? Feature Selection ?</h3>
<p style="text-align: justify;">For improvement, let&#8217;s do this. Until here, we&#8217;ve used trainTask for model building. Let&#8217;s use the knowledge of important variables. Take first 6 important variables and train the models on them. You can expect some improvement. To create a task selecting important variables, do this:</p>
<p><code>#selecting top 6 important features</code><br/>
<code>&gt; top_task &lt;- filterFeatures(trainTask, method = "rf.importance", abs = 6)</code></p>
<p style="text-align: justify;">So, I&#8217;ve asked this function to get me top 6 important features using the random forest importance feature. Now, replace <code>top_task</code> with <code>trainTask</code> in models above, and tell me in comments if you got any improvement.</p>
<p style="text-align: justify;">Also, try to create more features. The current leaderboard winner is at ~81% accuracy. If you have followed me till here, don&#8217;t give up now.</p>
<p>&nbsp;</p>
<h2>End Notes</h2>
<p style="text-align: justify;">The motive of this article was to get you started with machine learning techniques. These techniques are commonly used in industry today. Hence, make sure you understand them well. Don&#8217;t use these algorithms as black box approaches, understand them well. I&#8217;ve provided link to resources.</p>
<p style="text-align: justify;">What happened above, happens a lot in real life. You&#8217;d try many algorithms but wouldn&#8217;t get improvement in accuracy. But, you shouldn&#8217;t give up. Being a beginner, you should try exploring other ways to achieve accuracy. Remember, no matter how many wrong attempts you make, you just have to be right once.</p>
<p style="text-align: justify;">You might have to install packages while loading these models, but that&#8217;s one time only. If you followed this article completely, you are ready to build models. All you have to do is, learn the theory behind them.</p>
<p style="text-align: justify;">Did you find this article helpful ? Did you try the improvement methods I listed above ? Which algorithm gave you the max. accuracy? Share your observations / experience in the comments below.</p>

https://www.analyticsvidhya.com/blog/2016/08/practicing-machine-learning-techniques-in-r-with-mlr-package/?utm_source=feedburner&utm_medium=email&utm_campaign=Feed%3A+AnalyticsVidhya+%28Analytics+Vidhya%29